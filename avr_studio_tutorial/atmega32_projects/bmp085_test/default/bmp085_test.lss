
bmp085_test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000014cc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000002  00800060  000014cc  00001560  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000b  00800062  00800062  00001562  2**0
                  ALLOC
  3 .debug_aranges 000000c0  00000000  00000000  00001562  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000004aa  00000000  00000000  00001622  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002080  00000000  00000000  00001acc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000b78  00000000  00000000  00003b4c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001c58  00000000  00000000  000046c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000350  00000000  00000000  0000631c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000007f7  00000000  00000000  0000666c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000012e6  00000000  00000000  00006e63  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000b0  00000000  00000000  00008149  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 37 03 	jmp	0x66e	; 0x66e <__ctors_end>
       4:	0c 94 f9 03 	jmp	0x7f2	; 0x7f2 <__vector_1>
       8:	0c 94 03 04 	jmp	0x806	; 0x806 <__vector_2>
       c:	0c 94 0d 04 	jmp	0x81a	; 0x81a <__vector_3>
      10:	0c 94 54 03 	jmp	0x6a8	; 0x6a8 <__bad_interrupt>
      14:	0c 94 54 03 	jmp	0x6a8	; 0x6a8 <__bad_interrupt>
      18:	0c 94 54 03 	jmp	0x6a8	; 0x6a8 <__bad_interrupt>
      1c:	0c 94 54 03 	jmp	0x6a8	; 0x6a8 <__bad_interrupt>
      20:	0c 94 54 03 	jmp	0x6a8	; 0x6a8 <__bad_interrupt>
      24:	0c 94 54 03 	jmp	0x6a8	; 0x6a8 <__bad_interrupt>
      28:	0c 94 54 03 	jmp	0x6a8	; 0x6a8 <__bad_interrupt>
      2c:	0c 94 54 03 	jmp	0x6a8	; 0x6a8 <__bad_interrupt>
      30:	0c 94 54 03 	jmp	0x6a8	; 0x6a8 <__bad_interrupt>
      34:	0c 94 54 03 	jmp	0x6a8	; 0x6a8 <__bad_interrupt>
      38:	0c 94 54 03 	jmp	0x6a8	; 0x6a8 <__bad_interrupt>
      3c:	0c 94 54 03 	jmp	0x6a8	; 0x6a8 <__bad_interrupt>
      40:	0c 94 54 03 	jmp	0x6a8	; 0x6a8 <__bad_interrupt>
      44:	0c 94 54 03 	jmp	0x6a8	; 0x6a8 <__bad_interrupt>
      48:	0c 94 54 03 	jmp	0x6a8	; 0x6a8 <__bad_interrupt>
      4c:	0c 94 54 03 	jmp	0x6a8	; 0x6a8 <__bad_interrupt>
      50:	0c 94 a8 03 	jmp	0x750	; 0x750 <__vector_20>

00000054 <__c.1896>:
      54:	49 6e 69 74 20 2e 2e 2e 20 64 6f 6e 65 21 00        Init ... done!.

00000063 <font_fixed_8px_data>:
      63:	00 00 00 00 00 00 00 3e 45 51 45 3e 00 3e 6b 6f     .......>EQE>.>ko
      73:	6b 3e 00 1c 3e 7c 3e 1c 00 18 3c 7e 3c 18 00 30     k>..>|>...<~<..0
      83:	36 7f 36 30 00 18 5c 7e 5c 18 00 00 00 00 00 00     6.60..\~\.......
	...
      a3:	00 00 00 30 48 4a 36 0e 00 06 29 79 29 06 00 00     ...0HJ6...)y)...
      b3:	00 00 00 00 00 60 7e 0a 35 3f 00 2a 1c 36 1c 2a     .....`~.5?.*.6.*
      c3:	00 00 7f 3e 1c 08 00 08 1c 3e 7f 00 00 14 36 7f     ...>.....>....6.
      d3:	36 14 00 00 5f 00 5f 00 00 06 09 7f 01 7f 00 22     6..._._........"
      e3:	4d 55 59 22 00 60 60 60 60 00 00 14 b6 ff b6 14     MUY".````.......
      f3:	00 04 06 7f 06 04 00 10 30 7f 30 10 00 08 08 3e     ........0.0....>
     103:	1c 08 00 08 1c 3e 08 08 00 78 40 40 40 40 00 08     .....>...x@@@@..
     113:	3e 08 3e 08 00 30 3c 3f 3c 30 00 03 0f 3f 0f 03     >.>..0<?<0...?..
	...
     12b:	06 5f 06 00 00 07 03 00 07 03 00 24 7e 24 7e 24     ._.........$~$~$
     13b:	00 24 2b 6a 12 00 00 63 13 08 64 63 00 36 49 56     .$+j...c..dc.6IV
     14b:	20 50 00 00 07 03 00 00 00 00 3e 41 00 00 00 00      P........>A....
     15b:	41 3e 00 00 00 08 3e 1c 3e 08 00 08 08 3e 08 08     A>....>.>....>..
     16b:	00 00 e0 60 00 00 00 08 08 08 08 08 00 00 60 60     ...`..........``
     17b:	00 00 00 20 10 08 04 02 00 3e 51 49 45 3e 00 00     ... .....>QIE>..
     18b:	42 7f 40 00 00 62 51 49 49 46 00 22 49 49 49 36     B.@..bQIIF."III6
     19b:	00 18 14 12 7f 10 00 2f 49 49 49 31 00 3c 4a 49     ......./III1.<JI
     1ab:	49 30 00 01 71 09 05 03 00 36 49 49 49 36 00 06     I0..q....6III6..
     1bb:	49 49 29 1e 00 00 6c 6c 00 00 00 00 ec 6c 00 00     II)...ll.....l..
     1cb:	00 08 14 22 41 00 00 24 24 24 24 24 00 00 41 22     ..."A..$$$$$..A"
     1db:	14 08 00 02 01 59 09 06 00 3e 41 5d 55 1e 00 7e     .....Y...>A]U..~
     1eb:	11 11 11 7e 00 7f 49 49 49 36 00 3e 41 41 41 22     ...~..III6.>AAA"
     1fb:	00 7f 41 41 41 3e 00 7f 49 49 49 41 00 7f 09 09     ..AAA>..IIIA....
     20b:	09 01 00 3e 41 49 49 7a 00 7f 08 08 08 7f 00 00     ...>AIIz........
     21b:	41 7f 41 00 00 30 40 40 40 3f 00 7f 08 14 22 41     A.A..0@@@?...."A
     22b:	00 7f 40 40 40 40 00 7f 02 04 02 7f 00 7f 02 04     ..@@@@..........
     23b:	08 7f 00 3e 41 41 41 3e 00 7f 09 09 09 06 00 3e     ...>AAA>.......>
     24b:	41 51 21 5e 00 7f 09 09 19 66 00 26 49 49 49 32     AQ!^.....f.&III2
     25b:	00 01 01 7f 01 01 00 3f 40 40 40 3f 00 1f 20 40     .......?@@@?.. @
     26b:	20 1f 00 3f 40 3c 40 3f 00 63 14 08 14 63 00 07      ..?@<@?.c...c..
     27b:	08 70 08 07 00 71 49 45 43 00 00 00 7f 41 41 00     .p...qIEC....AA.
     28b:	00 02 04 08 10 20 00 00 41 41 7f 00 00 04 02 01     ..... ..AA......
     29b:	02 04 80 80 80 80 80 80 00 00 03 07 00 00 00 20     ............... 
     2ab:	54 54 54 78 00 7f 44 44 44 38 00 38 44 44 44 28     TTTx..DDD8.8DDD(
     2bb:	00 38 44 44 44 7f 00 38 54 54 54 08 00 08 7e 09     .8DDD..8TTT...~.
     2cb:	09 00 00 18 a4 a4 a4 7c 00 7f 04 04 78 00 00 00     .......|....x...
     2db:	00 7d 40 00 00 40 80 84 7d 00 00 7f 10 28 44 00     .}@..@..}....(D.
     2eb:	00 00 00 7f 40 00 00 7c 04 18 04 78 00 7c 04 04     ....@..|...x.|..
     2fb:	78 00 00 38 44 44 44 38 00 fc 44 44 44 38 00 38     x..8DDD8..DDD8.8
     30b:	44 44 44 fc 00 44 78 44 04 08 00 08 54 54 54 20     DDD..DxD....TTT 
     31b:	00 04 3e 44 24 00 00 3c 40 20 7c 00 00 1c 20 40     ..>D$..<@ |... @
     32b:	20 1c 00 3c 60 30 60 3c 00 6c 10 10 6c 00 00 9c      ..<`0`<.l..l...
     33b:	a0 60 3c 00 00 64 54 54 4c 00 00 08 3e 41 41 00     .`<..dTTL...>AA.
     34b:	00 00 00 77 00 00 00 00 41 41 3e 08 00 02 01 02     ...w....AA>.....
     35b:	01 00 00 3c 26 23 26 3c 00 1e a1 e1 21 12 00 3d     ...<&#&<....!..=
     36b:	40 20 7d 00 00 38 54 54 55 09 00 20 55 55 55 78     @ }..8TTU.. UUUx
     37b:	00 20 55 54 55 78 00 20 55 55 54 78 00 20 57 55     . UTUx. UUTx. WU
     38b:	57 78 00 1c a2 e2 22 14 00 38 55 55 55 08 00 38     Wx...."..8UUU..8
     39b:	55 54 55 08 00 38 55 55 54 08 00 00 01 7c 41 00     UTU..8UUT....|A.
     3ab:	00 00 01 7d 41 00 00 00 01 7c 40 00 00 70 29 24     ...}A....|@..p)$
     3bb:	29 70 00 78 2f 25 2f 78 00 7c 54 54 55 45 00 34     )p.x/%/x.|TTUE.4
     3cb:	54 7c 54 58 00 7e 09 7f 49 49 00 38 45 45 39 00     T|TX.~..II.8EE9.
     3db:	00 38 45 44 39 00 00 39 45 44 38 00 00 3c 41 21     .8ED9..9ED8..<A!
     3eb:	7d 00 00 3d 41 20 7c 00 00 9c a1 60 3d 00 00 3d     }..=A |....`=..=
     3fb:	42 42 3d 00 00 3c 41 40 3d 00 80 70 68 58 38 04     BB=..<A@=..phX8.
     40b:	00 48 3e 49 49 62 00 7e 61 5d 43 3f 00 22 14 08     .H>IIb.~a]C?."..
     41b:	14 22 00 40 88 7e 09 02 00 20 54 55 55 78 00 00     .".@.~... TUUx..
     42b:	00 7d 41 00 00 38 44 45 39 00 00 3c 40 21 7d 00     .}A..8DE9..<@!}.
     43b:	00 7a 09 0a 71 00 00 7a 11 22 79 00 00 08 55 55     .z..q..z."y...UU
     44b:	55 5e 00 4e 51 51 4e 00 00 30 48 4d 40 20 3e 41     U^.NQQN..0HM@ >A
     45b:	5d 4b 55 3e 04 04 04 04 04 1c 00 17 08 4c 6a 50     ]KU>.........LjP
     46b:	00 17 08 34 2a 78 00 00 30 7d 30 00 00 08 14 00     ...4*x..0}0.....
     47b:	08 14 00 14 08 00 14 08 44 11 44 11 44 11 aa 55     ........D.D.D..U
     48b:	aa 55 aa 55 bb ee bb ee bb ee 00 00 00 ff 00 00     .U.U............
     49b:	08 08 08 ff 00 00 00 70 28 25 29 70 00 70 29 25     .......p(%)p.p)%
     4ab:	29 70 00 70 29 25 28 70 3e 41 5d 55 41 3e 0a fb     )p.p)%(p>A]UA>..
     4bb:	00 ff 00 00 00 ff 00 ff 00 00 0a fa 02 fe 00 00     ................
     4cb:	0a 0b 08 0f 00 00 00 18 24 66 24 00 00 29 2a 7c     ........$f$..)*|
     4db:	2a 29 08 08 08 f8 00 00 00 00 00 0f 08 08 08 08     *)..............
     4eb:	08 0f 08 08 08 08 08 f8 08 08 00 00 00 ff 08 08     ................
     4fb:	08 08 08 08 08 08 08 08 08 ff 08 08 00 20 56 55     ............. VU
     50b:	56 79 00 70 2a 25 2a 71 00 0f 08 0b 0a 0a 00 fe     Vy.p*%*q........
     51b:	02 fa 0a 0a 0a 0b 08 0b 0a 0a 0a fa 02 fa 0a 0a     ................
     52b:	00 ff 00 fb 0a 0a 0a 0a 0a 0a 0a 0a 0a fb 00 fb     ................
     53b:	0a 0a 00 5d 22 22 22 5d 00 22 55 59 30 00 00 08     ...]"""]."UY0...
     54b:	7f 49 41 3e 00 7c 55 55 55 44 00 7c 55 54 55 44     .IA>.|UUUD.|UTUD
     55b:	00 7c 55 55 54 44 00 00 00 07 00 00 00 00 44 7d     .|UUTD........D}
     56b:	45 00 00 00 45 7d 45 00 00 00 45 7c 45 00 08 08     E...E}E...E|E...
     57b:	08 0f 00 00 00 00 00 f8 08 08 ff ff ff ff ff ff     ................
     58b:	f0 f0 f0 f0 f0 f0 00 00 00 77 00 00 00 00 45 7d     .........w....E}
     59b:	44 00 0f 0f 0f 0f 0f 0f 00 3c 42 43 3d 00 00 fe     D........<BC=...
     5ab:	4a 4a 34 00 00 3c 43 43 3d 00 00 3d 43 42 3c 00     JJ4..<CC=..=CB<.
     5bb:	00 32 49 4a 31 00 00 3a 45 46 39 00 00 fc 20 20     .2IJ1..:EF9...  
     5cb:	1c 00 00 fe aa 28 10 00 00 ff a5 24 18 00 00 3c     .....(.....$...<
     5db:	40 41 3d 00 00 3c 41 41 3d 00 00 3d 41 40 3c 00     @A=..<AA=..=A@<.
     5eb:	00 9c a0 61 3d 00 00 04 08 71 09 04 00 00 02 02     ...a=....q......
     5fb:	02 00 00 00 07 03 00 00 00 00 08 08 08 00 00 00     ................
     60b:	24 2e 24 00 00 24 24 24 24 24 05 17 0a 34 2a 78     $.$..$$$$$...4*x
     61b:	00 06 09 7f 01 7f 00 22 4d 55 59 22 00 08 08 2a     ......."MUY"...*
     62b:	08 08 00 00 08 18 18 00 00 06 09 09 06 00 00 00     ................
     63b:	08 00 08 00 00 00 08 00 00 00 00 02 0f 00 00 00     ................
     64b:	00 09 0f 05 00 00 00 09 0d 0a 00 00 00 3c 3c 3c     .............<<<
     65b:	3c 00 00 00 00 00 00 00                             <.......

00000663 <font_fixed_8px>:
     663:	00 06 06 08 00 ff 00 00 63 00 00                    ........c..

0000066e <__ctors_end>:
     66e:	11 24       	eor	r1, r1
     670:	1f be       	out	0x3f, r1	; 63
     672:	cf e5       	ldi	r28, 0x5F	; 95
     674:	d8 e0       	ldi	r29, 0x08	; 8
     676:	de bf       	out	0x3e, r29	; 62
     678:	cd bf       	out	0x3d, r28	; 61

0000067a <__do_copy_data>:
     67a:	10 e0       	ldi	r17, 0x00	; 0
     67c:	a0 e6       	ldi	r26, 0x60	; 96
     67e:	b0 e0       	ldi	r27, 0x00	; 0
     680:	ec ec       	ldi	r30, 0xCC	; 204
     682:	f4 e1       	ldi	r31, 0x14	; 20
     684:	02 c0       	rjmp	.+4      	; 0x68a <.do_copy_data_start>

00000686 <.do_copy_data_loop>:
     686:	05 90       	lpm	r0, Z+
     688:	0d 92       	st	X+, r0

0000068a <.do_copy_data_start>:
     68a:	a2 36       	cpi	r26, 0x62	; 98
     68c:	b1 07       	cpc	r27, r17
     68e:	d9 f7       	brne	.-10     	; 0x686 <.do_copy_data_loop>

00000690 <__do_clear_bss>:
     690:	10 e0       	ldi	r17, 0x00	; 0
     692:	a2 e6       	ldi	r26, 0x62	; 98
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	01 c0       	rjmp	.+2      	; 0x69a <.do_clear_bss_start>

00000698 <.do_clear_bss_loop>:
     698:	1d 92       	st	X+, r1

0000069a <.do_clear_bss_start>:
     69a:	ad 36       	cpi	r26, 0x6D	; 109
     69c:	b1 07       	cpc	r27, r17
     69e:	e1 f7       	brne	.-8      	; 0x698 <.do_clear_bss_loop>
     6a0:	0e 94 b3 03 	call	0x766	; 0x766 <main>
     6a4:	0c 94 64 0a 	jmp	0x14c8	; 0x14c8 <_exit>

000006a8 <__bad_interrupt>:
     6a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006ac <TWI_Master_Initialise>:
Call this function to set up the TWI master to its initial standby state.
Remember to enable interrupts from the main application after initializing the TWI.
****************************************************************************/
void TWI_Master_Initialise(void)
{
	TWBR = TWI_TWBR;                        // Set bit rate register (Baudrate). Defined in header file.
     6ac:	80 e2       	ldi	r24, 0x20	; 32
     6ae:	80 b9       	out	0x00, r24	; 0
	//TWDR = 0xFF;							// Default content = SDA released.
	//TWCR = (1<<TWEN);//|						// Enable TWI-interface and release TWI pins.
         //(0<<TWIE)|(0<<TWINT)|              // Disable Interupt.
         //(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|   // No Signal requests.
         //(0<<TWWC);                         //
}    
     6b0:	08 95       	ret

000006b2 <TWI_Transceiver_Busy>:
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
 	return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
     6b2:	86 b7       	in	r24, 0x36	; 54
}
     6b4:	81 70       	andi	r24, 0x01	; 1
     6b6:	08 95       	ret

000006b8 <TWI_Get_State_Info>:
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
	  while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
     6b8:	06 b6       	in	r0, 0x36	; 54
     6ba:	00 fc       	sbrc	r0, 0
     6bc:	fd cf       	rjmp	.-6      	; 0x6b8 <TWI_Get_State_Info>
	  return ( TWI_state );                         // Return error state.
}
     6be:	80 91 60 00 	lds	r24, 0x0060
     6c2:	08 95       	ret

000006c4 <TWI_Start_Transceiver_With_Data>:
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
     6c4:	fc 01       	movw	r30, r24
	  unsigned char temp;

	  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
     6c6:	06 b6       	in	r0, 0x36	; 54
     6c8:	00 fc       	sbrc	r0, 0
     6ca:	fd cf       	rjmp	.-6      	; 0x6c6 <TWI_Start_Transceiver_With_Data+0x2>

	  TWI_msgSize = msgSize;                        // Number of data to transmit.
     6cc:	60 93 67 00 	sts	0x0067, r22
	  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
     6d0:	80 81       	ld	r24, Z
     6d2:	80 93 63 00 	sts	0x0063, r24
	  
	  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
     6d6:	80 fd       	sbrc	r24, 0
     6d8:	0d c0       	rjmp	.+26     	; 0x6f4 <TWI_Start_Transceiver_With_Data+0x30>
     6da:	4e 2f       	mov	r20, r30
     6dc:	a4 e6       	ldi	r26, 0x64	; 100
     6de:	b0 e0       	ldi	r27, 0x00	; 0
     6e0:	cf 01       	movw	r24, r30
     6e2:	fc 01       	movw	r30, r24
     6e4:	02 c0       	rjmp	.+4      	; 0x6ea <TWI_Start_Transceiver_With_Data+0x26>
	  {
		for ( temp = 1; temp < msgSize; temp++ )
		  TWI_buf[ temp ] = msg[ temp ];
     6e6:	80 81       	ld	r24, Z
     6e8:	8d 93       	st	X+, r24
     6ea:	31 96       	adiw	r30, 0x01	; 1
	  TWI_msgSize = msgSize;                        // Number of data to transmit.
	  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
	  
	  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
	  {
		for ( temp = 1; temp < msgSize; temp++ )
     6ec:	8e 2f       	mov	r24, r30
     6ee:	84 1b       	sub	r24, r20
     6f0:	86 17       	cp	r24, r22
     6f2:	c8 f3       	brcs	.-14     	; 0x6e6 <TWI_Start_Transceiver_With_Data+0x22>
		  TWI_buf[ temp ] = msg[ temp ];
	  }
	  
	  //TWI_statusReg.all = 0;
	  TWI_statusReg.all = 0;      
     6f4:	10 92 62 00 	sts	0x0062, r1
	  TWI_state         = TWI_NO_STATE ;
     6f8:	88 ef       	ldi	r24, 0xF8	; 248
     6fa:	80 93 60 00 	sts	0x0060, r24
	  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
     6fe:	85 ea       	ldi	r24, 0xA5	; 165
     700:	86 bf       	out	0x36, r24	; 54
			 (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interrupt and clear the flag.
			 (1<<TWSTA);                            // Initiate a START condition.

}
     702:	08 95       	ret

00000704 <TWI_Start_Transceiver>:
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
     704:	06 b6       	in	r0, 0x36	; 54
     706:	00 fc       	sbrc	r0, 0
     708:	fd cf       	rjmp	.-6      	; 0x704 <TWI_Start_Transceiver>
	  
	TWI_statusReg.all = 0;      
     70a:	10 92 62 00 	sts	0x0062, r1
	TWI_state         = TWI_NO_STATE ;
     70e:	88 ef       	ldi	r24, 0xF8	; 248
     710:	80 93 60 00 	sts	0x0060, r24
	  
	TWCR = (1<<TWEN)|                             // TWI Interface enabled.
     714:	85 ea       	ldi	r24, 0xA5	; 165
     716:	86 bf       	out	0x36, r24	; 54
			(1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
			(0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
			(0<<TWWC);                             //
}
     718:	08 95       	ret

0000071a <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
     71a:	ac 01       	movw	r20, r24
	unsigned char i;

	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
     71c:	06 b6       	in	r0, 0x36	; 54
     71e:	00 fc       	sbrc	r0, 0
     720:	fd cf       	rjmp	.-6      	; 0x71c <TWI_Get_Data_From_Transceiver+0x2>

	if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
     722:	80 91 62 00 	lds	r24, 0x0062
     726:	80 ff       	sbrs	r24, 0
     728:	0f c0       	rjmp	.+30     	; 0x748 <TWI_Get_Data_From_Transceiver+0x2e>
     72a:	20 e0       	ldi	r18, 0x00	; 0
     72c:	30 e0       	ldi	r19, 0x00	; 0
     72e:	0a c0       	rjmp	.+20     	; 0x744 <TWI_Get_Data_From_Transceiver+0x2a>
	{                                             
		for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
		{
			msg[ i ] = TWI_buf[ i ];
     730:	fa 01       	movw	r30, r20
     732:	e2 0f       	add	r30, r18
     734:	f3 1f       	adc	r31, r19
     736:	d9 01       	movw	r26, r18
     738:	ad 59       	subi	r26, 0x9D	; 157
     73a:	bf 4f       	sbci	r27, 0xFF	; 255
     73c:	8c 91       	ld	r24, X
     73e:	80 83       	st	Z, r24
     740:	2f 5f       	subi	r18, 0xFF	; 255
     742:	3f 4f       	sbci	r19, 0xFF	; 255

	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

	if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
	{                                             
		for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
     744:	26 17       	cp	r18, r22
     746:	a0 f3       	brcs	.-24     	; 0x730 <TWI_Get_Data_From_Transceiver+0x16>
     748:	80 91 62 00 	lds	r24, 0x0062
			msg[ i ] = TWI_buf[ i ];
		}
	}

	return( TWI_statusReg.lastTransOK );                                   
}
     74c:	81 70       	andi	r24, 0x01	; 1
     74e:	08 95       	ret

00000750 <__vector_20>:
	
}


ISR(__vector_20)
{
     750:	1f 92       	push	r1
     752:	0f 92       	push	r0
     754:	0f b6       	in	r0, 0x3f	; 63
     756:	0f 92       	push	r0
     758:	11 24       	eor	r1, r1
  PORTA |= (1<<PINA7);
     75a:	df 9a       	sbi	0x1b, 7	; 27
}  
     75c:	0f 90       	pop	r0
     75e:	0f be       	out	0x3f, r0	; 63
     760:	0f 90       	pop	r0
     762:	1f 90       	pop	r1
     764:	18 95       	reti

00000766 <main>:




void main (void)
{
     766:	cf 92       	push	r12
     768:	df 92       	push	r13
     76a:	ef 92       	push	r14
     76c:	ff 92       	push	r15
     76e:	0f 93       	push	r16
     770:	1f 93       	push	r17
     772:	cf 93       	push	r28
     774:	df 93       	push	r29
	uint16_t sensorRead;
	unsigned char msgBuf[2];
	
	uint16_t statusCode;
	
	sei();
     776:	78 94       	sei
	
	myInit();
     778:	0e 94 17 04 	call	0x82e	; 0x82e <myInit>
	
	TWI_Master_Initialise();
     77c:	0e 94 56 03 	call	0x6ac	; 0x6ac <TWI_Master_Initialise>
	//pwmInit(100);
	
	lcd_set_font(FONT_FIXED_8,NORMAL);
     780:	83 e6       	ldi	r24, 0x63	; 99
     782:	96 e0       	ldi	r25, 0x06	; 6
     784:	60 e0       	ldi	r22, 0x00	; 0
     786:	0e 94 3e 06 	call	0xc7c	; 0xc7c <lcd_set_font>
	lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("Init ... done!"));
     78a:	83 e6       	ldi	r24, 0x63	; 99
     78c:	96 e0       	ldi	r25, 0x06	; 6
     78e:	60 e0       	ldi	r22, 0x00	; 0
     790:	44 e5       	ldi	r20, 0x54	; 84
     792:	50 e0       	ldi	r21, 0x00	; 0
     794:	0e 94 5f 09 	call	0x12be	; 0x12be <lcd_put_string_P>
		//TWSTA: twi start condition -> generates a start contition on the bus (it it is free)
		//                              if it is not free, it waits until a stop condition is
		//								detected 
		//TWIE:  the interrupt request for twi will be activated as long as the twint flag is high
		//TWINT: reset twint flag (by writing a one) -> starts the operation of the twi module
		TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);// | (1<<TWIE); 
     798:	34 ea       	ldi	r19, 0xA4	; 164
     79a:	c3 2e       	mov	r12, r19
		//while  (!(TWCR & (1<<TWINT)));

		
		
		//write the bmp addressWrite into the TWI data register
		TWDR = 0xEE;
     79c:	2e ee       	ldi	r18, 0xEE	; 238
     79e:	d2 2e       	mov	r13, r18
		//start transmission by reseting the TWINT (by writing a one)
		TWCR = (1<<TWINT) | (1<<TWEN);
     7a0:	04 e8       	ldi	r16, 0x84	; 132
		
		//while  (!(TWCR & (1<<TWINT)));
				
		TWDR = 0xF4;
     7a2:	94 ef       	ldi	r25, 0xF4	; 244
     7a4:	f9 2e       	mov	r15, r25
		TWDR = 0xF4;
		TWCR = (1<<TWINT) | (1<<TWEN);
					
		
		//send STOP condition
		TWCR = (1<<TWINT) | (1<<TWEN)| (1<<TWSTO);
     7a6:	84 e9       	ldi	r24, 0x94	; 148
     7a8:	e8 2e       	mov	r14, r24
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     7aa:	c8 ec       	ldi	r28, 0xC8	; 200
     7ac:	d0 e0       	ldi	r29, 0x00	; 0
		//TWSTA: twi start condition -> generates a start contition on the bus (it it is free)
		//                              if it is not free, it waits until a stop condition is
		//								detected 
		//TWIE:  the interrupt request for twi will be activated as long as the twint flag is high
		//TWINT: reset twint flag (by writing a one) -> starts the operation of the twi module
		TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);// | (1<<TWIE); 
     7ae:	c6 be       	out	0x36, r12	; 54
		
		
		//TWSR should now have the status code, that the START has been send successfully
		statusCode = TWSR;
     7b0:	11 b1       	in	r17, 0x01	; 1
		lcd_moveto_xy  (1, 0);	 
     7b2:	81 e0       	ldi	r24, 0x01	; 1
     7b4:	60 e0       	ldi	r22, 0x00	; 0
     7b6:	0e 94 56 04 	call	0x8ac	; 0x8ac <lcd_moveto_xy>
		lcd_put_uint(statusCode);
     7ba:	81 2f       	mov	r24, r17
     7bc:	90 e0       	ldi	r25, 0x00	; 0
     7be:	0e 94 dd 08 	call	0x11ba	; 0x11ba <lcd_put_uint>
		//while  (!(TWCR & (1<<TWINT)));

		
		
		//write the bmp addressWrite into the TWI data register
		TWDR = 0xEE;
     7c2:	d3 b8       	out	0x03, r13	; 3
		//start transmission by reseting the TWINT (by writing a one)
		TWCR = (1<<TWINT) | (1<<TWEN);
     7c4:	06 bf       	out	0x36, r16	; 54
		
		//while  (!(TWCR & (1<<TWINT)));
				
		TWDR = 0xF4;
     7c6:	f3 b8       	out	0x03, r15	; 3
		TWCR = (1<<TWINT) | (1<<TWEN);
     7c8:	06 bf       	out	0x36, r16	; 54

		//while  (!(TWCR & (1<<TWINT)));
				
		TWDR = 0xF4;
     7ca:	f3 b8       	out	0x03, r15	; 3
		TWCR = (1<<TWINT) | (1<<TWEN);
     7cc:	06 bf       	out	0x36, r16	; 54
					
		
		//send STOP condition
		TWCR = (1<<TWINT) | (1<<TWEN)| (1<<TWSTO);
     7ce:	e6 be       	out	0x36, r14	; 54
			
		//TWSR should now have the status code, that the slave has accepted the data package
		statusCode = TWSR;
     7d0:	11 b1       	in	r17, 0x01	; 1
		lcd_moveto_xy  (2, 0);	 
     7d2:	82 e0       	ldi	r24, 0x02	; 2
     7d4:	60 e0       	ldi	r22, 0x00	; 0
     7d6:	0e 94 56 04 	call	0x8ac	; 0x8ac <lcd_moveto_xy>
		lcd_put_uint(statusCode);	
     7da:	81 2f       	mov	r24, r17
     7dc:	90 e0       	ldi	r25, 0x00	; 0
     7de:	0e 94 dd 08 	call	0x11ba	; 0x11ba <lcd_put_uint>
     7e2:	88 ee       	ldi	r24, 0xE8	; 232
     7e4:	93 e0       	ldi	r25, 0x03	; 3
     7e6:	fe 01       	movw	r30, r28
     7e8:	31 97       	sbiw	r30, 0x01	; 1
     7ea:	f1 f7       	brne	.-4      	; 0x7e8 <main+0x82>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     7ec:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     7ee:	d9 f7       	brne	.-10     	; 0x7e6 <main+0x80>
     7f0:	de cf       	rjmp	.-68     	; 0x7ae <main+0x48>

000007f2 <__vector_1>:



//bei Button "warm" (button ganz rechts), läuft durch wenn fallende Flanke auf INT0 (PD.2)
ISR(INT0_vect) 
{
     7f2:	1f 92       	push	r1
     7f4:	0f 92       	push	r0
     7f6:	0f b6       	in	r0, 0x3f	; 63
     7f8:	0f 92       	push	r0
     7fa:	11 24       	eor	r1, r1

}
     7fc:	0f 90       	pop	r0
     7fe:	0f be       	out	0x3f, r0	; 63
     800:	0f 90       	pop	r0
     802:	1f 90       	pop	r1
     804:	18 95       	reti

00000806 <__vector_2>:

//----------------------------------------------------------------------------------------------

//bei Button "kalt" (button in der Mitte), läuft durch wenn fallende Flanke auf INT1 (PD.3)
ISR(INT1_vect) 
{
     806:	1f 92       	push	r1
     808:	0f 92       	push	r0
     80a:	0f b6       	in	r0, 0x3f	; 63
     80c:	0f 92       	push	r0
     80e:	11 24       	eor	r1, r1

}
     810:	0f 90       	pop	r0
     812:	0f be       	out	0x3f, r0	; 63
     814:	0f 90       	pop	r0
     816:	1f 90       	pop	r1
     818:	18 95       	reti

0000081a <__vector_3>:

//----------------------------------------------------------------------------------------------

//ISR läuft durch, wenn fallende Flanke auf INT2 (PB.2)
ISR(INT2_vect)
{	
     81a:	1f 92       	push	r1
     81c:	0f 92       	push	r0
     81e:	0f b6       	in	r0, 0x3f	; 63
     820:	0f 92       	push	r0
     822:	11 24       	eor	r1, r1



	//sleep_disable();	

}
     824:	0f 90       	pop	r0
     826:	0f be       	out	0x3f, r0	; 63
     828:	0f 90       	pop	r0
     82a:	1f 90       	pop	r1
     82c:	18 95       	reti

0000082e <myInit>:
	//set_sleep_mode(SLEEP_MODE_PWR_DOWN);


	//für dogm display
	//initialize lcd-display
	lcd_init();
     82e:	0e 94 ed 05 	call	0xbda	; 0xbda <lcd_init>
	
	
	
	//cpu status led
	DDRA |= (1<<PINA7);
     832:	d7 9a       	sbi	0x1a, 7	; 26
	PORTA &= ~(1<<PINA7);
     834:	df 98       	cbi	0x1b, 7	; 27
	
	DDRA |= (1<<PINA0);
     836:	d0 9a       	sbi	0x1a, 0	; 26
	
	DDRA |= (1<<PINA1);
     838:	d1 9a       	sbi	0x1a, 1	; 26
	//Enable interrupts for INT0, INT1, INT2	
	//GICR  |= (1<<BIT7) | (1<<BIT6) | (1<<BIT5); 
	GICR |= (1<<BIT5); //only INT2

*/
}
     83a:	08 95       	ret

0000083c <lcd_inc_page>:
/******************************************************************************
 * Changes the internal cursor by s pages
 * s             - number of pages to move
 */ 
uint8_t lcd_inc_page(int8_t s) {
  uint8_t p = lcd_current_page;
     83c:	90 91 68 00 	lds	r25, 0x0068
  p += s;
     840:	98 0f       	add	r25, r24
  p %= LCD_RAM_PAGES;    //all lcd have lcd_ram_pages which is power of two
     842:	93 70       	andi	r25, 0x03	; 3
  lcd_current_page = p;
     844:	90 93 68 00 	sts	0x0068, r25
  return p;
  }
     848:	89 2f       	mov	r24, r25
     84a:	08 95       	ret

0000084c <lcd_inc_column>:

/******************************************************************************
 * Changes the internal cursor by s columns, including wrapping (if selected)
 * s             - number of columns to move
 */ 
uint8_t lcd_inc_column(int16_t s) {
     84c:	ac 01       	movw	r20, r24
  uint16_t c = lcd_current_column;
     84e:	80 91 69 00 	lds	r24, 0x0069
  c += s;
     852:	9a 01       	movw	r18, r20
     854:	28 0f       	add	r18, r24
     856:	31 1d       	adc	r19, r1
     858:	80 91 68 00 	lds	r24, 0x0068
     85c:	0c c0       	rjmp	.+24     	; 0x876 <__stack+0x17>
#if LCD_WRAP_AROUND == 1
  while (c >= LCD_WIDTH) {
    if (s > 0) lcd_inc_page(1);
     85e:	14 16       	cp	r1, r20
     860:	15 06       	cpc	r1, r21
     862:	2c f4       	brge	.+10     	; 0x86e <__stack+0xf>
 * Changes the internal cursor by s pages
 * s             - number of pages to move
 */ 
uint8_t lcd_inc_page(int8_t s) {
  uint8_t p = lcd_current_page;
  p += s;
     864:	8f 5f       	subi	r24, 0xFF	; 255
  p %= LCD_RAM_PAGES;    //all lcd have lcd_ram_pages which is power of two
     866:	83 70       	andi	r24, 0x03	; 3
  c += s;
#if LCD_WRAP_AROUND == 1
  while (c >= LCD_WIDTH) {
    if (s > 0) lcd_inc_page(1);
    else       lcd_inc_page(-1);
    if (s > 0) c -= LCD_WIDTH;
     868:	24 58       	subi	r18, 0x84	; 132
     86a:	30 40       	sbci	r19, 0x00	; 0
     86c:	04 c0       	rjmp	.+8      	; 0x876 <__stack+0x17>
 * Changes the internal cursor by s pages
 * s             - number of pages to move
 */ 
uint8_t lcd_inc_page(int8_t s) {
  uint8_t p = lcd_current_page;
  p += s;
     86e:	81 50       	subi	r24, 0x01	; 1
  p %= LCD_RAM_PAGES;    //all lcd have lcd_ram_pages which is power of two
     870:	83 70       	andi	r24, 0x03	; 3
#if LCD_WRAP_AROUND == 1
  while (c >= LCD_WIDTH) {
    if (s > 0) lcd_inc_page(1);
    else       lcd_inc_page(-1);
    if (s > 0) c -= LCD_WIDTH;
    else       c += LCD_WIDTH;
     872:	2c 57       	subi	r18, 0x7C	; 124
     874:	3f 4f       	sbci	r19, 0xFF	; 255
 */ 
uint8_t lcd_inc_column(int16_t s) {
  uint16_t c = lcd_current_column;
  c += s;
#if LCD_WRAP_AROUND == 1
  while (c >= LCD_WIDTH) {
     876:	24 38       	cpi	r18, 0x84	; 132
     878:	31 05       	cpc	r19, r1
     87a:	88 f7       	brcc	.-30     	; 0x85e <lcd_inc_column+0x12>
     87c:	80 93 68 00 	sts	0x0068, r24
    else       lcd_inc_page(-1);
    if (s > 0) c -= LCD_WIDTH;
    else       c += LCD_WIDTH;
    }
#endif
  lcd_current_column = c;
     880:	20 93 69 00 	sts	0x0069, r18
  return c;
  }
     884:	82 2f       	mov	r24, r18
     886:	08 95       	ret

00000888 <lcd_data>:
/******************************************************************************
 * Writes one data byte
 * data          - the data byte
 */
void lcd_data(uint8_t data) {
  LCD_SELECT();
     888:	c4 98       	cbi	0x18, 4	; 24
  LCD_DRAM();
     88a:	dd 9a       	sbi	0x1b, 5	; 27
  spi_write(data);
     88c:	8f b9       	out	0x0f, r24	; 15
  LCD_UNSELECT();
     88e:	77 9b       	sbis	0x0e, 7	; 14
     890:	fe cf       	rjmp	.-4      	; 0x88e <lcd_data+0x6>
     892:	c4 9a       	sbi	0x18, 4	; 24
  lcd_inc_column(1);
     894:	81 e0       	ldi	r24, 0x01	; 1
     896:	90 e0       	ldi	r25, 0x00	; 0
     898:	0e 94 26 04 	call	0x84c	; 0x84c <lcd_inc_column>
  }
     89c:	08 95       	ret

0000089e <lcd_command>:
/******************************************************************************
 * Writes one command byte
 * cmd           - the command byte
 */
void lcd_command(uint8_t cmd) {
  LCD_SELECT();
     89e:	c4 98       	cbi	0x18, 4	; 24
  LCD_CMD();
     8a0:	dd 98       	cbi	0x1b, 5	; 27
   
  spi_write(cmd);
     8a2:	8f b9       	out	0x0f, r24	; 15
  
  
  //LCD_UNSELECT();
  while(!(SPSR & (1<<SPIF)));
     8a4:	77 9b       	sbis	0x0e, 7	; 14
     8a6:	fe cf       	rjmp	.-4      	; 0x8a4 <lcd_command+0x6>
  PORT_CS |= _BV(PIN_CS);
     8a8:	c4 9a       	sbi	0x18, 4	; 24
  }
     8aa:	08 95       	ret

000008ac <lcd_moveto_xy>:
/******************************************************************************
 * Moves the cursor to the given position
 * pages         - page to move to
 * columns       - column to move to
 */ 
void lcd_moveto_xy(uint8_t page, uint8_t column) {
     8ac:	0f 93       	push	r16
     8ae:	1f 93       	push	r17
     8b0:	08 2f       	mov	r16, r24
     8b2:	16 2f       	mov	r17, r22
  LCD_GOTO_ADDRESS(page,column);
     8b4:	8f 70       	andi	r24, 0x0F	; 15
     8b6:	80 6b       	ori	r24, 0xB0	; 176
     8b8:	0e 94 4f 04 	call	0x89e	; 0x89e <lcd_command>
     8bc:	81 2f       	mov	r24, r17
     8be:	82 95       	swap	r24
     8c0:	8f 70       	andi	r24, 0x0F	; 15
     8c2:	80 61       	ori	r24, 0x10	; 16
     8c4:	0e 94 4f 04 	call	0x89e	; 0x89e <lcd_command>
     8c8:	81 2f       	mov	r24, r17
     8ca:	8f 70       	andi	r24, 0x0F	; 15
     8cc:	0e 94 4f 04 	call	0x89e	; 0x89e <lcd_command>
  lcd_current_column = column; 
     8d0:	10 93 69 00 	sts	0x0069, r17
  lcd_current_page = page;
     8d4:	00 93 68 00 	sts	0x0068, r16
  }
     8d8:	1f 91       	pop	r17
     8da:	0f 91       	pop	r16
     8dc:	08 95       	ret

000008de <lcd_move_xy>:
/******************************************************************************
 * Moves the cursor relative to the current position
 * pages         - number of pages to move
 * columns       - number of columns to move
 */  
void lcd_move_xy(int8_t pages, int16_t columns) {
     8de:	1f 93       	push	r17
/******************************************************************************
 * Changes the internal cursor by s pages
 * s             - number of pages to move
 */ 
uint8_t lcd_inc_page(int8_t s) {
  uint8_t p = lcd_current_page;
     8e0:	10 91 68 00 	lds	r17, 0x0068
  p += s;
     8e4:	18 0f       	add	r17, r24
  p %= LCD_RAM_PAGES;    //all lcd have lcd_ram_pages which is power of two
     8e6:	13 70       	andi	r17, 0x03	; 3
  lcd_current_page = p;
     8e8:	10 93 68 00 	sts	0x0068, r17
 * Moves the cursor relative to the current position
 * pages         - number of pages to move
 * columns       - number of columns to move
 */  
void lcd_move_xy(int8_t pages, int16_t columns) {
  lcd_moveto_xy(lcd_inc_page(pages),lcd_inc_column(columns));
     8ec:	cb 01       	movw	r24, r22
     8ee:	0e 94 26 04 	call	0x84c	; 0x84c <lcd_inc_column>
     8f2:	68 2f       	mov	r22, r24
     8f4:	81 2f       	mov	r24, r17
     8f6:	0e 94 56 04 	call	0x8ac	; 0x8ac <lcd_moveto_xy>
  }
     8fa:	1f 91       	pop	r17
     8fc:	08 95       	ret

000008fe <lcd_draw_image_P>:
 * progmem_image - prog_uint8_t array of columns aka the bitmap image
 * pages         - height of image in pages
 * columns       - width of image in pixels (or columns)
 * style         - Bit2: sets inverse mode
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
     8fe:	bf 92       	push	r11
     900:	cf 92       	push	r12
     902:	df 92       	push	r13
     904:	ef 92       	push	r14
     906:	ff 92       	push	r15
     908:	0f 93       	push	r16
     90a:	1f 93       	push	r17
     90c:	cf 93       	push	r28
     90e:	df 93       	push	r29
     910:	08 2f       	mov	r16, r24
     912:	e9 2f       	mov	r30, r25
     914:	b6 2e       	mov	r11, r22
     916:	e4 2e       	mov	r14, r20
     918:	f2 2e       	mov	r15, r18
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
     91a:	24 e0       	ldi	r18, 0x04	; 4
     91c:	f2 22       	and	r15, r18
     91e:	10 e0       	ldi	r17, 0x00	; 0
				lcd_data(tmp);
			else
				lcd_data(~tmp);
      }
    if(++j != pages)
      lcd_move_xy(1,-columns);
     920:	84 2f       	mov	r24, r20
     922:	90 e0       	ldi	r25, 0x00	; 0
     924:	cc 24       	eor	r12, r12
     926:	dd 24       	eor	r13, r13
     928:	c8 1a       	sub	r12, r24
     92a:	d9 0a       	sbc	r13, r25
     92c:	18 c0       	rjmp	.+48     	; 0x95e <lcd_draw_image_P+0x60>
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++) {
      uint8_t tmp = pgm_read_byte(progmem_image++);
     92e:	fe 01       	movw	r30, r28
     930:	84 91       	lpm	r24, Z+
			if(!inv)
     932:	f1 10       	cpse	r15, r1
				lcd_data(tmp);
			else
				lcd_data(~tmp);
     934:	80 95       	com	r24
     936:	0e 94 44 04 	call	0x888	; 0x888 <lcd_data>
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++) {
      uint8_t tmp = pgm_read_byte(progmem_image++);
     93a:	21 96       	adiw	r28, 0x01	; 1
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++) {
     93c:	9e 01       	movw	r18, r28
     93e:	20 1b       	sub	r18, r16
     940:	2e 15       	cp	r18, r14
     942:	20 f4       	brcc	.+8      	; 0x94c <lcd_draw_image_P+0x4e>
     944:	80 91 69 00 	lds	r24, 0x0069
     948:	84 38       	cpi	r24, 0x84	; 132
     94a:	88 f3       	brcs	.-30     	; 0x92e <lcd_draw_image_P+0x30>
			if(!inv)
				lcd_data(tmp);
			else
				lcd_data(~tmp);
      }
    if(++j != pages)
     94c:	1f 5f       	subi	r17, 0xFF	; 255
     94e:	1b 15       	cp	r17, r11
     950:	21 f0       	breq	.+8      	; 0x95a <lcd_draw_image_P+0x5c>
      lcd_move_xy(1,-columns);
     952:	81 e0       	ldi	r24, 0x01	; 1
     954:	b6 01       	movw	r22, r12
     956:	0e 94 6f 04 	call	0x8de	; 0x8de <lcd_move_xy>
     95a:	0c 2f       	mov	r16, r28
     95c:	ed 2f       	mov	r30, r29
 * style         - Bit2: sets inverse mode
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
     95e:	1b 15       	cp	r17, r11
     960:	48 f4       	brcc	.+18     	; 0x974 <lcd_draw_image_P+0x76>
     962:	80 91 68 00 	lds	r24, 0x0068
     966:	84 30       	cpi	r24, 0x04	; 4
     968:	28 f4       	brcc	.+10     	; 0x974 <lcd_draw_image_P+0x76>
     96a:	80 2f       	mov	r24, r16
     96c:	9e 2f       	mov	r25, r30
     96e:	fc 01       	movw	r30, r24
     970:	ef 01       	movw	r28, r30
     972:	e4 cf       	rjmp	.-56     	; 0x93c <lcd_draw_image_P+0x3e>
				lcd_data(~tmp);
      }
    if(++j != pages)
      lcd_move_xy(1,-columns);
    }
  }
     974:	df 91       	pop	r29
     976:	cf 91       	pop	r28
     978:	1f 91       	pop	r17
     97a:	0f 91       	pop	r16
     97c:	ff 90       	pop	r15
     97e:	ef 90       	pop	r14
     980:	df 90       	pop	r13
     982:	cf 90       	pop	r12
     984:	bf 90       	pop	r11
     986:	08 95       	ret

00000988 <lcd_draw_image_xy_P>:
 * y             - y start coordinate on the screen (in pixel)
 * pages         - height of image in pages
 * columns       - width of image in pixels
 * style         - Bit2: sets inverse mode
 */
void lcd_draw_image_xy_P(PGM_P progmem_image, uint8_t x, uint8_t y, uint8_t pages, uint8_t columns, uint8_t style) {
     988:	2f 92       	push	r2
     98a:	3f 92       	push	r3
     98c:	4f 92       	push	r4
     98e:	5f 92       	push	r5
     990:	6f 92       	push	r6
     992:	7f 92       	push	r7
     994:	8f 92       	push	r8
     996:	9f 92       	push	r9
     998:	af 92       	push	r10
     99a:	bf 92       	push	r11
     99c:	cf 92       	push	r12
     99e:	df 92       	push	r13
     9a0:	ef 92       	push	r14
     9a2:	ff 92       	push	r15
     9a4:	0f 93       	push	r16
     9a6:	1f 93       	push	r17
     9a8:	df 93       	push	r29
     9aa:	cf 93       	push	r28
     9ac:	cd b7       	in	r28, 0x3d	; 61
     9ae:	de b7       	in	r29, 0x3e	; 62
     9b0:	28 97       	sbiw	r28, 0x08	; 8
     9b2:	0f b6       	in	r0, 0x3f	; 63
     9b4:	f8 94       	cli
     9b6:	de bf       	out	0x3e, r29	; 62
     9b8:	0f be       	out	0x3f, r0	; 63
     9ba:	cd bf       	out	0x3d, r28	; 61
     9bc:	f8 2e       	mov	r15, r24
     9be:	d9 2e       	mov	r13, r25
     9c0:	12 2f       	mov	r17, r18
     9c2:	2e 2d       	mov	r18, r14
	uint16_t i,j;
  uint8_t data   = 0;
  uint8_t inv    = style & INVERT_BIT;
     9c4:	24 70       	andi	r18, 0x04	; 4
     9c6:	2a 83       	std	Y+2, r18	; 0x02
	uint8_t offset = y & 0x7; //Optimized modulo 8
     9c8:	84 2f       	mov	r24, r20
     9ca:	87 70       	andi	r24, 0x07	; 7
     9cc:	89 83       	std	Y+1, r24	; 0x01
	//If there is an offset, we must use an additional page
	if(offset)  
     9ce:	81 11       	cpse	r24, r1
    pages++;
     9d0:	1f 5f       	subi	r17, 0xFF	; 255


//Function to read the current position
extern uint8_t lcd_current_page;
extern uint8_t lcd_current_column;
static inline uint8_t lcd_get_position_page()   {return lcd_current_page;};
     9d2:	50 91 68 00 	lds	r21, 0x0068
  //If there is not enough vertical space -> cut image
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
     9d6:	21 2f       	mov	r18, r17
     9d8:	30 e0       	ldi	r19, 0x00	; 0
     9da:	84 e0       	ldi	r24, 0x04	; 4
     9dc:	90 e0       	ldi	r25, 0x00	; 0
     9de:	85 1b       	sub	r24, r21
     9e0:	91 09       	sbc	r25, r1
     9e2:	82 17       	cp	r24, r18
     9e4:	93 07       	cpc	r25, r19
     9e6:	14 f4       	brge	.+4      	; 0x9ec <lcd_draw_image_xy_P+0x64>
    pages = LCD_RAM_PAGES - lcd_get_position_page();
     9e8:	14 e0       	ldi	r17, 0x04	; 4
     9ea:	15 1b       	sub	r17, r21
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
     9ec:	84 2f       	mov	r24, r20
     9ee:	86 95       	lsr	r24
     9f0:	86 95       	lsr	r24
     9f2:	86 95       	lsr	r24
     9f4:	0e 94 56 04 	call	0x8ac	; 0x8ac <lcd_moveto_xy>
     9f8:	80 2e       	mov	r8, r16
     9fa:	99 24       	eor	r9, r9
     9fc:	8f 2d       	mov	r24, r15
     9fe:	9d 2d       	mov	r25, r13
     a00:	5c 01       	movw	r10, r24
     a02:	88 27       	eor	r24, r24
     a04:	99 27       	eor	r25, r25
     a06:	88 19       	sub	r24, r8
     a08:	99 09       	sbc	r25, r9
     a0a:	15 01       	movw	r2, r10
     a0c:	28 0e       	add	r2, r24
     a0e:	39 1e       	adc	r3, r25
     a10:	18 86       	std	Y+8, r1	; 0x08
     a12:	1f 82       	std	Y+7, r1	; 0x07
	for (j=0; j<pages; j++) {
     a14:	61 2e       	mov	r6, r17
     a16:	77 24       	eor	r7, r7
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
      data = 0;
      if (!offset || j+1 != pages)
        data = pgm_read_byte(&progmem_image[j*columns + i]) << offset;
			if(j > 0 && offset)
				data |= pgm_read_byte(&progmem_image[(j-1)*columns + i]) >> (8-offset);
     a18:	28 e0       	ldi	r18, 0x08	; 8
     a1a:	42 2e       	mov	r4, r18
     a1c:	51 2c       	mov	r5, r1
     a1e:	e9 81       	ldd	r30, Y+1	; 0x01
     a20:	4e 1a       	sub	r4, r30
     a22:	51 08       	sbc	r5, r1
			if(inv)	lcd_data(~data);
      else 		lcd_data(data);
		  }
		if(j+1 != pages)
			lcd_move_xy(1,-columns);
     a24:	8d 83       	std	Y+5, r24	; 0x05
     a26:	9e 83       	std	Y+6, r25	; 0x06
     a28:	4c c0       	rjmp	.+152    	; 0xac2 <lcd_draw_image_xy_P+0x13a>
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
	for (j=0; j<pages; j++) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
      data = 0;
      if (!offset || j+1 != pages)
     a2a:	f9 81       	ldd	r31, Y+1	; 0x01
     a2c:	ff 23       	and	r31, r31
     a2e:	39 f0       	breq	.+14     	; 0xa3e <lcd_draw_image_xy_P+0xb6>
     a30:	8b 81       	ldd	r24, Y+3	; 0x03
     a32:	9c 81       	ldd	r25, Y+4	; 0x04
     a34:	86 15       	cp	r24, r6
     a36:	97 05       	cpc	r25, r7
     a38:	11 f4       	brne	.+4      	; 0xa3e <lcd_draw_image_xy_P+0xb6>
     a3a:	20 e0       	ldi	r18, 0x00	; 0
     a3c:	07 c0       	rjmp	.+14     	; 0xa4c <lcd_draw_image_xy_P+0xc4>
        data = pgm_read_byte(&progmem_image[j*columns + i]) << offset;
     a3e:	f7 01       	movw	r30, r14
     a40:	24 91       	lpm	r18, Z+
     a42:	09 80       	ldd	r0, Y+1	; 0x01
     a44:	01 c0       	rjmp	.+2      	; 0xa48 <lcd_draw_image_xy_P+0xc0>
     a46:	22 0f       	add	r18, r18
     a48:	0a 94       	dec	r0
     a4a:	ea f7       	brpl	.-6      	; 0xa46 <lcd_draw_image_xy_P+0xbe>
			if(j > 0 && offset)
     a4c:	8f 81       	ldd	r24, Y+7	; 0x07
     a4e:	98 85       	ldd	r25, Y+8	; 0x08
     a50:	89 2b       	or	r24, r25
     a52:	69 f0       	breq	.+26     	; 0xa6e <lcd_draw_image_xy_P+0xe6>
     a54:	99 81       	ldd	r25, Y+1	; 0x01
     a56:	99 23       	and	r25, r25
     a58:	51 f0       	breq	.+20     	; 0xa6e <lcd_draw_image_xy_P+0xe6>
				data |= pgm_read_byte(&progmem_image[(j-1)*columns + i]) >> (8-offset);
     a5a:	f6 01       	movw	r30, r12
     a5c:	84 91       	lpm	r24, Z+
     a5e:	90 e0       	ldi	r25, 0x00	; 0
     a60:	04 2c       	mov	r0, r4
     a62:	02 c0       	rjmp	.+4      	; 0xa68 <lcd_draw_image_xy_P+0xe0>
     a64:	95 95       	asr	r25
     a66:	87 95       	ror	r24
     a68:	0a 94       	dec	r0
     a6a:	e2 f7       	brpl	.-8      	; 0xa64 <lcd_draw_image_xy_P+0xdc>
     a6c:	28 2b       	or	r18, r24
			if(inv)	lcd_data(~data);
     a6e:	fa 81       	ldd	r31, Y+2	; 0x02
     a70:	ff 23       	and	r31, r31
     a72:	19 f0       	breq	.+6      	; 0xa7a <lcd_draw_image_xy_P+0xf2>
     a74:	82 2f       	mov	r24, r18
     a76:	80 95       	com	r24
     a78:	01 c0       	rjmp	.+2      	; 0xa7c <lcd_draw_image_xy_P+0xf4>
      else 		lcd_data(data);
     a7a:	82 2f       	mov	r24, r18
     a7c:	0e 94 44 04 	call	0x888	; 0x888 <lcd_data>
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
    pages = LCD_RAM_PAGES - lcd_get_position_page();
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
	for (j=0; j<pages; j++) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
     a80:	0f 5f       	subi	r16, 0xFF	; 255
     a82:	1f 4f       	sbci	r17, 0xFF	; 255
     a84:	08 94       	sec
     a86:	c1 1c       	adc	r12, r1
     a88:	d1 1c       	adc	r13, r1
     a8a:	08 94       	sec
     a8c:	e1 1c       	adc	r14, r1
     a8e:	f1 1c       	adc	r15, r1
     a90:	08 15       	cp	r16, r8
     a92:	19 05       	cpc	r17, r9
     a94:	28 f4       	brcc	.+10     	; 0xaa0 <lcd_draw_image_xy_P+0x118>
     a96:	80 91 69 00 	lds	r24, 0x0069
     a9a:	84 38       	cpi	r24, 0x84	; 132
     a9c:	08 f4       	brcc	.+2      	; 0xaa0 <lcd_draw_image_xy_P+0x118>
     a9e:	c5 cf       	rjmp	.-118    	; 0xa2a <lcd_draw_image_xy_P+0xa2>
			if(j > 0 && offset)
				data |= pgm_read_byte(&progmem_image[(j-1)*columns + i]) >> (8-offset);
			if(inv)	lcd_data(~data);
      else 		lcd_data(data);
		  }
		if(j+1 != pages)
     aa0:	8f 81       	ldd	r24, Y+7	; 0x07
     aa2:	98 85       	ldd	r25, Y+8	; 0x08
     aa4:	01 96       	adiw	r24, 0x01	; 1
     aa6:	98 87       	std	Y+8, r25	; 0x08
     aa8:	8f 83       	std	Y+7, r24	; 0x07
     aaa:	86 15       	cp	r24, r6
     aac:	97 05       	cpc	r25, r7
     aae:	29 f0       	breq	.+10     	; 0xaba <lcd_draw_image_xy_P+0x132>
			lcd_move_xy(1,-columns);
     ab0:	81 e0       	ldi	r24, 0x01	; 1
     ab2:	6d 81       	ldd	r22, Y+5	; 0x05
     ab4:	7e 81       	ldd	r23, Y+6	; 0x06
     ab6:	0e 94 6f 04 	call	0x8de	; 0x8de <lcd_move_xy>
     aba:	a8 0c       	add	r10, r8
     abc:	b9 1c       	adc	r11, r9
     abe:	28 0c       	add	r2, r8
     ac0:	39 1c       	adc	r3, r9
  //If there is not enough vertical space -> cut image
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
    pages = LCD_RAM_PAGES - lcd_get_position_page();
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
	for (j=0; j<pages; j++) {
     ac2:	ef 81       	ldd	r30, Y+7	; 0x07
     ac4:	f8 85       	ldd	r31, Y+8	; 0x08
     ac6:	e6 15       	cp	r30, r6
     ac8:	f7 05       	cpc	r31, r7
     aca:	40 f4       	brcc	.+16     	; 0xadc <lcd_draw_image_xy_P+0x154>
     acc:	61 01       	movw	r12, r2
     ace:	75 01       	movw	r14, r10
     ad0:	00 e0       	ldi	r16, 0x00	; 0
     ad2:	10 e0       	ldi	r17, 0x00	; 0
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
      data = 0;
      if (!offset || j+1 != pages)
     ad4:	31 96       	adiw	r30, 0x01	; 1
     ad6:	fc 83       	std	Y+4, r31	; 0x04
     ad8:	eb 83       	std	Y+3, r30	; 0x03
     ada:	da cf       	rjmp	.-76     	; 0xa90 <lcd_draw_image_xy_P+0x108>
      else 		lcd_data(data);
		  }
		if(j+1 != pages)
			lcd_move_xy(1,-columns);
	  }
  }
     adc:	28 96       	adiw	r28, 0x08	; 8
     ade:	0f b6       	in	r0, 0x3f	; 63
     ae0:	f8 94       	cli
     ae2:	de bf       	out	0x3e, r29	; 62
     ae4:	0f be       	out	0x3f, r0	; 63
     ae6:	cd bf       	out	0x3d, r28	; 61
     ae8:	cf 91       	pop	r28
     aea:	df 91       	pop	r29
     aec:	1f 91       	pop	r17
     aee:	0f 91       	pop	r16
     af0:	ff 90       	pop	r15
     af2:	ef 90       	pop	r14
     af4:	df 90       	pop	r13
     af6:	cf 90       	pop	r12
     af8:	bf 90       	pop	r11
     afa:	af 90       	pop	r10
     afc:	9f 90       	pop	r9
     afe:	8f 90       	pop	r8
     b00:	7f 90       	pop	r7
     b02:	6f 90       	pop	r6
     b04:	5f 90       	pop	r5
     b06:	4f 90       	pop	r4
     b08:	3f 90       	pop	r3
     b0a:	2f 90       	pop	r2
     b0c:	08 95       	ret

00000b0e <lcd_clear_area>:
 * pages         - height of area in pages
 * columns       - width of area in pixels
 * style         - Bit2: sets inverse mode
 * Cursor is moved to start of area after clear
 */
void lcd_clear_area(uint8_t pages, uint8_t columns, uint8_t style) {
     b0e:	df 92       	push	r13
     b10:	ef 92       	push	r14
     b12:	ff 92       	push	r15
     b14:	0f 93       	push	r16
     b16:	1f 93       	push	r17
     b18:	cf 93       	push	r28
     b1a:	df 93       	push	r29
     b1c:	38 2f       	mov	r19, r24
  uint8_t i,j,max;
  uint8_t inv = (style & INVERT_BIT)?0xFF:0;
     b1e:	42 fd       	sbrc	r20, 2
     b20:	02 c0       	rjmp	.+4      	; 0xb26 <lcd_clear_area+0x18>
     b22:	dd 24       	eor	r13, r13
     b24:	02 c0       	rjmp	.+4      	; 0xb2a <lcd_clear_area+0x1c>
     b26:	dd 24       	eor	r13, r13
     b28:	da 94       	dec	r13
     b2a:	24 e0       	ldi	r18, 0x04	; 4
     b2c:	80 91 68 00 	lds	r24, 0x0068
     b30:	28 1b       	sub	r18, r24
     b32:	e3 2e       	mov	r14, r19
     b34:	23 17       	cp	r18, r19
     b36:	08 f4       	brcc	.+2      	; 0xb3a <lcd_clear_area+0x2c>
     b38:	e2 2e       	mov	r14, r18
     b3a:	24 e8       	ldi	r18, 0x84	; 132
     b3c:	80 91 69 00 	lds	r24, 0x0069
     b40:	28 1b       	sub	r18, r24
     b42:	06 2f       	mov	r16, r22
     b44:	26 17       	cp	r18, r22
     b46:	08 f4       	brcc	.+2      	; 0xb4a <lcd_clear_area+0x3c>
     b48:	02 2f       	mov	r16, r18
     b4a:	ff 24       	eor	r15, r15
  
  for(j=0; j<pages; j++) {
    for(i=0; i<columns; i++) {
      lcd_data(inv);
      }
    lcd_move_xy(1,-columns);
     b4c:	80 2f       	mov	r24, r16
     b4e:	90 e0       	ldi	r25, 0x00	; 0
     b50:	cc 27       	eor	r28, r28
     b52:	dd 27       	eor	r29, r29
     b54:	c8 1b       	sub	r28, r24
     b56:	d9 0b       	sbc	r29, r25
     b58:	0b c0       	rjmp	.+22     	; 0xb70 <lcd_clear_area+0x62>
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
    columns = max;
  
  for(j=0; j<pages; j++) {
    for(i=0; i<columns; i++) {
      lcd_data(inv);
     b5a:	8d 2d       	mov	r24, r13
     b5c:	0e 94 44 04 	call	0x888	; 0x888 <lcd_data>
    pages = max;
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
    columns = max;
  
  for(j=0; j<pages; j++) {
    for(i=0; i<columns; i++) {
     b60:	1f 5f       	subi	r17, 0xFF	; 255
     b62:	10 17       	cp	r17, r16
     b64:	d0 f3       	brcs	.-12     	; 0xb5a <lcd_clear_area+0x4c>
      lcd_data(inv);
      }
    lcd_move_xy(1,-columns);
     b66:	81 e0       	ldi	r24, 0x01	; 1
     b68:	be 01       	movw	r22, r28
     b6a:	0e 94 6f 04 	call	0x8de	; 0x8de <lcd_move_xy>
  if(pages > (max = LCD_RAM_PAGES - lcd_get_position_page()))   
    pages = max;
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
    columns = max;
  
  for(j=0; j<pages; j++) {
     b6e:	f3 94       	inc	r15
     b70:	fe 14       	cp	r15, r14
     b72:	10 f4       	brcc	.+4      	; 0xb78 <lcd_clear_area+0x6a>
     b74:	10 e0       	ldi	r17, 0x00	; 0
     b76:	f5 cf       	rjmp	.-22     	; 0xb62 <lcd_clear_area+0x54>
    for(i=0; i<columns; i++) {
      lcd_data(inv);
      }
    lcd_move_xy(1,-columns);
    }
  lcd_move_xy(-pages,0);
     b78:	8e 2d       	mov	r24, r14
     b7a:	81 95       	neg	r24
     b7c:	60 e0       	ldi	r22, 0x00	; 0
     b7e:	70 e0       	ldi	r23, 0x00	; 0
     b80:	0e 94 6f 04 	call	0x8de	; 0x8de <lcd_move_xy>
  }
     b84:	df 91       	pop	r29
     b86:	cf 91       	pop	r28
     b88:	1f 91       	pop	r17
     b8a:	0f 91       	pop	r16
     b8c:	ff 90       	pop	r15
     b8e:	ef 90       	pop	r14
     b90:	df 90       	pop	r13
     b92:	08 95       	ret

00000b94 <lcd_clear_area_xy>:
 * style         - style modifier
 * col           - column of upper left corner
 * page          - page of upper left corner
 * Cursor is moved to start of area after clear
 */
void lcd_clear_area_xy(uint8_t pages, uint8_t columns, uint8_t style, uint8_t col, uint8_t page) {
     b94:	ef 92       	push	r14
     b96:	ff 92       	push	r15
     b98:	0f 93       	push	r16
     b9a:	1f 93       	push	r17
     b9c:	18 2f       	mov	r17, r24
     b9e:	f6 2e       	mov	r15, r22
     ba0:	e4 2e       	mov	r14, r20
     ba2:	82 2f       	mov	r24, r18
     ba4:	60 2f       	mov	r22, r16
  lcd_moveto_xy(col,page);
     ba6:	0e 94 56 04 	call	0x8ac	; 0x8ac <lcd_moveto_xy>
  lcd_clear_area(pages,columns,style);
     baa:	81 2f       	mov	r24, r17
     bac:	6f 2d       	mov	r22, r15
     bae:	4e 2d       	mov	r20, r14
     bb0:	0e 94 87 05 	call	0xb0e	; 0xb0e <lcd_clear_area>
  }
     bb4:	1f 91       	pop	r17
     bb6:	0f 91       	pop	r16
     bb8:	ff 90       	pop	r15
     bba:	ef 90       	pop	r14
     bbc:	08 95       	ret

00000bbe <init_spi_lcd>:
  */
void init_spi_lcd() {
   
   
   //set MOSI and SCK as output pins
   DDRB |= (1<<PINB5)|(1<<PINB7);
     bbe:	87 b3       	in	r24, 0x17	; 23
     bc0:	80 6a       	ori	r24, 0xA0	; 160
     bc2:	87 bb       	out	0x17, r24	; 23
   
   //set A0, LCD_Reset as outputs
   DDRA |= (1<<PINA5) | (1<<PINA4);
     bc4:	8a b3       	in	r24, 0x1a	; 26
     bc6:	80 63       	ori	r24, 0x30	; 48
     bc8:	8a bb       	out	0x1a, r24	; 26
   
   //set SS` as an output pin
   DDRB |= (1<<PINB4);
     bca:	bc 9a       	sbi	0x17, 4	; 23
		CPOL:   Clock Polarity -> leading edge  = falling edge
							   -> trailing edge = rising edge
		CPHA:	Clock Phase -> Leading edge  = setup
							   Trailing edge = sample
   */
   SPCR = (0<<SPIE) | (1<<SPE) | (0<<DORD) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (0<<SPR1) | (0<<SPR0);
     bcc:	8c e5       	ldi	r24, 0x5C	; 92
     bce:	8d b9       	out	0x0d, r24	; 13
         
   
   
   //SPI status register
   //SPI2X: Double SPI Speed Bit -> minimum SCK period will be two CPU clock periods
   SPSR = (1<<SPI2X);
     bd0:	81 e0       	ldi	r24, 0x01	; 1
     bd2:	8e b9       	out	0x0e, r24	; 14

   SPDR = LCD_NOP; //Do not use 0 here, only LCD_NOP is allowed!
     bd4:	83 ee       	ldi	r24, 0xE3	; 227
     bd6:	8f b9       	out	0x0f, r24	; 15
   

   
   }
     bd8:	08 95       	ret

00000bda <lcd_init>:
/******************************************************************************
  * Initializes the display in 6 o'clock mode, 4x booster for 2.4-3.3V supply voltage
  * scheme according to datasheet
  * Suitable for all DOGS, DOGM and DOGL displays.
  */
void lcd_init() {
     bda:	0f 93       	push	r16
     bdc:	1f 93       	push	r17
  //for better understanding -> write macros in clear text


  //set outputs
  //LCD_SET_PIN_DIRECTIONS();
  DDR_A0 |= (1<<PIN_A0);
     bde:	d5 9a       	sbi	0x1a, 5	; 26
  DDR_RST |= (1<<PIN_RST);
     be0:	d4 9a       	sbi	0x1a, 4	; 26
  DDR_CS  |= (1<<PIN_CS);
     be2:	bc 9a       	sbi	0x17, 4	; 23
  
  
  //Initialize SPI Interface
  //LCD_INIT_SPI();   
  init_spi_lcd();
     be4:	0e 94 df 05 	call	0xbbe	; 0xbbe <init_spi_lcd>
    
  
  //Apply Reset to the Display Controller
  //LCD_RESET();
  PORT_RST &= ~(1<<PIN_RST);
     be8:	dc 98       	cbi	0x1b, 4	; 27
     bea:	00 ed       	ldi	r16, 0xD0	; 208
     bec:	17 e0       	ldi	r17, 0x07	; 7
     bee:	c8 01       	movw	r24, r16
     bf0:	01 97       	sbiw	r24, 0x01	; 1
     bf2:	f1 f7       	brne	.-4      	; 0xbf0 <lcd_init+0x16>
  _delay_ms(1);
  PORT_RST |= (1<<PIN_RST);
     bf4:	dc 9a       	sbi	0x1b, 4	; 27
  
    
  //Load settings
  
  //(2)
  LCD_SET_FIRST_LINE(0);              //first bit in RAM is on the first line of the LCD
     bf6:	80 e4       	ldi	r24, 0x40	; 64
     bf8:	0e 94 4f 04 	call	0x89e	; 0x89e <lcd_command>
     bfc:	c8 01       	movw	r24, r16
     bfe:	01 97       	sbiw	r24, 0x01	; 1
     c00:	f1 f7       	brne	.-4      	; 0xbfe <lcd_init+0x24>
  //without this delay the content is displayed mirror inverted
  _delay_ms(1); 


  //(8)     
  LCD_SET_BOTTOM_VIEW();              //6 o'clock mode, normal orientation
     c02:	81 ea       	ldi	r24, 0xA1	; 161
     c04:	0e 94 4f 04 	call	0x89e	; 0x89e <lcd_command>
  // |
  //  --> lcd_command(LCD_BOTTOMVIEW)
  //					-> LCD_BOTTOMVIEW = ADC reverse
  //_delay_ms(1);
  //(15)
  LCD_ORIENTATION_NORMAL();
     c08:	80 ec       	ldi	r24, 0xC0	; 192
     c0a:	0e 94 4f 04 	call	0x89e	; 0x89e <lcd_command>
     c0e:	c8 01       	movw	r24, r16
     c10:	01 97       	sbiw	r24, 0x01	; 1
     c12:	f1 f7       	brne	.-4      	; 0xc10 <lcd_init+0x36>
  // |
  //   --> lcd_command(LCD_SHOW_NORMAL)
  //					-> LCD_SHOW_NORMAL = display all points, normal display (10)
    
  //(9)	
  LCD_SET_MODE_POSITIVE();            //positive display
     c14:	86 ea       	ldi	r24, 0xA6	; 166
     c16:	0e 94 4f 04 	call	0x89e	; 0x89e <lcd_command>
  //  --> lcd_command(LCD_DISPLAY_POSITIVE)
  //      				-> LCD_DISPLAY_POSITIVE = sets display normal (9)
   
  #if DISPLAY_TYPE == 132
    //(11)
    LCD_SET_BIAS_RATIO_1_9();           //bias 1/9
     c1a:	82 ea       	ldi	r24, 0xA2	; 162
     c1c:	0e 94 4f 04 	call	0x89e	; 0x89e <lcd_command>
    // |
	//  --> lcd_command(LCD_BIAS_1_9)
	
    //(16)	
	LCD_SET_POWER_CONTROL(7);           //power control mode: all features on
     c20:	8f e2       	ldi	r24, 0x2F	; 47
     c22:	0e 94 4f 04 	call	0x89e	; 0x89e <lcd_command>
	//  --> lcd_command(LCD_POWER_CONTROL | ((i) & 0x07))  
	//						-> command 16 with operating mode = 0b111
	
	
	//(20) -> selbst eingefügtes macro
	LCD_SET_BOOSTER_RATIO();
     c26:	80 e0       	ldi	r24, 0x00	; 0
     c28:	0e 94 4f 04 	call	0x89e	; 0x89e <lcd_command>
	
	
	//(17)
	LCD_SET_BIAS_VOLTAGE(3);            //set voltage regulator R/R
     c2c:	83 e2       	ldi	r24, 0x23	; 35
     c2e:	0e 94 4f 04 	call	0x89e	; 0x89e <lcd_command>
	// |
	//   --> lcd_command(LCD_VOLTAGE | ((i) & 0x07))
	// 						-> command 17 with resistor ration 0b011
    
	//(18)
	LCD_SET_VOLUME_MODE(0x1F);          //volume mode set
     c32:	81 e8       	ldi	r24, 0x81	; 129
     c34:	0e 94 4f 04 	call	0x89e	; 0x89e <lcd_command>
     c38:	8f e1       	ldi	r24, 0x1F	; 31
     c3a:	0e 94 4f 04 	call	0x89e	; 0x89e <lcd_command>
	//						-> standard command 18
	//  --> lcd_command(LCD_VOLUME_MODE_2 | ((i) & 0x3F))
	//						-> command 18 with electronic volume value 0b011111
	
	//(19)
	LCD_SET_INDICATOR_OFF();            //switch indicator off, no blinking
     c3e:	8c ea       	ldi	r24, 0xAC	; 172
     c40:	0e 94 4f 04 	call	0x89e	; 0x89e <lcd_command>
     c44:	80 e0       	ldi	r24, 0x00	; 0
     c46:	0e 94 4f 04 	call	0x89e	; 0x89e <lcd_command>
     c4a:	10 e0       	ldi	r17, 0x00	; 0
  
  
  uint8_t i,j;                        //clear display content
 
 for(j=0;j<LCD_RAM_PAGES;j++) {
    lcd_moveto_xy(j,0);   // array (uint8_t page, uint8_t column)
     c4c:	81 2f       	mov	r24, r17
     c4e:	60 e0       	ldi	r22, 0x00	; 0
     c50:	0e 94 56 04 	call	0x8ac	; 0x8ac <lcd_moveto_xy>
     c54:	00 e0       	ldi	r16, 0x00	; 0
    for (i=0;i<LCD_WIDTH;i++)
      lcd_data(0);
     c56:	80 e0       	ldi	r24, 0x00	; 0
     c58:	0e 94 44 04 	call	0x888	; 0x888 <lcd_data>
  
  uint8_t i,j;                        //clear display content
 
 for(j=0;j<LCD_RAM_PAGES;j++) {
    lcd_moveto_xy(j,0);   // array (uint8_t page, uint8_t column)
    for (i=0;i<LCD_WIDTH;i++)
     c5c:	0f 5f       	subi	r16, 0xFF	; 255
     c5e:	04 38       	cpi	r16, 0x84	; 132
     c60:	d1 f7       	brne	.-12     	; 0xc56 <lcd_init+0x7c>
  #endif
  
  
  uint8_t i,j;                        //clear display content
 
 for(j=0;j<LCD_RAM_PAGES;j++) {
     c62:	1f 5f       	subi	r17, 0xFF	; 255
     c64:	14 30       	cpi	r17, 0x04	; 4
     c66:	91 f7       	brne	.-28     	; 0xc4c <lcd_init+0x72>
    lcd_moveto_xy(j,0);   // array (uint8_t page, uint8_t column)
    for (i=0;i<LCD_WIDTH;i++)
      lcd_data(0);
    }

  lcd_moveto_xy(0,0);                 //Set write pointer
     c68:	80 e0       	ldi	r24, 0x00	; 0
     c6a:	60 e0       	ldi	r22, 0x00	; 0
     c6c:	0e 94 56 04 	call	0x8ac	; 0x8ac <lcd_moveto_xy>
  LCD_SWITCH_ON();                    //Switch display on (1)
     c70:	8f ea       	ldi	r24, 0xAF	; 175
     c72:	0e 94 4f 04 	call	0x89e	; 0x89e <lcd_command>
  return;
  }
     c76:	1f 91       	pop	r17
     c78:	0f 91       	pop	r16
     c7a:	08 95       	ret

00000c7c <lcd_set_font>:
 * Stores the default font type and style in a global variable
 * font          - Font identifier
 * style         - Style Modifier
 */
inline void lcd_set_font(FONT_P font, uint8_t style){
  global_font_select = font;
     c7c:	90 93 6c 00 	sts	0x006C, r25
     c80:	80 93 6b 00 	sts	0x006B, r24
  global_font_style = style;
     c84:	60 93 6a 00 	sts	0x006A, r22
}
     c88:	08 95       	ret

00000c8a <font_data>:
 * Loads the pointer to the selected fonts data
 */
inline PGM_P font_data(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->data));
     c8a:	fc 01       	movw	r30, r24
     c8c:	38 96       	adiw	r30, 0x08	; 8
     c8e:	25 91       	lpm	r18, Z+
     c90:	34 91       	lpm	r19, Z+
  else
    memcpy_P((char*)&tmp,&(font->data),sizeof(tmp));
  return tmp;
  }
     c92:	c9 01       	movw	r24, r18
     c94:	08 95       	ret

00000c96 <font_widthtable>:
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     c96:	fc 01       	movw	r30, r24
     c98:	36 96       	adiw	r30, 0x06	; 6
     c9a:	25 91       	lpm	r18, Z+
     c9c:	34 91       	lpm	r19, Z+
  else
    memcpy_P((char*)&tmp,&(font->widthtable),sizeof(tmp));
  return tmp;
  }
     c9e:	c9 01       	movw	r24, r18
     ca0:	08 95       	ret

00000ca2 <font_get_height_bytes>:
/******************************************************************************
 * Loads the height (in bytes) of the given font
 */
inline uint8_t font_get_height_bytes(FONT_P font) {
  FONT_P tmp = font;
  uint8_t t = pgm_read_byte(&tmp->height);
     ca2:	fc 01       	movw	r30, r24
     ca4:	33 96       	adiw	r30, 0x03	; 3
     ca6:	e4 91       	lpm	r30, Z+
     ca8:	e1 50       	subi	r30, 0x01	; 1
     caa:	e6 95       	lsr	r30
     cac:	e6 95       	lsr	r30
     cae:	e6 95       	lsr	r30
  return (((uint8_t)(t-1)>>3)+1);
  }
     cb0:	8e 2f       	mov	r24, r30
     cb2:	8f 5f       	subi	r24, 0xFF	; 255
     cb4:	08 95       	ret

00000cb6 <font_get_add_space>:
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     cb6:	fc 01       	movw	r30, r24
     cb8:	36 96       	adiw	r30, 0x06	; 6
     cba:	85 91       	lpm	r24, Z+
     cbc:	94 91       	lpm	r25, Z+
     cbe:	20 e0       	ldi	r18, 0x00	; 0
     cc0:	89 2b       	or	r24, r25
     cc2:	09 f0       	breq	.+2      	; 0xcc6 <font_get_add_space+0x10>
     cc4:	21 e0       	ldi	r18, 0x01	; 1
  PGM_P type = font_widthtable(font);
  if ( type != 0 ) //if there is a width table, then it's a proportional font
    return 1;
  else
    return 0;
  }
     cc6:	82 2f       	mov	r24, r18
     cc8:	08 95       	ret

00000cca <font_get_char_number>:


/******************************************************************************
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
     cca:	fc 01       	movw	r30, r24
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
     ccc:	35 96       	adiw	r30, 0x05	; 5
     cce:	84 91       	lpm	r24, Z+
     cd0:	35 97       	sbiw	r30, 0x05	; 5
     cd2:	86 17       	cp	r24, r22
     cd4:	40 f0       	brcs	.+16     	; 0xce6 <font_get_char_number+0x1c>
    return -1;
  uint8_t first = pgm_read_byte(&tmp->firstchar);
     cd6:	34 96       	adiw	r30, 0x04	; 4
     cd8:	84 91       	lpm	r24, Z+
  if (character < first) 
     cda:	68 17       	cp	r22, r24
     cdc:	20 f0       	brcs	.+8      	; 0xce6 <font_get_char_number+0x1c>
    return -1;
  return character - first;
     cde:	70 e0       	ldi	r23, 0x00	; 0
     ce0:	68 1b       	sub	r22, r24
     ce2:	71 09       	sbc	r23, r1
     ce4:	02 c0       	rjmp	.+4      	; 0xcea <font_get_char_number+0x20>
     ce6:	6f ef       	ldi	r22, 0xFF	; 255
     ce8:	7f ef       	ldi	r23, 0xFF	; 255
  }
     cea:	cb 01       	movw	r24, r22
     cec:	08 95       	ret

00000cee <font_get_char_width>:


/******************************************************************************
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
     cee:	ac 01       	movw	r20, r24
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     cf0:	06 96       	adiw	r24, 0x06	; 6
     cf2:	fc 01       	movw	r30, r24
     cf4:	25 91       	lpm	r18, Z+
     cf6:	34 91       	lpm	r19, Z+
/******************************************************************************
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
  PGM_P table = font_widthtable(font);
  if (table)
     cf8:	21 15       	cp	r18, r1
     cfa:	31 05       	cpc	r19, r1
     cfc:	c9 f0       	breq	.+50     	; 0xd30 <font_get_char_width+0x42>
/******************************************************************************
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
     cfe:	4b 5f       	subi	r20, 0xFB	; 251
     d00:	5f 4f       	sbci	r21, 0xFF	; 255
     d02:	fa 01       	movw	r30, r20
     d04:	84 91       	lpm	r24, Z+
     d06:	45 50       	subi	r20, 0x05	; 5
     d08:	50 40       	sbci	r21, 0x00	; 0
     d0a:	86 17       	cp	r24, r22
     d0c:	50 f0       	brcs	.+20     	; 0xd22 <font_get_char_width+0x34>
    return -1;
  uint8_t first = pgm_read_byte(&tmp->firstchar);
     d0e:	4c 5f       	subi	r20, 0xFC	; 252
     d10:	5f 4f       	sbci	r21, 0xFF	; 255
     d12:	fa 01       	movw	r30, r20
     d14:	84 91       	lpm	r24, Z+
  if (character < first) 
     d16:	68 17       	cp	r22, r24
     d18:	20 f0       	brcs	.+8      	; 0xd22 <font_get_char_width+0x34>
    return -1;
  return character - first;
     d1a:	70 e0       	ldi	r23, 0x00	; 0
     d1c:	68 1b       	sub	r22, r24
     d1e:	71 09       	sbc	r23, r1
     d20:	02 c0       	rjmp	.+4      	; 0xd26 <font_get_char_width+0x38>
     d22:	6f ef       	ldi	r22, 0xFF	; 255
     d24:	7f ef       	ldi	r23, 0xFF	; 255
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
  PGM_P table = font_widthtable(font);
  if (table)
    return pgm_read_byte(table+font_get_char_number(font,character));
     d26:	26 0f       	add	r18, r22
     d28:	37 1f       	adc	r19, r23
     d2a:	f9 01       	movw	r30, r18
     d2c:	84 91       	lpm	r24, Z+
     d2e:	08 95       	ret
  else
    return pgm_read_byte(&font->width);
     d30:	4e 5f       	subi	r20, 0xFE	; 254
     d32:	5f 4f       	sbci	r21, 0xFF	; 255
     d34:	fa 01       	movw	r30, r20
     d36:	84 91       	lpm	r24, Z+
  }
     d38:	08 95       	ret

00000d3a <font_get_char_position>:


/******************************************************************************
 * Calculate the pointer to the requested character inside the Flash ROM
 */
PGM_P font_get_char_position(FONT_P font, char character) {
     d3a:	ef 92       	push	r14
     d3c:	ff 92       	push	r15
     d3e:	0f 93       	push	r16
     d40:	1f 93       	push	r17
     d42:	9c 01       	movw	r18, r24
/******************************************************************************
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
     d44:	2b 5f       	subi	r18, 0xFB	; 251
     d46:	3f 4f       	sbci	r19, 0xFF	; 255
     d48:	f9 01       	movw	r30, r18
     d4a:	84 91       	lpm	r24, Z+
     d4c:	25 50       	subi	r18, 0x05	; 5
     d4e:	30 40       	sbci	r19, 0x00	; 0
     d50:	86 17       	cp	r24, r22
     d52:	68 f0       	brcs	.+26     	; 0xd6e <font_get_char_position+0x34>
    return -1;
  uint8_t first = pgm_read_byte(&tmp->firstchar);
     d54:	2c 5f       	subi	r18, 0xFC	; 252
     d56:	3f 4f       	sbci	r19, 0xFF	; 255
     d58:	f9 01       	movw	r30, r18
     d5a:	44 91       	lpm	r20, Z+
     d5c:	24 50       	subi	r18, 0x04	; 4
     d5e:	30 40       	sbci	r19, 0x00	; 0
  if (character < first) 
     d60:	64 17       	cp	r22, r20
     d62:	28 f0       	brcs	.+10     	; 0xd6e <font_get_char_position+0x34>
    return -1;
  return character - first;
     d64:	86 2f       	mov	r24, r22
     d66:	90 e0       	ldi	r25, 0x00	; 0
     d68:	84 1b       	sub	r24, r20
     d6a:	91 09       	sbc	r25, r1
     d6c:	02 c0       	rjmp	.+4      	; 0xd72 <font_get_char_position+0x38>
     d6e:	8f ef       	ldi	r24, 0xFF	; 255
     d70:	9f ef       	ldi	r25, 0xFF	; 255
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     d72:	f9 01       	movw	r30, r18
     d74:	36 96       	adiw	r30, 0x06	; 6
     d76:	45 91       	lpm	r20, Z+
     d78:	54 91       	lpm	r21, Z+
  uint16_t ret         = 0;
  int16_t  charnum_ret = font_get_char_number(font, character);
  uint8_t  charnum     = charnum_ret;
  PGM_P    base        = font_widthtable(font);

  if (charnum_ret < 0)     //char not found
     d7a:	97 ff       	sbrs	r25, 7
     d7c:	03 c0       	rjmp	.+6      	; 0xd84 <font_get_char_position+0x4a>
     d7e:	40 e0       	ldi	r20, 0x00	; 0
     d80:	50 e0       	ldi	r21, 0x00	; 0
     d82:	4b c0       	rjmp	.+150    	; 0xe1a <font_get_char_position+0xe0>
 * Calculate the pointer to the requested character inside the Flash ROM
 */
PGM_P font_get_char_position(FONT_P font, char character) {
  uint16_t ret         = 0;
  int16_t  charnum_ret = font_get_char_number(font, character);
  uint8_t  charnum     = charnum_ret;
     d84:	08 2f       	mov	r16, r24
  PGM_P    base        = font_widthtable(font);

  if (charnum_ret < 0)     //char not found
    return 0;
  if(base == 0)            //fixed width
     d86:	41 15       	cp	r20, r1
     d88:	51 05       	cpc	r21, r1
     d8a:	d9 f4       	brne	.+54     	; 0xdc2 <font_get_char_position+0x88>
 * Loads the pointer to the selected fonts data
 */
inline PGM_P font_data(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->data));
     d8c:	f9 01       	movw	r30, r18
     d8e:	38 96       	adiw	r30, 0x08	; 8
     d90:	e5 90       	lpm	r14, Z+
     d92:	f4 90       	lpm	r15, Z+
/******************************************************************************
 * Loads the height (in bytes) of the given font
 */
inline uint8_t font_get_height_bytes(FONT_P font) {
  FONT_P tmp = font;
  uint8_t t = pgm_read_byte(&tmp->height);
     d94:	2d 5f       	subi	r18, 0xFD	; 253
     d96:	3f 4f       	sbci	r19, 0xFF	; 255
     d98:	f9 01       	movw	r30, r18
     d9a:	14 91       	lpm	r17, Z+
     d9c:	23 50       	subi	r18, 0x03	; 3
     d9e:	30 40       	sbci	r19, 0x00	; 0
  PGM_P    base        = font_widthtable(font);

  if (charnum_ret < 0)     //char not found
    return 0;
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
     da0:	c9 01       	movw	r24, r18
     da2:	0e 94 77 06 	call	0xcee	; 0xcee <font_get_char_width>
     da6:	11 50       	subi	r17, 0x01	; 1
     da8:	16 95       	lsr	r17
     daa:	16 95       	lsr	r17
     dac:	16 95       	lsr	r17
     dae:	1f 5f       	subi	r17, 0xFF	; 255
     db0:	18 9f       	mul	r17, r24
     db2:	10 2d       	mov	r17, r0
     db4:	11 24       	eor	r1, r1
     db6:	10 9f       	mul	r17, r16
     db8:	a0 01       	movw	r20, r0
     dba:	11 24       	eor	r1, r1
     dbc:	4e 0d       	add	r20, r14
     dbe:	5f 1d       	adc	r21, r15
     dc0:	2c c0       	rjmp	.+88     	; 0xe1a <font_get_char_position+0xe0>
  if (charnum)             //proportional width
     dc2:	88 23       	and	r24, r24
     dc4:	19 f4       	brne	.+6      	; 0xdcc <font_get_char_position+0x92>
     dc6:	60 e0       	ldi	r22, 0x00	; 0
     dc8:	70 e0       	ldi	r23, 0x00	; 0
     dca:	0f c0       	rjmp	.+30     	; 0xdea <font_get_char_position+0xb0>
     dcc:	60 e0       	ldi	r22, 0x00	; 0
     dce:	70 e0       	ldi	r23, 0x00	; 0
    while(charnum--)
     dd0:	ca 01       	movw	r24, r20
     dd2:	80 0f       	add	r24, r16
     dd4:	91 1d       	adc	r25, r1
     dd6:	06 c0       	rjmp	.+12     	; 0xde4 <font_get_char_position+0xaa>

  if (charnum_ret < 0)     //char not found
    return 0;
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
  if (charnum)             //proportional width
     dd8:	fa 01       	movw	r30, r20
    while(charnum--)
      ret += pgm_read_byte(base++);
     dda:	4f 5f       	subi	r20, 0xFF	; 255
     ddc:	5f 4f       	sbci	r21, 0xFF	; 255
     dde:	e4 91       	lpm	r30, Z+
     de0:	6e 0f       	add	r22, r30
     de2:	71 1d       	adc	r23, r1
  if (charnum_ret < 0)     //char not found
    return 0;
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
  if (charnum)             //proportional width
    while(charnum--)
     de4:	48 17       	cp	r20, r24
     de6:	59 07       	cpc	r21, r25
     de8:	b9 f7       	brne	.-18     	; 0xdd8 <font_get_char_position+0x9e>
 * Loads the pointer to the selected fonts data
 */
inline PGM_P font_data(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->data));
     dea:	f9 01       	movw	r30, r18
     dec:	38 96       	adiw	r30, 0x08	; 8
     dee:	45 91       	lpm	r20, Z+
     df0:	54 91       	lpm	r21, Z+
/******************************************************************************
 * Loads the height (in bytes) of the given font
 */
inline uint8_t font_get_height_bytes(FONT_P font) {
  FONT_P tmp = font;
  uint8_t t = pgm_read_byte(&tmp->height);
     df2:	2d 5f       	subi	r18, 0xFD	; 253
     df4:	3f 4f       	sbci	r19, 0xFF	; 255
     df6:	f9 01       	movw	r30, r18
     df8:	84 91       	lpm	r24, Z+
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
  if (charnum)             //proportional width
    while(charnum--)
      ret += pgm_read_byte(base++);
  return (font_data(font))+ret*font_get_height_bytes(font);
     dfa:	81 50       	subi	r24, 0x01	; 1
     dfc:	86 95       	lsr	r24
     dfe:	86 95       	lsr	r24
     e00:	86 95       	lsr	r24
     e02:	8f 5f       	subi	r24, 0xFF	; 255
     e04:	90 e0       	ldi	r25, 0x00	; 0
     e06:	9c 01       	movw	r18, r24
     e08:	26 9f       	mul	r18, r22
     e0a:	c0 01       	movw	r24, r0
     e0c:	27 9f       	mul	r18, r23
     e0e:	90 0d       	add	r25, r0
     e10:	36 9f       	mul	r19, r22
     e12:	90 0d       	add	r25, r0
     e14:	11 24       	eor	r1, r1
     e16:	48 0f       	add	r20, r24
     e18:	59 1f       	adc	r21, r25
  }
     e1a:	ca 01       	movw	r24, r20
     e1c:	1f 91       	pop	r17
     e1e:	0f 91       	pop	r16
     e20:	ff 90       	pop	r15
     e22:	ef 90       	pop	r14
     e24:	08 95       	ret

00000e26 <lcd_put_char>:
 *****************************************************************************/

/******************************************************************************
 * Outputs a character on the display, using the given font and style
 */
uint8_t lcd_put_char(FONT_P font, uint8_t style, char character) {
     e26:	2f 92       	push	r2
     e28:	3f 92       	push	r3
     e2a:	4f 92       	push	r4
     e2c:	5f 92       	push	r5
     e2e:	6f 92       	push	r6
     e30:	7f 92       	push	r7
     e32:	8f 92       	push	r8
     e34:	9f 92       	push	r9
     e36:	af 92       	push	r10
     e38:	bf 92       	push	r11
     e3a:	cf 92       	push	r12
     e3c:	df 92       	push	r13
     e3e:	ef 92       	push	r14
     e40:	ff 92       	push	r15
     e42:	0f 93       	push	r16
     e44:	1f 93       	push	r17
     e46:	df 93       	push	r29
     e48:	cf 93       	push	r28
     e4a:	cd b7       	in	r28, 0x3d	; 61
     e4c:	de b7       	in	r29, 0x3e	; 62
     e4e:	2b 97       	sbiw	r28, 0x0b	; 11
     e50:	0f b6       	in	r0, 0x3f	; 63
     e52:	f8 94       	cli
     e54:	de bf       	out	0x3e, r29	; 62
     e56:	0f be       	out	0x3f, r0	; 63
     e58:	cd bf       	out	0x3d, r28	; 61
     e5a:	5c 01       	movw	r10, r24
     e5c:	f4 2e       	mov	r15, r20
  int8_t  i;
  uint8_t row  = 0;                             //current row of char
  uint8_t hc   = (style & DOUBLE_HEIGHT)?1:0;   //height changed
     e5e:	33 24       	eor	r3, r3
     e60:	33 94       	inc	r3
     e62:	36 22       	and	r3, r22
  uint8_t wc   = (style & DOUBLE_WIDTH)?1:0;    //width changed
     e64:	06 2f       	mov	r16, r22
     e66:	10 e0       	ldi	r17, 0x00	; 0
     e68:	c8 01       	movw	r24, r16
     e6a:	96 95       	lsr	r25
     e6c:	87 95       	ror	r24
     e6e:	28 2f       	mov	r18, r24
     e70:	21 70       	andi	r18, 0x01	; 1
     e72:	2c 83       	std	Y+4, r18	; 0x04
  uint8_t ul   = (style & UNDERLINE)?0x80:0x00; //underline
     e74:	64 fd       	sbrc	r22, 4
     e76:	02 c0       	rjmp	.+4      	; 0xe7c <lcd_put_char+0x56>
     e78:	66 24       	eor	r6, r6
     e7a:	02 c0       	rjmp	.+4      	; 0xe80 <lcd_put_char+0x5a>
     e7c:	80 e8       	ldi	r24, 0x80	; 128
     e7e:	68 2e       	mov	r6, r24
  uint8_t inv  = (style & INVERT)?0xFF:0;       //inverted
     e80:	02 fd       	sbrc	r16, 2
     e82:	02 c0       	rjmp	.+4      	; 0xe88 <lcd_put_char+0x62>
     e84:	77 24       	eor	r7, r7
     e86:	02 c0       	rjmp	.+4      	; 0xe8c <lcd_put_char+0x66>
     e88:	77 24       	eor	r7, r7
     e8a:	7a 94       	dec	r7
  uint8_t tmp;

  //load information about character
   uint8_t char_width    = font_get_char_width(font,character); 
     e8c:	c5 01       	movw	r24, r10
     e8e:	6f 2d       	mov	r22, r15
     e90:	0e 94 77 06 	call	0xcee	; 0xcee <font_get_char_width>
     e94:	e8 2e       	mov	r14, r24
/******************************************************************************
 * Loads the height (in bytes) of the given font
 */
inline uint8_t font_get_height_bytes(FONT_P font) {
  FONT_P tmp = font;
  uint8_t t = pgm_read_byte(&tmp->height);
     e96:	83 e0       	ldi	r24, 0x03	; 3
     e98:	90 e0       	ldi	r25, 0x00	; 0
     e9a:	a8 0e       	add	r10, r24
     e9c:	b9 1e       	adc	r11, r25
     e9e:	f5 01       	movw	r30, r10
     ea0:	d4 90       	lpm	r13, Z+
     ea2:	2d ef       	ldi	r18, 0xFD	; 253
     ea4:	3f ef       	ldi	r19, 0xFF	; 255
     ea6:	a2 0e       	add	r10, r18
     ea8:	b3 1e       	adc	r11, r19
  return (((uint8_t)(t-1)>>3)+1);
     eaa:	da 94       	dec	r13
     eac:	d6 94       	lsr	r13
     eae:	d6 94       	lsr	r13
     eb0:	d6 94       	lsr	r13
     eb2:	d3 94       	inc	r13
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     eb4:	f5 01       	movw	r30, r10
     eb6:	36 96       	adiw	r30, 0x06	; 6
     eb8:	85 91       	lpm	r24, Z+
     eba:	94 91       	lpm	r25, Z+
     ebc:	22 24       	eor	r2, r2
     ebe:	89 2b       	or	r24, r25
     ec0:	11 f0       	breq	.+4      	; 0xec6 <lcd_put_char+0xa0>
     ec2:	22 24       	eor	r2, r2
     ec4:	23 94       	inc	r2

  //load information about character
   uint8_t char_width    = font_get_char_width(font,character); 
   uint8_t font_height   = font_get_height_bytes(font);
   uint8_t free_space    = font_get_add_space(font,character);
   PGM_P   tableposition = font_get_char_position(font,character);
     ec6:	c5 01       	movw	r24, r10
     ec8:	6f 2d       	mov	r22, r15
     eca:	0e 94 9d 06 	call	0xd3a	; 0xd3a <font_get_char_position>
     ece:	9b 83       	std	Y+3, r25	; 0x03
     ed0:	8a 83       	std	Y+2, r24	; 0x02

  //final size of character
  uint8_t char_final_width  = (uint8_t)(char_width+free_space) << wc;
     ed2:	c2 2c       	mov	r12, r2
     ed4:	ce 0c       	add	r12, r14
     ed6:	0c 80       	ldd	r0, Y+4	; 0x04
     ed8:	01 c0       	rjmp	.+2      	; 0xedc <lcd_put_char+0xb6>
     eda:	cc 0c       	add	r12, r12
     edc:	0a 94       	dec	r0
     ede:	ea f7       	brpl	.-6      	; 0xeda <lcd_put_char+0xb4>
  uint8_t char_final_height = (uint8_t)font_height << hc; 
     ee0:	8d 2c       	mov	r8, r13
     ee2:	99 24       	eor	r9, r9
     ee4:	bd 2c       	mov	r11, r13
     ee6:	03 2c       	mov	r0, r3
     ee8:	01 c0       	rjmp	.+2      	; 0xeec <lcd_put_char+0xc6>
     eea:	bb 0c       	add	r11, r11
     eec:	0a 94       	dec	r0
     eee:	ea f7       	brpl	.-6      	; 0xeea <lcd_put_char+0xc4>

  //check for avail. space on display
  if ((style & WRAP) && (LCD_CURRENT_COL() + char_final_width > LCD_WIDTH)) {
     ef0:	03 ff       	sbrs	r16, 3
     ef2:	13 c0       	rjmp	.+38     	; 0xf1a <lcd_put_char+0xf4>
     ef4:	80 91 69 00 	lds	r24, 0x0069
     ef8:	90 e0       	ldi	r25, 0x00	; 0
     efa:	8c 0d       	add	r24, r12
     efc:	91 1d       	adc	r25, r1
     efe:	85 38       	cpi	r24, 0x85	; 133
     f00:	91 05       	cpc	r25, r1
     f02:	5c f0       	brlt	.+22     	; 0xf1a <lcd_put_char+0xf4>
    LCD_MOVE_TO(LCD_CURRENT_PAGE()+char_final_height,0);
     f04:	80 91 68 00 	lds	r24, 0x0068
     f08:	8b 0d       	add	r24, r11
     f0a:	60 e0       	ldi	r22, 0x00	; 0
     f0c:	0e 94 56 04 	call	0x8ac	; 0x8ac <lcd_moveto_xy>
    if (character == ' ') return 0;
     f10:	30 e2       	ldi	r19, 0x20	; 32
     f12:	f3 16       	cp	r15, r19
     f14:	11 f4       	brne	.+4      	; 0xf1a <lcd_put_char+0xf4>
     f16:	cc 24       	eor	r12, r12
     f18:	8e c0       	rjmp	.+284    	; 0x1036 <lcd_put_char+0x210>
    }
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
     f1a:	8e 2d       	mov	r24, r14
     f1c:	90 e0       	ldi	r25, 0x00	; 0
     f1e:	88 9e       	mul	r8, r24
     f20:	d0 01       	movw	r26, r0
     f22:	89 9e       	mul	r8, r25
     f24:	b0 0d       	add	r27, r0
     f26:	98 9e       	mul	r9, r24
     f28:	b0 0d       	add	r27, r0
     f2a:	11 24       	eor	r1, r1
     f2c:	be 83       	std	Y+6, r27	; 0x06
     f2e:	ad 83       	std	Y+5, r26	; 0x05
        LCD_WRITE(tmp);
      }
    if (free_space) {
      uint8_t c = inv;
      if(row == char_final_height-1) {
        c ^= ul; 
     f30:	b7 2d       	mov	r27, r7
     f32:	b6 25       	eor	r27, r6
     f34:	b9 83       	std	Y+1, r27	; 0x01
        if(hc)
          c ^= ul>>1;      
     f36:	a6 2c       	mov	r10, r6
     f38:	a6 94       	lsr	r10
     f3a:	ab 26       	eor	r10, r27
     f3c:	1b 86       	std	Y+11, r1	; 0x0b
     f3e:	1a 86       	std	Y+10, r1	; 0x0a
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
      tmp = pgm_read_byte(tableposition+i);
      if(row == char_final_height-1) 
     f40:	eb 2c       	mov	r14, r11
     f42:	ff 24       	eor	r15, r15
     f44:	08 94       	sec
     f46:	e1 08       	sbc	r14, r1
     f48:	f1 08       	sbc	r15, r1
        }
      LCD_WRITE(c);
      if(wc) 
        LCD_WRITE(c);
      }
    LCD_MOVE(1,-char_final_width);
     f4a:	4c 2c       	mov	r4, r12
     f4c:	55 24       	eor	r5, r5
     f4e:	ee 27       	eor	r30, r30
     f50:	ff 27       	eor	r31, r31
     f52:	e4 19       	sub	r30, r4
     f54:	f5 09       	sbc	r31, r5
     f56:	f9 87       	std	Y+9, r31	; 0x09
     f58:	e8 87       	std	Y+8, r30	; 0x08
    if (character == ' ') return 0;
    }
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
     f5a:	8a 84       	ldd	r8, Y+10	; 0x0a
     f5c:	9b 84       	ldd	r9, Y+11	; 0x0b
     f5e:	03 2c       	mov	r0, r3
     f60:	02 c0       	rjmp	.+4      	; 0xf66 <lcd_put_char+0x140>
     f62:	95 94       	asr	r9
     f64:	87 94       	ror	r8
     f66:	0a 94       	dec	r0
     f68:	e2 f7       	brpl	.-8      	; 0xf62 <lcd_put_char+0x13c>
     f6a:	00 e0       	ldi	r16, 0x00	; 0
 * part = 1:  abcdefgh -> aabbccdd
 * Used for double height font
 */
inline unsigned char double_bits(uint8_t part, char c) {
  char t = 0;
  if (part) c = c>>4;
     f6c:	fa 85       	ldd	r31, Y+10	; 0x0a
     f6e:	f1 70       	andi	r31, 0x01	; 1
     f70:	ff 83       	std	Y+7, r31	; 0x07
     f72:	2d c0       	rjmp	.+90     	; 0xfce <lcd_put_char+0x1a8>
    }
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
      tmp = pgm_read_byte(tableposition+i);
     f74:	2a 81       	ldd	r18, Y+2	; 0x02
     f76:	3b 81       	ldd	r19, Y+3	; 0x03
     f78:	e2 0f       	add	r30, r18
     f7a:	f3 1f       	adc	r31, r19
     f7c:	84 91       	lpm	r24, Z+
      if(row == char_final_height-1) 
     f7e:	aa 85       	ldd	r26, Y+10	; 0x0a
     f80:	bb 85       	ldd	r27, Y+11	; 0x0b
     f82:	ae 15       	cp	r26, r14
     f84:	bf 05       	cpc	r27, r15
     f86:	11 f0       	breq	.+4      	; 0xf8c <lcd_put_char+0x166>
     f88:	18 2f       	mov	r17, r24
     f8a:	02 c0       	rjmp	.+4      	; 0xf90 <lcd_put_char+0x16a>
        tmp |= ul;
     f8c:	18 2f       	mov	r17, r24
     f8e:	16 29       	or	r17, r6
      if(hc)
     f90:	33 20       	and	r3, r3
     f92:	89 f0       	breq	.+34     	; 0xfb6 <lcd_put_char+0x190>
 * part = 1:  abcdefgh -> aabbccdd
 * Used for double height font
 */
inline unsigned char double_bits(uint8_t part, char c) {
  char t = 0;
  if (part) c = c>>4;
     f94:	bf 81       	ldd	r27, Y+7	; 0x07
     f96:	bb 23       	and	r27, r27
     f98:	11 f0       	breq	.+4      	; 0xf9e <lcd_put_char+0x178>
     f9a:	12 95       	swap	r17
     f9c:	1f 70       	andi	r17, 0x0F	; 15
  if (c & 0x08) t  = 0xC0;
     f9e:	81 2f       	mov	r24, r17
     fa0:	13 fd       	sbrc	r17, 3
     fa2:	02 c0       	rjmp	.+4      	; 0xfa8 <lcd_put_char+0x182>
     fa4:	10 e0       	ldi	r17, 0x00	; 0
     fa6:	01 c0       	rjmp	.+2      	; 0xfaa <lcd_put_char+0x184>
     fa8:	10 ec       	ldi	r17, 0xC0	; 192
  if (c & 0x04) t |= 0x30;
     faa:	82 fd       	sbrc	r24, 2
     fac:	10 63       	ori	r17, 0x30	; 48
  if (c & 0x02) t |= 0x0C;
     fae:	81 fd       	sbrc	r24, 1
     fb0:	1c 60       	ori	r17, 0x0C	; 12
  if (c & 0x01) t |= 0x03;
     fb2:	80 fd       	sbrc	r24, 0
     fb4:	13 60       	ori	r17, 0x03	; 3
      tmp = pgm_read_byte(tableposition+i);
      if(row == char_final_height-1) 
        tmp |= ul;
      if(hc)
        tmp = double_bits((row&1),tmp);
      if(inv)
     fb6:	71 10       	cpse	r7, r1
        tmp = ~tmp;
     fb8:	10 95       	com	r17
      LCD_WRITE(tmp);
     fba:	81 2f       	mov	r24, r17
     fbc:	0e 94 44 04 	call	0x888	; 0x888 <lcd_data>
      if(wc) 
     fc0:	ec 81       	ldd	r30, Y+4	; 0x04
     fc2:	ee 23       	and	r30, r30
     fc4:	19 f0       	breq	.+6      	; 0xfcc <lcd_put_char+0x1a6>
        LCD_WRITE(tmp);
     fc6:	81 2f       	mov	r24, r17
     fc8:	0e 94 44 04 	call	0x888	; 0x888 <lcd_data>
     fcc:	0d 0d       	add	r16, r13
     fce:	80 2f       	mov	r24, r16
     fd0:	88 0d       	add	r24, r8
    if (character == ' ') return 0;
    }
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
     fd2:	e8 2f       	mov	r30, r24
     fd4:	ff 27       	eor	r31, r31
     fd6:	e7 fd       	sbrc	r30, 7
     fd8:	f0 95       	com	r31
     fda:	2d 81       	ldd	r18, Y+5	; 0x05
     fdc:	3e 81       	ldd	r19, Y+6	; 0x06
     fde:	e2 17       	cp	r30, r18
     fe0:	f3 07       	cpc	r31, r19
     fe2:	44 f2       	brlt	.-112    	; 0xf74 <lcd_put_char+0x14e>
        tmp = ~tmp;
      LCD_WRITE(tmp);
      if(wc) 
        LCD_WRITE(tmp);
      }
    if (free_space) {
     fe4:	22 20       	and	r2, r2
     fe6:	a9 f0       	breq	.+42     	; 0x1012 <lcd_put_char+0x1ec>
      uint8_t c = inv;
      if(row == char_final_height-1) {
     fe8:	8a 85       	ldd	r24, Y+10	; 0x0a
     fea:	9b 85       	ldd	r25, Y+11	; 0x0b
     fec:	8e 15       	cp	r24, r14
     fee:	9f 05       	cpc	r25, r15
     ff0:	11 f0       	breq	.+4      	; 0xff6 <lcd_put_char+0x1d0>
     ff2:	17 2d       	mov	r17, r7
     ff4:	05 c0       	rjmp	.+10     	; 0x1000 <lcd_put_char+0x1da>
        c ^= ul; 
        if(hc)
     ff6:	33 20       	and	r3, r3
     ff8:	11 f4       	brne	.+4      	; 0xffe <lcd_put_char+0x1d8>
     ffa:	19 81       	ldd	r17, Y+1	; 0x01
     ffc:	01 c0       	rjmp	.+2      	; 0x1000 <lcd_put_char+0x1da>
     ffe:	1a 2d       	mov	r17, r10
          c ^= ul>>1;      
        }
      LCD_WRITE(c);
    1000:	81 2f       	mov	r24, r17
    1002:	0e 94 44 04 	call	0x888	; 0x888 <lcd_data>
      if(wc) 
    1006:	9c 81       	ldd	r25, Y+4	; 0x04
    1008:	99 23       	and	r25, r25
    100a:	19 f0       	breq	.+6      	; 0x1012 <lcd_put_char+0x1ec>
        LCD_WRITE(c);
    100c:	81 2f       	mov	r24, r17
    100e:	0e 94 44 04 	call	0x888	; 0x888 <lcd_data>
      }
    LCD_MOVE(1,-char_final_width);
    1012:	81 e0       	ldi	r24, 0x01	; 1
    1014:	68 85       	ldd	r22, Y+8	; 0x08
    1016:	79 85       	ldd	r23, Y+9	; 0x09
    1018:	0e 94 6f 04 	call	0x8de	; 0x8de <lcd_move_xy>
    101c:	aa 85       	ldd	r26, Y+10	; 0x0a
    101e:	bb 85       	ldd	r27, Y+11	; 0x0b
    1020:	11 96       	adiw	r26, 0x01	; 1
    1022:	bb 87       	std	Y+11, r27	; 0x0b
    1024:	aa 87       	std	Y+10, r26	; 0x0a
    } while (++row < char_final_height);
    1026:	ab 15       	cp	r26, r11
    1028:	08 f4       	brcc	.+2      	; 0x102c <lcd_put_char+0x206>
    102a:	97 cf       	rjmp	.-210    	; 0xf5a <lcd_put_char+0x134>

  //move cursor to upper right corner of character
  LCD_MOVE(-char_final_height,char_final_width);
    102c:	8b 2d       	mov	r24, r11
    102e:	81 95       	neg	r24
    1030:	b2 01       	movw	r22, r4
    1032:	0e 94 6f 04 	call	0x8de	; 0x8de <lcd_move_xy>
  return char_final_width;
  }
    1036:	8c 2d       	mov	r24, r12
    1038:	2b 96       	adiw	r28, 0x0b	; 11
    103a:	0f b6       	in	r0, 0x3f	; 63
    103c:	f8 94       	cli
    103e:	de bf       	out	0x3e, r29	; 62
    1040:	0f be       	out	0x3f, r0	; 63
    1042:	cd bf       	out	0x3d, r28	; 61
    1044:	cf 91       	pop	r28
    1046:	df 91       	pop	r29
    1048:	1f 91       	pop	r17
    104a:	0f 91       	pop	r16
    104c:	ff 90       	pop	r15
    104e:	ef 90       	pop	r14
    1050:	df 90       	pop	r13
    1052:	cf 90       	pop	r12
    1054:	bf 90       	pop	r11
    1056:	af 90       	pop	r10
    1058:	9f 90       	pop	r9
    105a:	8f 90       	pop	r8
    105c:	7f 90       	pop	r7
    105e:	6f 90       	pop	r6
    1060:	5f 90       	pop	r5
    1062:	4f 90       	pop	r4
    1064:	3f 90       	pop	r3
    1066:	2f 90       	pop	r2
    1068:	08 95       	ret

0000106a <lcd_putc>:


/******************************************************************************
 * Outputs a character on the display, using the global font and style
 */ 
uint8_t  lcd_putc(char c) {
    106a:	48 2f       	mov	r20, r24
  return lcd_put_char(global_font_select, global_font_style, c);
    106c:	80 91 6b 00 	lds	r24, 0x006B
    1070:	90 91 6c 00 	lds	r25, 0x006C
    1074:	60 91 6a 00 	lds	r22, 0x006A
    1078:	0e 94 13 07 	call	0xe26	; 0xe26 <lcd_put_char>
  }
    107c:	08 95       	ret

0000107e <lcd_put_char_xy>:
/******************************************************************************
 * Outputs a string on the display, using the given font and style, reading
 * the string from main memory. The position of the string on the display
 * is selected by page / col.
 */ 
uint8_t lcd_put_char_xy(FONT_P font, uint8_t style, char character, uint8_t page, uint8_t col) {
    107e:	df 92       	push	r13
    1080:	ef 92       	push	r14
    1082:	ff 92       	push	r15
    1084:	0f 93       	push	r16
    1086:	1f 93       	push	r17
    1088:	7c 01       	movw	r14, r24
    108a:	16 2f       	mov	r17, r22
    108c:	d4 2e       	mov	r13, r20
    108e:	82 2f       	mov	r24, r18
    1090:	60 2f       	mov	r22, r16
  LCD_MOVE_TO(page,col);
    1092:	0e 94 56 04 	call	0x8ac	; 0x8ac <lcd_moveto_xy>
  return lcd_put_char(font,style,character);
    1096:	c7 01       	movw	r24, r14
    1098:	61 2f       	mov	r22, r17
    109a:	4d 2d       	mov	r20, r13
    109c:	0e 94 13 07 	call	0xe26	; 0xe26 <lcd_put_char>
  }
    10a0:	1f 91       	pop	r17
    10a2:	0f 91       	pop	r16
    10a4:	ff 90       	pop	r15
    10a6:	ef 90       	pop	r14
    10a8:	df 90       	pop	r13
    10aa:	08 95       	ret

000010ac <lcd_putc_xy>:
  }

/******************************************************************************
 * Outputs a character on the display, using the global font and style
 */ 
uint8_t  lcd_putc_xy(char c, uint8_t page, uint8_t col) {
    10ac:	0f 93       	push	r16
    10ae:	38 2f       	mov	r19, r24
    10b0:	26 2f       	mov	r18, r22
    10b2:	04 2f       	mov	r16, r20
  return lcd_put_char_xy(global_font_select, global_font_style, c, page, col);
    10b4:	80 91 6b 00 	lds	r24, 0x006B
    10b8:	90 91 6c 00 	lds	r25, 0x006C
    10bc:	60 91 6a 00 	lds	r22, 0x006A
    10c0:	43 2f       	mov	r20, r19
    10c2:	0e 94 3f 08 	call	0x107e	; 0x107e <lcd_put_char_xy>
  }  
    10c6:	0f 91       	pop	r16
    10c8:	08 95       	ret

000010ca <lcd_put_string_length>:
  
/******************************************************************************
 * Outputs a string on the display, using the given font and style, reading
 * length characters from the memory
 */ 
uint16_t lcd_put_string_length(FONT_P font, uint8_t style, char* str, uint8_t length) {
    10ca:	bf 92       	push	r11
    10cc:	cf 92       	push	r12
    10ce:	df 92       	push	r13
    10d0:	ef 92       	push	r14
    10d2:	ff 92       	push	r15
    10d4:	0f 93       	push	r16
    10d6:	1f 93       	push	r17
    10d8:	cf 93       	push	r28
    10da:	df 93       	push	r29
    10dc:	7c 01       	movw	r14, r24
    10de:	b6 2e       	mov	r11, r22
    10e0:	d4 2e       	mov	r13, r20
    10e2:	c2 2e       	mov	r12, r18
    10e4:	24 2f       	mov	r18, r20
    10e6:	35 2f       	mov	r19, r21
    10e8:	c9 01       	movw	r24, r18
    10ea:	8c 01       	movw	r16, r24
    10ec:	c0 e0       	ldi	r28, 0x00	; 0
    10ee:	d0 e0       	ldi	r29, 0x00	; 0
    10f0:	09 c0       	rjmp	.+18     	; 0x1104 <lcd_put_string_length+0x3a>
  unsigned char t;
  uint16_t total_len = 0;
  for(t=0;t<length;t++)
    total_len += lcd_put_char(font,style,*str++);
    10f2:	f8 01       	movw	r30, r16
    10f4:	41 91       	ld	r20, Z+
    10f6:	8f 01       	movw	r16, r30
    10f8:	c7 01       	movw	r24, r14
    10fa:	6b 2d       	mov	r22, r11
    10fc:	0e 94 13 07 	call	0xe26	; 0xe26 <lcd_put_char>
    1100:	c8 0f       	add	r28, r24
    1102:	d1 1d       	adc	r29, r1
 * length characters from the memory
 */ 
uint16_t lcd_put_string_length(FONT_P font, uint8_t style, char* str, uint8_t length) {
  unsigned char t;
  uint16_t total_len = 0;
  for(t=0;t<length;t++)
    1104:	80 2f       	mov	r24, r16
    1106:	8d 19       	sub	r24, r13
    1108:	8c 15       	cp	r24, r12
    110a:	98 f3       	brcs	.-26     	; 0x10f2 <lcd_put_string_length+0x28>
    total_len += lcd_put_char(font,style,*str++);
  return total_len;
  }
    110c:	ce 01       	movw	r24, r28
    110e:	df 91       	pop	r29
    1110:	cf 91       	pop	r28
    1112:	1f 91       	pop	r17
    1114:	0f 91       	pop	r16
    1116:	ff 90       	pop	r15
    1118:	ef 90       	pop	r14
    111a:	df 90       	pop	r13
    111c:	cf 90       	pop	r12
    111e:	bf 90       	pop	r11
    1120:	08 95       	ret

00001122 <lcd_put_string>:

  
/******************************************************************************
 * Outputs a string on the display, using the given font and style
 */
uint16_t lcd_put_string(FONT_P font, uint8_t style, char* str) {
    1122:	df 92       	push	r13
    1124:	ef 92       	push	r14
    1126:	ff 92       	push	r15
    1128:	0f 93       	push	r16
    112a:	1f 93       	push	r17
    112c:	cf 93       	push	r28
    112e:	df 93       	push	r29
    1130:	7c 01       	movw	r14, r24
    1132:	d6 2e       	mov	r13, r22
    1134:	8a 01       	movw	r16, r20
    1136:	c0 e0       	ldi	r28, 0x00	; 0
    1138:	d0 e0       	ldi	r29, 0x00	; 0
    113a:	06 c0       	rjmp	.+12     	; 0x1148 <lcd_put_string+0x26>
  unsigned char t;
  uint16_t length = 0;
  while((t = *str++))
    length += lcd_put_char(font,style,t);
    113c:	c7 01       	movw	r24, r14
    113e:	6d 2d       	mov	r22, r13
    1140:	0e 94 13 07 	call	0xe26	; 0xe26 <lcd_put_char>
    1144:	c8 0f       	add	r28, r24
    1146:	d1 1d       	adc	r29, r1
 * Outputs a string on the display, using the given font and style
 */
uint16_t lcd_put_string(FONT_P font, uint8_t style, char* str) {
  unsigned char t;
  uint16_t length = 0;
  while((t = *str++))
    1148:	f8 01       	movw	r30, r16
    114a:	41 91       	ld	r20, Z+
    114c:	8f 01       	movw	r16, r30
    114e:	44 23       	and	r20, r20
    1150:	a9 f7       	brne	.-22     	; 0x113c <lcd_put_string+0x1a>
    length += lcd_put_char(font,style,t);
  return length;
  }
    1152:	ce 01       	movw	r24, r28
    1154:	df 91       	pop	r29
    1156:	cf 91       	pop	r28
    1158:	1f 91       	pop	r17
    115a:	0f 91       	pop	r16
    115c:	ff 90       	pop	r15
    115e:	ef 90       	pop	r14
    1160:	df 90       	pop	r13
    1162:	08 95       	ret

00001164 <lcd_put_short>:
  }  
  
/******************************************************************************
 * Outputs a 8bit signed integer on the display
 */   
uint16_t lcd_put_short (int8_t integer) {
    1164:	0f 93       	push	r16
    1166:	1f 93       	push	r17
    1168:	df 93       	push	r29
    116a:	cf 93       	push	r28
    116c:	cd b7       	in	r28, 0x3d	; 61
    116e:	de b7       	in	r29, 0x3e	; 62
    1170:	2a 97       	sbiw	r28, 0x0a	; 10
    1172:	0f b6       	in	r0, 0x3f	; 63
    1174:	f8 94       	cli
    1176:	de bf       	out	0x3e, r29	; 62
    1178:	0f be       	out	0x3f, r0	; 63
    117a:	cd bf       	out	0x3d, r28	; 61
  char buffer[10];
	itoa(integer, buffer, 10);
    117c:	99 27       	eor	r25, r25
    117e:	87 fd       	sbrc	r24, 7
    1180:	90 95       	com	r25
    1182:	8e 01       	movw	r16, r28
    1184:	0f 5f       	subi	r16, 0xFF	; 255
    1186:	1f 4f       	sbci	r17, 0xFF	; 255
    1188:	b8 01       	movw	r22, r16
    118a:	4a e0       	ldi	r20, 0x0A	; 10
    118c:	50 e0       	ldi	r21, 0x00	; 0
    118e:	0e 94 b3 09 	call	0x1366	; 0x1366 <itoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    1192:	80 91 6b 00 	lds	r24, 0x006B
    1196:	90 91 6c 00 	lds	r25, 0x006C
    119a:	60 91 6a 00 	lds	r22, 0x006A
    119e:	a8 01       	movw	r20, r16
    11a0:	0e 94 91 08 	call	0x1122	; 0x1122 <lcd_put_string>
  }    
    11a4:	2a 96       	adiw	r28, 0x0a	; 10
    11a6:	0f b6       	in	r0, 0x3f	; 63
    11a8:	f8 94       	cli
    11aa:	de bf       	out	0x3e, r29	; 62
    11ac:	0f be       	out	0x3f, r0	; 63
    11ae:	cd bf       	out	0x3d, r28	; 61
    11b0:	cf 91       	pop	r28
    11b2:	df 91       	pop	r29
    11b4:	1f 91       	pop	r17
    11b6:	0f 91       	pop	r16
    11b8:	08 95       	ret

000011ba <lcd_put_uint>:

  
/******************************************************************************
 * Outputs a 16bit unsigned integer on the display // Added by Olli S.
 */   
uint16_t lcd_put_uint  (uint16_t integer) {
    11ba:	0f 93       	push	r16
    11bc:	1f 93       	push	r17
    11be:	df 93       	push	r29
    11c0:	cf 93       	push	r28
    11c2:	cd b7       	in	r28, 0x3d	; 61
    11c4:	de b7       	in	r29, 0x3e	; 62
    11c6:	2a 97       	sbiw	r28, 0x0a	; 10
    11c8:	0f b6       	in	r0, 0x3f	; 63
    11ca:	f8 94       	cli
    11cc:	de bf       	out	0x3e, r29	; 62
    11ce:	0f be       	out	0x3f, r0	; 63
    11d0:	cd bf       	out	0x3d, r28	; 61
  char buffer[10];
	utoa(integer, buffer, 10);
    11d2:	8e 01       	movw	r16, r28
    11d4:	0f 5f       	subi	r16, 0xFF	; 255
    11d6:	1f 4f       	sbci	r17, 0xFF	; 255
    11d8:	b8 01       	movw	r22, r16
    11da:	4a e0       	ldi	r20, 0x0A	; 10
    11dc:	50 e0       	ldi	r21, 0x00	; 0
    11de:	0e 94 08 0a 	call	0x1410	; 0x1410 <utoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    11e2:	80 91 6b 00 	lds	r24, 0x006B
    11e6:	90 91 6c 00 	lds	r25, 0x006C
    11ea:	60 91 6a 00 	lds	r22, 0x006A
    11ee:	a8 01       	movw	r20, r16
    11f0:	0e 94 91 08 	call	0x1122	; 0x1122 <lcd_put_string>
  }  
    11f4:	2a 96       	adiw	r28, 0x0a	; 10
    11f6:	0f b6       	in	r0, 0x3f	; 63
    11f8:	f8 94       	cli
    11fa:	de bf       	out	0x3e, r29	; 62
    11fc:	0f be       	out	0x3f, r0	; 63
    11fe:	cd bf       	out	0x3d, r28	; 61
    1200:	cf 91       	pop	r28
    1202:	df 91       	pop	r29
    1204:	1f 91       	pop	r17
    1206:	0f 91       	pop	r16
    1208:	08 95       	ret

0000120a <lcd_put_int>:

  
/******************************************************************************
 * Outputs a 16bit signed integer on the display // Added by Olli S.
 */   
uint16_t lcd_put_int (int16_t integer) {
    120a:	0f 93       	push	r16
    120c:	1f 93       	push	r17
    120e:	df 93       	push	r29
    1210:	cf 93       	push	r28
    1212:	cd b7       	in	r28, 0x3d	; 61
    1214:	de b7       	in	r29, 0x3e	; 62
    1216:	2a 97       	sbiw	r28, 0x0a	; 10
    1218:	0f b6       	in	r0, 0x3f	; 63
    121a:	f8 94       	cli
    121c:	de bf       	out	0x3e, r29	; 62
    121e:	0f be       	out	0x3f, r0	; 63
    1220:	cd bf       	out	0x3d, r28	; 61
  char buffer[10];
	itoa(integer, buffer, 10);
    1222:	8e 01       	movw	r16, r28
    1224:	0f 5f       	subi	r16, 0xFF	; 255
    1226:	1f 4f       	sbci	r17, 0xFF	; 255
    1228:	b8 01       	movw	r22, r16
    122a:	4a e0       	ldi	r20, 0x0A	; 10
    122c:	50 e0       	ldi	r21, 0x00	; 0
    122e:	0e 94 b3 09 	call	0x1366	; 0x1366 <itoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    1232:	80 91 6b 00 	lds	r24, 0x006B
    1236:	90 91 6c 00 	lds	r25, 0x006C
    123a:	60 91 6a 00 	lds	r22, 0x006A
    123e:	a8 01       	movw	r20, r16
    1240:	0e 94 91 08 	call	0x1122	; 0x1122 <lcd_put_string>
  }  
    1244:	2a 96       	adiw	r28, 0x0a	; 10
    1246:	0f b6       	in	r0, 0x3f	; 63
    1248:	f8 94       	cli
    124a:	de bf       	out	0x3e, r29	; 62
    124c:	0f be       	out	0x3f, r0	; 63
    124e:	cd bf       	out	0x3d, r28	; 61
    1250:	cf 91       	pop	r28
    1252:	df 91       	pop	r29
    1254:	1f 91       	pop	r17
    1256:	0f 91       	pop	r16
    1258:	08 95       	ret

0000125a <lcd_put_long>:

#if INCLUDE_INTEGER_OUTPUT == 1
/******************************************************************************
 * Outputs a 32bit signed integer on the display // Added by Olli S.
 */ 
uint16_t lcd_put_long  (int32_t integer) {
    125a:	0f 93       	push	r16
    125c:	1f 93       	push	r17
    125e:	df 93       	push	r29
    1260:	cf 93       	push	r28
    1262:	cd b7       	in	r28, 0x3d	; 61
    1264:	de b7       	in	r29, 0x3e	; 62
    1266:	2a 97       	sbiw	r28, 0x0a	; 10
    1268:	0f b6       	in	r0, 0x3f	; 63
    126a:	f8 94       	cli
    126c:	de bf       	out	0x3e, r29	; 62
    126e:	0f be       	out	0x3f, r0	; 63
    1270:	cd bf       	out	0x3d, r28	; 61
  char buffer[10];
	ltoa(integer, buffer, 10);
    1272:	8e 01       	movw	r16, r28
    1274:	0f 5f       	subi	r16, 0xFF	; 255
    1276:	1f 4f       	sbci	r17, 0xFF	; 255
    1278:	a8 01       	movw	r20, r16
    127a:	2a e0       	ldi	r18, 0x0A	; 10
    127c:	30 e0       	ldi	r19, 0x00	; 0
    127e:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <ltoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    1282:	80 91 6b 00 	lds	r24, 0x006B
    1286:	90 91 6c 00 	lds	r25, 0x006C
    128a:	60 91 6a 00 	lds	r22, 0x006A
    128e:	a8 01       	movw	r20, r16
    1290:	0e 94 91 08 	call	0x1122	; 0x1122 <lcd_put_string>
  }
    1294:	2a 96       	adiw	r28, 0x0a	; 10
    1296:	0f b6       	in	r0, 0x3f	; 63
    1298:	f8 94       	cli
    129a:	de bf       	out	0x3e, r29	; 62
    129c:	0f be       	out	0x3f, r0	; 63
    129e:	cd bf       	out	0x3d, r28	; 61
    12a0:	cf 91       	pop	r28
    12a2:	df 91       	pop	r29
    12a4:	1f 91       	pop	r17
    12a6:	0f 91       	pop	r16
    12a8:	08 95       	ret

000012aa <lcd_putstr>:
  
  
/******************************************************************************
 * Outputs a string on the display, using the global font and style
 */   
uint16_t lcd_putstr(char* str) {
    12aa:	ac 01       	movw	r20, r24
  return lcd_put_string(global_font_select, global_font_style, str);
    12ac:	80 91 6b 00 	lds	r24, 0x006B
    12b0:	90 91 6c 00 	lds	r25, 0x006C
    12b4:	60 91 6a 00 	lds	r22, 0x006A
    12b8:	0e 94 91 08 	call	0x1122	; 0x1122 <lcd_put_string>
  }
    12bc:	08 95       	ret

000012be <lcd_put_string_P>:

/******************************************************************************
 * Outputs a string on the display, loading it from the program memory,
 * using the given font and style
 */
uint16_t lcd_put_string_P(FONT_P font, uint8_t style, PGM_P str) {
    12be:	df 92       	push	r13
    12c0:	ef 92       	push	r14
    12c2:	ff 92       	push	r15
    12c4:	0f 93       	push	r16
    12c6:	1f 93       	push	r17
    12c8:	cf 93       	push	r28
    12ca:	df 93       	push	r29
    12cc:	7c 01       	movw	r14, r24
    12ce:	d6 2e       	mov	r13, r22
    12d0:	8a 01       	movw	r16, r20
    12d2:	c0 e0       	ldi	r28, 0x00	; 0
    12d4:	d0 e0       	ldi	r29, 0x00	; 0
    12d6:	06 c0       	rjmp	.+12     	; 0x12e4 <lcd_put_string_P+0x26>
  unsigned char t;
  uint16_t length = 0;
  while((t = pgm_read_byte(str++))) 
    length += lcd_put_char(font,style,t);
    12d8:	c7 01       	movw	r24, r14
    12da:	6d 2d       	mov	r22, r13
    12dc:	0e 94 13 07 	call	0xe26	; 0xe26 <lcd_put_char>
    12e0:	c8 0f       	add	r28, r24
    12e2:	d1 1d       	adc	r29, r1
    12e4:	f8 01       	movw	r30, r16
 * using the given font and style
 */
uint16_t lcd_put_string_P(FONT_P font, uint8_t style, PGM_P str) {
  unsigned char t;
  uint16_t length = 0;
  while((t = pgm_read_byte(str++))) 
    12e6:	0f 5f       	subi	r16, 0xFF	; 255
    12e8:	1f 4f       	sbci	r17, 0xFF	; 255
    12ea:	44 91       	lpm	r20, Z+
    12ec:	44 23       	and	r20, r20
    12ee:	a1 f7       	brne	.-24     	; 0x12d8 <lcd_put_string_P+0x1a>
    length += lcd_put_char(font,style,t);
  return length;
  }
    12f0:	ce 01       	movw	r24, r28
    12f2:	df 91       	pop	r29
    12f4:	cf 91       	pop	r28
    12f6:	1f 91       	pop	r17
    12f8:	0f 91       	pop	r16
    12fa:	ff 90       	pop	r15
    12fc:	ef 90       	pop	r14
    12fe:	df 90       	pop	r13
    1300:	08 95       	ret

00001302 <lcd_putstr_P>:
  
/******************************************************************************
 * Outputs a string stored in program memory on the display, using the global 
 * font and style
 */   
uint16_t lcd_putstr_P(PGM_P str) {
    1302:	ac 01       	movw	r20, r24
  return lcd_put_string_P(global_font_select, global_font_style, str);
    1304:	80 91 6b 00 	lds	r24, 0x006B
    1308:	90 91 6c 00 	lds	r25, 0x006C
    130c:	60 91 6a 00 	lds	r22, 0x006A
    1310:	0e 94 5f 09 	call	0x12be	; 0x12be <lcd_put_string_P>
  }
    1314:	08 95       	ret

00001316 <lcd_put_string_xy_P>:
/******************************************************************************
 * Outputs a string on the display, using the given font and style, reading
 * the string from program memory. The position of the string on the display
 * is selected by page / col.
 */ 
uint16_t lcd_put_string_xy_P(FONT_P font, uint8_t style, PGM_P str,uint8_t page, uint8_t col) {
    1316:	cf 92       	push	r12
    1318:	df 92       	push	r13
    131a:	ef 92       	push	r14
    131c:	ff 92       	push	r15
    131e:	0f 93       	push	r16
    1320:	1f 93       	push	r17
    1322:	7c 01       	movw	r14, r24
    1324:	16 2f       	mov	r17, r22
    1326:	6a 01       	movw	r12, r20
    1328:	82 2f       	mov	r24, r18
    132a:	60 2f       	mov	r22, r16
  LCD_MOVE_TO(page,col);
    132c:	0e 94 56 04 	call	0x8ac	; 0x8ac <lcd_moveto_xy>
  return lcd_put_string_P(font,style,str);
    1330:	c7 01       	movw	r24, r14
    1332:	61 2f       	mov	r22, r17
    1334:	a6 01       	movw	r20, r12
    1336:	0e 94 5f 09 	call	0x12be	; 0x12be <lcd_put_string_P>
  }
    133a:	1f 91       	pop	r17
    133c:	0f 91       	pop	r16
    133e:	ff 90       	pop	r15
    1340:	ef 90       	pop	r14
    1342:	df 90       	pop	r13
    1344:	cf 90       	pop	r12
    1346:	08 95       	ret

00001348 <lcd_putstr_xy_P>:

/******************************************************************************
 * Outputs a string on the display, using the global font and style at the 
 * given position
 */   
uint16_t lcd_putstr_xy_P(PGM_P  str, uint8_t page, uint8_t col) {
    1348:	0f 93       	push	r16
    134a:	fc 01       	movw	r30, r24
    134c:	26 2f       	mov	r18, r22
    134e:	04 2f       	mov	r16, r20
  return lcd_put_string_xy_P(global_font_select, global_font_style, str, page, col);
    1350:	80 91 6b 00 	lds	r24, 0x006B
    1354:	90 91 6c 00 	lds	r25, 0x006C
    1358:	60 91 6a 00 	lds	r22, 0x006A
    135c:	af 01       	movw	r20, r30
    135e:	0e 94 8b 09 	call	0x1316	; 0x1316 <lcd_put_string_xy_P>
  }  
    1362:	0f 91       	pop	r16
    1364:	08 95       	ret

00001366 <itoa>:
    1366:	fb 01       	movw	r30, r22
    1368:	9f 01       	movw	r18, r30
    136a:	e8 94       	clt
    136c:	42 30       	cpi	r20, 0x02	; 2
    136e:	c4 f0       	brlt	.+48     	; 0x13a0 <itoa+0x3a>
    1370:	45 32       	cpi	r20, 0x25	; 37
    1372:	b4 f4       	brge	.+44     	; 0x13a0 <itoa+0x3a>
    1374:	4a 30       	cpi	r20, 0x0A	; 10
    1376:	29 f4       	brne	.+10     	; 0x1382 <itoa+0x1c>
    1378:	97 fb       	bst	r25, 7
    137a:	1e f4       	brtc	.+6      	; 0x1382 <itoa+0x1c>
    137c:	90 95       	com	r25
    137e:	81 95       	neg	r24
    1380:	9f 4f       	sbci	r25, 0xFF	; 255
    1382:	64 2f       	mov	r22, r20
    1384:	77 27       	eor	r23, r23
    1386:	0e 94 2e 0a 	call	0x145c	; 0x145c <__udivmodhi4>
    138a:	80 5d       	subi	r24, 0xD0	; 208
    138c:	8a 33       	cpi	r24, 0x3A	; 58
    138e:	0c f0       	brlt	.+2      	; 0x1392 <itoa+0x2c>
    1390:	89 5d       	subi	r24, 0xD9	; 217
    1392:	81 93       	st	Z+, r24
    1394:	cb 01       	movw	r24, r22
    1396:	00 97       	sbiw	r24, 0x00	; 0
    1398:	a1 f7       	brne	.-24     	; 0x1382 <itoa+0x1c>
    139a:	16 f4       	brtc	.+4      	; 0x13a0 <itoa+0x3a>
    139c:	5d e2       	ldi	r21, 0x2D	; 45
    139e:	51 93       	st	Z+, r21
    13a0:	10 82       	st	Z, r1
    13a2:	c9 01       	movw	r24, r18
    13a4:	0c 94 1e 0a 	jmp	0x143c	; 0x143c <strrev>

000013a8 <ltoa>:
    13a8:	fa 01       	movw	r30, r20
    13aa:	cf 93       	push	r28
    13ac:	ff 93       	push	r31
    13ae:	ef 93       	push	r30
    13b0:	22 30       	cpi	r18, 0x02	; 2
    13b2:	44 f1       	brlt	.+80     	; 0x1404 <ltoa+0x5c>
    13b4:	25 32       	cpi	r18, 0x25	; 37
    13b6:	34 f5       	brge	.+76     	; 0x1404 <ltoa+0x5c>
    13b8:	c2 2f       	mov	r28, r18
    13ba:	e8 94       	clt
    13bc:	ca 30       	cpi	r28, 0x0A	; 10
    13be:	49 f4       	brne	.+18     	; 0x13d2 <ltoa+0x2a>
    13c0:	97 fb       	bst	r25, 7
    13c2:	3e f4       	brtc	.+14     	; 0x13d2 <ltoa+0x2a>
    13c4:	90 95       	com	r25
    13c6:	80 95       	com	r24
    13c8:	70 95       	com	r23
    13ca:	61 95       	neg	r22
    13cc:	7f 4f       	sbci	r23, 0xFF	; 255
    13ce:	8f 4f       	sbci	r24, 0xFF	; 255
    13d0:	9f 4f       	sbci	r25, 0xFF	; 255
    13d2:	2c 2f       	mov	r18, r28
    13d4:	33 27       	eor	r19, r19
    13d6:	44 27       	eor	r20, r20
    13d8:	55 27       	eor	r21, r21
    13da:	ff 93       	push	r31
    13dc:	ef 93       	push	r30
    13de:	0e 94 42 0a 	call	0x1484	; 0x1484 <__udivmodsi4>
    13e2:	ef 91       	pop	r30
    13e4:	ff 91       	pop	r31
    13e6:	60 5d       	subi	r22, 0xD0	; 208
    13e8:	6a 33       	cpi	r22, 0x3A	; 58
    13ea:	0c f0       	brlt	.+2      	; 0x13ee <ltoa+0x46>
    13ec:	69 5d       	subi	r22, 0xD9	; 217
    13ee:	61 93       	st	Z+, r22
    13f0:	b9 01       	movw	r22, r18
    13f2:	ca 01       	movw	r24, r20
    13f4:	60 50       	subi	r22, 0x00	; 0
    13f6:	70 40       	sbci	r23, 0x00	; 0
    13f8:	80 40       	sbci	r24, 0x00	; 0
    13fa:	90 40       	sbci	r25, 0x00	; 0
    13fc:	51 f7       	brne	.-44     	; 0x13d2 <ltoa+0x2a>
    13fe:	16 f4       	brtc	.+4      	; 0x1404 <ltoa+0x5c>
    1400:	cd e2       	ldi	r28, 0x2D	; 45
    1402:	c1 93       	st	Z+, r28
    1404:	10 82       	st	Z, r1
    1406:	8f 91       	pop	r24
    1408:	9f 91       	pop	r25
    140a:	cf 91       	pop	r28
    140c:	0c 94 1e 0a 	jmp	0x143c	; 0x143c <strrev>

00001410 <utoa>:
    1410:	fb 01       	movw	r30, r22
    1412:	9f 01       	movw	r18, r30
    1414:	42 30       	cpi	r20, 0x02	; 2
    1416:	74 f0       	brlt	.+28     	; 0x1434 <utoa+0x24>
    1418:	45 32       	cpi	r20, 0x25	; 37
    141a:	64 f4       	brge	.+24     	; 0x1434 <utoa+0x24>
    141c:	64 2f       	mov	r22, r20
    141e:	77 27       	eor	r23, r23
    1420:	0e 94 2e 0a 	call	0x145c	; 0x145c <__udivmodhi4>
    1424:	80 5d       	subi	r24, 0xD0	; 208
    1426:	8a 33       	cpi	r24, 0x3A	; 58
    1428:	0c f0       	brlt	.+2      	; 0x142c <utoa+0x1c>
    142a:	89 5d       	subi	r24, 0xD9	; 217
    142c:	81 93       	st	Z+, r24
    142e:	cb 01       	movw	r24, r22
    1430:	00 97       	sbiw	r24, 0x00	; 0
    1432:	a1 f7       	brne	.-24     	; 0x141c <utoa+0xc>
    1434:	10 82       	st	Z, r1
    1436:	c9 01       	movw	r24, r18
    1438:	0c 94 1e 0a 	jmp	0x143c	; 0x143c <strrev>

0000143c <strrev>:
    143c:	dc 01       	movw	r26, r24
    143e:	fc 01       	movw	r30, r24
    1440:	67 2f       	mov	r22, r23
    1442:	71 91       	ld	r23, Z+
    1444:	77 23       	and	r23, r23
    1446:	e1 f7       	brne	.-8      	; 0x1440 <strrev+0x4>
    1448:	32 97       	sbiw	r30, 0x02	; 2
    144a:	04 c0       	rjmp	.+8      	; 0x1454 <strrev+0x18>
    144c:	7c 91       	ld	r23, X
    144e:	6d 93       	st	X+, r22
    1450:	70 83       	st	Z, r23
    1452:	62 91       	ld	r22, -Z
    1454:	ae 17       	cp	r26, r30
    1456:	bf 07       	cpc	r27, r31
    1458:	c8 f3       	brcs	.-14     	; 0x144c <strrev+0x10>
    145a:	08 95       	ret

0000145c <__udivmodhi4>:
    145c:	aa 1b       	sub	r26, r26
    145e:	bb 1b       	sub	r27, r27
    1460:	51 e1       	ldi	r21, 0x11	; 17
    1462:	07 c0       	rjmp	.+14     	; 0x1472 <__udivmodhi4_ep>

00001464 <__udivmodhi4_loop>:
    1464:	aa 1f       	adc	r26, r26
    1466:	bb 1f       	adc	r27, r27
    1468:	a6 17       	cp	r26, r22
    146a:	b7 07       	cpc	r27, r23
    146c:	10 f0       	brcs	.+4      	; 0x1472 <__udivmodhi4_ep>
    146e:	a6 1b       	sub	r26, r22
    1470:	b7 0b       	sbc	r27, r23

00001472 <__udivmodhi4_ep>:
    1472:	88 1f       	adc	r24, r24
    1474:	99 1f       	adc	r25, r25
    1476:	5a 95       	dec	r21
    1478:	a9 f7       	brne	.-22     	; 0x1464 <__udivmodhi4_loop>
    147a:	80 95       	com	r24
    147c:	90 95       	com	r25
    147e:	bc 01       	movw	r22, r24
    1480:	cd 01       	movw	r24, r26
    1482:	08 95       	ret

00001484 <__udivmodsi4>:
    1484:	a1 e2       	ldi	r26, 0x21	; 33
    1486:	1a 2e       	mov	r1, r26
    1488:	aa 1b       	sub	r26, r26
    148a:	bb 1b       	sub	r27, r27
    148c:	fd 01       	movw	r30, r26
    148e:	0d c0       	rjmp	.+26     	; 0x14aa <__udivmodsi4_ep>

00001490 <__udivmodsi4_loop>:
    1490:	aa 1f       	adc	r26, r26
    1492:	bb 1f       	adc	r27, r27
    1494:	ee 1f       	adc	r30, r30
    1496:	ff 1f       	adc	r31, r31
    1498:	a2 17       	cp	r26, r18
    149a:	b3 07       	cpc	r27, r19
    149c:	e4 07       	cpc	r30, r20
    149e:	f5 07       	cpc	r31, r21
    14a0:	20 f0       	brcs	.+8      	; 0x14aa <__udivmodsi4_ep>
    14a2:	a2 1b       	sub	r26, r18
    14a4:	b3 0b       	sbc	r27, r19
    14a6:	e4 0b       	sbc	r30, r20
    14a8:	f5 0b       	sbc	r31, r21

000014aa <__udivmodsi4_ep>:
    14aa:	66 1f       	adc	r22, r22
    14ac:	77 1f       	adc	r23, r23
    14ae:	88 1f       	adc	r24, r24
    14b0:	99 1f       	adc	r25, r25
    14b2:	1a 94       	dec	r1
    14b4:	69 f7       	brne	.-38     	; 0x1490 <__udivmodsi4_loop>
    14b6:	60 95       	com	r22
    14b8:	70 95       	com	r23
    14ba:	80 95       	com	r24
    14bc:	90 95       	com	r25
    14be:	9b 01       	movw	r18, r22
    14c0:	ac 01       	movw	r20, r24
    14c2:	bd 01       	movw	r22, r26
    14c4:	cf 01       	movw	r24, r30
    14c6:	08 95       	ret

000014c8 <_exit>:
    14c8:	f8 94       	cli

000014ca <__stop_program>:
    14ca:	ff cf       	rjmp	.-2      	; 0x14ca <__stop_program>
