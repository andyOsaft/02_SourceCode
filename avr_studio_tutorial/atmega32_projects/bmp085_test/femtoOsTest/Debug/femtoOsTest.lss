
femtoOsTest.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001862  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  00001862  000018f6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000027  00800068  00800068  000018fe  2**0
                  ALLOC
  3 .stab         00000d14  00000000  00000000  00001900  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000219  00000000  00000000  00002614  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000282d  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 0000064d  00000000  00000000  0000296d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002d6e  00000000  00000000  00002fba  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000d43  00000000  00000000  00005d28  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000240f  00000000  00000000  00006a6b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000420  00000000  00000000  00008e7c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000008cb  00000000  00000000  0000929c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002156  00000000  00000000  00009b67  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 00000384  00000000  00000000  0000bcbd  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000118  00000000  00000000  0000c041  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3a 03 	jmp	0x674	; 0x674 <__ctors_end>
       4:	0c 94 7f 04 	jmp	0x8fe	; 0x8fe <__vector_1>
       8:	0c 94 89 04 	jmp	0x912	; 0x912 <__vector_2>
       c:	0c 94 93 04 	jmp	0x926	; 0x926 <__vector_3>
      10:	0c 94 57 03 	jmp	0x6ae	; 0x6ae <__bad_interrupt>
      14:	0c 94 57 03 	jmp	0x6ae	; 0x6ae <__bad_interrupt>
      18:	0c 94 57 03 	jmp	0x6ae	; 0x6ae <__bad_interrupt>
      1c:	0c 94 57 03 	jmp	0x6ae	; 0x6ae <__bad_interrupt>
      20:	0c 94 57 03 	jmp	0x6ae	; 0x6ae <__bad_interrupt>
      24:	0c 94 57 03 	jmp	0x6ae	; 0x6ae <__bad_interrupt>
      28:	0c 94 57 03 	jmp	0x6ae	; 0x6ae <__bad_interrupt>
      2c:	0c 94 57 03 	jmp	0x6ae	; 0x6ae <__bad_interrupt>
      30:	0c 94 57 03 	jmp	0x6ae	; 0x6ae <__bad_interrupt>
      34:	0c 94 57 03 	jmp	0x6ae	; 0x6ae <__bad_interrupt>
      38:	0c 94 57 03 	jmp	0x6ae	; 0x6ae <__bad_interrupt>
      3c:	0c 94 57 03 	jmp	0x6ae	; 0x6ae <__bad_interrupt>
      40:	0c 94 57 03 	jmp	0x6ae	; 0x6ae <__bad_interrupt>
      44:	0c 94 57 03 	jmp	0x6ae	; 0x6ae <__bad_interrupt>
      48:	0c 94 57 03 	jmp	0x6ae	; 0x6ae <__bad_interrupt>
      4c:	0c 94 30 04 	jmp	0x860	; 0x860 <__vector_19>
      50:	0c 94 57 03 	jmp	0x6ae	; 0x6ae <__bad_interrupt>

00000054 <__c.2059>:
      54:	68 65 6c 6c 6f 00                                   hello.

0000005a <__c.2019>:
      5a:	49 6e 69 74 20 2e 2e 2e 20 64 6f 6e 65 21 00        Init ... done!.

00000069 <font_fixed_8px_data>:
      69:	00 00 00 00 00 00 00 3e 45 51 45 3e 00 3e 6b 6f     .......>EQE>.>ko
      79:	6b 3e 00 1c 3e 7c 3e 1c 00 18 3c 7e 3c 18 00 30     k>..>|>...<~<..0
      89:	36 7f 36 30 00 18 5c 7e 5c 18 00 00 00 00 00 00     6.60..\~\.......
	...
      a9:	00 00 00 30 48 4a 36 0e 00 06 29 79 29 06 00 00     ...0HJ6...)y)...
      b9:	00 00 00 00 00 60 7e 0a 35 3f 00 2a 1c 36 1c 2a     .....`~.5?.*.6.*
      c9:	00 00 7f 3e 1c 08 00 08 1c 3e 7f 00 00 14 36 7f     ...>.....>....6.
      d9:	36 14 00 00 5f 00 5f 00 00 06 09 7f 01 7f 00 22     6..._._........"
      e9:	4d 55 59 22 00 60 60 60 60 00 00 14 b6 ff b6 14     MUY".````.......
      f9:	00 04 06 7f 06 04 00 10 30 7f 30 10 00 08 08 3e     ........0.0....>
     109:	1c 08 00 08 1c 3e 08 08 00 78 40 40 40 40 00 08     .....>...x@@@@..
     119:	3e 08 3e 08 00 30 3c 3f 3c 30 00 03 0f 3f 0f 03     >.>..0<?<0...?..
	...
     131:	06 5f 06 00 00 07 03 00 07 03 00 24 7e 24 7e 24     ._.........$~$~$
     141:	00 24 2b 6a 12 00 00 63 13 08 64 63 00 36 49 56     .$+j...c..dc.6IV
     151:	20 50 00 00 07 03 00 00 00 00 3e 41 00 00 00 00      P........>A....
     161:	41 3e 00 00 00 08 3e 1c 3e 08 00 08 08 3e 08 08     A>....>.>....>..
     171:	00 00 e0 60 00 00 00 08 08 08 08 08 00 00 60 60     ...`..........``
     181:	00 00 00 20 10 08 04 02 00 3e 51 49 45 3e 00 00     ... .....>QIE>..
     191:	42 7f 40 00 00 62 51 49 49 46 00 22 49 49 49 36     B.@..bQIIF."III6
     1a1:	00 18 14 12 7f 10 00 2f 49 49 49 31 00 3c 4a 49     ......./III1.<JI
     1b1:	49 30 00 01 71 09 05 03 00 36 49 49 49 36 00 06     I0..q....6III6..
     1c1:	49 49 29 1e 00 00 6c 6c 00 00 00 00 ec 6c 00 00     II)...ll.....l..
     1d1:	00 08 14 22 41 00 00 24 24 24 24 24 00 00 41 22     ..."A..$$$$$..A"
     1e1:	14 08 00 02 01 59 09 06 00 3e 41 5d 55 1e 00 7e     .....Y...>A]U..~
     1f1:	11 11 11 7e 00 7f 49 49 49 36 00 3e 41 41 41 22     ...~..III6.>AAA"
     201:	00 7f 41 41 41 3e 00 7f 49 49 49 41 00 7f 09 09     ..AAA>..IIIA....
     211:	09 01 00 3e 41 49 49 7a 00 7f 08 08 08 7f 00 00     ...>AIIz........
     221:	41 7f 41 00 00 30 40 40 40 3f 00 7f 08 14 22 41     A.A..0@@@?...."A
     231:	00 7f 40 40 40 40 00 7f 02 04 02 7f 00 7f 02 04     ..@@@@..........
     241:	08 7f 00 3e 41 41 41 3e 00 7f 09 09 09 06 00 3e     ...>AAA>.......>
     251:	41 51 21 5e 00 7f 09 09 19 66 00 26 49 49 49 32     AQ!^.....f.&III2
     261:	00 01 01 7f 01 01 00 3f 40 40 40 3f 00 1f 20 40     .......?@@@?.. @
     271:	20 1f 00 3f 40 3c 40 3f 00 63 14 08 14 63 00 07      ..?@<@?.c...c..
     281:	08 70 08 07 00 71 49 45 43 00 00 00 7f 41 41 00     .p...qIEC....AA.
     291:	00 02 04 08 10 20 00 00 41 41 7f 00 00 04 02 01     ..... ..AA......
     2a1:	02 04 80 80 80 80 80 80 00 00 03 07 00 00 00 20     ............... 
     2b1:	54 54 54 78 00 7f 44 44 44 38 00 38 44 44 44 28     TTTx..DDD8.8DDD(
     2c1:	00 38 44 44 44 7f 00 38 54 54 54 08 00 08 7e 09     .8DDD..8TTT...~.
     2d1:	09 00 00 18 a4 a4 a4 7c 00 7f 04 04 78 00 00 00     .......|....x...
     2e1:	00 7d 40 00 00 40 80 84 7d 00 00 7f 10 28 44 00     .}@..@..}....(D.
     2f1:	00 00 00 7f 40 00 00 7c 04 18 04 78 00 7c 04 04     ....@..|...x.|..
     301:	78 00 00 38 44 44 44 38 00 fc 44 44 44 38 00 38     x..8DDD8..DDD8.8
     311:	44 44 44 fc 00 44 78 44 04 08 00 08 54 54 54 20     DDD..DxD....TTT 
     321:	00 04 3e 44 24 00 00 3c 40 20 7c 00 00 1c 20 40     ..>D$..<@ |... @
     331:	20 1c 00 3c 60 30 60 3c 00 6c 10 10 6c 00 00 9c      ..<`0`<.l..l...
     341:	a0 60 3c 00 00 64 54 54 4c 00 00 08 3e 41 41 00     .`<..dTTL...>AA.
     351:	00 00 00 77 00 00 00 00 41 41 3e 08 00 02 01 02     ...w....AA>.....
     361:	01 00 00 3c 26 23 26 3c 00 1e a1 e1 21 12 00 3d     ...<&#&<....!..=
     371:	40 20 7d 00 00 38 54 54 55 09 00 20 55 55 55 78     @ }..8TTU.. UUUx
     381:	00 20 55 54 55 78 00 20 55 55 54 78 00 20 57 55     . UTUx. UUTx. WU
     391:	57 78 00 1c a2 e2 22 14 00 38 55 55 55 08 00 38     Wx...."..8UUU..8
     3a1:	55 54 55 08 00 38 55 55 54 08 00 00 01 7c 41 00     UTU..8UUT....|A.
     3b1:	00 00 01 7d 41 00 00 00 01 7c 40 00 00 70 29 24     ...}A....|@..p)$
     3c1:	29 70 00 78 2f 25 2f 78 00 7c 54 54 55 45 00 34     )p.x/%/x.|TTUE.4
     3d1:	54 7c 54 58 00 7e 09 7f 49 49 00 38 45 45 39 00     T|TX.~..II.8EE9.
     3e1:	00 38 45 44 39 00 00 39 45 44 38 00 00 3c 41 21     .8ED9..9ED8..<A!
     3f1:	7d 00 00 3d 41 20 7c 00 00 9c a1 60 3d 00 00 3d     }..=A |....`=..=
     401:	42 42 3d 00 00 3c 41 40 3d 00 80 70 68 58 38 04     BB=..<A@=..phX8.
     411:	00 48 3e 49 49 62 00 7e 61 5d 43 3f 00 22 14 08     .H>IIb.~a]C?."..
     421:	14 22 00 40 88 7e 09 02 00 20 54 55 55 78 00 00     .".@.~... TUUx..
     431:	00 7d 41 00 00 38 44 45 39 00 00 3c 40 21 7d 00     .}A..8DE9..<@!}.
     441:	00 7a 09 0a 71 00 00 7a 11 22 79 00 00 08 55 55     .z..q..z."y...UU
     451:	55 5e 00 4e 51 51 4e 00 00 30 48 4d 40 20 3e 41     U^.NQQN..0HM@ >A
     461:	5d 4b 55 3e 04 04 04 04 04 1c 00 17 08 4c 6a 50     ]KU>.........LjP
     471:	00 17 08 34 2a 78 00 00 30 7d 30 00 00 08 14 00     ...4*x..0}0.....
     481:	08 14 00 14 08 00 14 08 44 11 44 11 44 11 aa 55     ........D.D.D..U
     491:	aa 55 aa 55 bb ee bb ee bb ee 00 00 00 ff 00 00     .U.U............
     4a1:	08 08 08 ff 00 00 00 70 28 25 29 70 00 70 29 25     .......p(%)p.p)%
     4b1:	29 70 00 70 29 25 28 70 3e 41 5d 55 41 3e 0a fb     )p.p)%(p>A]UA>..
     4c1:	00 ff 00 00 00 ff 00 ff 00 00 0a fa 02 fe 00 00     ................
     4d1:	0a 0b 08 0f 00 00 00 18 24 66 24 00 00 29 2a 7c     ........$f$..)*|
     4e1:	2a 29 08 08 08 f8 00 00 00 00 00 0f 08 08 08 08     *)..............
     4f1:	08 0f 08 08 08 08 08 f8 08 08 00 00 00 ff 08 08     ................
     501:	08 08 08 08 08 08 08 08 08 ff 08 08 00 20 56 55     ............. VU
     511:	56 79 00 70 2a 25 2a 71 00 0f 08 0b 0a 0a 00 fe     Vy.p*%*q........
     521:	02 fa 0a 0a 0a 0b 08 0b 0a 0a 0a fa 02 fa 0a 0a     ................
     531:	00 ff 00 fb 0a 0a 0a 0a 0a 0a 0a 0a 0a fb 00 fb     ................
     541:	0a 0a 00 5d 22 22 22 5d 00 22 55 59 30 00 00 08     ...]"""]."UY0...
     551:	7f 49 41 3e 00 7c 55 55 55 44 00 7c 55 54 55 44     .IA>.|UUUD.|UTUD
     561:	00 7c 55 55 54 44 00 00 00 07 00 00 00 00 44 7d     .|UUTD........D}
     571:	45 00 00 00 45 7d 45 00 00 00 45 7c 45 00 08 08     E...E}E...E|E...
     581:	08 0f 00 00 00 00 00 f8 08 08 ff ff ff ff ff ff     ................
     591:	f0 f0 f0 f0 f0 f0 00 00 00 77 00 00 00 00 45 7d     .........w....E}
     5a1:	44 00 0f 0f 0f 0f 0f 0f 00 3c 42 43 3d 00 00 fe     D........<BC=...
     5b1:	4a 4a 34 00 00 3c 43 43 3d 00 00 3d 43 42 3c 00     JJ4..<CC=..=CB<.
     5c1:	00 32 49 4a 31 00 00 3a 45 46 39 00 00 fc 20 20     .2IJ1..:EF9...  
     5d1:	1c 00 00 fe aa 28 10 00 00 ff a5 24 18 00 00 3c     .....(.....$...<
     5e1:	40 41 3d 00 00 3c 41 41 3d 00 00 3d 41 40 3c 00     @A=..<AA=..=A@<.
     5f1:	00 9c a0 61 3d 00 00 04 08 71 09 04 00 00 02 02     ...a=....q......
     601:	02 00 00 00 07 03 00 00 00 00 08 08 08 00 00 00     ................
     611:	24 2e 24 00 00 24 24 24 24 24 05 17 0a 34 2a 78     $.$..$$$$$...4*x
     621:	00 06 09 7f 01 7f 00 22 4d 55 59 22 00 08 08 2a     ......."MUY"...*
     631:	08 08 00 00 08 18 18 00 00 06 09 09 06 00 00 00     ................
     641:	08 00 08 00 00 00 08 00 00 00 00 02 0f 00 00 00     ................
     651:	00 09 0f 05 00 00 00 09 0d 0a 00 00 00 3c 3c 3c     .............<<<
     661:	3c 00 00 00 00 00 00 00                             <.......

00000669 <font_fixed_8px>:
     669:	00 06 06 08 00 ff 00 00 69 00 00                    ........i..

00000674 <__ctors_end>:
     674:	11 24       	eor	r1, r1
     676:	1f be       	out	0x3f, r1	; 63
     678:	cf e5       	ldi	r28, 0x5F	; 95
     67a:	d8 e0       	ldi	r29, 0x08	; 8
     67c:	de bf       	out	0x3e, r29	; 62
     67e:	cd bf       	out	0x3d, r28	; 61

00000680 <__do_copy_data>:
     680:	10 e0       	ldi	r17, 0x00	; 0
     682:	a0 e6       	ldi	r26, 0x60	; 96
     684:	b0 e0       	ldi	r27, 0x00	; 0
     686:	e2 e6       	ldi	r30, 0x62	; 98
     688:	f8 e1       	ldi	r31, 0x18	; 24
     68a:	02 c0       	rjmp	.+4      	; 0x690 <__do_copy_data+0x10>
     68c:	05 90       	lpm	r0, Z+
     68e:	0d 92       	st	X+, r0
     690:	a8 36       	cpi	r26, 0x68	; 104
     692:	b1 07       	cpc	r27, r17
     694:	d9 f7       	brne	.-10     	; 0x68c <__do_copy_data+0xc>

00000696 <__do_clear_bss>:
     696:	10 e0       	ldi	r17, 0x00	; 0
     698:	a8 e6       	ldi	r26, 0x68	; 104
     69a:	b0 e0       	ldi	r27, 0x00	; 0
     69c:	01 c0       	rjmp	.+2      	; 0x6a0 <.do_clear_bss_start>

0000069e <.do_clear_bss_loop>:
     69e:	1d 92       	st	X+, r1

000006a0 <.do_clear_bss_start>:
     6a0:	af 38       	cpi	r26, 0x8F	; 143
     6a2:	b1 07       	cpc	r27, r17
     6a4:	e1 f7       	brne	.-8      	; 0x69e <.do_clear_bss_loop>
     6a6:	0e 94 e7 03 	call	0x7ce	; 0x7ce <main>
     6aa:	0c 94 2f 0c 	jmp	0x185e	; 0x185e <_exit>

000006ae <__bad_interrupt>:
     6ae:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006b2 <readInternalRegister>:
	
	read an internal 16 bit register of the bmp085

************************************************************************************************/
uint16_t readInternalRegister(unsigned char registerAddress)
{
     6b2:	0f 93       	push	r16
     6b4:	1f 93       	push	r17
     6b6:	df 93       	push	r29
     6b8:	cf 93       	push	r28
     6ba:	00 d0       	rcall	.+0      	; 0x6bc <readInternalRegister+0xa>
     6bc:	cd b7       	in	r28, 0x3d	; 61
     6be:	de b7       	in	r29, 0x3e	; 62
	unsigned char msgBuf[2];
	unsigned char msb, lsb;
	
	//prepare message for i2c transmission
	//1st byte: -> module address write
	msgBuf[0] = (barometricSensorAddress<<TWI_ADR_BITS) |  (FALSE<<TWI_READ_BIT);
     6c0:	90 91 60 00 	lds	r25, 0x0060
     6c4:	99 0f       	add	r25, r25
     6c6:	99 83       	std	Y+1, r25	; 0x01
	//2nd byte: -> target register´s address for reading
	msgBuf[1] = registerAddress;
     6c8:	8a 83       	std	Y+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( msgBuf, 2 );
     6ca:	8e 01       	movw	r16, r28
     6cc:	0f 5f       	subi	r16, 0xFF	; 255
     6ce:	1f 4f       	sbci	r17, 0xFF	; 255
     6d0:	c8 01       	movw	r24, r16
     6d2:	62 e0       	ldi	r22, 0x02	; 2
     6d4:	0e 94 23 0b 	call	0x1646	; 0x1646 <TWI_Start_Transceiver_With_Data>
	
	
	//send a restart condition -> just start a new message
	//1st byte: -> module address read
	msgBuf[0] = (barometricSensorAddress<<TWI_ADR_BITS) |  (TRUE<<TWI_READ_BIT);
     6d8:	80 91 60 00 	lds	r24, 0x0060
     6dc:	90 91 61 00 	lds	r25, 0x0061
     6e0:	88 0f       	add	r24, r24
     6e2:	99 1f       	adc	r25, r25
     6e4:	81 60       	ori	r24, 0x01	; 1
     6e6:	89 83       	std	Y+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( msgBuf, 1 );
     6e8:	c8 01       	movw	r24, r16
     6ea:	61 e0       	ldi	r22, 0x01	; 1
     6ec:	0e 94 23 0b 	call	0x1646	; 0x1646 <TWI_Start_Transceiver_With_Data>

	lcd_moveto_xy  (2, 0);		
     6f0:	82 e0       	ldi	r24, 0x02	; 2
     6f2:	60 e0       	ldi	r22, 0x00	; 0
     6f4:	0e 94 11 05 	call	0xa22	; 0xa22 <lcd_moveto_xy>
	lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("hello"));
     6f8:	89 e6       	ldi	r24, 0x69	; 105
     6fa:	96 e0       	ldi	r25, 0x06	; 6
     6fc:	60 e0       	ldi	r22, 0x00	; 0
     6fe:	44 e5       	ldi	r20, 0x54	; 84
     700:	50 e0       	ldi	r21, 0x00	; 0
     702:	0e 94 7f 09 	call	0x12fe	; 0x12fe <lcd_put_string_P>

	
	//the sensor sends first the 8 msb, then the 8 lsb
	TWI_Get_Data_From_Transceiver(msgBuf,2);
     706:	c8 01       	movw	r24, r16
     708:	62 e0       	ldi	r22, 0x02	; 2
     70a:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <TWI_Get_Data_From_Transceiver>
	msb=msgBuf[0];
	lsb=msgBuf[1];
	
	
		
	return (((uint16_t)msb<<8) | ((uint16_t)lsb));
     70e:	99 81       	ldd	r25, Y+1	; 0x01
     710:	80 e0       	ldi	r24, 0x00	; 0
     712:	2a 81       	ldd	r18, Y+2	; 0x02
     714:	30 e0       	ldi	r19, 0x00	; 0
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
	while(!Wire.available()); // wait until data available
	msb = Wire.read();
	while(!Wire.available()); // wait until data available
	lsb = Wire.read();
	return (((int)msb<<8) | ((int)lsb));*/
     71a:	82 2f       	mov	r24, r18
     71c:	93 2f       	mov	r25, r19
     71e:	0f 90       	pop	r0
     720:	0f 90       	pop	r0
     722:	cf 91       	pop	r28
     724:	df 91       	pop	r29
     726:	1f 91       	pop	r17
     728:	0f 91       	pop	r16
     72a:	08 95       	ret

0000072c <getCalibrationData>:

************************************************************************************************/
void  getCalibrationData() 
{	

	ac1 = readInternalRegister(0xAA);
     72c:	8a ea       	ldi	r24, 0xAA	; 170
     72e:	0e 94 59 03 	call	0x6b2	; 0x6b2 <readInternalRegister>
     732:	90 93 7b 00 	sts	0x007B, r25
     736:	80 93 7a 00 	sts	0x007A, r24
	
	ac2 = readInternalRegister(0xAC);
     73a:	8c ea       	ldi	r24, 0xAC	; 172
     73c:	0e 94 59 03 	call	0x6b2	; 0x6b2 <readInternalRegister>
     740:	90 93 83 00 	sts	0x0083, r25
     744:	80 93 82 00 	sts	0x0082, r24

	ac3 = readInternalRegister(0xAE);
     748:	8e ea       	ldi	r24, 0xAE	; 174
     74a:	0e 94 59 03 	call	0x6b2	; 0x6b2 <readInternalRegister>
     74e:	90 93 8b 00 	sts	0x008B, r25
     752:	80 93 8a 00 	sts	0x008A, r24

	ac4 = readInternalRegister(0xB0);
     756:	80 eb       	ldi	r24, 0xB0	; 176
     758:	0e 94 59 03 	call	0x6b2	; 0x6b2 <readInternalRegister>
     75c:	90 93 87 00 	sts	0x0087, r25
     760:	80 93 86 00 	sts	0x0086, r24

	ac5 = readInternalRegister(0xB2);
     764:	82 eb       	ldi	r24, 0xB2	; 178
     766:	0e 94 59 03 	call	0x6b2	; 0x6b2 <readInternalRegister>
     76a:	90 93 81 00 	sts	0x0081, r25
     76e:	80 93 80 00 	sts	0x0080, r24

	ac6 = readInternalRegister(0xB4);
     772:	84 eb       	ldi	r24, 0xB4	; 180
     774:	0e 94 59 03 	call	0x6b2	; 0x6b2 <readInternalRegister>
     778:	90 93 7f 00 	sts	0x007F, r25
     77c:	80 93 7e 00 	sts	0x007E, r24

	b1 = readInternalRegister(0xB6);
     780:	86 eb       	ldi	r24, 0xB6	; 182
     782:	0e 94 59 03 	call	0x6b2	; 0x6b2 <readInternalRegister>
     786:	90 93 7d 00 	sts	0x007D, r25
     78a:	80 93 7c 00 	sts	0x007C, r24

	b2 = readInternalRegister(0xB8);
     78e:	88 eb       	ldi	r24, 0xB8	; 184
     790:	0e 94 59 03 	call	0x6b2	; 0x6b2 <readInternalRegister>
     794:	90 93 77 00 	sts	0x0077, r25
     798:	80 93 76 00 	sts	0x0076, r24

	mb = readInternalRegister(0xBA);
     79c:	8a eb       	ldi	r24, 0xBA	; 186
     79e:	0e 94 59 03 	call	0x6b2	; 0x6b2 <readInternalRegister>
     7a2:	90 93 79 00 	sts	0x0079, r25
     7a6:	80 93 78 00 	sts	0x0078, r24

	mc = readInternalRegister(0xBC);
     7aa:	8c eb       	ldi	r24, 0xBC	; 188
     7ac:	0e 94 59 03 	call	0x6b2	; 0x6b2 <readInternalRegister>
     7b0:	90 93 89 00 	sts	0x0089, r25
     7b4:	80 93 88 00 	sts	0x0088, r24

	md = readInternalRegister(0xBE);
     7b8:	8e eb       	ldi	r24, 0xBE	; 190
     7ba:	0e 94 59 03 	call	0x6b2	; 0x6b2 <readInternalRegister>
     7be:	90 93 85 00 	sts	0x0085, r25
     7c2:	80 93 84 00 	sts	0x0084, r24

}
     7c6:	08 95       	ret

000007c8 <setupBarometricSensor>:
		Initialisation for the barometric sensor bmp085.

************************************************************************************************/
void setupBarometricSensor()
{    
	getCalibrationData();
     7c8:	0e 94 96 03 	call	0x72c	; 0x72c <getCalibrationData>
}
     7cc:	08 95       	ret

000007ce <main>:




void main (void)
{
     7ce:	cf 92       	push	r12
     7d0:	df 92       	push	r13
     7d2:	ef 92       	push	r14
     7d4:	ff 92       	push	r15
     7d6:	0f 93       	push	r16
     7d8:	1f 93       	push	r17
	uint16_t sensorRead;
	unsigned char msgBuf[2];
	
	uint16_t statusCode;
	
	sei();
     7da:	78 94       	sei
	
	myInit();
     7dc:	0e 94 9d 04 	call	0x93a	; 0x93a <myInit>
	
	TWI_Master_Initialise();
     7e0:	0e 94 16 0b 	call	0x162c	; 0x162c <TWI_Master_Initialise>
	//pwmInit(100);
	
	lcd_set_font(FONT_FIXED_8,NORMAL);
     7e4:	09 e6       	ldi	r16, 0x69	; 105
     7e6:	16 e0       	ldi	r17, 0x06	; 6
     7e8:	c8 01       	movw	r24, r16
     7ea:	60 e0       	ldi	r22, 0x00	; 0
     7ec:	0e 94 34 07 	call	0xe68	; 0xe68 <lcd_set_font>
	lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("Init ... done!"));
     7f0:	c8 01       	movw	r24, r16
     7f2:	60 e0       	ldi	r22, 0x00	; 0
     7f4:	4a e5       	ldi	r20, 0x5A	; 90
     7f6:	50 e0       	ldi	r21, 0x00	; 0
     7f8:	0e 94 7f 09 	call	0x12fe	; 0x12fe <lcd_put_string_P>
		//TWSTA: twi start condition -> generates a start contition on the bus (it it is free)
		//                              if it is not free, it waits until a stop condition is
		//								detected 
		//TWIE:  the interrupt request for twi will be activated as long as the twint flag is high
		//TWINT: reset twint flag (by writing a one) -> starts the operation of the twi module
		TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);// | (1<<TWIE); 
     7fc:	0f 2e       	mov	r0, r31
     7fe:	f4 ea       	ldi	r31, 0xA4	; 164
     800:	ef 2e       	mov	r14, r31
     802:	f0 2d       	mov	r31, r0
		//while  (!(TWCR & (1<<TWINT)));

		
		
		//write the bmp addressWrite into the TWI data register
		TWDR = 0xEE;
     804:	0f 2e       	mov	r0, r31
     806:	fe ee       	ldi	r31, 0xEE	; 238
     808:	df 2e       	mov	r13, r31
     80a:	f0 2d       	mov	r31, r0
		//start transmission by reseting the TWINT (by writing a one)
		TWCR = (1<<TWINT) | (1<<TWEN);
     80c:	14 e8       	ldi	r17, 0x84	; 132
		
		//while  (!(TWCR & (1<<TWINT)));
				
		TWDR = 0xF4;
     80e:	04 ef       	ldi	r16, 0xF4	; 244
		TWDR = 0xF4;
		TWCR = (1<<TWINT) | (1<<TWEN);
					
		
		//send STOP condition
		TWCR = (1<<TWINT) | (1<<TWEN)| (1<<TWSTO);
     810:	0f 2e       	mov	r0, r31
     812:	f4 e9       	ldi	r31, 0x94	; 148
     814:	cf 2e       	mov	r12, r31
     816:	f0 2d       	mov	r31, r0
		//TWSTA: twi start condition -> generates a start contition on the bus (it it is free)
		//                              if it is not free, it waits until a stop condition is
		//								detected 
		//TWIE:  the interrupt request for twi will be activated as long as the twint flag is high
		//TWINT: reset twint flag (by writing a one) -> starts the operation of the twi module
		TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);// | (1<<TWIE); 
     818:	e6 be       	out	0x36, r14	; 54
		
		
		//TWSR should now have the status code, that the START has been send successfully
		statusCode = TWSR;
     81a:	f1 b0       	in	r15, 0x01	; 1
		lcd_moveto_xy  (1, 0);	 
     81c:	81 e0       	ldi	r24, 0x01	; 1
     81e:	60 e0       	ldi	r22, 0x00	; 0
     820:	0e 94 11 05 	call	0xa22	; 0xa22 <lcd_moveto_xy>
		lcd_put_uint(statusCode);
     824:	8f 2d       	mov	r24, r15
     826:	90 e0       	ldi	r25, 0x00	; 0
     828:	0e 94 c3 0a 	call	0x1586	; 0x1586 <lcd_put_uint>
		//while  (!(TWCR & (1<<TWINT)));

		
		
		//write the bmp addressWrite into the TWI data register
		TWDR = 0xEE;
     82c:	d3 b8       	out	0x03, r13	; 3
		//start transmission by reseting the TWINT (by writing a one)
		TWCR = (1<<TWINT) | (1<<TWEN);
     82e:	16 bf       	out	0x36, r17	; 54
		
		//while  (!(TWCR & (1<<TWINT)));
				
		TWDR = 0xF4;
     830:	03 b9       	out	0x03, r16	; 3
		TWCR = (1<<TWINT) | (1<<TWEN);
     832:	16 bf       	out	0x36, r17	; 54

		//while  (!(TWCR & (1<<TWINT)));
				
		TWDR = 0xF4;
     834:	03 b9       	out	0x03, r16	; 3
		TWCR = (1<<TWINT) | (1<<TWEN);
     836:	16 bf       	out	0x36, r17	; 54
					
		
		//send STOP condition
		TWCR = (1<<TWINT) | (1<<TWEN)| (1<<TWSTO);
     838:	c6 be       	out	0x36, r12	; 54
			
		//TWSR should now have the status code, that the slave has accepted the data package
		statusCode = TWSR;
     83a:	f1 b0       	in	r15, 0x01	; 1
		lcd_moveto_xy  (2, 0);	 
     83c:	82 e0       	ldi	r24, 0x02	; 2
     83e:	60 e0       	ldi	r22, 0x00	; 0
     840:	0e 94 11 05 	call	0xa22	; 0xa22 <lcd_moveto_xy>
		lcd_put_uint(statusCode);	
     844:	8f 2d       	mov	r24, r15
     846:	90 e0       	ldi	r25, 0x00	; 0
     848:	0e 94 c3 0a 	call	0x1586	; 0x1586 <lcd_put_uint>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     84c:	8f ef       	ldi	r24, 0xFF	; 255
     84e:	90 e7       	ldi	r25, 0x70	; 112
     850:	a2 e0       	ldi	r26, 0x02	; 2
     852:	81 50       	subi	r24, 0x01	; 1
     854:	90 40       	sbci	r25, 0x00	; 0
     856:	a0 40       	sbci	r26, 0x00	; 0
     858:	e1 f7       	brne	.-8      	; 0x852 <main+0x84>
     85a:	00 c0       	rjmp	.+0      	; 0x85c <main+0x8e>
     85c:	00 00       	nop
     85e:	dc cf       	rjmp	.-72     	; 0x818 <main+0x4a>

00000860 <__vector_19>:
	
}


ISR(TWI_vect)
{
     860:	1f 92       	push	r1
     862:	0f 92       	push	r0
     864:	0f b6       	in	r0, 0x3f	; 63
     866:	0f 92       	push	r0
     868:	11 24       	eor	r1, r1
  PORTA |= (1<<PINA7);
     86a:	df 9a       	sbi	0x1b, 7	; 27
     86c:	0f 90       	pop	r0
     86e:	0f be       	out	0x3f, r0	; 63
     870:	0f 90       	pop	r0
     872:	1f 90       	pop	r1
     874:	18 95       	reti

00000876 <adcInit>:
{
  
  uint16_t result;
 									
								
  ADMUX &= ~((1<<REFS1) | (1<<REFS0)); // externe Referenzspannung nutzen (typischerweise Vcc-Pegel)
     876:	87 b1       	in	r24, 0x07	; 7
     878:	8f 73       	andi	r24, 0x3F	; 63
     87a:	87 b9       	out	0x07, r24	; 7


  ADCSRA |= ((1<<ADEN) | (1<<ADPS2) | (1<<ADPS1));    	// ADC Prescaler wählen. BIT0 bis BII 2 in ADCSRA
     87c:	86 b1       	in	r24, 0x06	; 6
     87e:	86 68       	ori	r24, 0x86	; 134
     880:	86 b9       	out	0x06, r24	; 6
                               					    // UND ADC aktivieren



  //Erste conversion anstoßen, danach läuft der ADC im free run mode
  ADCSRA |= (1<<ADSC);	
     882:	36 9a       	sbi	0x06, 6	; 6
  

  //Auf Abschluss der Konvertierung warten
  //Das Register ADCSRA wird mit "1<<ADSC" maskiert. Da ADSC den Wert 6 hat, wartet das while 
  //also solange, bis das Bit6 von ADCSRA == 0 wird.
  while (ADCSRA & (1<<ADSC) ) {}
     884:	36 99       	sbic	0x06, 6	; 6
     886:	fe cf       	rjmp	.-4      	; 0x884 <adcInit+0xe>
  	
  //ADCSRA |= (1<<ADIE);		// ADC - > Interrupt Enable		
  
  /* ADCW muss einmal gelesen werden, sonst wird Ergebnis der nächsten
     Wandlung nicht übernommen. */
  result = ADCW;		 
     888:	84 b1       	in	r24, 0x04	; 4
     88a:	95 b1       	in	r25, 0x05	; 5
   
}
     88c:	08 95       	ret

0000088e <adcRead15>:
{
	uint16_t result=0;
	
	// 	Kanal waehlen(durch Parameterübergabe)	
	//  Kanäle 4 bis 7 sind verfügbar
	if ((channel >= 4) && (channel <=7))
     88e:	98 2f       	mov	r25, r24
     890:	94 50       	subi	r25, 0x04	; 4
     892:	94 30       	cpi	r25, 0x04	; 4
     894:	08 f4       	brcc	.+2      	; 0x898 <adcRead15+0xa>
 		ADMUX = channel;                  // 	Kanal waehlen(durch Parameterübergabe)
     896:	87 b9       	out	0x07, r24	; 7

	//Erste conversion anstoßen, danach läuft der ADC im free run mode
  	ADCSRA |= (1<<ADSC);	
     898:	36 9a       	sbi	0x06, 6	; 6
  

  	//Auf Abschluss der Konvertierung warten
	while (ADCSRA & (1<<ADSC) ) {}
     89a:	36 99       	sbic	0x06, 6	; 6
     89c:	fe cf       	rjmp	.-4      	; 0x89a <adcRead15+0xc>
	
	//result in bit value
	result = ADCW;
     89e:	44 b1       	in	r20, 0x04	; 4
     8a0:	55 b1       	in	r21, 0x05	; 5
	//convert result into voltage value
	//korrektes runden mit +(divisor>>1)
	//ohne die 16bit casts würde das zwischenergebnis auf die bitwertigkeit des
	//niedrigsten teil des terms reduziert (hier 8 bit von 100 oder 15)
	result = ((result * (uint16_t)15 * (int16_t)100)+(1023>>1)) / (uint16_t)1023;
     8a2:	2c ed       	ldi	r18, 0xDC	; 220
     8a4:	35 e0       	ldi	r19, 0x05	; 5
     8a6:	42 9f       	mul	r20, r18
     8a8:	c0 01       	movw	r24, r0
     8aa:	43 9f       	mul	r20, r19
     8ac:	90 0d       	add	r25, r0
     8ae:	52 9f       	mul	r21, r18
     8b0:	90 0d       	add	r25, r0
     8b2:	11 24       	eor	r1, r1
     8b4:	81 50       	subi	r24, 0x01	; 1
     8b6:	9e 4f       	sbci	r25, 0xFE	; 254
     8b8:	6f ef       	ldi	r22, 0xFF	; 255
     8ba:	73 e0       	ldi	r23, 0x03	; 3
     8bc:	0e 94 7e 0b 	call	0x16fc	; 0x16fc <__udivmodhi4>

	return result;
}
     8c0:	86 2f       	mov	r24, r22
     8c2:	97 2f       	mov	r25, r23
     8c4:	08 95       	ret

000008c6 <adcRead5>:
{
	uint16_t result=0;
	
	// 	Kanal waehlen(durch Parameterübergabe)	
	//  Kanäle 4 bis 7 sind verfügbar
	if ((channel >= 4) && (channel <=7))
     8c6:	98 2f       	mov	r25, r24
     8c8:	94 50       	subi	r25, 0x04	; 4
     8ca:	94 30       	cpi	r25, 0x04	; 4
     8cc:	08 f4       	brcc	.+2      	; 0x8d0 <adcRead5+0xa>
 		ADMUX = channel;                  // 	Kanal waehlen(durch Parameterübergabe)
     8ce:	87 b9       	out	0x07, r24	; 7

	//Erste conversion anstoßen, danach läuft der ADC im free run mode
  	ADCSRA |= (1<<ADSC);	
     8d0:	36 9a       	sbi	0x06, 6	; 6
  

  	//Auf Abschluss der Konvertierung warten
	while (ADCSRA & (1<<ADSC) ) {}
     8d2:	36 99       	sbic	0x06, 6	; 6
     8d4:	fe cf       	rjmp	.-4      	; 0x8d2 <adcRead5+0xc>
	
	//result in bit value
	result = ADCW;
     8d6:	44 b1       	in	r20, 0x04	; 4
     8d8:	55 b1       	in	r21, 0x05	; 5
	//convert result into voltage value
	//korrektes runden mit +(divisor>>1)
	//ohne die 16bit casts würde das zwischenergebnis auf die bitwertigkeit des
	//niedrigsten teil des terms reduziert (hier 8 bit von 100 oder 15)
	result = ((result * (uint16_t)5 * (uint16_t)100) + (1023>>1)) / (uint16_t)1023;
     8da:	24 ef       	ldi	r18, 0xF4	; 244
     8dc:	31 e0       	ldi	r19, 0x01	; 1
     8de:	42 9f       	mul	r20, r18
     8e0:	c0 01       	movw	r24, r0
     8e2:	43 9f       	mul	r20, r19
     8e4:	90 0d       	add	r25, r0
     8e6:	52 9f       	mul	r21, r18
     8e8:	90 0d       	add	r25, r0
     8ea:	11 24       	eor	r1, r1
     8ec:	81 50       	subi	r24, 0x01	; 1
     8ee:	9e 4f       	sbci	r25, 0xFE	; 254
     8f0:	6f ef       	ldi	r22, 0xFF	; 255
     8f2:	73 e0       	ldi	r23, 0x03	; 3
     8f4:	0e 94 7e 0b 	call	0x16fc	; 0x16fc <__udivmodhi4>

	return result;

}
     8f8:	86 2f       	mov	r24, r22
     8fa:	97 2f       	mov	r25, r23
     8fc:	08 95       	ret

000008fe <__vector_1>:



//bei Button "warm" (button ganz rechts), läuft durch wenn fallende Flanke auf INT0 (PD.2)
ISR(INT0_vect) 
{
     8fe:	1f 92       	push	r1
     900:	0f 92       	push	r0
     902:	0f b6       	in	r0, 0x3f	; 63
     904:	0f 92       	push	r0
     906:	11 24       	eor	r1, r1

}
     908:	0f 90       	pop	r0
     90a:	0f be       	out	0x3f, r0	; 63
     90c:	0f 90       	pop	r0
     90e:	1f 90       	pop	r1
     910:	18 95       	reti

00000912 <__vector_2>:

//----------------------------------------------------------------------------------------------

//bei Button "kalt" (button in der Mitte), läuft durch wenn fallende Flanke auf INT1 (PD.3)
ISR(INT1_vect) 
{
     912:	1f 92       	push	r1
     914:	0f 92       	push	r0
     916:	0f b6       	in	r0, 0x3f	; 63
     918:	0f 92       	push	r0
     91a:	11 24       	eor	r1, r1

}
     91c:	0f 90       	pop	r0
     91e:	0f be       	out	0x3f, r0	; 63
     920:	0f 90       	pop	r0
     922:	1f 90       	pop	r1
     924:	18 95       	reti

00000926 <__vector_3>:

//----------------------------------------------------------------------------------------------

//ISR läuft durch, wenn fallende Flanke auf INT2 (PB.2)
ISR(INT2_vect)
{	
     926:	1f 92       	push	r1
     928:	0f 92       	push	r0
     92a:	0f b6       	in	r0, 0x3f	; 63
     92c:	0f 92       	push	r0
     92e:	11 24       	eor	r1, r1



	//sleep_disable();	

}
     930:	0f 90       	pop	r0
     932:	0f be       	out	0x3f, r0	; 63
     934:	0f 90       	pop	r0
     936:	1f 90       	pop	r1
     938:	18 95       	reti

0000093a <myInit>:
	//set_sleep_mode(SLEEP_MODE_PWR_DOWN);


	//für dogm display
	//initialize lcd-display
	lcd_init();
     93a:	0e 94 d7 06 	call	0xdae	; 0xdae <lcd_init>
	
	
	
	//cpu status led
	DDRA |= (1<<PINA7);
     93e:	d7 9a       	sbi	0x1a, 7	; 26
	PORTA &= ~(1<<PINA7);
     940:	df 98       	cbi	0x1b, 7	; 27
	
	DDRA |= (1<<PINA0);
     942:	d0 9a       	sbi	0x1a, 0	; 26
	
	DDRA |= (1<<PINA1);
     944:	d1 9a       	sbi	0x1a, 1	; 26
	//Enable interrupts for INT0, INT1, INT2	
	//GICR  |= (1<<BIT7) | (1<<BIT6) | (1<<BIT5); 
	GICR |= (1<<BIT5); //only INT2

*/
}
     946:	08 95       	ret

00000948 <pwmInit>:

#include "pwmInit.h"

void pwmInit(uint16_t compare)
{
	DDRD |= (1<<BIT4) | (1<<BIT5);		//D.4&5 als Ausgänge definieren
     948:	21 b3       	in	r18, 0x11	; 17
     94a:	20 63       	ori	r18, 0x30	; 48
     94c:	21 bb       	out	0x11, r18	; 17
	
	//PWM, Phase Correct with ICR1 as TOP value
	//TOP: 625
	TCCR1A |= (1<<WGM11);	
     94e:	2f b5       	in	r18, 0x2f	; 47
     950:	22 60       	ori	r18, 0x02	; 2
     952:	2f bd       	out	0x2f, r18	; 47
	TCCR1A &= ~(1<<WGM10);	
     954:	2f b5       	in	r18, 0x2f	; 47
     956:	2e 7f       	andi	r18, 0xFE	; 254
     958:	2f bd       	out	0x2f, r18	; 47

	TCCR1B |= (1<<WGM13);
     95a:	2e b5       	in	r18, 0x2e	; 46
     95c:	20 61       	ori	r18, 0x10	; 16
     95e:	2e bd       	out	0x2e, r18	; 46
	TCCR1B &= ~(1<<WGM12);
     960:	2e b5       	in	r18, 0x2e	; 46
     962:	27 7f       	andi	r18, 0xF7	; 247
     964:	2e bd       	out	0x2e, r18	; 46

	ICR1 = 625;
     966:	21 e7       	ldi	r18, 0x71	; 113
     968:	32 e0       	ldi	r19, 0x02	; 2
     96a:	37 bd       	out	0x27, r19	; 39
     96c:	26 bd       	out	0x26, r18	; 38
	

	//Nicht invertierende PWM, KanalA -> auf Pin D.5
	//- Clear OC1A/OC1B on Compare Match when up-counting. 
	//- Set OC1A/OC1B on Compare Match when downcounting.
	TCCR1A |= (1<<COM1A1); 	
     96e:	2f b5       	in	r18, 0x2f	; 47
     970:	20 68       	ori	r18, 0x80	; 128
     972:	2f bd       	out	0x2f, r18	; 47
	TCCR1A &= ~(1<<COM1A0);
     974:	2f b5       	in	r18, 0x2f	; 47
     976:	2f 7b       	andi	r18, 0xBF	; 191
     978:	2f bd       	out	0x2f, r18	; 47

	//Prescaler = 64
	TCCR1B |= (1<<CS10) | (1<<CS11);
     97a:	2e b5       	in	r18, 0x2e	; 46
     97c:	23 60       	ori	r18, 0x03	; 3
     97e:	2e bd       	out	0x2e, r18	; 46
	TCCR1B |= ~(1<<CS12); 
     980:	2e b5       	in	r18, 0x2e	; 46
     982:	2b 6f       	ori	r18, 0xFB	; 251
     984:	2e bd       	out	0x2e, r18	; 46
		1 	1 	0 	Externer Pin 1, negative Flanke
		1 	1 	1 	Externer Pin 1, positive Flanke 
	*/
	
	//OCR1A->16bit register
	OCR1A=compare;	//Vergleichswert laden
     986:	9b bd       	out	0x2b, r25	; 43
     988:	8a bd       	out	0x2a, r24	; 42
	
	
}
     98a:	08 95       	ret

0000098c <pwmUpdate>:


void pwmUpdate(uint16_t compare)
{
	OCR1A=compare;	
     98c:	9b bd       	out	0x2b, r25	; 43
     98e:	8a bd       	out	0x2a, r24	; 42
}
     990:	08 95       	ret

00000992 <timer_init>:
#include "timerInit.h"

void timer_init(uint16_t compare)
{

	TCCR1B |= (1<<WGM12);	//CTC Mode:
     992:	2e b5       	in	r18, 0x2e	; 46
     994:	28 60       	ori	r18, 0x08	; 8
     996:	2e bd       	out	0x2e, r18	; 46
							//Timer1 zählt hoch, bei compare match wird er wieder zu 0 gesetzt

	TCCR1B |= (1<<CS10); //Prescaler nicht aktiviert - es liegt der Systemtakt an
     998:	2e b5       	in	r18, 0x2e	; 46
     99a:	21 60       	ori	r18, 0x01	; 1
     99c:	2e bd       	out	0x2e, r18	; 46
	1 	0 	1 	CK / 1024
	1 	1 	0 	Externer Pin 1, negative Flanke
	1 	1 	1 	Externer Pin 1, positive Flanke 
*/
	
	OCR1A=compare;	//Vergleichswert laden
     99e:	9b bd       	out	0x2b, r25	; 43
     9a0:	8a bd       	out	0x2a, r24	; 42
	
	
}
     9a2:	08 95       	ret

000009a4 <lcd_inc_page>:
/******************************************************************************
 * Changes the internal cursor by s pages
 * s             - number of pages to move
 */ 
uint8_t lcd_inc_page(int8_t s) {
  uint8_t p = lcd_current_page;
     9a4:	90 91 6e 00 	lds	r25, 0x006E
  p += s;
     9a8:	89 0f       	add	r24, r25
  p %= LCD_RAM_PAGES;    //all lcd have lcd_ram_pages which is power of two
     9aa:	83 70       	andi	r24, 0x03	; 3
  lcd_current_page = p;
     9ac:	80 93 6e 00 	sts	0x006E, r24
  return p;
  }
     9b0:	08 95       	ret

000009b2 <lcd_inc_column>:

/******************************************************************************
 * Changes the internal cursor by s columns, including wrapping (if selected)
 * s             - number of columns to move
 */ 
uint8_t lcd_inc_column(int16_t s) {
     9b2:	0f 93       	push	r16
     9b4:	1f 93       	push	r17
     9b6:	cf 93       	push	r28
     9b8:	df 93       	push	r29
     9ba:	8c 01       	movw	r16, r24
  uint16_t c = lcd_current_column;
     9bc:	80 91 6f 00 	lds	r24, 0x006F
  c += s;
     9c0:	e8 01       	movw	r28, r16
     9c2:	c8 0f       	add	r28, r24
     9c4:	d1 1d       	adc	r29, r1
#if LCD_WRAP_AROUND == 1
  while (c >= LCD_WIDTH) {
     9c6:	c4 38       	cpi	r28, 0x84	; 132
     9c8:	d1 05       	cpc	r29, r1
     9ca:	88 f0       	brcs	.+34     	; 0x9ee <lcd_inc_column+0x3c>
    if (s > 0) lcd_inc_page(1);
     9cc:	10 16       	cp	r1, r16
     9ce:	11 06       	cpc	r1, r17
     9d0:	34 f4       	brge	.+12     	; 0x9de <lcd_inc_column+0x2c>
     9d2:	81 e0       	ldi	r24, 0x01	; 1
     9d4:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <lcd_inc_page>
    else       lcd_inc_page(-1);
    if (s > 0) c -= LCD_WIDTH;
     9d8:	c4 58       	subi	r28, 0x84	; 132
     9da:	d0 40       	sbci	r29, 0x00	; 0
     9dc:	05 c0       	rjmp	.+10     	; 0x9e8 <lcd_inc_column+0x36>
  uint16_t c = lcd_current_column;
  c += s;
#if LCD_WRAP_AROUND == 1
  while (c >= LCD_WIDTH) {
    if (s > 0) lcd_inc_page(1);
    else       lcd_inc_page(-1);
     9de:	8f ef       	ldi	r24, 0xFF	; 255
     9e0:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <lcd_inc_page>
    if (s > 0) c -= LCD_WIDTH;
    else       c += LCD_WIDTH;
     9e4:	cc 57       	subi	r28, 0x7C	; 124
     9e6:	df 4f       	sbci	r29, 0xFF	; 255
 */ 
uint8_t lcd_inc_column(int16_t s) {
  uint16_t c = lcd_current_column;
  c += s;
#if LCD_WRAP_AROUND == 1
  while (c >= LCD_WIDTH) {
     9e8:	c4 38       	cpi	r28, 0x84	; 132
     9ea:	d1 05       	cpc	r29, r1
     9ec:	78 f7       	brcc	.-34     	; 0x9cc <lcd_inc_column+0x1a>
    else       lcd_inc_page(-1);
    if (s > 0) c -= LCD_WIDTH;
    else       c += LCD_WIDTH;
    }
#endif
  lcd_current_column = c;
     9ee:	c0 93 6f 00 	sts	0x006F, r28
  return c;
  }
     9f2:	8c 2f       	mov	r24, r28
     9f4:	df 91       	pop	r29
     9f6:	cf 91       	pop	r28
     9f8:	1f 91       	pop	r17
     9fa:	0f 91       	pop	r16
     9fc:	08 95       	ret

000009fe <lcd_data>:
/******************************************************************************
 * Writes one data byte
 * data          - the data byte
 */
void lcd_data(uint8_t data) {
  LCD_SELECT();
     9fe:	c4 98       	cbi	0x18, 4	; 24
  LCD_DRAM();
     a00:	dd 9a       	sbi	0x1b, 5	; 27
  spi_write(data);
     a02:	8f b9       	out	0x0f, r24	; 15
  LCD_UNSELECT();
     a04:	77 9b       	sbis	0x0e, 7	; 14
     a06:	fe cf       	rjmp	.-4      	; 0xa04 <lcd_data+0x6>
     a08:	c4 9a       	sbi	0x18, 4	; 24
  lcd_inc_column(1);
     a0a:	81 e0       	ldi	r24, 0x01	; 1
     a0c:	90 e0       	ldi	r25, 0x00	; 0
     a0e:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <lcd_inc_column>
  }
     a12:	08 95       	ret

00000a14 <lcd_command>:
/******************************************************************************
 * Writes one command byte
 * cmd           - the command byte
 */
void lcd_command(uint8_t cmd) {
  LCD_SELECT();
     a14:	c4 98       	cbi	0x18, 4	; 24
  LCD_CMD();
     a16:	dd 98       	cbi	0x1b, 5	; 27
   
  spi_write(cmd);
     a18:	8f b9       	out	0x0f, r24	; 15
  
  
  //LCD_UNSELECT();
  while(!(SPSR & (1<<SPIF)));
     a1a:	77 9b       	sbis	0x0e, 7	; 14
     a1c:	fe cf       	rjmp	.-4      	; 0xa1a <lcd_command+0x6>
  PORT_CS |= _BV(PIN_CS);
     a1e:	c4 9a       	sbi	0x18, 4	; 24
  }
     a20:	08 95       	ret

00000a22 <lcd_moveto_xy>:
/******************************************************************************
 * Moves the cursor to the given position
 * pages         - page to move to
 * columns       - column to move to
 */ 
void lcd_moveto_xy(uint8_t page, uint8_t column) {
     a22:	0f 93       	push	r16
     a24:	1f 93       	push	r17
     a26:	08 2f       	mov	r16, r24
     a28:	16 2f       	mov	r17, r22
  LCD_GOTO_ADDRESS(page,column);
     a2a:	8f 70       	andi	r24, 0x0F	; 15
     a2c:	80 6b       	ori	r24, 0xB0	; 176
     a2e:	0e 94 0a 05 	call	0xa14	; 0xa14 <lcd_command>
     a32:	81 2f       	mov	r24, r17
     a34:	82 95       	swap	r24
     a36:	8f 70       	andi	r24, 0x0F	; 15
     a38:	80 61       	ori	r24, 0x10	; 16
     a3a:	0e 94 0a 05 	call	0xa14	; 0xa14 <lcd_command>
     a3e:	81 2f       	mov	r24, r17
     a40:	8f 70       	andi	r24, 0x0F	; 15
     a42:	0e 94 0a 05 	call	0xa14	; 0xa14 <lcd_command>
  lcd_current_column = column; 
     a46:	10 93 6f 00 	sts	0x006F, r17
  lcd_current_page = page;
     a4a:	00 93 6e 00 	sts	0x006E, r16
  }
     a4e:	1f 91       	pop	r17
     a50:	0f 91       	pop	r16
     a52:	08 95       	ret

00000a54 <lcd_move_xy>:
/******************************************************************************
 * Moves the cursor relative to the current position
 * pages         - number of pages to move
 * columns       - number of columns to move
 */  
void lcd_move_xy(int8_t pages, int16_t columns) {
     a54:	1f 93       	push	r17
     a56:	cf 93       	push	r28
     a58:	df 93       	push	r29
     a5a:	eb 01       	movw	r28, r22
  lcd_moveto_xy(lcd_inc_page(pages),lcd_inc_column(columns));
     a5c:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <lcd_inc_page>
     a60:	18 2f       	mov	r17, r24
     a62:	ce 01       	movw	r24, r28
     a64:	0e 94 d9 04 	call	0x9b2	; 0x9b2 <lcd_inc_column>
     a68:	68 2f       	mov	r22, r24
     a6a:	81 2f       	mov	r24, r17
     a6c:	0e 94 11 05 	call	0xa22	; 0xa22 <lcd_moveto_xy>
  }
     a70:	df 91       	pop	r29
     a72:	cf 91       	pop	r28
     a74:	1f 91       	pop	r17
     a76:	08 95       	ret

00000a78 <lcd_draw_image_P>:
 * progmem_image - prog_uint8_t array of columns aka the bitmap image
 * pages         - height of image in pages
 * columns       - width of image in pixels (or columns)
 * style         - Bit2: sets inverse mode
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
     a78:	8f 92       	push	r8
     a7a:	9f 92       	push	r9
     a7c:	af 92       	push	r10
     a7e:	bf 92       	push	r11
     a80:	cf 92       	push	r12
     a82:	df 92       	push	r13
     a84:	ef 92       	push	r14
     a86:	ff 92       	push	r15
     a88:	0f 93       	push	r16
     a8a:	1f 93       	push	r17
     a8c:	cf 93       	push	r28
     a8e:	df 93       	push	r29
     a90:	18 2f       	mov	r17, r24
     a92:	d9 2e       	mov	r13, r25
     a94:	c6 2e       	mov	r12, r22
     a96:	04 2f       	mov	r16, r20
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
     a98:	ff 24       	eor	r15, r15
     a9a:	68 94       	set
     a9c:	f2 f8       	bld	r15, 2
     a9e:	f2 22       	and	r15, r18
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
     aa0:	66 23       	and	r22, r22
     aa2:	09 f4       	brne	.+2      	; 0xaa6 <lcd_draw_image_P+0x2e>
     aa4:	40 c0       	rjmp	.+128    	; 0xb26 <lcd_draw_image_P+0xae>
     aa6:	80 91 6e 00 	lds	r24, 0x006E
     aaa:	84 30       	cpi	r24, 0x04	; 4
     aac:	70 f1       	brcs	.+92     	; 0xb0a <lcd_draw_image_P+0x92>
     aae:	3b c0       	rjmp	.+118    	; 0xb26 <lcd_draw_image_P+0xae>
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++) {
     ab0:	81 2e       	mov	r8, r17
     ab2:	e4 01       	movw	r28, r8
     ab4:	4e 01       	movw	r8, r28
     ab6:	9d 2c       	mov	r9, r13
     ab8:	e4 01       	movw	r28, r8
 * style         - Bit2: sets inverse mode
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
     aba:	fe 01       	movw	r30, r28
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++) {
      uint8_t tmp = pgm_read_byte(progmem_image++);
     abc:	21 96       	adiw	r28, 0x01	; 1
     abe:	84 91       	lpm	r24, Z+
			if(!inv)
     ac0:	ff 20       	and	r15, r15
     ac2:	19 f4       	brne	.+6      	; 0xaca <lcd_draw_image_P+0x52>
				lcd_data(tmp);
     ac4:	0e 94 ff 04 	call	0x9fe	; 0x9fe <lcd_data>
     ac8:	03 c0       	rjmp	.+6      	; 0xad0 <lcd_draw_image_P+0x58>
			else
				lcd_data(~tmp);
     aca:	80 95       	com	r24
     acc:	0e 94 ff 04 	call	0x9fe	; 0x9fe <lcd_data>
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++) {
     ad0:	4e 01       	movw	r8, r28
     ad2:	81 1a       	sub	r8, r17
     ad4:	80 16       	cp	r8, r16
     ad6:	40 f4       	brcc	.+16     	; 0xae8 <lcd_draw_image_P+0x70>
     ad8:	80 91 6f 00 	lds	r24, 0x006F
     adc:	84 38       	cpi	r24, 0x84	; 132
     ade:	68 f3       	brcs	.-38     	; 0xaba <lcd_draw_image_P+0x42>
      uint8_t tmp = pgm_read_byte(progmem_image++);
     ae0:	9e 01       	movw	r18, r28
     ae2:	1c 2f       	mov	r17, r28
     ae4:	d3 2e       	mov	r13, r19
     ae6:	03 c0       	rjmp	.+6      	; 0xaee <lcd_draw_image_P+0x76>
     ae8:	9e 01       	movw	r18, r28
     aea:	1c 2f       	mov	r17, r28
     aec:	d3 2e       	mov	r13, r19
			if(!inv)
				lcd_data(tmp);
			else
				lcd_data(~tmp);
      }
    if(++j != pages)
     aee:	e3 94       	inc	r14
     af0:	ec 14       	cp	r14, r12
     af2:	c9 f0       	breq	.+50     	; 0xb26 <lcd_draw_image_P+0xae>
      lcd_move_xy(1,-columns);
     af4:	81 e0       	ldi	r24, 0x01	; 1
     af6:	b5 01       	movw	r22, r10
     af8:	0e 94 2a 05 	call	0xa54	; 0xa54 <lcd_move_xy>
 * style         - Bit2: sets inverse mode
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
     afc:	ec 14       	cp	r14, r12
     afe:	98 f4       	brcc	.+38     	; 0xb26 <lcd_draw_image_P+0xae>
     b00:	80 91 6e 00 	lds	r24, 0x006E
     b04:	84 30       	cpi	r24, 0x04	; 4
     b06:	40 f0       	brcs	.+16     	; 0xb18 <lcd_draw_image_P+0xa0>
     b08:	0e c0       	rjmp	.+28     	; 0xb26 <lcd_draw_image_P+0xae>
 * pages         - height of image in pages
 * columns       - width of image in pixels (or columns)
 * style         - Bit2: sets inverse mode
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
     b0a:	ee 24       	eor	r14, r14
				lcd_data(tmp);
			else
				lcd_data(~tmp);
      }
    if(++j != pages)
      lcd_move_xy(1,-columns);
     b0c:	a4 2e       	mov	r10, r20
     b0e:	bb 24       	eor	r11, r11
     b10:	b0 94       	com	r11
     b12:	a1 94       	neg	r10
     b14:	b1 08       	sbc	r11, r1
     b16:	b3 94       	inc	r11
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++) {
     b18:	00 23       	and	r16, r16
     b1a:	49 f3       	breq	.-46     	; 0xaee <lcd_draw_image_P+0x76>
     b1c:	80 91 6f 00 	lds	r24, 0x006F
     b20:	84 38       	cpi	r24, 0x84	; 132
     b22:	30 f2       	brcs	.-116    	; 0xab0 <lcd_draw_image_P+0x38>
     b24:	e4 cf       	rjmp	.-56     	; 0xaee <lcd_draw_image_P+0x76>
				lcd_data(~tmp);
      }
    if(++j != pages)
      lcd_move_xy(1,-columns);
    }
  }
     b26:	df 91       	pop	r29
     b28:	cf 91       	pop	r28
     b2a:	1f 91       	pop	r17
     b2c:	0f 91       	pop	r16
     b2e:	ff 90       	pop	r15
     b30:	ef 90       	pop	r14
     b32:	df 90       	pop	r13
     b34:	cf 90       	pop	r12
     b36:	bf 90       	pop	r11
     b38:	af 90       	pop	r10
     b3a:	9f 90       	pop	r9
     b3c:	8f 90       	pop	r8
     b3e:	08 95       	ret

00000b40 <lcd_draw_image_xy_P>:
 * y             - y start coordinate on the screen (in pixel)
 * pages         - height of image in pages
 * columns       - width of image in pixels
 * style         - Bit2: sets inverse mode
 */
void lcd_draw_image_xy_P(PGM_P progmem_image, uint8_t x, uint8_t y, uint8_t pages, uint8_t columns, uint8_t style) {
     b40:	2f 92       	push	r2
     b42:	3f 92       	push	r3
     b44:	4f 92       	push	r4
     b46:	5f 92       	push	r5
     b48:	6f 92       	push	r6
     b4a:	7f 92       	push	r7
     b4c:	8f 92       	push	r8
     b4e:	9f 92       	push	r9
     b50:	af 92       	push	r10
     b52:	bf 92       	push	r11
     b54:	cf 92       	push	r12
     b56:	df 92       	push	r13
     b58:	ef 92       	push	r14
     b5a:	ff 92       	push	r15
     b5c:	0f 93       	push	r16
     b5e:	1f 93       	push	r17
     b60:	df 93       	push	r29
     b62:	cf 93       	push	r28
     b64:	cd b7       	in	r28, 0x3d	; 61
     b66:	de b7       	in	r29, 0x3e	; 62
     b68:	28 97       	sbiw	r28, 0x08	; 8
     b6a:	0f b6       	in	r0, 0x3f	; 63
     b6c:	f8 94       	cli
     b6e:	de bf       	out	0x3e, r29	; 62
     b70:	0f be       	out	0x3f, r0	; 63
     b72:	cd bf       	out	0x3d, r28	; 61
     b74:	6c 01       	movw	r12, r24
     b76:	62 2e       	mov	r6, r18
	uint16_t i,j;
  uint8_t data   = 0;
  uint8_t inv    = style & INVERT_BIT;
     b78:	24 e0       	ldi	r18, 0x04	; 4
     b7a:	e2 22       	and	r14, r18
	uint8_t offset = y & 0x7; //Optimized modulo 8
     b7c:	0f 2e       	mov	r0, r31
     b7e:	f7 e0       	ldi	r31, 0x07	; 7
     b80:	ff 2e       	mov	r15, r31
     b82:	f0 2d       	mov	r31, r0
     b84:	f4 22       	and	r15, r20
	//If there is an offset, we must use an additional page
	if(offset)  
     b86:	09 f0       	breq	.+2      	; 0xb8a <lcd_draw_image_xy_P+0x4a>
    pages++;
     b88:	63 94       	inc	r6


//Function to read the current position
extern uint8_t lcd_current_page;
extern uint8_t lcd_current_column;
static inline uint8_t lcd_get_position_page()   {return lcd_current_page;};
     b8a:	80 91 6e 00 	lds	r24, 0x006E
  //If there is not enough vertical space -> cut image
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
     b8e:	e6 2d       	mov	r30, r6
     b90:	f0 e0       	ldi	r31, 0x00	; 0
     b92:	24 e0       	ldi	r18, 0x04	; 4
     b94:	30 e0       	ldi	r19, 0x00	; 0
     b96:	28 1b       	sub	r18, r24
     b98:	31 09       	sbc	r19, r1
     b9a:	2e 17       	cp	r18, r30
     b9c:	3f 07       	cpc	r19, r31
     b9e:	24 f4       	brge	.+8      	; 0xba8 <lcd_draw_image_xy_P+0x68>
    pages = LCD_RAM_PAGES - lcd_get_position_page();
     ba0:	66 24       	eor	r6, r6
     ba2:	68 94       	set
     ba4:	62 f8       	bld	r6, 2
     ba6:	68 1a       	sub	r6, r24
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
     ba8:	84 2f       	mov	r24, r20
     baa:	86 95       	lsr	r24
     bac:	86 95       	lsr	r24
     bae:	86 95       	lsr	r24
     bb0:	0e 94 11 05 	call	0xa22	; 0xa22 <lcd_moveto_xy>
 * y             - y start coordinate on the screen (in pixel)
 * pages         - height of image in pages
 * columns       - width of image in pixels
 * style         - Bit2: sets inverse mode
 */
void lcd_draw_image_xy_P(PGM_P progmem_image, uint8_t x, uint8_t y, uint8_t pages, uint8_t columns, uint8_t style) {
     bb4:	80 2e       	mov	r8, r16
     bb6:	99 24       	eor	r9, r9
     bb8:	16 01       	movw	r2, r12
     bba:	28 18       	sub	r2, r8
     bbc:	39 08       	sbc	r3, r9
     bbe:	da 82       	std	Y+2, r13	; 0x02
     bc0:	c9 82       	std	Y+1, r12	; 0x01
  //If there is not enough vertical space -> cut image
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
    pages = LCD_RAM_PAGES - lcd_get_position_page();
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
	for (j=0; j<pages; j++) {
     bc2:	aa 24       	eor	r10, r10
     bc4:	bb 24       	eor	r11, r11
     bc6:	77 24       	eor	r7, r7
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
      data = 0;
      if (!offset || j+1 != pages)
        data = pgm_read_byte(&progmem_image[j*columns + i]) << offset;
			if(j > 0 && offset)
				data |= pgm_read_byte(&progmem_image[(j-1)*columns + i]) >> (8-offset);
     bc8:	88 e0       	ldi	r24, 0x08	; 8
     bca:	90 e0       	ldi	r25, 0x00	; 0
     bcc:	fc 01       	movw	r30, r24
     bce:	ef 19       	sub	r30, r15
     bd0:	f1 09       	sbc	r31, r1
     bd2:	fc 83       	std	Y+4, r31	; 0x04
     bd4:	eb 83       	std	Y+3, r30	; 0x03
			if(inv)	lcd_data(~data);
      else 		lcd_data(data);
		  }
		if(j+1 != pages)
			lcd_move_xy(1,-columns);
     bd6:	c4 01       	movw	r24, r8
     bd8:	22 27       	eor	r18, r18
     bda:	33 27       	eor	r19, r19
     bdc:	28 1b       	sub	r18, r24
     bde:	39 0b       	sbc	r19, r25
     be0:	3e 83       	std	Y+6, r19	; 0x06
     be2:	2d 83       	std	Y+5, r18	; 0x05
  //If there is not enough vertical space -> cut image
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
    pages = LCD_RAM_PAGES - lcd_get_position_page();
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
	for (j=0; j<pages; j++) {
     be4:	53 c0       	rjmp	.+166    	; 0xc8c <lcd_draw_image_xy_P+0x14c>
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
     be6:	09 81       	ldd	r16, Y+1	; 0x01
     be8:	1a 81       	ldd	r17, Y+2	; 0x02
     bea:	61 01       	movw	r12, r2
     bec:	18 86       	std	Y+8, r1	; 0x08
     bee:	1f 82       	std	Y+7, r1	; 0x07
      data = 0;
      if (!offset || j+1 != pages)
     bf0:	25 01       	movw	r4, r10
     bf2:	08 94       	sec
     bf4:	41 1c       	adc	r4, r1
     bf6:	51 1c       	adc	r5, r1
     bf8:	ff 20       	and	r15, r15
     bfa:	19 f0       	breq	.+6      	; 0xc02 <lcd_draw_image_xy_P+0xc2>
     bfc:	64 14       	cp	r6, r4
     bfe:	75 04       	cpc	r7, r5
     c00:	41 f0       	breq	.+16     	; 0xc12 <lcd_draw_image_xy_P+0xd2>
        data = pgm_read_byte(&progmem_image[j*columns + i]) << offset;
     c02:	f8 01       	movw	r30, r16
     c04:	84 91       	lpm	r24, Z+
     c06:	0f 2c       	mov	r0, r15
     c08:	01 c0       	rjmp	.+2      	; 0xc0c <lcd_draw_image_xy_P+0xcc>
     c0a:	88 0f       	add	r24, r24
     c0c:	0a 94       	dec	r0
     c0e:	ea f7       	brpl	.-6      	; 0xc0a <lcd_draw_image_xy_P+0xca>
     c10:	01 c0       	rjmp	.+2      	; 0xc14 <lcd_draw_image_xy_P+0xd4>
    pages = LCD_RAM_PAGES - lcd_get_position_page();
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
	for (j=0; j<pages; j++) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
      data = 0;
     c12:	80 e0       	ldi	r24, 0x00	; 0
      if (!offset || j+1 != pages)
        data = pgm_read_byte(&progmem_image[j*columns + i]) << offset;
			if(j > 0 && offset)
     c14:	a1 14       	cp	r10, r1
     c16:	b1 04       	cpc	r11, r1
     c18:	61 f0       	breq	.+24     	; 0xc32 <lcd_draw_image_xy_P+0xf2>
     c1a:	ff 20       	and	r15, r15
     c1c:	51 f0       	breq	.+20     	; 0xc32 <lcd_draw_image_xy_P+0xf2>
				data |= pgm_read_byte(&progmem_image[(j-1)*columns + i]) >> (8-offset);
     c1e:	f6 01       	movw	r30, r12
     c20:	24 91       	lpm	r18, Z+
     c22:	30 e0       	ldi	r19, 0x00	; 0
     c24:	0b 80       	ldd	r0, Y+3	; 0x03
     c26:	02 c0       	rjmp	.+4      	; 0xc2c <lcd_draw_image_xy_P+0xec>
     c28:	35 95       	asr	r19
     c2a:	27 95       	ror	r18
     c2c:	0a 94       	dec	r0
     c2e:	e2 f7       	brpl	.-8      	; 0xc28 <lcd_draw_image_xy_P+0xe8>
     c30:	82 2b       	or	r24, r18
			if(inv)	lcd_data(~data);
     c32:	ee 20       	and	r14, r14
     c34:	21 f0       	breq	.+8      	; 0xc3e <lcd_draw_image_xy_P+0xfe>
     c36:	80 95       	com	r24
     c38:	0e 94 ff 04 	call	0x9fe	; 0x9fe <lcd_data>
     c3c:	02 c0       	rjmp	.+4      	; 0xc42 <lcd_draw_image_xy_P+0x102>
      else 		lcd_data(data);
     c3e:	0e 94 ff 04 	call	0x9fe	; 0x9fe <lcd_data>
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
    pages = LCD_RAM_PAGES - lcd_get_position_page();
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
	for (j=0; j<pages; j++) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
     c42:	2f 81       	ldd	r18, Y+7	; 0x07
     c44:	38 85       	ldd	r19, Y+8	; 0x08
     c46:	2f 5f       	subi	r18, 0xFF	; 255
     c48:	3f 4f       	sbci	r19, 0xFF	; 255
     c4a:	38 87       	std	Y+8, r19	; 0x08
     c4c:	2f 83       	std	Y+7, r18	; 0x07
     c4e:	28 15       	cp	r18, r8
     c50:	39 05       	cpc	r19, r9
     c52:	48 f4       	brcc	.+18     	; 0xc66 <lcd_draw_image_xy_P+0x126>
     c54:	08 94       	sec
     c56:	c1 1c       	adc	r12, r1
     c58:	d1 1c       	adc	r13, r1
     c5a:	0f 5f       	subi	r16, 0xFF	; 255
     c5c:	1f 4f       	sbci	r17, 0xFF	; 255
     c5e:	80 91 6f 00 	lds	r24, 0x006F
     c62:	84 38       	cpi	r24, 0x84	; 132
     c64:	48 f2       	brcs	.-110    	; 0xbf8 <lcd_draw_image_xy_P+0xb8>
			if(j > 0 && offset)
				data |= pgm_read_byte(&progmem_image[(j-1)*columns + i]) >> (8-offset);
			if(inv)	lcd_data(~data);
      else 		lcd_data(data);
		  }
		if(j+1 != pages)
     c66:	08 94       	sec
     c68:	a1 1c       	adc	r10, r1
     c6a:	b1 1c       	adc	r11, r1
     c6c:	6a 14       	cp	r6, r10
     c6e:	7b 04       	cpc	r7, r11
     c70:	29 f0       	breq	.+10     	; 0xc7c <lcd_draw_image_xy_P+0x13c>
			lcd_move_xy(1,-columns);
     c72:	81 e0       	ldi	r24, 0x01	; 1
     c74:	6d 81       	ldd	r22, Y+5	; 0x05
     c76:	7e 81       	ldd	r23, Y+6	; 0x06
     c78:	0e 94 2a 05 	call	0xa54	; 0xa54 <lcd_move_xy>
     c7c:	28 0c       	add	r2, r8
     c7e:	39 1c       	adc	r3, r9
     c80:	89 81       	ldd	r24, Y+1	; 0x01
     c82:	9a 81       	ldd	r25, Y+2	; 0x02
     c84:	88 0d       	add	r24, r8
     c86:	99 1d       	adc	r25, r9
     c88:	9a 83       	std	Y+2, r25	; 0x02
     c8a:	89 83       	std	Y+1, r24	; 0x01
  //If there is not enough vertical space -> cut image
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
    pages = LCD_RAM_PAGES - lcd_get_position_page();
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
	for (j=0; j<pages; j++) {
     c8c:	a6 14       	cp	r10, r6
     c8e:	b7 04       	cpc	r11, r7
     c90:	48 f4       	brcc	.+18     	; 0xca4 <lcd_draw_image_xy_P+0x164>
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
     c92:	81 14       	cp	r8, r1
     c94:	91 04       	cpc	r9, r1
     c96:	39 f3       	breq	.-50     	; 0xc66 <lcd_draw_image_xy_P+0x126>
     c98:	80 91 6f 00 	lds	r24, 0x006F
     c9c:	84 38       	cpi	r24, 0x84	; 132
     c9e:	08 f4       	brcc	.+2      	; 0xca2 <lcd_draw_image_xy_P+0x162>
     ca0:	a2 cf       	rjmp	.-188    	; 0xbe6 <lcd_draw_image_xy_P+0xa6>
     ca2:	e1 cf       	rjmp	.-62     	; 0xc66 <lcd_draw_image_xy_P+0x126>
      else 		lcd_data(data);
		  }
		if(j+1 != pages)
			lcd_move_xy(1,-columns);
	  }
  }
     ca4:	28 96       	adiw	r28, 0x08	; 8
     ca6:	0f b6       	in	r0, 0x3f	; 63
     ca8:	f8 94       	cli
     caa:	de bf       	out	0x3e, r29	; 62
     cac:	0f be       	out	0x3f, r0	; 63
     cae:	cd bf       	out	0x3d, r28	; 61
     cb0:	cf 91       	pop	r28
     cb2:	df 91       	pop	r29
     cb4:	1f 91       	pop	r17
     cb6:	0f 91       	pop	r16
     cb8:	ff 90       	pop	r15
     cba:	ef 90       	pop	r14
     cbc:	df 90       	pop	r13
     cbe:	cf 90       	pop	r12
     cc0:	bf 90       	pop	r11
     cc2:	af 90       	pop	r10
     cc4:	9f 90       	pop	r9
     cc6:	8f 90       	pop	r8
     cc8:	7f 90       	pop	r7
     cca:	6f 90       	pop	r6
     ccc:	5f 90       	pop	r5
     cce:	4f 90       	pop	r4
     cd0:	3f 90       	pop	r3
     cd2:	2f 90       	pop	r2
     cd4:	08 95       	ret

00000cd6 <lcd_clear_area>:
 * pages         - height of area in pages
 * columns       - width of area in pixels
 * style         - Bit2: sets inverse mode
 * Cursor is moved to start of area after clear
 */
void lcd_clear_area(uint8_t pages, uint8_t columns, uint8_t style) {
     cd6:	cf 92       	push	r12
     cd8:	df 92       	push	r13
     cda:	ef 92       	push	r14
     cdc:	ff 92       	push	r15
     cde:	0f 93       	push	r16
     ce0:	1f 93       	push	r17
     ce2:	cf 93       	push	r28
     ce4:	df 93       	push	r29
  uint8_t i,j,max;
  uint8_t inv = (style & INVERT_BIT)?0xFF:0;
     ce6:	42 ff       	sbrs	r20, 2
     ce8:	03 c0       	rjmp	.+6      	; 0xcf0 <lcd_clear_area+0x1a>
     cea:	ff 24       	eor	r15, r15
     cec:	fa 94       	dec	r15
     cee:	01 c0       	rjmp	.+2      	; 0xcf2 <lcd_clear_area+0x1c>
     cf0:	ff 24       	eor	r15, r15
  
  if(pages > (max = LCD_RAM_PAGES - lcd_get_position_page()))   
     cf2:	20 91 6e 00 	lds	r18, 0x006E
     cf6:	94 e0       	ldi	r25, 0x04	; 4
     cf8:	92 1b       	sub	r25, r18
 * style         - Bit2: sets inverse mode
 * Cursor is moved to start of area after clear
 */
void lcd_clear_area(uint8_t pages, uint8_t columns, uint8_t style) {
  uint8_t i,j,max;
  uint8_t inv = (style & INVERT_BIT)?0xFF:0;
     cfa:	d8 2e       	mov	r13, r24
     cfc:	98 17       	cp	r25, r24
     cfe:	08 f4       	brcc	.+2      	; 0xd02 <lcd_clear_area+0x2c>
     d00:	d9 2e       	mov	r13, r25
  
  if(pages > (max = LCD_RAM_PAGES - lcd_get_position_page()))   
    pages = max;
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
     d02:	90 91 6f 00 	lds	r25, 0x006F
     d06:	84 e8       	ldi	r24, 0x84	; 132
     d08:	89 1b       	sub	r24, r25
 * style         - Bit2: sets inverse mode
 * Cursor is moved to start of area after clear
 */
void lcd_clear_area(uint8_t pages, uint8_t columns, uint8_t style) {
  uint8_t i,j,max;
  uint8_t inv = (style & INVERT_BIT)?0xFF:0;
     d0a:	06 2f       	mov	r16, r22
     d0c:	86 17       	cp	r24, r22
     d0e:	08 f4       	brcc	.+2      	; 0xd12 <lcd_clear_area+0x3c>
     d10:	08 2f       	mov	r16, r24
  if(pages > (max = LCD_RAM_PAGES - lcd_get_position_page()))   
    pages = max;
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
    columns = max;
  
  for(j=0; j<pages; j++) {
     d12:	dd 20       	and	r13, r13
     d14:	81 f4       	brne	.+32     	; 0xd36 <lcd_clear_area+0x60>
     d16:	19 c0       	rjmp	.+50     	; 0xd4a <lcd_clear_area+0x74>
    for(i=0; i<columns; i++) {
     d18:	1c 2d       	mov	r17, r12
      lcd_data(inv);
     d1a:	8f 2d       	mov	r24, r15
     d1c:	0e 94 ff 04 	call	0x9fe	; 0x9fe <lcd_data>
    pages = max;
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
    columns = max;
  
  for(j=0; j<pages; j++) {
    for(i=0; i<columns; i++) {
     d20:	1f 5f       	subi	r17, 0xFF	; 255
     d22:	10 17       	cp	r17, r16
     d24:	d0 f3       	brcs	.-12     	; 0xd1a <lcd_clear_area+0x44>
      lcd_data(inv);
      }
    lcd_move_xy(1,-columns);
     d26:	81 e0       	ldi	r24, 0x01	; 1
     d28:	be 01       	movw	r22, r28
     d2a:	0e 94 2a 05 	call	0xa54	; 0xa54 <lcd_move_xy>
  if(pages > (max = LCD_RAM_PAGES - lcd_get_position_page()))   
    pages = max;
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
    columns = max;
  
  for(j=0; j<pages; j++) {
     d2e:	e3 94       	inc	r14
     d30:	ed 14       	cp	r14, r13
     d32:	40 f0       	brcs	.+16     	; 0xd44 <lcd_clear_area+0x6e>
     d34:	0a c0       	rjmp	.+20     	; 0xd4a <lcd_clear_area+0x74>
     d36:	ee 24       	eor	r14, r14
    for(i=0; i<columns; i++) {
     d38:	cc 24       	eor	r12, r12
      lcd_data(inv);
      }
    lcd_move_xy(1,-columns);
     d3a:	c0 2f       	mov	r28, r16
     d3c:	d0 e0       	ldi	r29, 0x00	; 0
     d3e:	d0 95       	com	r29
     d40:	c1 95       	neg	r28
     d42:	df 4f       	sbci	r29, 0xFF	; 255
    pages = max;
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
    columns = max;
  
  for(j=0; j<pages; j++) {
    for(i=0; i<columns; i++) {
     d44:	00 23       	and	r16, r16
     d46:	41 f7       	brne	.-48     	; 0xd18 <lcd_clear_area+0x42>
     d48:	ee cf       	rjmp	.-36     	; 0xd26 <lcd_clear_area+0x50>
      lcd_data(inv);
      }
    lcd_move_xy(1,-columns);
    }
  lcd_move_xy(-pages,0);
     d4a:	8d 2d       	mov	r24, r13
     d4c:	81 95       	neg	r24
     d4e:	60 e0       	ldi	r22, 0x00	; 0
     d50:	70 e0       	ldi	r23, 0x00	; 0
     d52:	0e 94 2a 05 	call	0xa54	; 0xa54 <lcd_move_xy>
  }
     d56:	df 91       	pop	r29
     d58:	cf 91       	pop	r28
     d5a:	1f 91       	pop	r17
     d5c:	0f 91       	pop	r16
     d5e:	ff 90       	pop	r15
     d60:	ef 90       	pop	r14
     d62:	df 90       	pop	r13
     d64:	cf 90       	pop	r12
     d66:	08 95       	ret

00000d68 <lcd_clear_area_xy>:
 * style         - style modifier
 * col           - column of upper left corner
 * page          - page of upper left corner
 * Cursor is moved to start of area after clear
 */
void lcd_clear_area_xy(uint8_t pages, uint8_t columns, uint8_t style, uint8_t col, uint8_t page) {
     d68:	ef 92       	push	r14
     d6a:	ff 92       	push	r15
     d6c:	0f 93       	push	r16
     d6e:	1f 93       	push	r17
     d70:	f8 2e       	mov	r15, r24
     d72:	16 2f       	mov	r17, r22
     d74:	e4 2e       	mov	r14, r20
     d76:	82 2f       	mov	r24, r18
     d78:	60 2f       	mov	r22, r16
  lcd_moveto_xy(col,page);
     d7a:	0e 94 11 05 	call	0xa22	; 0xa22 <lcd_moveto_xy>
  lcd_clear_area(pages,columns,style);
     d7e:	8f 2d       	mov	r24, r15
     d80:	61 2f       	mov	r22, r17
     d82:	4e 2d       	mov	r20, r14
     d84:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <lcd_clear_area>
  }
     d88:	1f 91       	pop	r17
     d8a:	0f 91       	pop	r16
     d8c:	ff 90       	pop	r15
     d8e:	ef 90       	pop	r14
     d90:	08 95       	ret

00000d92 <init_spi_lcd>:
  */
void init_spi_lcd() {
   
   
   //set MOSI and SCK as output pins
   DDRB |= (1<<PINB5)|(1<<PINB7);
     d92:	87 b3       	in	r24, 0x17	; 23
     d94:	80 6a       	ori	r24, 0xA0	; 160
     d96:	87 bb       	out	0x17, r24	; 23
   
   //set A0, LCD_Reset as outputs
   DDRA |= (1<<PINA5) | (1<<PINA4);
     d98:	8a b3       	in	r24, 0x1a	; 26
     d9a:	80 63       	ori	r24, 0x30	; 48
     d9c:	8a bb       	out	0x1a, r24	; 26
   
   //set SS` as an output pin
   DDRB |= (1<<PINB4);
     d9e:	bc 9a       	sbi	0x17, 4	; 23
		CPOL:   Clock Polarity -> leading edge  = falling edge
							   -> trailing edge = rising edge
		CPHA:	Clock Phase -> Leading edge  = setup
							   Trailing edge = sample
   */
   SPCR = (0<<SPIE) | (1<<SPE) | (0<<DORD) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (0<<SPR1) | (0<<SPR0);
     da0:	8c e5       	ldi	r24, 0x5C	; 92
     da2:	8d b9       	out	0x0d, r24	; 13
         
   
   
   //SPI status register
   //SPI2X: Double SPI Speed Bit -> minimum SCK period will be two CPU clock periods
   SPSR = (1<<SPI2X);
     da4:	81 e0       	ldi	r24, 0x01	; 1
     da6:	8e b9       	out	0x0e, r24	; 14

   SPDR = LCD_NOP; //Do not use 0 here, only LCD_NOP is allowed!
     da8:	83 ee       	ldi	r24, 0xE3	; 227
     daa:	8f b9       	out	0x0f, r24	; 15
   

   
   }
     dac:	08 95       	ret

00000dae <lcd_init>:
/******************************************************************************
  * Initializes the display in 6 o'clock mode, 4x booster for 2.4-3.3V supply voltage
  * scheme according to datasheet
  * Suitable for all DOGS, DOGM and DOGL displays.
  */
void lcd_init() {
     dae:	ff 92       	push	r15
     db0:	0f 93       	push	r16
     db2:	1f 93       	push	r17
  //for better understanding -> write macros in clear text


  //set outputs
  //LCD_SET_PIN_DIRECTIONS();
  DDR_A0 |= (1<<PIN_A0);
     db4:	d5 9a       	sbi	0x1a, 5	; 26
  DDR_RST |= (1<<PIN_RST);
     db6:	d4 9a       	sbi	0x1a, 4	; 26
  DDR_CS  |= (1<<PIN_CS);
     db8:	bc 9a       	sbi	0x17, 4	; 23
  
  
  //Initialize SPI Interface
  //LCD_INIT_SPI();   
  init_spi_lcd();
     dba:	0e 94 c9 06 	call	0xd92	; 0xd92 <init_spi_lcd>
    
  
  //Apply Reset to the Display Controller
  //LCD_RESET();
  PORT_RST &= ~(1<<PIN_RST);
     dbe:	dc 98       	cbi	0x1b, 4	; 27
     dc0:	8f ec       	ldi	r24, 0xCF	; 207
     dc2:	97 e0       	ldi	r25, 0x07	; 7
     dc4:	01 97       	sbiw	r24, 0x01	; 1
     dc6:	f1 f7       	brne	.-4      	; 0xdc4 <lcd_init+0x16>
     dc8:	00 c0       	rjmp	.+0      	; 0xdca <lcd_init+0x1c>
     dca:	00 00       	nop
  _delay_ms(1);
  PORT_RST |= (1<<PIN_RST);
     dcc:	dc 9a       	sbi	0x1b, 4	; 27
  
    
  //Load settings
  
  //(2)
  LCD_SET_FIRST_LINE(0);              //first bit in RAM is on the first line of the LCD
     dce:	80 e4       	ldi	r24, 0x40	; 64
     dd0:	0e 94 0a 05 	call	0xa14	; 0xa14 <lcd_command>
     dd4:	8f ec       	ldi	r24, 0xCF	; 207
     dd6:	97 e0       	ldi	r25, 0x07	; 7
     dd8:	01 97       	sbiw	r24, 0x01	; 1
     dda:	f1 f7       	brne	.-4      	; 0xdd8 <lcd_init+0x2a>
     ddc:	00 c0       	rjmp	.+0      	; 0xdde <lcd_init+0x30>
     dde:	00 00       	nop
  //without this delay the content is displayed mirror inverted
  _delay_ms(1); 


  //(8)     
  LCD_SET_BOTTOM_VIEW();              //6 o'clock mode, normal orientation
     de0:	81 ea       	ldi	r24, 0xA1	; 161
     de2:	0e 94 0a 05 	call	0xa14	; 0xa14 <lcd_command>
  // |
  //  --> lcd_command(LCD_BOTTOMVIEW)
  //					-> LCD_BOTTOMVIEW = ADC reverse
  //_delay_ms(1);
  //(15)
  LCD_ORIENTATION_NORMAL();
     de6:	80 ec       	ldi	r24, 0xC0	; 192
     de8:	0e 94 0a 05 	call	0xa14	; 0xa14 <lcd_command>
     dec:	8f ec       	ldi	r24, 0xCF	; 207
     dee:	97 e0       	ldi	r25, 0x07	; 7
     df0:	01 97       	sbiw	r24, 0x01	; 1
     df2:	f1 f7       	brne	.-4      	; 0xdf0 <lcd_init+0x42>
     df4:	00 c0       	rjmp	.+0      	; 0xdf6 <lcd_init+0x48>
     df6:	00 00       	nop
  // |
  //   --> lcd_command(LCD_SHOW_NORMAL)
  //					-> LCD_SHOW_NORMAL = display all points, normal display (10)
    
  //(9)	
  LCD_SET_MODE_POSITIVE();            //positive display
     df8:	86 ea       	ldi	r24, 0xA6	; 166
     dfa:	0e 94 0a 05 	call	0xa14	; 0xa14 <lcd_command>
  //  --> lcd_command(LCD_DISPLAY_POSITIVE)
  //      				-> LCD_DISPLAY_POSITIVE = sets display normal (9)
   
  #if DISPLAY_TYPE == 132
    //(11)
    LCD_SET_BIAS_RATIO_1_9();           //bias 1/9
     dfe:	82 ea       	ldi	r24, 0xA2	; 162
     e00:	0e 94 0a 05 	call	0xa14	; 0xa14 <lcd_command>
    // |
	//  --> lcd_command(LCD_BIAS_1_9)
	
    //(16)	
	LCD_SET_POWER_CONTROL(7);           //power control mode: all features on
     e04:	8f e2       	ldi	r24, 0x2F	; 47
     e06:	0e 94 0a 05 	call	0xa14	; 0xa14 <lcd_command>
	//  --> lcd_command(LCD_POWER_CONTROL | ((i) & 0x07))  
	//						-> command 16 with operating mode = 0b111
	
	
	//(20) -> selbst eingefügtes macro
	LCD_SET_BOOSTER_RATIO();
     e0a:	80 e0       	ldi	r24, 0x00	; 0
     e0c:	0e 94 0a 05 	call	0xa14	; 0xa14 <lcd_command>
	
	
	//(17)
	LCD_SET_BIAS_VOLTAGE(3);            //set voltage regulator R/R
     e10:	83 e2       	ldi	r24, 0x23	; 35
     e12:	0e 94 0a 05 	call	0xa14	; 0xa14 <lcd_command>
	// |
	//   --> lcd_command(LCD_VOLTAGE | ((i) & 0x07))
	// 						-> command 17 with resistor ration 0b011
    
	//(18)
	LCD_SET_VOLUME_MODE(0x1F);          //volume mode set
     e16:	81 e8       	ldi	r24, 0x81	; 129
     e18:	0e 94 0a 05 	call	0xa14	; 0xa14 <lcd_command>
     e1c:	8f e1       	ldi	r24, 0x1F	; 31
     e1e:	0e 94 0a 05 	call	0xa14	; 0xa14 <lcd_command>
	//						-> standard command 18
	//  --> lcd_command(LCD_VOLUME_MODE_2 | ((i) & 0x3F))
	//						-> command 18 with electronic volume value 0b011111
	
	//(19)
	LCD_SET_INDICATOR_OFF();            //switch indicator off, no blinking
     e22:	8c ea       	ldi	r24, 0xAC	; 172
     e24:	0e 94 0a 05 	call	0xa14	; 0xa14 <lcd_command>
     e28:	80 e0       	ldi	r24, 0x00	; 0
     e2a:	0e 94 0a 05 	call	0xa14	; 0xa14 <lcd_command>
  #endif
  
  
  uint8_t i,j;                        //clear display content
 
 for(j=0;j<LCD_RAM_PAGES;j++) {
     e2e:	00 e0       	ldi	r16, 0x00	; 0
    lcd_moveto_xy(j,0);   // array (uint8_t page, uint8_t column)
     e30:	0f 2e       	mov	r0, r31
     e32:	f4 e8       	ldi	r31, 0x84	; 132
     e34:	ff 2e       	mov	r15, r31
     e36:	f0 2d       	mov	r31, r0
     e38:	80 2f       	mov	r24, r16
     e3a:	60 e0       	ldi	r22, 0x00	; 0
     e3c:	0e 94 11 05 	call	0xa22	; 0xa22 <lcd_moveto_xy>
     e40:	1f 2d       	mov	r17, r15
    for (i=0;i<LCD_WIDTH;i++)
      lcd_data(0);
     e42:	80 e0       	ldi	r24, 0x00	; 0
     e44:	0e 94 ff 04 	call	0x9fe	; 0x9fe <lcd_data>
     e48:	11 50       	subi	r17, 0x01	; 1
  
  uint8_t i,j;                        //clear display content
 
 for(j=0;j<LCD_RAM_PAGES;j++) {
    lcd_moveto_xy(j,0);   // array (uint8_t page, uint8_t column)
    for (i=0;i<LCD_WIDTH;i++)
     e4a:	d9 f7       	brne	.-10     	; 0xe42 <lcd_init+0x94>
  #endif
  
  
  uint8_t i,j;                        //clear display content
 
 for(j=0;j<LCD_RAM_PAGES;j++) {
     e4c:	0f 5f       	subi	r16, 0xFF	; 255
     e4e:	04 30       	cpi	r16, 0x04	; 4
     e50:	99 f7       	brne	.-26     	; 0xe38 <lcd_init+0x8a>
    lcd_moveto_xy(j,0);   // array (uint8_t page, uint8_t column)
    for (i=0;i<LCD_WIDTH;i++)
      lcd_data(0);
    }

  lcd_moveto_xy(0,0);                 //Set write pointer
     e52:	80 e0       	ldi	r24, 0x00	; 0
     e54:	60 e0       	ldi	r22, 0x00	; 0
     e56:	0e 94 11 05 	call	0xa22	; 0xa22 <lcd_moveto_xy>
  LCD_SWITCH_ON();                    //Switch display on (1)
     e5a:	8f ea       	ldi	r24, 0xAF	; 175
     e5c:	0e 94 0a 05 	call	0xa14	; 0xa14 <lcd_command>
  return;
  }
     e60:	1f 91       	pop	r17
     e62:	0f 91       	pop	r16
     e64:	ff 90       	pop	r15
     e66:	08 95       	ret

00000e68 <lcd_set_font>:
 * Stores the default font type and style in a global variable
 * font          - Font identifier
 * style         - Style Modifier
 */
inline void lcd_set_font(FONT_P font, uint8_t style){
  global_font_select = font;
     e68:	90 93 8e 00 	sts	0x008E, r25
     e6c:	80 93 8d 00 	sts	0x008D, r24
  global_font_style = style;
     e70:	60 93 8c 00 	sts	0x008C, r22
}
     e74:	08 95       	ret

00000e76 <font_data>:
 * Loads the pointer to the selected fonts data
 */
inline PGM_P font_data(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->data));
     e76:	fc 01       	movw	r30, r24
     e78:	38 96       	adiw	r30, 0x08	; 8
     e7a:	25 91       	lpm	r18, Z+
     e7c:	34 91       	lpm	r19, Z+
  else
    memcpy_P((char*)&tmp,&(font->data),sizeof(tmp));
  return tmp;
  }
     e7e:	82 2f       	mov	r24, r18
     e80:	93 2f       	mov	r25, r19
     e82:	08 95       	ret

00000e84 <font_widthtable>:
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     e84:	fc 01       	movw	r30, r24
     e86:	36 96       	adiw	r30, 0x06	; 6
     e88:	25 91       	lpm	r18, Z+
     e8a:	34 91       	lpm	r19, Z+
  else
    memcpy_P((char*)&tmp,&(font->widthtable),sizeof(tmp));
  return tmp;
  }
     e8c:	82 2f       	mov	r24, r18
     e8e:	93 2f       	mov	r25, r19
     e90:	08 95       	ret

00000e92 <font_get_height_bytes>:
/******************************************************************************
 * Loads the height (in bytes) of the given font
 */
inline uint8_t font_get_height_bytes(FONT_P font) {
  FONT_P tmp = font;
  uint8_t t = pgm_read_byte(&tmp->height);
     e92:	fc 01       	movw	r30, r24
     e94:	33 96       	adiw	r30, 0x03	; 3
     e96:	84 91       	lpm	r24, Z+
  return (((uint8_t)(t-1)>>3)+1);
     e98:	81 50       	subi	r24, 0x01	; 1
     e9a:	86 95       	lsr	r24
     e9c:	86 95       	lsr	r24
     e9e:	86 95       	lsr	r24
  }
     ea0:	8f 5f       	subi	r24, 0xFF	; 255
     ea2:	08 95       	ret

00000ea4 <font_get_add_space>:
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     ea4:	fc 01       	movw	r30, r24
     ea6:	36 96       	adiw	r30, 0x06	; 6
     ea8:	25 91       	lpm	r18, Z+
     eaa:	34 91       	lpm	r19, Z+
 * Decides if an additional space to the right of the character is needed
 */
inline uint8_t font_get_add_space(FONT_P font, char character) {
  PGM_P type = font_widthtable(font);
  if ( type != 0 ) //if there is a width table, then it's a proportional font
    return 1;
     eac:	81 e0       	ldi	r24, 0x01	; 1
     eae:	21 15       	cp	r18, r1
     eb0:	31 05       	cpc	r19, r1
     eb2:	09 f4       	brne	.+2      	; 0xeb6 <font_get_add_space+0x12>
     eb4:	80 e0       	ldi	r24, 0x00	; 0
  else
    return 0;
  }
     eb6:	08 95       	ret

00000eb8 <font_get_char_number>:
/******************************************************************************
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
     eb8:	fc 01       	movw	r30, r24
     eba:	35 96       	adiw	r30, 0x05	; 5
     ebc:	e4 91       	lpm	r30, Z+
     ebe:	e6 17       	cp	r30, r22
     ec0:	50 f0       	brcs	.+20     	; 0xed6 <font_get_char_number+0x1e>
    return -1;
  uint8_t first = pgm_read_byte(&tmp->firstchar);
     ec2:	04 96       	adiw	r24, 0x04	; 4
     ec4:	fc 01       	movw	r30, r24
     ec6:	84 91       	lpm	r24, Z+
  if (character < first) 
     ec8:	68 17       	cp	r22, r24
     eca:	40 f0       	brcs	.+16     	; 0xedc <font_get_char_number+0x24>
    return -1;
  return character - first;
     ecc:	26 2f       	mov	r18, r22
     ece:	30 e0       	ldi	r19, 0x00	; 0
     ed0:	28 1b       	sub	r18, r24
     ed2:	31 09       	sbc	r19, r1
     ed4:	05 c0       	rjmp	.+10     	; 0xee0 <font_get_char_number+0x28>
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
    return -1;
     ed6:	2f ef       	ldi	r18, 0xFF	; 255
     ed8:	3f ef       	ldi	r19, 0xFF	; 255
     eda:	02 c0       	rjmp	.+4      	; 0xee0 <font_get_char_number+0x28>
  uint8_t first = pgm_read_byte(&tmp->firstchar);
  if (character < first) 
    return -1;
     edc:	2f ef       	ldi	r18, 0xFF	; 255
     ede:	3f ef       	ldi	r19, 0xFF	; 255
  return character - first;
  }
     ee0:	82 2f       	mov	r24, r18
     ee2:	93 2f       	mov	r25, r19
     ee4:	08 95       	ret

00000ee6 <font_get_char_width>:
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     ee6:	fc 01       	movw	r30, r24
     ee8:	36 96       	adiw	r30, 0x06	; 6
     eea:	25 91       	lpm	r18, Z+
     eec:	34 91       	lpm	r19, Z+
/******************************************************************************
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
  PGM_P table = font_widthtable(font);
  if (table)
     eee:	21 15       	cp	r18, r1
     ef0:	31 05       	cpc	r19, r1
     ef2:	c9 f0       	breq	.+50     	; 0xf26 <font_get_char_width+0x40>
/******************************************************************************
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
     ef4:	fc 01       	movw	r30, r24
     ef6:	35 96       	adiw	r30, 0x05	; 5
     ef8:	e4 91       	lpm	r30, Z+
     efa:	e6 17       	cp	r30, r22
     efc:	50 f0       	brcs	.+20     	; 0xf12 <font_get_char_width+0x2c>
    return -1;
  uint8_t first = pgm_read_byte(&tmp->firstchar);
     efe:	fc 01       	movw	r30, r24
     f00:	34 96       	adiw	r30, 0x04	; 4
     f02:	e4 91       	lpm	r30, Z+
  if (character < first) 
     f04:	6e 17       	cp	r22, r30
     f06:	40 f0       	brcs	.+16     	; 0xf18 <font_get_char_width+0x32>
    return -1;
  return character - first;
     f08:	86 2f       	mov	r24, r22
     f0a:	90 e0       	ldi	r25, 0x00	; 0
     f0c:	8e 1b       	sub	r24, r30
     f0e:	91 09       	sbc	r25, r1
     f10:	05 c0       	rjmp	.+10     	; 0xf1c <font_get_char_width+0x36>
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
    return -1;
     f12:	8f ef       	ldi	r24, 0xFF	; 255
     f14:	9f ef       	ldi	r25, 0xFF	; 255
     f16:	02 c0       	rjmp	.+4      	; 0xf1c <font_get_char_width+0x36>
  uint8_t first = pgm_read_byte(&tmp->firstchar);
  if (character < first) 
    return -1;
     f18:	8f ef       	ldi	r24, 0xFF	; 255
     f1a:	9f ef       	ldi	r25, 0xFF	; 255
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
  PGM_P table = font_widthtable(font);
  if (table)
    return pgm_read_byte(table+font_get_char_number(font,character));
     f1c:	28 0f       	add	r18, r24
     f1e:	39 1f       	adc	r19, r25
     f20:	f9 01       	movw	r30, r18
     f22:	84 91       	lpm	r24, Z+
     f24:	08 95       	ret
  else
    return pgm_read_byte(&font->width);
     f26:	02 96       	adiw	r24, 0x02	; 2
     f28:	fc 01       	movw	r30, r24
     f2a:	84 91       	lpm	r24, Z+
  }
     f2c:	08 95       	ret

00000f2e <font_get_char_position>:


/******************************************************************************
 * Calculate the pointer to the requested character inside the Flash ROM
 */
PGM_P font_get_char_position(FONT_P font, char character) {
     f2e:	cf 92       	push	r12
     f30:	df 92       	push	r13
     f32:	ef 92       	push	r14
     f34:	ff 92       	push	r15
     f36:	0f 93       	push	r16
     f38:	1f 93       	push	r17
     f3a:	cf 93       	push	r28
     f3c:	df 93       	push	r29
/******************************************************************************
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
     f3e:	ac 01       	movw	r20, r24
     f40:	4b 5f       	subi	r20, 0xFB	; 251
     f42:	5f 4f       	sbci	r21, 0xFF	; 255
     f44:	fa 01       	movw	r30, r20
     f46:	24 91       	lpm	r18, Z+
     f48:	26 17       	cp	r18, r22
     f4a:	08 f4       	brcc	.+2      	; 0xf4e <font_get_char_position+0x20>
     f4c:	94 c0       	rjmp	.+296    	; 0x1076 <font_get_char_position+0x148>
    return -1;
  uint8_t first = pgm_read_byte(&tmp->firstchar);
     f4e:	ec 01       	movw	r28, r24
     f50:	24 96       	adiw	r28, 0x04	; 4
     f52:	fe 01       	movw	r30, r28
     f54:	24 91       	lpm	r18, Z+
  if (character < first) 
     f56:	62 17       	cp	r22, r18
     f58:	08 f4       	brcc	.+2      	; 0xf5c <font_get_char_position+0x2e>
     f5a:	8d c0       	rjmp	.+282    	; 0x1076 <font_get_char_position+0x148>
    return -1;
  return character - first;
     f5c:	e6 2e       	mov	r14, r22
     f5e:	ff 24       	eor	r15, r15
     f60:	f7 01       	movw	r30, r14
     f62:	e2 1b       	sub	r30, r18
     f64:	f1 09       	sbc	r31, r1
     f66:	9f 01       	movw	r18, r30
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     f68:	8c 01       	movw	r16, r24
     f6a:	0a 5f       	subi	r16, 0xFA	; 250
     f6c:	1f 4f       	sbci	r17, 0xFF	; 255
     f6e:	f8 01       	movw	r30, r16
     f70:	a5 91       	lpm	r26, Z+
     f72:	b4 91       	lpm	r27, Z+
  uint16_t ret         = 0;
  int16_t  charnum_ret = font_get_char_number(font, character);
  uint8_t  charnum     = charnum_ret;
  PGM_P    base        = font_widthtable(font);

  if (charnum_ret < 0)     //char not found
     f74:	33 23       	and	r19, r19
     f76:	0c f4       	brge	.+2      	; 0xf7a <font_get_char_position+0x4c>
     f78:	71 c0       	rjmp	.+226    	; 0x105c <font_get_char_position+0x12e>
 * Calculate the pointer to the requested character inside the Flash ROM
 */
PGM_P font_get_char_position(FONT_P font, char character) {
  uint16_t ret         = 0;
  int16_t  charnum_ret = font_get_char_number(font, character);
  uint8_t  charnum     = charnum_ret;
     f7a:	72 2f       	mov	r23, r18
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     f7c:	9d 01       	movw	r18, r26
  uint8_t  charnum     = charnum_ret;
  PGM_P    base        = font_widthtable(font);

  if (charnum_ret < 0)     //char not found
    return 0;
  if(base == 0)            //fixed width
     f7e:	10 97       	sbiw	r26, 0x00	; 0
     f80:	09 f0       	breq	.+2      	; 0xf84 <font_get_char_position+0x56>
     f82:	3e c0       	rjmp	.+124    	; 0x1000 <font_get_char_position+0xd2>
 * Loads the pointer to the selected fonts data
 */
inline PGM_P font_data(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->data));
     f84:	fc 01       	movw	r30, r24
     f86:	38 96       	adiw	r30, 0x08	; 8
     f88:	a5 91       	lpm	r26, Z+
     f8a:	b4 91       	lpm	r27, Z+
     f8c:	ca 2e       	mov	r12, r26
     f8e:	db 2e       	mov	r13, r27
  PGM_P    base        = font_widthtable(font);

  if (charnum_ret < 0)     //char not found
    return 0;
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
     f90:	a7 2f       	mov	r26, r23
     f92:	b0 e0       	ldi	r27, 0x00	; 0
/******************************************************************************
 * Loads the height (in bytes) of the given font
 */
inline uint8_t font_get_height_bytes(FONT_P font) {
  FONT_P tmp = font;
  uint8_t t = pgm_read_byte(&tmp->height);
     f94:	fc 01       	movw	r30, r24
     f96:	33 96       	adiw	r30, 0x03	; 3
     f98:	74 91       	lpm	r23, Z+
  return (((uint8_t)(t-1)>>3)+1);
     f9a:	71 50       	subi	r23, 0x01	; 1
     f9c:	76 95       	lsr	r23
     f9e:	76 95       	lsr	r23
     fa0:	76 95       	lsr	r23
     fa2:	7f 5f       	subi	r23, 0xFF	; 255
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     fa4:	f8 01       	movw	r30, r16
     fa6:	25 91       	lpm	r18, Z+
     fa8:	34 91       	lpm	r19, Z+
/******************************************************************************
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
  PGM_P table = font_widthtable(font);
  if (table)
     faa:	21 15       	cp	r18, r1
     fac:	31 05       	cpc	r19, r1
     fae:	b9 f0       	breq	.+46     	; 0xfde <font_get_char_position+0xb0>
/******************************************************************************
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
     fb0:	fa 01       	movw	r30, r20
     fb2:	44 91       	lpm	r20, Z+
     fb4:	46 17       	cp	r20, r22
     fb6:	48 f0       	brcs	.+18     	; 0xfca <font_get_char_position+0x9c>
    return -1;
  uint8_t first = pgm_read_byte(&tmp->firstchar);
     fb8:	fe 01       	movw	r30, r28
     fba:	84 91       	lpm	r24, Z+
  if (character < first) 
     fbc:	68 17       	cp	r22, r24
     fbe:	40 f0       	brcs	.+16     	; 0xfd0 <font_get_char_position+0xa2>
    return -1;
  return character - first;
     fc0:	a7 01       	movw	r20, r14
     fc2:	48 1b       	sub	r20, r24
     fc4:	51 09       	sbc	r21, r1
     fc6:	ca 01       	movw	r24, r20
     fc8:	05 c0       	rjmp	.+10     	; 0xfd4 <font_get_char_position+0xa6>
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
    return -1;
     fca:	8f ef       	ldi	r24, 0xFF	; 255
     fcc:	9f ef       	ldi	r25, 0xFF	; 255
     fce:	02 c0       	rjmp	.+4      	; 0xfd4 <font_get_char_position+0xa6>
  uint8_t first = pgm_read_byte(&tmp->firstchar);
  if (character < first) 
    return -1;
     fd0:	8f ef       	ldi	r24, 0xFF	; 255
     fd2:	9f ef       	ldi	r25, 0xFF	; 255
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
  PGM_P table = font_widthtable(font);
  if (table)
    return pgm_read_byte(table+font_get_char_number(font,character));
     fd4:	28 0f       	add	r18, r24
     fd6:	39 1f       	adc	r19, r25
     fd8:	f9 01       	movw	r30, r18
     fda:	84 91       	lpm	r24, Z+
     fdc:	03 c0       	rjmp	.+6      	; 0xfe4 <font_get_char_position+0xb6>
  else
    return pgm_read_byte(&font->width);
     fde:	02 96       	adiw	r24, 0x02	; 2
     fe0:	fc 01       	movw	r30, r24
     fe2:	84 91       	lpm	r24, Z+
  PGM_P    base        = font_widthtable(font);

  if (charnum_ret < 0)     //char not found
    return 0;
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
     fe4:	87 9f       	mul	r24, r23
     fe6:	80 2d       	mov	r24, r0
     fe8:	11 24       	eor	r1, r1
     fea:	90 e0       	ldi	r25, 0x00	; 0
     fec:	8a 9f       	mul	r24, r26
     fee:	90 01       	movw	r18, r0
     ff0:	8b 9f       	mul	r24, r27
     ff2:	30 0d       	add	r19, r0
     ff4:	9a 9f       	mul	r25, r26
     ff6:	30 0d       	add	r19, r0
     ff8:	11 24       	eor	r1, r1
     ffa:	2c 0d       	add	r18, r12
     ffc:	3d 1d       	adc	r19, r13
     ffe:	30 c0       	rjmp	.+96     	; 0x1060 <font_get_char_position+0x132>
  if (charnum)             //proportional width
    1000:	77 23       	and	r23, r23
    1002:	99 f0       	breq	.+38     	; 0x102a <font_get_char_position+0xfc>
    while(charnum--)
    1004:	71 50       	subi	r23, 0x01	; 1


/******************************************************************************
 * Calculate the pointer to the requested character inside the Flash ROM
 */
PGM_P font_get_char_position(FONT_P font, char character) {
    1006:	47 2f       	mov	r20, r23
    1008:	50 e0       	ldi	r21, 0x00	; 0
    100a:	4f 5f       	subi	r20, 0xFF	; 255
    100c:	5f 4f       	sbci	r21, 0xFF	; 255
    100e:	a4 0f       	add	r26, r20
    1010:	b5 1f       	adc	r27, r21
    1012:	40 e0       	ldi	r20, 0x00	; 0
    1014:	50 e0       	ldi	r21, 0x00	; 0
    1016:	f9 01       	movw	r30, r18
    return 0;
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
  if (charnum)             //proportional width
    while(charnum--)
      ret += pgm_read_byte(base++);
    1018:	2f 5f       	subi	r18, 0xFF	; 255
    101a:	3f 4f       	sbci	r19, 0xFF	; 255
    101c:	e4 91       	lpm	r30, Z+
    101e:	4e 0f       	add	r20, r30
    1020:	51 1d       	adc	r21, r1
  if (charnum_ret < 0)     //char not found
    return 0;
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
  if (charnum)             //proportional width
    while(charnum--)
    1022:	2a 17       	cp	r18, r26
    1024:	3b 07       	cpc	r19, r27
    1026:	b9 f7       	brne	.-18     	; 0x1016 <font_get_char_position+0xe8>
    1028:	02 c0       	rjmp	.+4      	; 0x102e <font_get_char_position+0x100>

/******************************************************************************
 * Calculate the pointer to the requested character inside the Flash ROM
 */
PGM_P font_get_char_position(FONT_P font, char character) {
  uint16_t ret         = 0;
    102a:	40 e0       	ldi	r20, 0x00	; 0
    102c:	50 e0       	ldi	r21, 0x00	; 0
 * Loads the pointer to the selected fonts data
 */
inline PGM_P font_data(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->data));
    102e:	fc 01       	movw	r30, r24
    1030:	38 96       	adiw	r30, 0x08	; 8
    1032:	25 91       	lpm	r18, Z+
    1034:	34 91       	lpm	r19, Z+
/******************************************************************************
 * Loads the height (in bytes) of the given font
 */
inline uint8_t font_get_height_bytes(FONT_P font) {
  FONT_P tmp = font;
  uint8_t t = pgm_read_byte(&tmp->height);
    1036:	03 96       	adiw	r24, 0x03	; 3
    1038:	fc 01       	movw	r30, r24
    103a:	84 91       	lpm	r24, Z+
  return (((uint8_t)(t-1)>>3)+1);
    103c:	81 50       	subi	r24, 0x01	; 1
    103e:	86 95       	lsr	r24
    1040:	86 95       	lsr	r24
    1042:	86 95       	lsr	r24
    1044:	8f 5f       	subi	r24, 0xFF	; 255
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
  if (charnum)             //proportional width
    while(charnum--)
      ret += pgm_read_byte(base++);
  return (font_data(font))+ret*font_get_height_bytes(font);
    1046:	90 e0       	ldi	r25, 0x00	; 0
    1048:	84 9f       	mul	r24, r20
    104a:	60 01       	movw	r12, r0
    104c:	85 9f       	mul	r24, r21
    104e:	d0 0c       	add	r13, r0
    1050:	94 9f       	mul	r25, r20
    1052:	d0 0c       	add	r13, r0
    1054:	11 24       	eor	r1, r1
    1056:	2c 0d       	add	r18, r12
    1058:	3d 1d       	adc	r19, r13
    105a:	02 c0       	rjmp	.+4      	; 0x1060 <font_get_char_position+0x132>
  int16_t  charnum_ret = font_get_char_number(font, character);
  uint8_t  charnum     = charnum_ret;
  PGM_P    base        = font_widthtable(font);

  if (charnum_ret < 0)     //char not found
    return 0;
    105c:	20 e0       	ldi	r18, 0x00	; 0
    105e:	30 e0       	ldi	r19, 0x00	; 0
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
  if (charnum)             //proportional width
    while(charnum--)
      ret += pgm_read_byte(base++);
  return (font_data(font))+ret*font_get_height_bytes(font);
  }
    1060:	82 2f       	mov	r24, r18
    1062:	93 2f       	mov	r25, r19
    1064:	df 91       	pop	r29
    1066:	cf 91       	pop	r28
    1068:	1f 91       	pop	r17
    106a:	0f 91       	pop	r16
    106c:	ff 90       	pop	r15
    106e:	ef 90       	pop	r14
    1070:	df 90       	pop	r13
    1072:	cf 90       	pop	r12
    1074:	08 95       	ret
  int16_t  charnum_ret = font_get_char_number(font, character);
  uint8_t  charnum     = charnum_ret;
  PGM_P    base        = font_widthtable(font);

  if (charnum_ret < 0)     //char not found
    return 0;
    1076:	20 e0       	ldi	r18, 0x00	; 0
    1078:	30 e0       	ldi	r19, 0x00	; 0
    107a:	f2 cf       	rjmp	.-28     	; 0x1060 <font_get_char_position+0x132>

0000107c <lcd_put_char>:
 *****************************************************************************/

/******************************************************************************
 * Outputs a character on the display, using the given font and style
 */
uint8_t lcd_put_char(FONT_P font, uint8_t style, char character) {
    107c:	2f 92       	push	r2
    107e:	3f 92       	push	r3
    1080:	4f 92       	push	r4
    1082:	5f 92       	push	r5
    1084:	6f 92       	push	r6
    1086:	7f 92       	push	r7
    1088:	8f 92       	push	r8
    108a:	9f 92       	push	r9
    108c:	af 92       	push	r10
    108e:	bf 92       	push	r11
    1090:	cf 92       	push	r12
    1092:	df 92       	push	r13
    1094:	ef 92       	push	r14
    1096:	ff 92       	push	r15
    1098:	0f 93       	push	r16
    109a:	1f 93       	push	r17
    109c:	df 93       	push	r29
    109e:	cf 93       	push	r28
    10a0:	cd b7       	in	r28, 0x3d	; 61
    10a2:	de b7       	in	r29, 0x3e	; 62
    10a4:	2d 97       	sbiw	r28, 0x0d	; 13
    10a6:	0f b6       	in	r0, 0x3f	; 63
    10a8:	f8 94       	cli
    10aa:	de bf       	out	0x3e, r29	; 62
    10ac:	0f be       	out	0x3f, r0	; 63
    10ae:	cd bf       	out	0x3d, r28	; 61
    10b0:	04 2f       	mov	r16, r20
  int8_t  i;
  uint8_t row  = 0;                             //current row of char
  uint8_t hc   = (style & DOUBLE_HEIGHT)?1:0;   //height changed
    10b2:	88 24       	eor	r8, r8
    10b4:	83 94       	inc	r8
    10b6:	86 22       	and	r8, r22
  uint8_t wc   = (style & DOUBLE_WIDTH)?1:0;    //width changed
    10b8:	16 2f       	mov	r17, r22
    10ba:	99 24       	eor	r9, r9
    10bc:	93 94       	inc	r9
    10be:	61 ff       	sbrs	r22, 1
    10c0:	99 24       	eor	r9, r9
  uint8_t ul   = (style & UNDERLINE)?0x80:0x00; //underline
    10c2:	14 ff       	sbrs	r17, 4
    10c4:	05 c0       	rjmp	.+10     	; 0x10d0 <lcd_put_char+0x54>
    10c6:	0f 2e       	mov	r0, r31
    10c8:	f0 e8       	ldi	r31, 0x80	; 128
    10ca:	4f 2e       	mov	r4, r31
    10cc:	f0 2d       	mov	r31, r0
    10ce:	01 c0       	rjmp	.+2      	; 0x10d2 <lcd_put_char+0x56>
    10d0:	44 24       	eor	r4, r4
  uint8_t inv  = (style & INVERT)?0xFF:0;       //inverted
    10d2:	12 ff       	sbrs	r17, 2
    10d4:	03 c0       	rjmp	.+6      	; 0x10dc <lcd_put_char+0x60>
    10d6:	77 24       	eor	r7, r7
    10d8:	7a 94       	dec	r7
    10da:	01 c0       	rjmp	.+2      	; 0x10de <lcd_put_char+0x62>
    10dc:	77 24       	eor	r7, r7
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
    10de:	9c 01       	movw	r18, r24
    10e0:	2a 5f       	subi	r18, 0xFA	; 250
    10e2:	3f 4f       	sbci	r19, 0xFF	; 255
    10e4:	f9 01       	movw	r30, r18
    10e6:	45 91       	lpm	r20, Z+
    10e8:	54 91       	lpm	r21, Z+
/******************************************************************************
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
  PGM_P table = font_widthtable(font);
  if (table)
    10ea:	41 15       	cp	r20, r1
    10ec:	51 05       	cpc	r21, r1
    10ee:	c9 f0       	breq	.+50     	; 0x1122 <lcd_put_char+0xa6>
/******************************************************************************
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
    10f0:	fc 01       	movw	r30, r24
    10f2:	35 96       	adiw	r30, 0x05	; 5
    10f4:	e4 91       	lpm	r30, Z+
    10f6:	e0 17       	cp	r30, r16
    10f8:	50 f0       	brcs	.+20     	; 0x110e <lcd_put_char+0x92>
    return -1;
  uint8_t first = pgm_read_byte(&tmp->firstchar);
    10fa:	fc 01       	movw	r30, r24
    10fc:	34 96       	adiw	r30, 0x04	; 4
    10fe:	e4 91       	lpm	r30, Z+
  if (character < first) 
    1100:	0e 17       	cp	r16, r30
    1102:	40 f0       	brcs	.+16     	; 0x1114 <lcd_put_char+0x98>
    return -1;
  return character - first;
    1104:	60 2f       	mov	r22, r16
    1106:	70 e0       	ldi	r23, 0x00	; 0
    1108:	6e 1b       	sub	r22, r30
    110a:	71 09       	sbc	r23, r1
    110c:	05 c0       	rjmp	.+10     	; 0x1118 <lcd_put_char+0x9c>
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
    return -1;
    110e:	6f ef       	ldi	r22, 0xFF	; 255
    1110:	7f ef       	ldi	r23, 0xFF	; 255
    1112:	02 c0       	rjmp	.+4      	; 0x1118 <lcd_put_char+0x9c>
  uint8_t first = pgm_read_byte(&tmp->firstchar);
  if (character < first) 
    return -1;
    1114:	6f ef       	ldi	r22, 0xFF	; 255
    1116:	7f ef       	ldi	r23, 0xFF	; 255
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
  PGM_P table = font_widthtable(font);
  if (table)
    return pgm_read_byte(table+font_get_char_number(font,character));
    1118:	46 0f       	add	r20, r22
    111a:	57 1f       	adc	r21, r23
    111c:	fa 01       	movw	r30, r20
    111e:	e4 90       	lpm	r14, Z+
    1120:	03 c0       	rjmp	.+6      	; 0x1128 <lcd_put_char+0xac>
  else
    return pgm_read_byte(&font->width);
    1122:	fc 01       	movw	r30, r24
    1124:	32 96       	adiw	r30, 0x02	; 2
    1126:	e4 90       	lpm	r14, Z+
/******************************************************************************
 * Loads the height (in bytes) of the given font
 */
inline uint8_t font_get_height_bytes(FONT_P font) {
  FONT_P tmp = font;
  uint8_t t = pgm_read_byte(&tmp->height);
    1128:	fc 01       	movw	r30, r24
    112a:	33 96       	adiw	r30, 0x03	; 3
    112c:	64 90       	lpm	r6, Z+
  return (((uint8_t)(t-1)>>3)+1);
    112e:	6a 94       	dec	r6
    1130:	66 94       	lsr	r6
    1132:	66 94       	lsr	r6
    1134:	66 94       	lsr	r6
    1136:	63 94       	inc	r6
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
    1138:	f9 01       	movw	r30, r18
    113a:	25 91       	lpm	r18, Z+
    113c:	34 91       	lpm	r19, Z+
 * Decides if an additional space to the right of the character is needed
 */
inline uint8_t font_get_add_space(FONT_P font, char character) {
  PGM_P type = font_widthtable(font);
  if ( type != 0 ) //if there is a width table, then it's a proportional font
    return 1;
    113e:	f1 e0       	ldi	r31, 0x01	; 1
    1140:	fa 83       	std	Y+2, r31	; 0x02
    1142:	21 15       	cp	r18, r1
    1144:	31 05       	cpc	r19, r1
    1146:	09 f4       	brne	.+2      	; 0x114a <lcd_put_char+0xce>
    1148:	1a 82       	std	Y+2, r1	; 0x02

  //load information about character
   uint8_t char_width    = font_get_char_width(font,character); 
   uint8_t font_height   = font_get_height_bytes(font);
   uint8_t free_space    = font_get_add_space(font,character);
   PGM_P   tableposition = font_get_char_position(font,character);
    114a:	60 2f       	mov	r22, r16
    114c:	0e 94 97 07 	call	0xf2e	; 0xf2e <font_get_char_position>
    1150:	5c 01       	movw	r10, r24

  //final size of character
  uint8_t char_final_width  = (uint8_t)(char_width+free_space) << wc;
    1152:	8a 81       	ldd	r24, Y+2	; 0x02
    1154:	8e 0d       	add	r24, r14
    1156:	09 2c       	mov	r0, r9
    1158:	01 c0       	rjmp	.+2      	; 0x115c <lcd_put_char+0xe0>
    115a:	88 0f       	add	r24, r24
    115c:	0a 94       	dec	r0
    115e:	ea f7       	brpl	.-6      	; 0x115a <lcd_put_char+0xde>
    1160:	88 87       	std	Y+8, r24	; 0x08
  uint8_t char_final_height = (uint8_t)font_height << hc; 
    1162:	c6 2c       	mov	r12, r6
    1164:	dd 24       	eor	r13, r13
    1166:	8d 82       	std	Y+5, r8	; 0x05
    1168:	26 2d       	mov	r18, r6
    116a:	08 2c       	mov	r0, r8
    116c:	01 c0       	rjmp	.+2      	; 0x1170 <lcd_put_char+0xf4>
    116e:	22 0f       	add	r18, r18
    1170:	0a 94       	dec	r0
    1172:	ea f7       	brpl	.-6      	; 0x116e <lcd_put_char+0xf2>
    1174:	29 83       	std	Y+1, r18	; 0x01

  //check for avail. space on display
  if ((style & WRAP) && (LCD_CURRENT_COL() + char_final_width > LCD_WIDTH)) {
    1176:	13 ff       	sbrs	r17, 3
    1178:	12 c0       	rjmp	.+36     	; 0x119e <lcd_put_char+0x122>
    117a:	80 91 6f 00 	lds	r24, 0x006F
    117e:	90 e0       	ldi	r25, 0x00	; 0
    1180:	48 85       	ldd	r20, Y+8	; 0x08
    1182:	84 0f       	add	r24, r20
    1184:	91 1d       	adc	r25, r1
    1186:	85 38       	cpi	r24, 0x85	; 133
    1188:	91 05       	cpc	r25, r1
    118a:	4c f0       	brlt	.+18     	; 0x119e <lcd_put_char+0x122>
    LCD_MOVE_TO(LCD_CURRENT_PAGE()+char_final_height,0);
    118c:	80 91 6e 00 	lds	r24, 0x006E
    1190:	82 0f       	add	r24, r18
    1192:	60 e0       	ldi	r22, 0x00	; 0
    1194:	0e 94 11 05 	call	0xa22	; 0xa22 <lcd_moveto_xy>
    if (character == ' ') return 0;
    1198:	00 32       	cpi	r16, 0x20	; 32
    119a:	09 f4       	brne	.+2      	; 0x119e <lcd_put_char+0x122>
    119c:	95 c0       	rjmp	.+298    	; 0x12c8 <lcd_put_char+0x24c>
    }
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
    119e:	8e 2d       	mov	r24, r14
    11a0:	90 e0       	ldi	r25, 0x00	; 0
    11a2:	c8 9e       	mul	r12, r24
    11a4:	70 01       	movw	r14, r0
    11a6:	c9 9e       	mul	r12, r25
    11a8:	f0 0c       	add	r15, r0
    11aa:	d8 9e       	mul	r13, r24
    11ac:	f0 0c       	add	r15, r0
    11ae:	11 24       	eor	r1, r1
        LCD_WRITE(tmp);
      }
    if (free_space) {
      uint8_t c = inv;
      if(row == char_final_height-1) {
        c ^= ul; 
    11b0:	87 2d       	mov	r24, r7
    11b2:	84 25       	eor	r24, r4
        if(hc)
          c ^= ul>>1;      
    11b4:	94 2d       	mov	r25, r4
    11b6:	96 95       	lsr	r25
    11b8:	22 24       	eor	r2, r2
    11ba:	33 24       	eor	r3, r3
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
      tmp = pgm_read_byte(tableposition+i);
      if(row == char_final_height-1) 
    11bc:	e9 81       	ldd	r30, Y+1	; 0x01
    11be:	ce 2e       	mov	r12, r30
    11c0:	dd 24       	eor	r13, r13
    11c2:	08 94       	sec
    11c4:	c1 08       	sbc	r12, r1
    11c6:	d1 08       	sbc	r13, r1
      LCD_WRITE(tmp);
      if(wc) 
        LCD_WRITE(tmp);
      }
    if (free_space) {
      uint8_t c = inv;
    11c8:	79 86       	std	Y+9, r7	; 0x09
      if(row == char_final_height-1) {
        c ^= ul; 
    11ca:	8a 87       	std	Y+10, r24	; 0x0a
        if(hc)
          c ^= ul>>1;      
    11cc:	89 27       	eor	r24, r25
    11ce:	8b 87       	std	Y+11, r24	; 0x0b
        }
      LCD_WRITE(c);
      if(wc) 
        LCD_WRITE(c);
      }
    LCD_MOVE(1,-char_final_width);
    11d0:	98 85       	ldd	r25, Y+8	; 0x08
    11d2:	89 2f       	mov	r24, r25
    11d4:	90 e0       	ldi	r25, 0x00	; 0
    11d6:	9c 83       	std	Y+4, r25	; 0x04
    11d8:	8b 83       	std	Y+3, r24	; 0x03
    11da:	90 95       	com	r25
    11dc:	81 95       	neg	r24
    11de:	9f 4f       	sbci	r25, 0xFF	; 255
    11e0:	9f 83       	std	Y+7, r25	; 0x07
    11e2:	8e 83       	std	Y+6, r24	; 0x06
    if (free_space) {
      uint8_t c = inv;
      if(row == char_final_height-1) {
        c ^= ul; 
        if(hc)
          c ^= ul>>1;      
    11e4:	3d 86       	std	Y+13, r3	; 0x0d
    11e6:	2c 86       	std	Y+12, r2	; 0x0c
    if (character == ' ') return 0;
    }
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
    11e8:	81 01       	movw	r16, r2
    11ea:	0d 80       	ldd	r0, Y+5	; 0x05
    11ec:	02 c0       	rjmp	.+4      	; 0x11f2 <lcd_put_char+0x176>
    11ee:	15 95       	asr	r17
    11f0:	07 95       	ror	r16
    11f2:	0a 94       	dec	r0
    11f4:	e2 f7       	brpl	.-8      	; 0x11ee <lcd_put_char+0x172>
    11f6:	80 2f       	mov	r24, r16
    11f8:	99 27       	eor	r25, r25
    11fa:	87 fd       	sbrc	r24, 7
    11fc:	90 95       	com	r25
    11fe:	8e 15       	cp	r24, r14
    1200:	9f 05       	cpc	r25, r15
    1202:	a4 f5       	brge	.+104    	; 0x126c <lcd_put_char+0x1f0>
      tmp = pgm_read_byte(tableposition+i);
      if(row == char_final_height-1) 
        tmp |= ul;
      if(hc)
        tmp = double_bits((row&1),tmp);
    1204:	55 24       	eor	r5, r5
    1206:	53 94       	inc	r5
    1208:	52 20       	and	r5, r2
    }
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
      tmp = pgm_read_byte(tableposition+i);
    120a:	e0 2f       	mov	r30, r16
    120c:	ff 27       	eor	r31, r31
    120e:	e7 fd       	sbrc	r30, 7
    1210:	f0 95       	com	r31
    1212:	ea 0d       	add	r30, r10
    1214:	fb 1d       	adc	r31, r11
    1216:	14 91       	lpm	r17, Z+
      if(row == char_final_height-1) 
    1218:	8c 85       	ldd	r24, Y+12	; 0x0c
    121a:	9d 85       	ldd	r25, Y+13	; 0x0d
    121c:	c8 16       	cp	r12, r24
    121e:	d9 06       	cpc	r13, r25
    1220:	09 f4       	brne	.+2      	; 0x1224 <lcd_put_char+0x1a8>
        tmp |= ul;
    1222:	14 29       	or	r17, r4
      if(hc)
    1224:	88 20       	and	r8, r8
    1226:	81 f0       	breq	.+32     	; 0x1248 <lcd_put_char+0x1cc>
 * part = 1:  abcdefgh -> aabbccdd
 * Used for double height font
 */
inline unsigned char double_bits(uint8_t part, char c) {
  char t = 0;
  if (part) c = c>>4;
    1228:	55 20       	and	r5, r5
    122a:	11 f0       	breq	.+4      	; 0x1230 <lcd_put_char+0x1b4>
    122c:	12 95       	swap	r17
    122e:	1f 70       	andi	r17, 0x0F	; 15
  if (c & 0x08) t  = 0xC0;
    1230:	81 2f       	mov	r24, r17
    1232:	13 fd       	sbrc	r17, 3
    1234:	02 c0       	rjmp	.+4      	; 0x123a <lcd_put_char+0x1be>
 * part = 0:  abcdefgh -> eeffgghh
 * part = 1:  abcdefgh -> aabbccdd
 * Used for double height font
 */
inline unsigned char double_bits(uint8_t part, char c) {
  char t = 0;
    1236:	10 e0       	ldi	r17, 0x00	; 0
    1238:	01 c0       	rjmp	.+2      	; 0x123c <lcd_put_char+0x1c0>
  if (part) c = c>>4;
  if (c & 0x08) t  = 0xC0;
    123a:	10 ec       	ldi	r17, 0xC0	; 192
  if (c & 0x04) t |= 0x30;
    123c:	82 fd       	sbrc	r24, 2
    123e:	10 63       	ori	r17, 0x30	; 48
  if (c & 0x02) t |= 0x0C;
    1240:	81 fd       	sbrc	r24, 1
    1242:	1c 60       	ori	r17, 0x0C	; 12
  if (c & 0x01) t |= 0x03;
    1244:	80 fd       	sbrc	r24, 0
    1246:	13 60       	ori	r17, 0x03	; 3
      tmp = pgm_read_byte(tableposition+i);
      if(row == char_final_height-1) 
        tmp |= ul;
      if(hc)
        tmp = double_bits((row&1),tmp);
      if(inv)
    1248:	71 10       	cpse	r7, r1
        tmp = ~tmp;
    124a:	10 95       	com	r17
      LCD_WRITE(tmp);
    124c:	81 2f       	mov	r24, r17
    124e:	0e 94 ff 04 	call	0x9fe	; 0x9fe <lcd_data>
      if(wc) 
    1252:	99 20       	and	r9, r9
    1254:	19 f0       	breq	.+6      	; 0x125c <lcd_put_char+0x1e0>
        LCD_WRITE(tmp);
    1256:	81 2f       	mov	r24, r17
    1258:	0e 94 ff 04 	call	0x9fe	; 0x9fe <lcd_data>
 *****************************************************************************/

/******************************************************************************
 * Outputs a character on the display, using the given font and style
 */
uint8_t lcd_put_char(FONT_P font, uint8_t style, char character) {
    125c:	06 0d       	add	r16, r6
    if (character == ' ') return 0;
    }
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
    125e:	80 2f       	mov	r24, r16
    1260:	99 27       	eor	r25, r25
    1262:	87 fd       	sbrc	r24, 7
    1264:	90 95       	com	r25
    1266:	8e 15       	cp	r24, r14
    1268:	9f 05       	cpc	r25, r15
    126a:	7c f2       	brlt	.-98     	; 0x120a <lcd_put_char+0x18e>
        tmp = ~tmp;
      LCD_WRITE(tmp);
      if(wc) 
        LCD_WRITE(tmp);
      }
    if (free_space) {
    126c:	fa 81       	ldd	r31, Y+2	; 0x02
    126e:	ff 23       	and	r31, r31
    1270:	a1 f0       	breq	.+40     	; 0x129a <lcd_put_char+0x21e>
      uint8_t c = inv;
      if(row == char_final_height-1) {
    1272:	8c 85       	ldd	r24, Y+12	; 0x0c
    1274:	9d 85       	ldd	r25, Y+13	; 0x0d
    1276:	c8 16       	cp	r12, r24
    1278:	d9 06       	cpc	r13, r25
    127a:	21 f4       	brne	.+8      	; 0x1284 <lcd_put_char+0x208>
        c ^= ul; 
        if(hc)
    127c:	88 20       	and	r8, r8
    127e:	21 f0       	breq	.+8      	; 0x1288 <lcd_put_char+0x20c>
          c ^= ul>>1;      
    1280:	1b 85       	ldd	r17, Y+11	; 0x0b
    1282:	03 c0       	rjmp	.+6      	; 0x128a <lcd_put_char+0x20e>
      LCD_WRITE(tmp);
      if(wc) 
        LCD_WRITE(tmp);
      }
    if (free_space) {
      uint8_t c = inv;
    1284:	19 85       	ldd	r17, Y+9	; 0x09
    1286:	01 c0       	rjmp	.+2      	; 0x128a <lcd_put_char+0x20e>
      if(row == char_final_height-1) {
        c ^= ul; 
    1288:	1a 85       	ldd	r17, Y+10	; 0x0a
        if(hc)
          c ^= ul>>1;      
        }
      LCD_WRITE(c);
    128a:	81 2f       	mov	r24, r17
    128c:	0e 94 ff 04 	call	0x9fe	; 0x9fe <lcd_data>
      if(wc) 
    1290:	99 20       	and	r9, r9
    1292:	19 f0       	breq	.+6      	; 0x129a <lcd_put_char+0x21e>
        LCD_WRITE(c);
    1294:	81 2f       	mov	r24, r17
    1296:	0e 94 ff 04 	call	0x9fe	; 0x9fe <lcd_data>
      }
    LCD_MOVE(1,-char_final_width);
    129a:	8b 81       	ldd	r24, Y+3	; 0x03
    129c:	9c 81       	ldd	r25, Y+4	; 0x04
    129e:	08 2f       	mov	r16, r24
    12a0:	19 2f       	mov	r17, r25
    12a2:	81 e0       	ldi	r24, 0x01	; 1
    12a4:	6e 81       	ldd	r22, Y+6	; 0x06
    12a6:	7f 81       	ldd	r23, Y+7	; 0x07
    12a8:	0e 94 2a 05 	call	0xa54	; 0xa54 <lcd_move_xy>
    12ac:	08 94       	sec
    12ae:	21 1c       	adc	r2, r1
    12b0:	31 1c       	adc	r3, r1
    } while (++row < char_final_height);
    12b2:	99 81       	ldd	r25, Y+1	; 0x01
    12b4:	29 16       	cp	r2, r25
    12b6:	08 f4       	brcc	.+2      	; 0x12ba <lcd_put_char+0x23e>
    12b8:	95 cf       	rjmp	.-214    	; 0x11e4 <lcd_put_char+0x168>

  //move cursor to upper right corner of character
  LCD_MOVE(-char_final_height,char_final_width);
    12ba:	89 2f       	mov	r24, r25
    12bc:	81 95       	neg	r24
    12be:	60 2f       	mov	r22, r16
    12c0:	71 2f       	mov	r23, r17
    12c2:	0e 94 2a 05 	call	0xa54	; 0xa54 <lcd_move_xy>
  return char_final_width;
    12c6:	01 c0       	rjmp	.+2      	; 0x12ca <lcd_put_char+0x24e>
  uint8_t char_final_height = (uint8_t)font_height << hc; 

  //check for avail. space on display
  if ((style & WRAP) && (LCD_CURRENT_COL() + char_final_width > LCD_WIDTH)) {
    LCD_MOVE_TO(LCD_CURRENT_PAGE()+char_final_height,0);
    if (character == ' ') return 0;
    12c8:	18 86       	std	Y+8, r1	; 0x08
    } while (++row < char_final_height);

  //move cursor to upper right corner of character
  LCD_MOVE(-char_final_height,char_final_width);
  return char_final_width;
  }
    12ca:	88 85       	ldd	r24, Y+8	; 0x08
    12cc:	2d 96       	adiw	r28, 0x0d	; 13
    12ce:	0f b6       	in	r0, 0x3f	; 63
    12d0:	f8 94       	cli
    12d2:	de bf       	out	0x3e, r29	; 62
    12d4:	0f be       	out	0x3f, r0	; 63
    12d6:	cd bf       	out	0x3d, r28	; 61
    12d8:	cf 91       	pop	r28
    12da:	df 91       	pop	r29
    12dc:	1f 91       	pop	r17
    12de:	0f 91       	pop	r16
    12e0:	ff 90       	pop	r15
    12e2:	ef 90       	pop	r14
    12e4:	df 90       	pop	r13
    12e6:	cf 90       	pop	r12
    12e8:	bf 90       	pop	r11
    12ea:	af 90       	pop	r10
    12ec:	9f 90       	pop	r9
    12ee:	8f 90       	pop	r8
    12f0:	7f 90       	pop	r7
    12f2:	6f 90       	pop	r6
    12f4:	5f 90       	pop	r5
    12f6:	4f 90       	pop	r4
    12f8:	3f 90       	pop	r3
    12fa:	2f 90       	pop	r2
    12fc:	08 95       	ret

000012fe <lcd_put_string_P>:

/******************************************************************************
 * Outputs a string on the display, loading it from the program memory,
 * using the given font and style
 */
uint16_t lcd_put_string_P(FONT_P font, uint8_t style, PGM_P str) {
    12fe:	df 92       	push	r13
    1300:	ef 92       	push	r14
    1302:	ff 92       	push	r15
    1304:	0f 93       	push	r16
    1306:	1f 93       	push	r17
    1308:	cf 93       	push	r28
    130a:	df 93       	push	r29
    130c:	7c 01       	movw	r14, r24
    130e:	d6 2e       	mov	r13, r22
    1310:	ea 01       	movw	r28, r20
  unsigned char t;
  uint16_t length = 0;
  while((t = pgm_read_byte(str++))) 
    1312:	fa 01       	movw	r30, r20
    1314:	44 91       	lpm	r20, Z+
    1316:	44 23       	and	r20, r20
    1318:	79 f0       	breq	.+30     	; 0x1338 <lcd_put_string_P+0x3a>
    131a:	21 96       	adiw	r28, 0x01	; 1
 * Outputs a string on the display, loading it from the program memory,
 * using the given font and style
 */
uint16_t lcd_put_string_P(FONT_P font, uint8_t style, PGM_P str) {
  unsigned char t;
  uint16_t length = 0;
    131c:	00 e0       	ldi	r16, 0x00	; 0
    131e:	10 e0       	ldi	r17, 0x00	; 0
  while((t = pgm_read_byte(str++))) 
    length += lcd_put_char(font,style,t);
    1320:	c7 01       	movw	r24, r14
    1322:	6d 2d       	mov	r22, r13
    1324:	0e 94 3e 08 	call	0x107c	; 0x107c <lcd_put_char>
    1328:	08 0f       	add	r16, r24
    132a:	11 1d       	adc	r17, r1
    132c:	fe 01       	movw	r30, r28
 * using the given font and style
 */
uint16_t lcd_put_string_P(FONT_P font, uint8_t style, PGM_P str) {
  unsigned char t;
  uint16_t length = 0;
  while((t = pgm_read_byte(str++))) 
    132e:	21 96       	adiw	r28, 0x01	; 1
    1330:	44 91       	lpm	r20, Z+
    1332:	44 23       	and	r20, r20
    1334:	a9 f7       	brne	.-22     	; 0x1320 <lcd_put_string_P+0x22>
    1336:	02 c0       	rjmp	.+4      	; 0x133c <lcd_put_string_P+0x3e>
 * Outputs a string on the display, loading it from the program memory,
 * using the given font and style
 */
uint16_t lcd_put_string_P(FONT_P font, uint8_t style, PGM_P str) {
  unsigned char t;
  uint16_t length = 0;
    1338:	00 e0       	ldi	r16, 0x00	; 0
    133a:	10 e0       	ldi	r17, 0x00	; 0
  while((t = pgm_read_byte(str++))) 
    length += lcd_put_char(font,style,t);
  return length;
  }
    133c:	80 2f       	mov	r24, r16
    133e:	91 2f       	mov	r25, r17
    1340:	df 91       	pop	r29
    1342:	cf 91       	pop	r28
    1344:	1f 91       	pop	r17
    1346:	0f 91       	pop	r16
    1348:	ff 90       	pop	r15
    134a:	ef 90       	pop	r14
    134c:	df 90       	pop	r13
    134e:	08 95       	ret

00001350 <lcd_put_string>:

  
/******************************************************************************
 * Outputs a string on the display, using the given font and style
 */
uint16_t lcd_put_string(FONT_P font, uint8_t style, char* str) {
    1350:	df 92       	push	r13
    1352:	ef 92       	push	r14
    1354:	ff 92       	push	r15
    1356:	0f 93       	push	r16
    1358:	1f 93       	push	r17
    135a:	cf 93       	push	r28
    135c:	df 93       	push	r29
    135e:	7c 01       	movw	r14, r24
    1360:	d6 2e       	mov	r13, r22
    1362:	fa 01       	movw	r30, r20
  unsigned char t;
  uint16_t length = 0;
  while((t = *str++))
    1364:	40 81       	ld	r20, Z
    1366:	44 23       	and	r20, r20
    1368:	89 f0       	breq	.+34     	; 0x138c <lcd_put_string+0x3c>
    136a:	8f 01       	movw	r16, r30
    136c:	0f 5f       	subi	r16, 0xFF	; 255
    136e:	1f 4f       	sbci	r17, 0xFF	; 255
/******************************************************************************
 * Outputs a string on the display, using the given font and style
 */
uint16_t lcd_put_string(FONT_P font, uint8_t style, char* str) {
  unsigned char t;
  uint16_t length = 0;
    1370:	c0 e0       	ldi	r28, 0x00	; 0
    1372:	d0 e0       	ldi	r29, 0x00	; 0
  while((t = *str++))
    length += lcd_put_char(font,style,t);
    1374:	c7 01       	movw	r24, r14
    1376:	6d 2d       	mov	r22, r13
    1378:	0e 94 3e 08 	call	0x107c	; 0x107c <lcd_put_char>
    137c:	c8 0f       	add	r28, r24
    137e:	d1 1d       	adc	r29, r1
 * Outputs a string on the display, using the given font and style
 */
uint16_t lcd_put_string(FONT_P font, uint8_t style, char* str) {
  unsigned char t;
  uint16_t length = 0;
  while((t = *str++))
    1380:	f8 01       	movw	r30, r16
    1382:	41 91       	ld	r20, Z+
    1384:	8f 01       	movw	r16, r30
    1386:	44 23       	and	r20, r20
    1388:	a9 f7       	brne	.-22     	; 0x1374 <lcd_put_string+0x24>
    138a:	02 c0       	rjmp	.+4      	; 0x1390 <lcd_put_string+0x40>
/******************************************************************************
 * Outputs a string on the display, using the given font and style
 */
uint16_t lcd_put_string(FONT_P font, uint8_t style, char* str) {
  unsigned char t;
  uint16_t length = 0;
    138c:	c0 e0       	ldi	r28, 0x00	; 0
    138e:	d0 e0       	ldi	r29, 0x00	; 0
  while((t = *str++))
    length += lcd_put_char(font,style,t);
  return length;
  }
    1390:	7e 01       	movw	r14, r28
    1392:	8c 2f       	mov	r24, r28
    1394:	9f 2d       	mov	r25, r15
    1396:	df 91       	pop	r29
    1398:	cf 91       	pop	r28
    139a:	1f 91       	pop	r17
    139c:	0f 91       	pop	r16
    139e:	ff 90       	pop	r15
    13a0:	ef 90       	pop	r14
    13a2:	df 90       	pop	r13
    13a4:	08 95       	ret

000013a6 <lcd_put_string_length>:
  
/******************************************************************************
 * Outputs a string on the display, using the given font and style, reading
 * length characters from the memory
 */ 
uint16_t lcd_put_string_length(FONT_P font, uint8_t style, char* str, uint8_t length) {
    13a6:	8f 92       	push	r8
    13a8:	9f 92       	push	r9
    13aa:	bf 92       	push	r11
    13ac:	cf 92       	push	r12
    13ae:	df 92       	push	r13
    13b0:	ef 92       	push	r14
    13b2:	ff 92       	push	r15
    13b4:	0f 93       	push	r16
    13b6:	1f 93       	push	r17
    13b8:	cf 93       	push	r28
    13ba:	df 93       	push	r29
    13bc:	6c 01       	movw	r12, r24
    13be:	b6 2e       	mov	r11, r22
    13c0:	f4 2e       	mov	r15, r20
    13c2:	e2 2e       	mov	r14, r18
  unsigned char t;
  uint16_t total_len = 0;
  for(t=0;t<length;t++)
    13c4:	22 23       	and	r18, r18
    13c6:	99 f0       	breq	.+38     	; 0x13ee <lcd_put_string_length+0x48>
    13c8:	84 2e       	mov	r8, r20
    13ca:	e4 01       	movw	r28, r8
    13cc:	4e 01       	movw	r8, r28
    13ce:	95 2e       	mov	r9, r21
    13d0:	e4 01       	movw	r28, r8
 * Outputs a string on the display, using the given font and style, reading
 * length characters from the memory
 */ 
uint16_t lcd_put_string_length(FONT_P font, uint8_t style, char* str, uint8_t length) {
  unsigned char t;
  uint16_t total_len = 0;
    13d2:	00 e0       	ldi	r16, 0x00	; 0
    13d4:	10 e0       	ldi	r17, 0x00	; 0
  for(t=0;t<length;t++)
    total_len += lcd_put_char(font,style,*str++);
    13d6:	49 91       	ld	r20, Y+
    13d8:	c6 01       	movw	r24, r12
    13da:	6b 2d       	mov	r22, r11
    13dc:	0e 94 3e 08 	call	0x107c	; 0x107c <lcd_put_char>
    13e0:	08 0f       	add	r16, r24
    13e2:	11 1d       	adc	r17, r1
 * length characters from the memory
 */ 
uint16_t lcd_put_string_length(FONT_P font, uint8_t style, char* str, uint8_t length) {
  unsigned char t;
  uint16_t total_len = 0;
  for(t=0;t<length;t++)
    13e4:	4e 01       	movw	r8, r28
    13e6:	8f 18       	sub	r8, r15
    13e8:	8e 14       	cp	r8, r14
    13ea:	a8 f3       	brcs	.-22     	; 0x13d6 <lcd_put_string_length+0x30>
    13ec:	02 c0       	rjmp	.+4      	; 0x13f2 <lcd_put_string_length+0x4c>
 * Outputs a string on the display, using the given font and style, reading
 * length characters from the memory
 */ 
uint16_t lcd_put_string_length(FONT_P font, uint8_t style, char* str, uint8_t length) {
  unsigned char t;
  uint16_t total_len = 0;
    13ee:	00 e0       	ldi	r16, 0x00	; 0
    13f0:	10 e0       	ldi	r17, 0x00	; 0
  for(t=0;t<length;t++)
    total_len += lcd_put_char(font,style,*str++);
  return total_len;
  }
    13f2:	80 2f       	mov	r24, r16
    13f4:	91 2f       	mov	r25, r17
    13f6:	df 91       	pop	r29
    13f8:	cf 91       	pop	r28
    13fa:	1f 91       	pop	r17
    13fc:	0f 91       	pop	r16
    13fe:	ff 90       	pop	r15
    1400:	ef 90       	pop	r14
    1402:	df 90       	pop	r13
    1404:	cf 90       	pop	r12
    1406:	bf 90       	pop	r11
    1408:	9f 90       	pop	r9
    140a:	8f 90       	pop	r8
    140c:	08 95       	ret

0000140e <lcd_put_string_xy_P>:
/******************************************************************************
 * Outputs a string on the display, using the given font and style, reading
 * the string from program memory. The position of the string on the display
 * is selected by page / col.
 */ 
uint16_t lcd_put_string_xy_P(FONT_P font, uint8_t style, PGM_P str,uint8_t page, uint8_t col) {
    140e:	ef 92       	push	r14
    1410:	ff 92       	push	r15
    1412:	0f 93       	push	r16
    1414:	1f 93       	push	r17
    1416:	cf 93       	push	r28
    1418:	df 93       	push	r29
    141a:	ec 01       	movw	r28, r24
    141c:	16 2f       	mov	r17, r22
    141e:	7a 01       	movw	r14, r20
    1420:	82 2f       	mov	r24, r18
    1422:	60 2f       	mov	r22, r16
  LCD_MOVE_TO(page,col);
    1424:	0e 94 11 05 	call	0xa22	; 0xa22 <lcd_moveto_xy>
  return lcd_put_string_P(font,style,str);
    1428:	ce 01       	movw	r24, r28
    142a:	61 2f       	mov	r22, r17
    142c:	a7 01       	movw	r20, r14
    142e:	0e 94 7f 09 	call	0x12fe	; 0x12fe <lcd_put_string_P>
  }
    1432:	df 91       	pop	r29
    1434:	cf 91       	pop	r28
    1436:	1f 91       	pop	r17
    1438:	0f 91       	pop	r16
    143a:	ff 90       	pop	r15
    143c:	ef 90       	pop	r14
    143e:	08 95       	ret

00001440 <lcd_put_char_xy>:
/******************************************************************************
 * Outputs a string on the display, using the given font and style, reading
 * the string from main memory. The position of the string on the display
 * is selected by page / col.
 */ 
uint8_t lcd_put_char_xy(FONT_P font, uint8_t style, char character, uint8_t page, uint8_t col) {
    1440:	ff 92       	push	r15
    1442:	0f 93       	push	r16
    1444:	1f 93       	push	r17
    1446:	cf 93       	push	r28
    1448:	df 93       	push	r29
    144a:	ec 01       	movw	r28, r24
    144c:	f6 2e       	mov	r15, r22
    144e:	14 2f       	mov	r17, r20
    1450:	82 2f       	mov	r24, r18
    1452:	60 2f       	mov	r22, r16
  LCD_MOVE_TO(page,col);
    1454:	0e 94 11 05 	call	0xa22	; 0xa22 <lcd_moveto_xy>
  return lcd_put_char(font,style,character);
    1458:	ce 01       	movw	r24, r28
    145a:	6f 2d       	mov	r22, r15
    145c:	41 2f       	mov	r20, r17
    145e:	0e 94 3e 08 	call	0x107c	; 0x107c <lcd_put_char>
  }
    1462:	df 91       	pop	r29
    1464:	cf 91       	pop	r28
    1466:	1f 91       	pop	r17
    1468:	0f 91       	pop	r16
    146a:	ff 90       	pop	r15
    146c:	08 95       	ret

0000146e <lcd_putc>:


/******************************************************************************
 * Outputs a character on the display, using the global font and style
 */ 
uint8_t  lcd_putc(char c) {
    146e:	48 2f       	mov	r20, r24
  return lcd_put_char(global_font_select, global_font_style, c);
    1470:	80 91 8d 00 	lds	r24, 0x008D
    1474:	90 91 8e 00 	lds	r25, 0x008E
    1478:	60 91 8c 00 	lds	r22, 0x008C
    147c:	0e 94 3e 08 	call	0x107c	; 0x107c <lcd_put_char>
  }
    1480:	08 95       	ret

00001482 <lcd_putc_xy>:

/******************************************************************************
 * Outputs a character on the display, using the global font and style
 */ 
uint8_t  lcd_putc_xy(char c, uint8_t page, uint8_t col) {
    1482:	0f 93       	push	r16
    1484:	38 2f       	mov	r19, r24
    1486:	26 2f       	mov	r18, r22
    1488:	04 2f       	mov	r16, r20
  return lcd_put_char_xy(global_font_select, global_font_style, c, page, col);
    148a:	80 91 8d 00 	lds	r24, 0x008D
    148e:	90 91 8e 00 	lds	r25, 0x008E
    1492:	60 91 8c 00 	lds	r22, 0x008C
    1496:	43 2f       	mov	r20, r19
    1498:	0e 94 20 0a 	call	0x1440	; 0x1440 <lcd_put_char_xy>
  }  
    149c:	0f 91       	pop	r16
    149e:	08 95       	ret

000014a0 <lcd_putstr>:
  
  
/******************************************************************************
 * Outputs a string on the display, using the global font and style
 */   
uint16_t lcd_putstr(char* str) {
    14a0:	ac 01       	movw	r20, r24
  return lcd_put_string(global_font_select, global_font_style, str);
    14a2:	80 91 8d 00 	lds	r24, 0x008D
    14a6:	90 91 8e 00 	lds	r25, 0x008E
    14aa:	60 91 8c 00 	lds	r22, 0x008C
    14ae:	0e 94 a8 09 	call	0x1350	; 0x1350 <lcd_put_string>
  }
    14b2:	08 95       	ret

000014b4 <lcd_putstr_P>:
  
/******************************************************************************
 * Outputs a string stored in program memory on the display, using the global 
 * font and style
 */   
uint16_t lcd_putstr_P(PGM_P str) {
    14b4:	ac 01       	movw	r20, r24
  return lcd_put_string_P(global_font_select, global_font_style, str);
    14b6:	80 91 8d 00 	lds	r24, 0x008D
    14ba:	90 91 8e 00 	lds	r25, 0x008E
    14be:	60 91 8c 00 	lds	r22, 0x008C
    14c2:	0e 94 7f 09 	call	0x12fe	; 0x12fe <lcd_put_string_P>
  }
    14c6:	08 95       	ret

000014c8 <lcd_putstr_xy_P>:

/******************************************************************************
 * Outputs a string on the display, using the global font and style at the 
 * given position
 */   
uint16_t lcd_putstr_xy_P(PGM_P  str, uint8_t page, uint8_t col) {
    14c8:	0f 93       	push	r16
    14ca:	fc 01       	movw	r30, r24
    14cc:	26 2f       	mov	r18, r22
    14ce:	04 2f       	mov	r16, r20
  return lcd_put_string_xy_P(global_font_select, global_font_style, str, page, col);
    14d0:	80 91 8d 00 	lds	r24, 0x008D
    14d4:	90 91 8e 00 	lds	r25, 0x008E
    14d8:	60 91 8c 00 	lds	r22, 0x008C
    14dc:	af 01       	movw	r20, r30
    14de:	0e 94 07 0a 	call	0x140e	; 0x140e <lcd_put_string_xy_P>
  }  
    14e2:	0f 91       	pop	r16
    14e4:	08 95       	ret

000014e6 <lcd_put_long>:

#if INCLUDE_INTEGER_OUTPUT == 1
/******************************************************************************
 * Outputs a 32bit signed integer on the display // Added by Olli S.
 */ 
uint16_t lcd_put_long  (int32_t integer) {
    14e6:	0f 93       	push	r16
    14e8:	1f 93       	push	r17
    14ea:	df 93       	push	r29
    14ec:	cf 93       	push	r28
    14ee:	cd b7       	in	r28, 0x3d	; 61
    14f0:	de b7       	in	r29, 0x3e	; 62
    14f2:	2a 97       	sbiw	r28, 0x0a	; 10
    14f4:	0f b6       	in	r0, 0x3f	; 63
    14f6:	f8 94       	cli
    14f8:	de bf       	out	0x3e, r29	; 62
    14fa:	0f be       	out	0x3f, r0	; 63
    14fc:	cd bf       	out	0x3d, r28	; 61
  char buffer[10];
	ltoa(integer, buffer, 10);
    14fe:	8e 01       	movw	r16, r28
    1500:	0f 5f       	subi	r16, 0xFF	; 255
    1502:	1f 4f       	sbci	r17, 0xFF	; 255
    1504:	a8 01       	movw	r20, r16
    1506:	2a e0       	ldi	r18, 0x0A	; 10
    1508:	30 e0       	ldi	r19, 0x00	; 0
    150a:	0e 94 b3 0b 	call	0x1766	; 0x1766 <ltoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    150e:	80 91 8d 00 	lds	r24, 0x008D
    1512:	90 91 8e 00 	lds	r25, 0x008E
    1516:	60 91 8c 00 	lds	r22, 0x008C
    151a:	a8 01       	movw	r20, r16
    151c:	0e 94 a8 09 	call	0x1350	; 0x1350 <lcd_put_string>
  }
    1520:	2a 96       	adiw	r28, 0x0a	; 10
    1522:	0f b6       	in	r0, 0x3f	; 63
    1524:	f8 94       	cli
    1526:	de bf       	out	0x3e, r29	; 62
    1528:	0f be       	out	0x3f, r0	; 63
    152a:	cd bf       	out	0x3d, r28	; 61
    152c:	cf 91       	pop	r28
    152e:	df 91       	pop	r29
    1530:	1f 91       	pop	r17
    1532:	0f 91       	pop	r16
    1534:	08 95       	ret

00001536 <lcd_put_int>:

  
/******************************************************************************
 * Outputs a 16bit signed integer on the display // Added by Olli S.
 */   
uint16_t lcd_put_int (int16_t integer) {
    1536:	0f 93       	push	r16
    1538:	1f 93       	push	r17
    153a:	df 93       	push	r29
    153c:	cf 93       	push	r28
    153e:	cd b7       	in	r28, 0x3d	; 61
    1540:	de b7       	in	r29, 0x3e	; 62
    1542:	2a 97       	sbiw	r28, 0x0a	; 10
    1544:	0f b6       	in	r0, 0x3f	; 63
    1546:	f8 94       	cli
    1548:	de bf       	out	0x3e, r29	; 62
    154a:	0f be       	out	0x3f, r0	; 63
    154c:	cd bf       	out	0x3d, r28	; 61
  char buffer[10];
	itoa(integer, buffer, 10);
    154e:	8e 01       	movw	r16, r28
    1550:	0f 5f       	subi	r16, 0xFF	; 255
    1552:	1f 4f       	sbci	r17, 0xFF	; 255
    1554:	b8 01       	movw	r22, r16
    1556:	4a e0       	ldi	r20, 0x0A	; 10
    1558:	50 e0       	ldi	r21, 0x00	; 0
    155a:	0e 94 92 0b 	call	0x1724	; 0x1724 <itoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    155e:	80 91 8d 00 	lds	r24, 0x008D
    1562:	90 91 8e 00 	lds	r25, 0x008E
    1566:	60 91 8c 00 	lds	r22, 0x008C
    156a:	a8 01       	movw	r20, r16
    156c:	0e 94 a8 09 	call	0x1350	; 0x1350 <lcd_put_string>
  }  
    1570:	2a 96       	adiw	r28, 0x0a	; 10
    1572:	0f b6       	in	r0, 0x3f	; 63
    1574:	f8 94       	cli
    1576:	de bf       	out	0x3e, r29	; 62
    1578:	0f be       	out	0x3f, r0	; 63
    157a:	cd bf       	out	0x3d, r28	; 61
    157c:	cf 91       	pop	r28
    157e:	df 91       	pop	r29
    1580:	1f 91       	pop	r17
    1582:	0f 91       	pop	r16
    1584:	08 95       	ret

00001586 <lcd_put_uint>:

  
/******************************************************************************
 * Outputs a 16bit unsigned integer on the display // Added by Olli S.
 */   
uint16_t lcd_put_uint  (uint16_t integer) {
    1586:	0f 93       	push	r16
    1588:	1f 93       	push	r17
    158a:	df 93       	push	r29
    158c:	cf 93       	push	r28
    158e:	cd b7       	in	r28, 0x3d	; 61
    1590:	de b7       	in	r29, 0x3e	; 62
    1592:	2a 97       	sbiw	r28, 0x0a	; 10
    1594:	0f b6       	in	r0, 0x3f	; 63
    1596:	f8 94       	cli
    1598:	de bf       	out	0x3e, r29	; 62
    159a:	0f be       	out	0x3f, r0	; 63
    159c:	cd bf       	out	0x3d, r28	; 61
  char buffer[10];
	utoa(integer, buffer, 10);
    159e:	8e 01       	movw	r16, r28
    15a0:	0f 5f       	subi	r16, 0xFF	; 255
    15a2:	1f 4f       	sbci	r17, 0xFF	; 255
    15a4:	b8 01       	movw	r22, r16
    15a6:	4a e0       	ldi	r20, 0x0A	; 10
    15a8:	50 e0       	ldi	r21, 0x00	; 0
    15aa:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <utoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    15ae:	80 91 8d 00 	lds	r24, 0x008D
    15b2:	90 91 8e 00 	lds	r25, 0x008E
    15b6:	60 91 8c 00 	lds	r22, 0x008C
    15ba:	a8 01       	movw	r20, r16
    15bc:	0e 94 a8 09 	call	0x1350	; 0x1350 <lcd_put_string>
  }  
    15c0:	2a 96       	adiw	r28, 0x0a	; 10
    15c2:	0f b6       	in	r0, 0x3f	; 63
    15c4:	f8 94       	cli
    15c6:	de bf       	out	0x3e, r29	; 62
    15c8:	0f be       	out	0x3f, r0	; 63
    15ca:	cd bf       	out	0x3d, r28	; 61
    15cc:	cf 91       	pop	r28
    15ce:	df 91       	pop	r29
    15d0:	1f 91       	pop	r17
    15d2:	0f 91       	pop	r16
    15d4:	08 95       	ret

000015d6 <lcd_put_short>:
  
/******************************************************************************
 * Outputs a 8bit signed integer on the display
 */   
uint16_t lcd_put_short (int8_t integer) {
    15d6:	0f 93       	push	r16
    15d8:	1f 93       	push	r17
    15da:	df 93       	push	r29
    15dc:	cf 93       	push	r28
    15de:	cd b7       	in	r28, 0x3d	; 61
    15e0:	de b7       	in	r29, 0x3e	; 62
    15e2:	2a 97       	sbiw	r28, 0x0a	; 10
    15e4:	0f b6       	in	r0, 0x3f	; 63
    15e6:	f8 94       	cli
    15e8:	de bf       	out	0x3e, r29	; 62
    15ea:	0f be       	out	0x3f, r0	; 63
    15ec:	cd bf       	out	0x3d, r28	; 61
  char buffer[10];
	itoa(integer, buffer, 10);
    15ee:	99 27       	eor	r25, r25
    15f0:	87 fd       	sbrc	r24, 7
    15f2:	90 95       	com	r25
    15f4:	8e 01       	movw	r16, r28
    15f6:	0f 5f       	subi	r16, 0xFF	; 255
    15f8:	1f 4f       	sbci	r17, 0xFF	; 255
    15fa:	b8 01       	movw	r22, r16
    15fc:	4a e0       	ldi	r20, 0x0A	; 10
    15fe:	50 e0       	ldi	r21, 0x00	; 0
    1600:	0e 94 92 0b 	call	0x1724	; 0x1724 <itoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    1604:	80 91 8d 00 	lds	r24, 0x008D
    1608:	90 91 8e 00 	lds	r25, 0x008E
    160c:	60 91 8c 00 	lds	r22, 0x008C
    1610:	a8 01       	movw	r20, r16
    1612:	0e 94 a8 09 	call	0x1350	; 0x1350 <lcd_put_string>
  }    
    1616:	2a 96       	adiw	r28, 0x0a	; 10
    1618:	0f b6       	in	r0, 0x3f	; 63
    161a:	f8 94       	cli
    161c:	de bf       	out	0x3e, r29	; 62
    161e:	0f be       	out	0x3f, r0	; 63
    1620:	cd bf       	out	0x3d, r28	; 61
    1622:	cf 91       	pop	r28
    1624:	df 91       	pop	r29
    1626:	1f 91       	pop	r17
    1628:	0f 91       	pop	r16
    162a:	08 95       	ret

0000162c <TWI_Master_Initialise>:
Call this function to set up the TWI master to its initial standby state.
Remember to enable interrupts from the main application after initializing the TWI.
****************************************************************************/
void TWI_Master_Initialise(void)
{
	TWBR = TWI_TWBR;                        // Set bit rate register (Baudrate). Defined in header file.
    162c:	80 e2       	ldi	r24, 0x20	; 32
    162e:	80 b9       	out	0x00, r24	; 0
	//TWDR = 0xFF;							// Default content = SDA released.
	//TWCR = (1<<TWEN);//|						// Enable TWI-interface and release TWI pins.
         //(0<<TWIE)|(0<<TWINT)|              // Disable Interupt.
         //(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|   // No Signal requests.
         //(0<<TWWC);                         //
}    
    1630:	08 95       	ret

00001632 <TWI_Transceiver_Busy>:
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
 	return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
    1632:	86 b7       	in	r24, 0x36	; 54
}
    1634:	81 70       	andi	r24, 0x01	; 1
    1636:	08 95       	ret

00001638 <TWI_Get_State_Info>:
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
	  while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
    1638:	0e 94 19 0b 	call	0x1632	; 0x1632 <TWI_Transceiver_Busy>
    163c:	88 23       	and	r24, r24
    163e:	e1 f7       	brne	.-8      	; 0x1638 <TWI_Get_State_Info>
	  return ( TWI_state );                         // Return error state.
}
    1640:	80 91 67 00 	lds	r24, 0x0067
    1644:	08 95       	ret

00001646 <TWI_Start_Transceiver_With_Data>:
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
    1646:	1f 93       	push	r17
    1648:	cf 93       	push	r28
    164a:	df 93       	push	r29
    164c:	ec 01       	movw	r28, r24
    164e:	16 2f       	mov	r17, r22
	  unsigned char temp;

	  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    1650:	0e 94 19 0b 	call	0x1632	; 0x1632 <TWI_Transceiver_Busy>
    1654:	88 23       	and	r24, r24
    1656:	e1 f7       	brne	.-8      	; 0x1650 <TWI_Start_Transceiver_With_Data+0xa>

	  TWI_msgSize = msgSize;                        // Number of data to transmit.
    1658:	10 93 75 00 	sts	0x0075, r17
	  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
    165c:	88 81       	ld	r24, Y
    165e:	80 93 71 00 	sts	0x0071, r24
	  
	  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
    1662:	80 fd       	sbrc	r24, 0
    1664:	0f c0       	rjmp	.+30     	; 0x1684 <TWI_Start_Transceiver_With_Data+0x3e>
	  {
		for ( temp = 1; temp < msgSize; temp++ )
    1666:	12 30       	cpi	r17, 0x02	; 2
    1668:	68 f0       	brcs	.+26     	; 0x1684 <TWI_Start_Transceiver_With_Data+0x3e>
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    166a:	21 96       	adiw	r28, 0x01	; 1
	  TWI_msgSize = msgSize;                        // Number of data to transmit.
	  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
	  
	  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
	  {
		for ( temp = 1; temp < msgSize; temp++ )
    166c:	e2 e7       	ldi	r30, 0x72	; 114
    166e:	f0 e0       	ldi	r31, 0x00	; 0
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    1670:	cf 01       	movw	r24, r30
    1672:	01 96       	adiw	r24, 0x01	; 1
    1674:	12 50       	subi	r17, 0x02	; 2
    1676:	81 0f       	add	r24, r17
    1678:	91 1d       	adc	r25, r1
	  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
	  
	  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
	  {
		for ( temp = 1; temp < msgSize; temp++ )
		  TWI_buf[ temp ] = msg[ temp ];
    167a:	29 91       	ld	r18, Y+
    167c:	21 93       	st	Z+, r18
	  TWI_msgSize = msgSize;                        // Number of data to transmit.
	  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
	  
	  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
	  {
		for ( temp = 1; temp < msgSize; temp++ )
    167e:	e8 17       	cp	r30, r24
    1680:	f9 07       	cpc	r31, r25
    1682:	d9 f7       	brne	.-10     	; 0x167a <TWI_Start_Transceiver_With_Data+0x34>
		  TWI_buf[ temp ] = msg[ temp ];
	  }
	  
	  //TWI_statusReg.all = 0;
	  TWI_statusReg.all = 0;      
    1684:	10 92 70 00 	sts	0x0070, r1
	  TWI_state         = TWI_NO_STATE ;
    1688:	88 ef       	ldi	r24, 0xF8	; 248
    168a:	80 93 67 00 	sts	0x0067, r24
	  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    168e:	85 ea       	ldi	r24, 0xA5	; 165
    1690:	86 bf       	out	0x36, r24	; 54
			 (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interrupt and clear the flag.
			 (1<<TWSTA);                            // Initiate a START condition.

}
    1692:	df 91       	pop	r29
    1694:	cf 91       	pop	r28
    1696:	1f 91       	pop	r17
    1698:	08 95       	ret

0000169a <TWI_Start_Transceiver>:
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    169a:	0e 94 19 0b 	call	0x1632	; 0x1632 <TWI_Transceiver_Busy>
    169e:	88 23       	and	r24, r24
    16a0:	e1 f7       	brne	.-8      	; 0x169a <TWI_Start_Transceiver>
	  
	TWI_statusReg.all = 0;      
    16a2:	10 92 70 00 	sts	0x0070, r1
	TWI_state         = TWI_NO_STATE ;
    16a6:	88 ef       	ldi	r24, 0xF8	; 248
    16a8:	80 93 67 00 	sts	0x0067, r24
	  
	TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    16ac:	85 ea       	ldi	r24, 0xA5	; 165
    16ae:	86 bf       	out	0x36, r24	; 54
			(1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
			(0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
			(0<<TWWC);                             //
}
    16b0:	08 95       	ret

000016b2 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    16b2:	ff 92       	push	r15
    16b4:	0f 93       	push	r16
    16b6:	1f 93       	push	r17
    16b8:	f8 2e       	mov	r15, r24
    16ba:	09 2f       	mov	r16, r25
    16bc:	16 2f       	mov	r17, r22
	unsigned char i;

	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    16be:	0e 94 19 0b 	call	0x1632	; 0x1632 <TWI_Transceiver_Busy>
    16c2:	88 23       	and	r24, r24
    16c4:	e1 f7       	brne	.-8      	; 0x16be <TWI_Get_Data_From_Transceiver+0xc>

	if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    16c6:	80 91 70 00 	lds	r24, 0x0070
    16ca:	80 ff       	sbrs	r24, 0
    16cc:	10 c0       	rjmp	.+32     	; 0x16ee <TWI_Get_Data_From_Transceiver+0x3c>
	{                                             
		for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    16ce:	11 23       	and	r17, r17
    16d0:	71 f0       	breq	.+28     	; 0x16ee <TWI_Get_Data_From_Transceiver+0x3c>
    16d2:	e1 e7       	ldi	r30, 0x71	; 113
    16d4:	f0 e0       	ldi	r31, 0x00	; 0
    16d6:	af 2d       	mov	r26, r15
    16d8:	b0 2f       	mov	r27, r16
data when they have arrived. Include a pointer to where to place the data and the number of bytes
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
    16da:	cf 01       	movw	r24, r30
    16dc:	01 96       	adiw	r24, 0x01	; 1
    16de:	11 50       	subi	r17, 0x01	; 1
    16e0:	81 0f       	add	r24, r17
    16e2:	91 1d       	adc	r25, r1

	if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
	{                                             
		for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
		{
			msg[ i ] = TWI_buf[ i ];
    16e4:	21 91       	ld	r18, Z+
    16e6:	2d 93       	st	X+, r18

	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

	if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
	{                                             
		for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    16e8:	e8 17       	cp	r30, r24
    16ea:	f9 07       	cpc	r31, r25
    16ec:	d9 f7       	brne	.-10     	; 0x16e4 <TWI_Get_Data_From_Transceiver+0x32>
		{
			msg[ i ] = TWI_buf[ i ];
		}
	}

	return( TWI_statusReg.lastTransOK );                                   
    16ee:	80 91 70 00 	lds	r24, 0x0070
}
    16f2:	81 70       	andi	r24, 0x01	; 1
    16f4:	1f 91       	pop	r17
    16f6:	0f 91       	pop	r16
    16f8:	ff 90       	pop	r15
    16fa:	08 95       	ret

000016fc <__udivmodhi4>:
    16fc:	aa 1b       	sub	r26, r26
    16fe:	bb 1b       	sub	r27, r27
    1700:	51 e1       	ldi	r21, 0x11	; 17
    1702:	07 c0       	rjmp	.+14     	; 0x1712 <__udivmodhi4_ep>

00001704 <__udivmodhi4_loop>:
    1704:	aa 1f       	adc	r26, r26
    1706:	bb 1f       	adc	r27, r27
    1708:	a6 17       	cp	r26, r22
    170a:	b7 07       	cpc	r27, r23
    170c:	10 f0       	brcs	.+4      	; 0x1712 <__udivmodhi4_ep>
    170e:	a6 1b       	sub	r26, r22
    1710:	b7 0b       	sbc	r27, r23

00001712 <__udivmodhi4_ep>:
    1712:	88 1f       	adc	r24, r24
    1714:	99 1f       	adc	r25, r25
    1716:	5a 95       	dec	r21
    1718:	a9 f7       	brne	.-22     	; 0x1704 <__udivmodhi4_loop>
    171a:	80 95       	com	r24
    171c:	90 95       	com	r25
    171e:	bc 01       	movw	r22, r24
    1720:	cd 01       	movw	r24, r26
    1722:	08 95       	ret

00001724 <itoa>:
    1724:	fb 01       	movw	r30, r22
    1726:	9f 01       	movw	r18, r30
    1728:	e8 94       	clt
    172a:	42 30       	cpi	r20, 0x02	; 2
    172c:	c4 f0       	brlt	.+48     	; 0x175e <itoa+0x3a>
    172e:	45 32       	cpi	r20, 0x25	; 37
    1730:	b4 f4       	brge	.+44     	; 0x175e <itoa+0x3a>
    1732:	4a 30       	cpi	r20, 0x0A	; 10
    1734:	29 f4       	brne	.+10     	; 0x1740 <itoa+0x1c>
    1736:	97 fb       	bst	r25, 7
    1738:	1e f4       	brtc	.+6      	; 0x1740 <itoa+0x1c>
    173a:	90 95       	com	r25
    173c:	81 95       	neg	r24
    173e:	9f 4f       	sbci	r25, 0xFF	; 255
    1740:	64 2f       	mov	r22, r20
    1742:	77 27       	eor	r23, r23
    1744:	0e 94 7e 0b 	call	0x16fc	; 0x16fc <__udivmodhi4>
    1748:	80 5d       	subi	r24, 0xD0	; 208
    174a:	8a 33       	cpi	r24, 0x3A	; 58
    174c:	0c f0       	brlt	.+2      	; 0x1750 <itoa+0x2c>
    174e:	89 5d       	subi	r24, 0xD9	; 217
    1750:	81 93       	st	Z+, r24
    1752:	cb 01       	movw	r24, r22
    1754:	00 97       	sbiw	r24, 0x00	; 0
    1756:	a1 f7       	brne	.-24     	; 0x1740 <itoa+0x1c>
    1758:	16 f4       	brtc	.+4      	; 0x175e <itoa+0x3a>
    175a:	5d e2       	ldi	r21, 0x2D	; 45
    175c:	51 93       	st	Z+, r21
    175e:	10 82       	st	Z, r1
    1760:	c9 01       	movw	r24, r18
    1762:	0c 94 fd 0b 	jmp	0x17fa	; 0x17fa <strrev>

00001766 <ltoa>:
    1766:	fa 01       	movw	r30, r20
    1768:	cf 93       	push	r28
    176a:	ff 93       	push	r31
    176c:	ef 93       	push	r30
    176e:	22 30       	cpi	r18, 0x02	; 2
    1770:	44 f1       	brlt	.+80     	; 0x17c2 <ltoa+0x5c>
    1772:	25 32       	cpi	r18, 0x25	; 37
    1774:	34 f5       	brge	.+76     	; 0x17c2 <ltoa+0x5c>
    1776:	c2 2f       	mov	r28, r18
    1778:	e8 94       	clt
    177a:	ca 30       	cpi	r28, 0x0A	; 10
    177c:	49 f4       	brne	.+18     	; 0x1790 <ltoa+0x2a>
    177e:	97 fb       	bst	r25, 7
    1780:	3e f4       	brtc	.+14     	; 0x1790 <ltoa+0x2a>
    1782:	90 95       	com	r25
    1784:	80 95       	com	r24
    1786:	70 95       	com	r23
    1788:	61 95       	neg	r22
    178a:	7f 4f       	sbci	r23, 0xFF	; 255
    178c:	8f 4f       	sbci	r24, 0xFF	; 255
    178e:	9f 4f       	sbci	r25, 0xFF	; 255
    1790:	2c 2f       	mov	r18, r28
    1792:	33 27       	eor	r19, r19
    1794:	44 27       	eor	r20, r20
    1796:	55 27       	eor	r21, r21
    1798:	ff 93       	push	r31
    179a:	ef 93       	push	r30
    179c:	0e 94 0d 0c 	call	0x181a	; 0x181a <__udivmodsi4>
    17a0:	ef 91       	pop	r30
    17a2:	ff 91       	pop	r31
    17a4:	60 5d       	subi	r22, 0xD0	; 208
    17a6:	6a 33       	cpi	r22, 0x3A	; 58
    17a8:	0c f0       	brlt	.+2      	; 0x17ac <ltoa+0x46>
    17aa:	69 5d       	subi	r22, 0xD9	; 217
    17ac:	61 93       	st	Z+, r22
    17ae:	b9 01       	movw	r22, r18
    17b0:	ca 01       	movw	r24, r20
    17b2:	60 50       	subi	r22, 0x00	; 0
    17b4:	70 40       	sbci	r23, 0x00	; 0
    17b6:	80 40       	sbci	r24, 0x00	; 0
    17b8:	90 40       	sbci	r25, 0x00	; 0
    17ba:	51 f7       	brne	.-44     	; 0x1790 <ltoa+0x2a>
    17bc:	16 f4       	brtc	.+4      	; 0x17c2 <ltoa+0x5c>
    17be:	cd e2       	ldi	r28, 0x2D	; 45
    17c0:	c1 93       	st	Z+, r28
    17c2:	10 82       	st	Z, r1
    17c4:	8f 91       	pop	r24
    17c6:	9f 91       	pop	r25
    17c8:	cf 91       	pop	r28
    17ca:	0c 94 fd 0b 	jmp	0x17fa	; 0x17fa <strrev>

000017ce <utoa>:
    17ce:	fb 01       	movw	r30, r22
    17d0:	9f 01       	movw	r18, r30
    17d2:	42 30       	cpi	r20, 0x02	; 2
    17d4:	74 f0       	brlt	.+28     	; 0x17f2 <utoa+0x24>
    17d6:	45 32       	cpi	r20, 0x25	; 37
    17d8:	64 f4       	brge	.+24     	; 0x17f2 <utoa+0x24>
    17da:	64 2f       	mov	r22, r20
    17dc:	77 27       	eor	r23, r23
    17de:	0e 94 7e 0b 	call	0x16fc	; 0x16fc <__udivmodhi4>
    17e2:	80 5d       	subi	r24, 0xD0	; 208
    17e4:	8a 33       	cpi	r24, 0x3A	; 58
    17e6:	0c f0       	brlt	.+2      	; 0x17ea <utoa+0x1c>
    17e8:	89 5d       	subi	r24, 0xD9	; 217
    17ea:	81 93       	st	Z+, r24
    17ec:	cb 01       	movw	r24, r22
    17ee:	00 97       	sbiw	r24, 0x00	; 0
    17f0:	a1 f7       	brne	.-24     	; 0x17da <utoa+0xc>
    17f2:	10 82       	st	Z, r1
    17f4:	c9 01       	movw	r24, r18
    17f6:	0c 94 fd 0b 	jmp	0x17fa	; 0x17fa <strrev>

000017fa <strrev>:
    17fa:	dc 01       	movw	r26, r24
    17fc:	fc 01       	movw	r30, r24
    17fe:	67 2f       	mov	r22, r23
    1800:	71 91       	ld	r23, Z+
    1802:	77 23       	and	r23, r23
    1804:	e1 f7       	brne	.-8      	; 0x17fe <strrev+0x4>
    1806:	32 97       	sbiw	r30, 0x02	; 2
    1808:	04 c0       	rjmp	.+8      	; 0x1812 <strrev+0x18>
    180a:	7c 91       	ld	r23, X
    180c:	6d 93       	st	X+, r22
    180e:	70 83       	st	Z, r23
    1810:	62 91       	ld	r22, -Z
    1812:	ae 17       	cp	r26, r30
    1814:	bf 07       	cpc	r27, r31
    1816:	c8 f3       	brcs	.-14     	; 0x180a <strrev+0x10>
    1818:	08 95       	ret

0000181a <__udivmodsi4>:
    181a:	a1 e2       	ldi	r26, 0x21	; 33
    181c:	1a 2e       	mov	r1, r26
    181e:	aa 1b       	sub	r26, r26
    1820:	bb 1b       	sub	r27, r27
    1822:	fd 01       	movw	r30, r26
    1824:	0d c0       	rjmp	.+26     	; 0x1840 <__udivmodsi4_ep>

00001826 <__udivmodsi4_loop>:
    1826:	aa 1f       	adc	r26, r26
    1828:	bb 1f       	adc	r27, r27
    182a:	ee 1f       	adc	r30, r30
    182c:	ff 1f       	adc	r31, r31
    182e:	a2 17       	cp	r26, r18
    1830:	b3 07       	cpc	r27, r19
    1832:	e4 07       	cpc	r30, r20
    1834:	f5 07       	cpc	r31, r21
    1836:	20 f0       	brcs	.+8      	; 0x1840 <__udivmodsi4_ep>
    1838:	a2 1b       	sub	r26, r18
    183a:	b3 0b       	sbc	r27, r19
    183c:	e4 0b       	sbc	r30, r20
    183e:	f5 0b       	sbc	r31, r21

00001840 <__udivmodsi4_ep>:
    1840:	66 1f       	adc	r22, r22
    1842:	77 1f       	adc	r23, r23
    1844:	88 1f       	adc	r24, r24
    1846:	99 1f       	adc	r25, r25
    1848:	1a 94       	dec	r1
    184a:	69 f7       	brne	.-38     	; 0x1826 <__udivmodsi4_loop>
    184c:	60 95       	com	r22
    184e:	70 95       	com	r23
    1850:	80 95       	com	r24
    1852:	90 95       	com	r25
    1854:	9b 01       	movw	r18, r22
    1856:	ac 01       	movw	r20, r24
    1858:	bd 01       	movw	r22, r26
    185a:	cf 01       	movw	r24, r30
    185c:	08 95       	ret

0000185e <_exit>:
    185e:	f8 94       	cli

00001860 <__stop_program>:
    1860:	ff cf       	rjmp	.-2      	; 0x1860 <__stop_program>
