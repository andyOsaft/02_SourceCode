
PowerCell.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000058  00800100  00006ebe  00006f52  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00006ebe  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000c6c  00800158  00800158  00006faa  2**0
                  ALLOC
  3 .stab         00002028  00000000  00000000  00006fac  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000900  00000000  00000000  00008fd4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000380  00000000  00000000  000098d8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000554e  00000000  00000000  00009c58  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001657  00000000  00000000  0000f1a6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000034cd  00000000  00000000  000107fd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000016d8  00000000  00000000  00013ccc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001e30  00000000  00000000  000153a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002d3a  00000000  00000000  000171d4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 49 07 	jmp	0xe92	; 0xe92 <__ctors_end>
       4:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
       8:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
       c:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      10:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      14:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      18:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      1c:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      20:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      24:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      28:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      2c:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      30:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      34:	0c 94 2d 1c 	jmp	0x385a	; 0x385a <__vector_13>
      38:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      3c:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      40:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      44:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      48:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      4c:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      50:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      54:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      58:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      5c:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      60:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      64:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      68:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      6c:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      70:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      74:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      78:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      7c:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      80:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      84:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>
      88:	0c 94 68 07 	jmp	0xed0	; 0xed0 <__bad_interrupt>

0000008c <font_fixed_8px_data>:
      8c:	00 00 00 00 00 00 00 3e 45 51 45 3e 00 3e 6b 6f     .......>EQE>.>ko
      9c:	6b 3e 00 1c 3e 7c 3e 1c 00 18 3c 7e 3c 18 00 30     k>..>|>...<~<..0
      ac:	36 7f 36 30 00 18 5c 7e 5c 18 00 00 00 00 00 00     6.60..\~\.......
	...
      cc:	00 00 00 30 48 4a 36 0e 00 06 29 79 29 06 00 00     ...0HJ6...)y)...
      dc:	00 00 00 00 00 60 7e 0a 35 3f 00 2a 1c 36 1c 2a     .....`~.5?.*.6.*
      ec:	00 00 7f 3e 1c 08 00 08 1c 3e 7f 00 00 14 36 7f     ...>.....>....6.
      fc:	36 14 00 00 5f 00 5f 00 00 06 09 7f 01 7f 00 22     6..._._........"
     10c:	4d 55 59 22 00 60 60 60 60 00 00 14 b6 ff b6 14     MUY".````.......
     11c:	00 04 06 7f 06 04 00 10 30 7f 30 10 00 08 08 3e     ........0.0....>
     12c:	1c 08 00 08 1c 3e 08 08 00 78 40 40 40 40 00 08     .....>...x@@@@..
     13c:	3e 08 3e 08 00 30 3c 3f 3c 30 00 03 0f 3f 0f 03     >.>..0<?<0...?..
	...
     154:	06 5f 06 00 00 07 03 00 07 03 00 24 7e 24 7e 24     ._.........$~$~$
     164:	00 24 2b 6a 12 00 00 63 13 08 64 63 00 36 49 56     .$+j...c..dc.6IV
     174:	20 50 00 00 07 03 00 00 00 00 3e 41 00 00 00 00      P........>A....
     184:	41 3e 00 00 00 08 3e 1c 3e 08 00 08 08 3e 08 08     A>....>.>....>..
     194:	00 00 e0 60 00 00 00 08 08 08 08 08 00 00 60 60     ...`..........``
     1a4:	00 00 00 20 10 08 04 02 00 3e 51 49 45 3e 00 00     ... .....>QIE>..
     1b4:	42 7f 40 00 00 62 51 49 49 46 00 22 49 49 49 36     B.@..bQIIF."III6
     1c4:	00 18 14 12 7f 10 00 2f 49 49 49 31 00 3c 4a 49     ......./III1.<JI
     1d4:	49 30 00 01 71 09 05 03 00 36 49 49 49 36 00 06     I0..q....6III6..
     1e4:	49 49 29 1e 00 00 6c 6c 00 00 00 00 ec 6c 00 00     II)...ll.....l..
     1f4:	00 08 14 22 41 00 00 24 24 24 24 24 00 00 41 22     ..."A..$$$$$..A"
     204:	14 08 00 02 01 59 09 06 00 3e 41 5d 55 1e 00 7e     .....Y...>A]U..~
     214:	11 11 11 7e 00 7f 49 49 49 36 00 3e 41 41 41 22     ...~..III6.>AAA"
     224:	00 7f 41 41 41 3e 00 7f 49 49 49 41 00 7f 09 09     ..AAA>..IIIA....
     234:	09 01 00 3e 41 49 49 7a 00 7f 08 08 08 7f 00 00     ...>AIIz........
     244:	41 7f 41 00 00 30 40 40 40 3f 00 7f 08 14 22 41     A.A..0@@@?...."A
     254:	00 7f 40 40 40 40 00 7f 02 04 02 7f 00 7f 02 04     ..@@@@..........
     264:	08 7f 00 3e 41 41 41 3e 00 7f 09 09 09 06 00 3e     ...>AAA>.......>
     274:	41 51 21 5e 00 7f 09 09 19 66 00 26 49 49 49 32     AQ!^.....f.&III2
     284:	00 01 01 7f 01 01 00 3f 40 40 40 3f 00 1f 20 40     .......?@@@?.. @
     294:	20 1f 00 3f 40 3c 40 3f 00 63 14 08 14 63 00 07      ..?@<@?.c...c..
     2a4:	08 70 08 07 00 71 49 45 43 00 00 00 7f 41 41 00     .p...qIEC....AA.
     2b4:	00 02 04 08 10 20 00 00 41 41 7f 00 00 04 02 01     ..... ..AA......
     2c4:	02 04 80 80 80 80 80 80 00 00 03 07 00 00 00 20     ............... 
     2d4:	54 54 54 78 00 7f 44 44 44 38 00 38 44 44 44 28     TTTx..DDD8.8DDD(
     2e4:	00 38 44 44 44 7f 00 38 54 54 54 08 00 08 7e 09     .8DDD..8TTT...~.
     2f4:	09 00 00 18 a4 a4 a4 7c 00 7f 04 04 78 00 00 00     .......|....x...
     304:	00 7d 40 00 00 40 80 84 7d 00 00 7f 10 28 44 00     .}@..@..}....(D.
     314:	00 00 00 7f 40 00 00 7c 04 18 04 78 00 7c 04 04     ....@..|...x.|..
     324:	78 00 00 38 44 44 44 38 00 fc 44 44 44 38 00 38     x..8DDD8..DDD8.8
     334:	44 44 44 fc 00 44 78 44 04 08 00 08 54 54 54 20     DDD..DxD....TTT 
     344:	00 04 3e 44 24 00 00 3c 40 20 7c 00 00 1c 20 40     ..>D$..<@ |... @
     354:	20 1c 00 3c 60 30 60 3c 00 6c 10 10 6c 00 00 9c      ..<`0`<.l..l...
     364:	a0 60 3c 00 00 64 54 54 4c 00 00 08 3e 41 41 00     .`<..dTTL...>AA.
     374:	00 00 00 77 00 00 00 00 41 41 3e 08 00 02 01 02     ...w....AA>.....
     384:	01 00 00 3c 26 23 26 3c 00 1e a1 e1 21 12 00 3d     ...<&#&<....!..=
     394:	40 20 7d 00 00 38 54 54 55 09 00 20 55 55 55 78     @ }..8TTU.. UUUx
     3a4:	00 20 55 54 55 78 00 20 55 55 54 78 00 20 57 55     . UTUx. UUTx. WU
     3b4:	57 78 00 1c a2 e2 22 14 00 38 55 55 55 08 00 38     Wx...."..8UUU..8
     3c4:	55 54 55 08 00 38 55 55 54 08 00 00 01 7c 41 00     UTU..8UUT....|A.
     3d4:	00 00 01 7d 41 00 00 00 01 7c 40 00 00 70 29 24     ...}A....|@..p)$
     3e4:	29 70 00 78 2f 25 2f 78 00 7c 54 54 55 45 00 34     )p.x/%/x.|TTUE.4
     3f4:	54 7c 54 58 00 7e 09 7f 49 49 00 38 45 45 39 00     T|TX.~..II.8EE9.
     404:	00 38 45 44 39 00 00 39 45 44 38 00 00 3c 41 21     .8ED9..9ED8..<A!
     414:	7d 00 00 3d 41 20 7c 00 00 9c a1 60 3d 00 00 3d     }..=A |....`=..=
     424:	42 42 3d 00 00 3c 41 40 3d 00 80 70 68 58 38 04     BB=..<A@=..phX8.
     434:	00 48 3e 49 49 62 00 7e 61 5d 43 3f 00 22 14 08     .H>IIb.~a]C?."..
     444:	14 22 00 40 88 7e 09 02 00 20 54 55 55 78 00 00     .".@.~... TUUx..
     454:	00 7d 41 00 00 38 44 45 39 00 00 3c 40 21 7d 00     .}A..8DE9..<@!}.
     464:	00 7a 09 0a 71 00 00 7a 11 22 79 00 00 08 55 55     .z..q..z."y...UU
     474:	55 5e 00 4e 51 51 4e 00 00 30 48 4d 40 20 3e 41     U^.NQQN..0HM@ >A
     484:	5d 4b 55 3e 04 04 04 04 04 1c 00 17 08 4c 6a 50     ]KU>.........LjP
     494:	00 17 08 34 2a 78 00 00 30 7d 30 00 00 08 14 00     ...4*x..0}0.....
     4a4:	08 14 00 14 08 00 14 08 44 11 44 11 44 11 aa 55     ........D.D.D..U
     4b4:	aa 55 aa 55 bb ee bb ee bb ee 00 00 00 ff 00 00     .U.U............
     4c4:	08 08 08 ff 00 00 00 70 28 25 29 70 00 70 29 25     .......p(%)p.p)%
     4d4:	29 70 00 70 29 25 28 70 3e 41 5d 55 41 3e 0a fb     )p.p)%(p>A]UA>..
     4e4:	00 ff 00 00 00 ff 00 ff 00 00 0a fa 02 fe 00 00     ................
     4f4:	0a 0b 08 0f 00 00 00 18 24 66 24 00 00 29 2a 7c     ........$f$..)*|
     504:	2a 29 08 08 08 f8 00 00 00 00 00 0f 08 08 08 08     *)..............
     514:	08 0f 08 08 08 08 08 f8 08 08 00 00 00 ff 08 08     ................
     524:	08 08 08 08 08 08 08 08 08 ff 08 08 00 20 56 55     ............. VU
     534:	56 79 00 70 2a 25 2a 71 00 0f 08 0b 0a 0a 00 fe     Vy.p*%*q........
     544:	02 fa 0a 0a 0a 0b 08 0b 0a 0a 0a fa 02 fa 0a 0a     ................
     554:	00 ff 00 fb 0a 0a 0a 0a 0a 0a 0a 0a 0a fb 00 fb     ................
     564:	0a 0a 00 5d 22 22 22 5d 00 22 55 59 30 00 00 08     ...]"""]."UY0...
     574:	7f 49 41 3e 00 7c 55 55 55 44 00 7c 55 54 55 44     .IA>.|UUUD.|UTUD
     584:	00 7c 55 55 54 44 00 00 00 07 00 00 00 00 44 7d     .|UUTD........D}
     594:	45 00 00 00 45 7d 45 00 00 00 45 7c 45 00 08 08     E...E}E...E|E...
     5a4:	08 0f 00 00 00 00 00 f8 08 08 ff ff ff ff ff ff     ................
     5b4:	f0 f0 f0 f0 f0 f0 00 00 00 77 00 00 00 00 45 7d     .........w....E}
     5c4:	44 00 0f 0f 0f 0f 0f 0f 00 3c 42 43 3d 00 00 fe     D........<BC=...
     5d4:	4a 4a 34 00 00 3c 43 43 3d 00 00 3d 43 42 3c 00     JJ4..<CC=..=CB<.
     5e4:	00 32 49 4a 31 00 00 3a 45 46 39 00 00 fc 20 20     .2IJ1..:EF9...  
     5f4:	1c 00 00 fe aa 28 10 00 00 ff a5 24 18 00 00 3c     .....(.....$...<
     604:	40 41 3d 00 00 3c 41 41 3d 00 00 3d 41 40 3c 00     @A=..<AA=..=A@<.
     614:	00 9c a0 61 3d 00 00 04 08 71 09 04 00 00 02 02     ...a=....q......
     624:	02 00 00 00 07 03 00 00 00 00 08 08 08 00 00 00     ................
     634:	24 2e 24 00 00 24 24 24 24 24 05 17 0a 34 2a 78     $.$..$$$$$...4*x
     644:	00 06 09 7f 01 7f 00 22 4d 55 59 22 00 08 08 2a     ......."MUY"...*
     654:	08 08 00 00 08 18 18 00 00 06 09 09 06 00 00 00     ................
     664:	08 00 08 00 00 00 08 00 00 00 00 02 0f 00 00 00     ................
     674:	00 09 0f 05 00 00 00 09 0d 0a 00 00 00 3c 3c 3c     .............<<<
     684:	3c 00 00 00 00 00 00 00                             <.......

0000068c <font_fixed_8px>:
     68c:	00 06 06 08 00 ff 00 00 8c 00                       ..........

00000696 <font_proportional_16px_data>:
     696:	04 02 05 08 07 09 07 02 04 04 06 07 03 05 02 07     ................
     6a6:	06 06 06 06 06 06 06 06 06 06 02 03 05 08 05 06     ................
     6b6:	09 08 07 07 07 06 06 07 07 04 05 07 06 08 07 07     ................
     6c6:	07 07 07 07 06 07 08 0a 08 08 06 04 05 04 08 08     ................
     6d6:	03 06 06 05 06 06 05 06 06 02 03 06 02 08 06 06     ................
     6e6:	06 06 05 06 05 06 07 08 06 07 06 06 02 06 07 00     ................
     6f6:	07 00 03 00 06 08 07 07 06 00 00 00 00 00 00 00     ................
     706:	00 03 03 06 06 07 08 00 00 00 00 00 00 00 00 00     ................
	...
     71e:	00 00 00 08 00 00 00 00 06 09 06 06 00 00 00 00     ................
     72e:	00 00 06 08 0a 0a 0a 00 00 00 00 00 08 00 00 00     ................
	...
     74a:	00 00 08 08 00 00 00 00 07 00 00 07 00 00 00 00     ................
     75a:	07 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
     76a:	00 00 07 00 07 00 00 00 07 00 00 00 00 00 00 00     ................
     77a:	00 f8 0d f8 0d 3c 00 3c 00 00 00 3c 00 3c 00 00     .....<.<...<.<..
     78a:	03 60 0f e0 03 78 03 60 0f e0 03 78 03 60 00 70     .`...x.`...x.`.p
     79a:	04 f8 08 88 08 fc 1f 88 08 88 0f 10 07 f8 00 88     ................
     7aa:	00 f8 0c 00 03 80 00 60 00 98 0f 80 08 80 0f 70     .......`.......p
     7ba:	07 f8 0f 88 08 f8 09 70 07 00 0e 00 0b 3c 00 3c     .......p.....<.<
     7ca:	00 e0 0f f8 3f 1c 70 04 40 04 40 1c 70 f8 3f e0     ....?.p.@.@.p.?.
     7da:	0f 28 00 10 00 7c 00 7c 00 10 00 28 00 80 00 80     .(...|.|...(....
     7ea:	00 80 00 f0 07 80 00 80 00 80 00 00 18 00 1e 00     ................
     7fa:	06 80 00 80 00 80 00 80 00 80 00 00 0c 00 0c 00     ................
     80a:	00 00 0c 00 03 c0 00 30 00 0c 00 00 00 f0 07 f8     .......0........
     81a:	0f 08 08 08 08 f8 0f f0 07 10 08 10 08 f8 0f f8     ................
     82a:	0f 00 08 00 08 30 0c 08 0e 08 0b 88 09 f8 08 70     .....0.........p
     83a:	08 10 04 08 08 88 08 88 08 f8 0f 70 07 80 01 60     ...........p...`
     84a:	01 10 01 f8 0f f8 0f 00 01 00 04 78 08 78 08 48     ...........x.x.H
     85a:	08 c8 0f 88 07 e0 07 f0 0f 58 08 48 08 c8 0f 80     .........X.H....
     86a:	07 08 00 08 0e 88 0f e8 01 78 00 18 00 70 07 f8     .........x...p..
     87a:	0f 88 08 88 08 f8 0f 70 07 f0 00 f8 09 08 09 08     .......p........
     88a:	0d f8 07 f0 03 60 0c 60 0c 00 18 30 1e 30 06 80     .....`.`...0.0..
     89a:	01 c0 03 60 06 30 0c 18 18 30 03 30 03 30 03 30     ...`.0...0.0.0.0
     8aa:	03 30 03 30 03 30 03 30 03 18 18 30 0c 60 06 c0     .0.0.0.0...0.`..
     8ba:	03 80 01 10 00 08 00 88 0d c8 0d 78 00 30 00 e0     ...........x.0..
     8ca:	07 10 08 c8 13 e8 17 28 14 e8 13 e8 17 10 14 e0     .......(........
     8da:	03 00 0c 80 0f e0 03 38 01 38 01 e0 03 80 0f 00     .......8.8......
     8ea:	0c f8 0f f8 0f 88 08 88 08 88 08 f8 0f 70 07 f0     .............p..
     8fa:	07 f8 0f 08 08 08 08 08 08 08 08 30 06 f8 0f f8     ...........0....
     90a:	0f 08 08 08 08 18 0c f0 07 e0 03 f8 0f f8 0f 88     ................
     91a:	08 88 08 88 08 08 08 f8 0f f8 0f 88 00 88 00 88     ................
     92a:	00 08 00 f0 07 f8 0f 08 08 08 08 88 08 88 0f b0     ................
     93a:	0f f8 0f f8 0f 80 00 80 00 80 00 f8 0f f8 0f 08     ................
     94a:	08 f8 0f f8 0f 08 08 00 08 08 08 08 08 f8 0f f8     ................
     95a:	07 f8 0f f8 0f c0 01 60 03 30 06 18 0c 08 08 f8     .......`.0......
     96a:	0f f8 0f 00 08 00 08 00 08 00 08 f8 0f 78 00 e0     .............x..
     97a:	01 80 07 80 01 60 00 f8 0f f8 0f f8 0f 18 00 78     .....`.........x
     98a:	00 e0 01 80 07 00 0e f8 0f f0 07 f8 0f 08 08 08     ................
     99a:	08 08 08 f8 0f f0 07 f8 0f f8 0f 08 01 08 01 08     ................
     9aa:	01 f8 01 f0 00 f0 07 f8 0f 08 08 08 08 08 18 f8     ................
     9ba:	1f f0 17 f8 0f f8 0f 88 00 88 01 88 03 f8 06 70     ...............p
     9ca:	0c 70 06 f8 08 88 08 88 08 88 08 88 0f 30 07 08     .p...........0..
     9da:	00 08 00 f8 0f f8 0f 08 00 08 00 f8 07 f8 0f 00     ................
     9ea:	08 00 08 00 08 f8 0f f8 07 38 00 f8 00 c0 03 00     .........8......
     9fa:	0f 00 0f c0 03 f8 00 38 00 f8 03 f8 0f 00 0f c0     .......8........
     a0a:	03 f0 00 f0 00 c0 03 00 0f f8 0f f8 03 18 0c 38     ...............8
     a1a:	0e 60 03 c0 01 c0 01 60 03 38 0e 18 0c 18 00 78     .`.....`.8.....x
     a2a:	00 e0 00 80 0f 80 0f e0 00 78 00 18 00 08 0e 08     .........x......
     a3a:	0f 88 09 c8 08 78 08 38 08 fc 1f fc 1f 04 10 04     .....x.8........
     a4a:	10 0c 00 30 00 c0 00 00 03 00 0c 04 10 04 10 fc     ...0............
     a5a:	1f fc 1f 40 00 20 00 10 00 08 00 08 00 10 00 20     ...@. ......... 
     a6a:	00 40 00 00 10 00 10 00 10 00 10 00 10 00 10 00     .@..............
     a7a:	10 00 10 04 00 0c 00 08 00 00 06 40 0f 20 09 20     ...........@. . 
     a8a:	09 e0 0f c0 0f fc 0f fc 0f 40 08 20 08 e0 0f c0     .........@. ....
     a9a:	07 c0 07 e0 0f 20 08 20 08 40 04 c0 07 e0 0f 20     ..... . .@..... 
     aaa:	08 20 04 fc 0f fc 0f c0 07 e0 0f 20 09 20 09 e0     . ......... . ..
     aba:	09 c0 05 20 00 f8 0f fc 0f 24 00 04 00 c0 27 e0     ... .....$....'.
     aca:	4f 20 48 20 44 e0 7f e0 3f fc 0f fc 0f 40 00 20     O H D...?....@. 
     ada:	00 e0 0f c0 0f ec 0f ec 0f 20 40 ec 7f ec 3f fc     ......... @...?.
     aea:	0f fc 0f 80 03 c0 06 60 0c 20 08 fc 0f fc 0f e0     .......`. ......
     afa:	0f e0 0f 20 00 e0 0f c0 0f 20 00 e0 0f c0 0f e0     ... ..... ......
     b0a:	0f e0 0f 40 00 20 00 e0 0f c0 0f c0 07 e0 0f 20     ...@. ......... 
     b1a:	08 20 08 e0 0f c0 07 e0 7f e0 7f 40 08 20 08 e0     . .........@. ..
     b2a:	0f c0 07 c0 07 e0 0f 20 08 20 04 e0 7f e0 7f e0     ....... . ......
     b3a:	0f e0 0f 40 00 60 00 60 00 c0 04 e0 09 a0 09 20     ...@.`.`....... 
     b4a:	0b 20 0f 40 06 20 00 f8 07 f8 0f 20 08 20 08 e0     . .@. ..... . ..
     b5a:	07 e0 0f 00 08 00 04 e0 0f e0 0f e0 00 e0 03 00     ................
     b6a:	0f 00 0c 00 0f e0 03 e0 00 e0 00 e0 07 00 0e c0     ................
     b7a:	03 c0 03 00 0e e0 07 e0 00 60 0c e0 0e 80 03 80     .........`......
     b8a:	03 e0 0e 60 0c e0 00 e0 03 00 6f 00 7c 00 1f e0     ...`......o.|...
     b9a:	03 e0 00 20 0c 20 0e 20 0b a0 09 e0 08 60 08 80     ... . . .....`..
     baa:	00 80 00 f8 1f 7c 3f 04 20 04 20 fc 3f fc 3f 04     .....|?. . .?.?.
     bba:	20 04 20 7c 3f f8 1f 80 00 80 00 80 03 c0 00 c0      . |?...........
     bca:	00 80 01 00 03 00 03 c0 01 e0 03 f0 07 58 0d 48     .............X.H
     bda:	09 48 09 48 09 10 04 00 20 00 3c 00 1c 00 20 00     .H.H.... .<... .
     bea:	3c 00 1c 00 20 00 3c 00 1c 00 0c 00 0c 00 00 00     <... .<.........
     bfa:	0c 00 0c 00 00 00 0c 00 0c 00 00 10 00 10 00 fc     ................
     c0a:	07 fc 07 10 00 10 00 00 00 10 01 10 01 fc 07 fc     ................
     c1a:	07 10 01 10 01 00 00 08 00 0c 00 04 00 0c 00 08     ................
     c2a:	00 1c 00 3c 00 20 00 20 00 3c 00 1c 00 1c 00 3c     ...<. . .<.....<
     c3a:	00 20 00 1c 00 3c 00 20 00 20 00 3c 00 1c 00 20     . ...<. . .<... 
     c4a:	00 3c 00 1c 00 00 00 c0 03 e0 07 e0 07 e0 07 e0     .<..............
     c5a:	07 c0 03 80 00 80 00 80 00 80 00 80 00 80 00 80     ................
     c6a:	00 80 00 00 00 80 01 c0 03 60 06 00 00 80 01 c0     .........`......
     c7a:	03 60 06 00 00 70 00 88 00 88 00 88 00 70 00 00     .`...p.......p..
     c8a:	00 00 00 80 08 80 08 80 08 f0 0f 80 08 80 08 80     ................
     c9a:	08 00 00 10 01 88 01 c8 01 78 01 30 01 00 00 90     .........x.0....
     caa:	00 08 01 28 01 f8 01 d0 00 f0 00 f8 01 08 01 08     ...(............
     cba:	01 f8 01 f0 00 00 00 60 06 c0 03 80 01 00 00 60     .......`.......`
     cca:	06 c0 03 80 01 10 00 f8 09 00 04 00 03 80 00 60     ...............`
     cda:	06 10 05 88 04 c0 0f 00 04 10 00 f8 09 00 04 00     ................
     cea:	03 80 00 60 00 90 08 48 0c 40 0a 80 09 88 00 a8     ...`...H.@......
     cfa:	08 d8 04 00 02 80 01 60 06 10 05 88 04 c0 0f 00     .......`........
     d0a:	04 00 0c 86 0f e6 03 38 01 38 01 e6 03 86 0f 00     .......8.8......
     d1a:	0c e0 07 f6 0f 16 08 10 08 10 08 16 08 f6 0f e0     ................
     d2a:	07 00 00 00 00 00 00 20 02 40 01 80 00 40 01 20     ....... .@...@. 
     d3a:	02 f0 07 f6 0f 06 08 00 08 06 08 f6 0f f0 07 f8     ................
     d4a:	0f fc 0f 04 00 44 08 7c 08 f8 0f 80 07 00 06 4c     .....D.|.......L
     d5a:	0f 2c 09 20 09 2c 09 ec 0f c0 0f c0 07 ec 0f 2c     .,. .,.........,
     d6a:	08 20 08 2c 08 ec 0f c0 07 c0 17 e0 0f 20 0e 20     . .,......... . 
     d7a:	09 e0 08 e0 0f d0 07 e0 07 ec 0f 0c 08 00 08 0c     ................
     d8a:	04 ec 0f e0 0f                                      .....

00000d8f <font_proportional_16px>:
     d8f:	00 07 0b 10 20 fc 96 06 73 07                       .... ...s.

00000d99 <__c.2411>:
     d99:	2a 20 6e 65 78 74 2d 3e 20 00                       * next-> .

00000da3 <__c.2413>:
     da3:	2a 20 20 20 20 20 20 20 20 00                       *        .

00000dad <__c.2415>:
     dad:	2a 20 20 20 20 20 20 20 20 00                       *        .

00000db7 <__c.2417>:
     db7:	2a 20 64 65 74 61 69 6c 20 00                       * detail .

00000dc1 <__c.2422>:
     dc1:	43 75 72 72 65 6e 74 4d 6f 6e 00                    CurrentMon.

00000dcc <__c.2425>:
     dcc:	43 75 72 72 65 6e 74 20 4d 6f 6e 69 74 6f 72 3a     Current Monitor:
	...

00000ddd <__c.2427>:
     ddd:	53 6f 6c 61 72 3a 20 00                             Solar: .

00000de5 <__c.2429>:
     de5:	20 6d 41 00                                          mA.

00000de9 <__c.2431>:
     de9:	43 6f 6e 73 75 6d 65 72 3a 20 00                    Consumer: .

00000df4 <__c.2433>:
     df4:	20 6d 41 00                                          mA.

00000df8 <__c.2436>:
     df8:	56 6f 6c 74 61 67 65 4d 6f 6e 00                    VoltageMon.

00000e03 <__c.2439>:
     e03:	56 6f 6c 74 61 67 65 20 4d 6f 6e 69 74 6f 72 3a     Voltage Monitor:
	...

00000e14 <__c.2441>:
     e14:	42 61 74 74 65 72 79 3a 20 00                       Battery: .

00000e1e <__c.2443>:
     e1e:	20 6d 56 00                                          mV.

00000e22 <__c.2445>:
     e22:	53 6f 6c 61 72 3a 20 00                             Solar: .

00000e2a <__c.2447>:
     e2a:	20 6d 56 00                                          mV.

00000e2e <__c.2450>:
     e2e:	54 65 6d 70 4d 6f 6e 20 20 20 00                    TempMon   .

00000e39 <__c.2453>:
     e39:	54 65 6d 70 65 72 61 74 75 72 65 20 4d 6f 6e 69     Temperature Moni
     e49:	74 6f 72 3a 00                                      tor:.

00000e4e <__c.2456>:
     e4e:	53 79 73 53 74 61 74 75 73 20 00                    SysStatus .

00000e59 <__c.2459>:
     e59:	53 79 73 74 65 6d 20 53 74 61 74 75 73 3a 00        System Status:.

00000e68 <__c.2462>:
     e68:	4c 6f 67 67 69 6e 67 20 20 20 20 00                 Logging    .

00000e74 <__c.2465>:
     e74:	4c 6f 67 67 69 6e 67 3a 00                          Logging:.

00000e7d <__c.2468>:
     e7d:	53 77 69 74 63 68 4f 66 66 20 00                    SwitchOff .

00000e88 <__c.2470>:
     e88:	2a 20 64 6f 20 69 74 20 00 00                       * do it ..

00000e92 <__ctors_end>:
     e92:	11 24       	eor	r1, r1
     e94:	1f be       	out	0x3f, r1	; 63
     e96:	cf ef       	ldi	r28, 0xFF	; 255
     e98:	d0 e4       	ldi	r29, 0x40	; 64
     e9a:	de bf       	out	0x3e, r29	; 62
     e9c:	cd bf       	out	0x3d, r28	; 61

00000e9e <__do_copy_data>:
     e9e:	11 e0       	ldi	r17, 0x01	; 1
     ea0:	a0 e0       	ldi	r26, 0x00	; 0
     ea2:	b1 e0       	ldi	r27, 0x01	; 1
     ea4:	ee eb       	ldi	r30, 0xBE	; 190
     ea6:	fe e6       	ldi	r31, 0x6E	; 110
     ea8:	00 e0       	ldi	r16, 0x00	; 0
     eaa:	0b bf       	out	0x3b, r16	; 59
     eac:	02 c0       	rjmp	.+4      	; 0xeb2 <__do_copy_data+0x14>
     eae:	07 90       	elpm	r0, Z+
     eb0:	0d 92       	st	X+, r0
     eb2:	a8 35       	cpi	r26, 0x58	; 88
     eb4:	b1 07       	cpc	r27, r17
     eb6:	d9 f7       	brne	.-10     	; 0xeae <__do_copy_data+0x10>

00000eb8 <__do_clear_bss>:
     eb8:	1d e0       	ldi	r17, 0x0D	; 13
     eba:	a8 e5       	ldi	r26, 0x58	; 88
     ebc:	b1 e0       	ldi	r27, 0x01	; 1
     ebe:	01 c0       	rjmp	.+2      	; 0xec2 <.do_clear_bss_start>

00000ec0 <.do_clear_bss_loop>:
     ec0:	1d 92       	st	X+, r1

00000ec2 <.do_clear_bss_start>:
     ec2:	a4 3c       	cpi	r26, 0xC4	; 196
     ec4:	b1 07       	cpc	r27, r17
     ec6:	e1 f7       	brne	.-8      	; 0xec0 <.do_clear_bss_loop>
     ec8:	0e 94 a6 13 	call	0x274c	; 0x274c <main>
     ecc:	0c 94 5d 37 	jmp	0x6eba	; 0x6eba <_exit>

00000ed0 <__bad_interrupt>:
     ed0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000ed4 <adcInit>:

#include "adc.h"
#include <avr/io.h>

void adcInit()
{
     ed4:	cf 93       	push	r28
     ed6:	df 93       	push	r29
     ed8:	00 d0       	rcall	.+0      	; 0xeda <adcInit+0x6>
     eda:	cd b7       	in	r28, 0x3d	; 61
     edc:	de b7       	in	r29, 0x3e	; 62
        CPU Frequenz: 8MHz
        -> Prescaler 64 -> ADC Frequenz 125kHz
            
    */
    
    ADCSRA |= (1<<ADEN);
     ede:	8a e7       	ldi	r24, 0x7A	; 122
     ee0:	90 e0       	ldi	r25, 0x00	; 0
     ee2:	2a e7       	ldi	r18, 0x7A	; 122
     ee4:	30 e0       	ldi	r19, 0x00	; 0
     ee6:	f9 01       	movw	r30, r18
     ee8:	20 81       	ld	r18, Z
     eea:	20 68       	ori	r18, 0x80	; 128
     eec:	fc 01       	movw	r30, r24
     eee:	20 83       	st	Z, r18
    
    //Differential Test:
    // * negative input -> ADC1
    // * positive input -> ADC0
    ADMUX |= ( 1<<MUX4 );  
     ef0:	8c e7       	ldi	r24, 0x7C	; 124
     ef2:	90 e0       	ldi	r25, 0x00	; 0
     ef4:	2c e7       	ldi	r18, 0x7C	; 124
     ef6:	30 e0       	ldi	r19, 0x00	; 0
     ef8:	f9 01       	movw	r30, r18
     efa:	20 81       	ld	r18, Z
     efc:	20 61       	ori	r18, 0x10	; 16
     efe:	fc 01       	movw	r30, r24
     f00:	20 83       	st	Z, r18
   
 
    
    ADCSRA |= ((1<<ADPS2) | (1<<ADPS1) | (1<<ADSC));
     f02:	8a e7       	ldi	r24, 0x7A	; 122
     f04:	90 e0       	ldi	r25, 0x00	; 0
     f06:	2a e7       	ldi	r18, 0x7A	; 122
     f08:	30 e0       	ldi	r19, 0x00	; 0
     f0a:	f9 01       	movw	r30, r18
     f0c:	20 81       	ld	r18, Z
     f0e:	26 64       	ori	r18, 0x46	; 70
     f10:	fc 01       	movw	r30, r24
     f12:	20 83       	st	Z, r18

    /* Auf Abschluss der Konvertierung warten
       Das Register ADCSRA wird mit "1<<ADSC" maskiert. Da ADSC den Wert 6 hat, wartet das while 
       also solange, bis das Bit6 von ADCSRA == 0 wird.
    */
    while (ADCSRA & (1<<ADSC) ) {}
     f14:	00 00       	nop
     f16:	8a e7       	ldi	r24, 0x7A	; 122
     f18:	90 e0       	ldi	r25, 0x00	; 0
     f1a:	fc 01       	movw	r30, r24
     f1c:	80 81       	ld	r24, Z
     f1e:	88 2f       	mov	r24, r24
     f20:	90 e0       	ldi	r25, 0x00	; 0
     f22:	80 74       	andi	r24, 0x40	; 64
     f24:	90 70       	andi	r25, 0x00	; 0
     f26:	00 97       	sbiw	r24, 0x00	; 0
     f28:	b1 f7       	brne	.-20     	; 0xf16 <adcInit+0x42>
    //ADCSRA |= (1<<ADIE);				
  
    /* ADCW muss einmal gelesen werden, sonst wird Ergebnis der n‰chsten
        Wandlung nicht ¸bernommen. 
    */
    result = ADCW;		 
     f2a:	88 e7       	ldi	r24, 0x78	; 120
     f2c:	90 e0       	ldi	r25, 0x00	; 0
     f2e:	fc 01       	movw	r30, r24
     f30:	80 81       	ld	r24, Z
     f32:	91 81       	ldd	r25, Z+1	; 0x01
     f34:	9a 83       	std	Y+2, r25	; 0x02
     f36:	89 83       	std	Y+1, r24	; 0x01
   
}
     f38:	0f 90       	pop	r0
     f3a:	0f 90       	pop	r0
     f3c:	df 91       	pop	r29
     f3e:	cf 91       	pop	r28
     f40:	08 95       	ret

00000f42 <adcRead>:



**************************************************************************************************************/
uint16_t adcRead(uint8_t channel)
{
     f42:	cf 93       	push	r28
     f44:	df 93       	push	r29
     f46:	00 d0       	rcall	.+0      	; 0xf48 <adcRead+0x6>
     f48:	00 d0       	rcall	.+0      	; 0xf4a <adcRead+0x8>
     f4a:	0f 92       	push	r0
     f4c:	cd b7       	in	r28, 0x3d	; 61
     f4e:	de b7       	in	r29, 0x3e	; 62
     f50:	8d 83       	std	Y+5, r24	; 0x05
	uint32_t result;
  
  
    if( channel == BATTERY_VOLTAGE )
     f52:	8d 81       	ldd	r24, Y+5	; 0x05
     f54:	88 23       	and	r24, r24
     f56:	31 f4       	brne	.+12     	; 0xf64 <adcRead+0x22>
    {
        //Single Ended
        //ADMUX:            00101
        //Absolute Input:   ADC5
        ADMUX = 0x05;
     f58:	8c e7       	ldi	r24, 0x7C	; 124
     f5a:	90 e0       	ldi	r25, 0x00	; 0
     f5c:	25 e0       	ldi	r18, 0x05	; 5
     f5e:	fc 01       	movw	r30, r24
     f60:	20 83       	st	Z, r18
     f62:	23 c0       	rjmp	.+70     	; 0xfaa <adcRead+0x68>
    }
    else if( channel == TEMPERATURE_SENSOR_VOLTAGE )
     f64:	8d 81       	ldd	r24, Y+5	; 0x05
     f66:	81 30       	cpi	r24, 0x01	; 1
     f68:	31 f4       	brne	.+12     	; 0xf76 <adcRead+0x34>
    {
        //Single Ended
        //ADMUX:            00110
        //Absolute Input:   ADC6
        ADMUX = 0x06;        
     f6a:	8c e7       	ldi	r24, 0x7C	; 124
     f6c:	90 e0       	ldi	r25, 0x00	; 0
     f6e:	26 e0       	ldi	r18, 0x06	; 6
     f70:	fc 01       	movw	r30, r24
     f72:	20 83       	st	Z, r18
     f74:	1a c0       	rjmp	.+52     	; 0xfaa <adcRead+0x68>
    }
    else if( channel == SOLAR_REGULATOR_CURRENT )
     f76:	8d 81       	ldd	r24, Y+5	; 0x05
     f78:	82 30       	cpi	r24, 0x02	; 2
     f7a:	31 f4       	brne	.+12     	; 0xf88 <adcRead+0x46>
    {
        //Differential Ended
        //ADMUX:            10000
        //Negative Input:   ADC1
        //Positive Input:   ADC0
        ADMUX = 0x10;   
     f7c:	8c e7       	ldi	r24, 0x7C	; 124
     f7e:	90 e0       	ldi	r25, 0x00	; 0
     f80:	20 e1       	ldi	r18, 0x10	; 16
     f82:	fc 01       	movw	r30, r24
     f84:	20 83       	st	Z, r18
     f86:	11 c0       	rjmp	.+34     	; 0xfaa <adcRead+0x68>
    }   
    else if( channel == WIND_REGULATOR_CURRENT )
     f88:	8d 81       	ldd	r24, Y+5	; 0x05
     f8a:	83 30       	cpi	r24, 0x03	; 3
     f8c:	31 f4       	brne	.+12     	; 0xf9a <adcRead+0x58>
    {
        //Differential Ended
        //ADMUX:            10011
        //Negative Input:   ADC1
        //Positive Input:   ADC3
        ADMUX = 0x13;       
     f8e:	8c e7       	ldi	r24, 0x7C	; 124
     f90:	90 e0       	ldi	r25, 0x00	; 0
     f92:	23 e1       	ldi	r18, 0x13	; 19
     f94:	fc 01       	movw	r30, r24
     f96:	20 83       	st	Z, r18
     f98:	08 c0       	rjmp	.+16     	; 0xfaa <adcRead+0x68>
    }   
    else if( channel == CONSUMER_CURRENT )          
     f9a:	8d 81       	ldd	r24, Y+5	; 0x05
     f9c:	84 30       	cpi	r24, 0x04	; 4
     f9e:	29 f4       	brne	.+10     	; 0xfaa <adcRead+0x68>
    {
        //Differential Ended
        //ADMUX:            11100   
        //Negative Input:   ADC2
        //Positive Input:   ADC4
        ADMUX = 0x1C;
     fa0:	8c e7       	ldi	r24, 0x7C	; 124
     fa2:	90 e0       	ldi	r25, 0x00	; 0
     fa4:	2c e1       	ldi	r18, 0x1C	; 28
     fa6:	fc 01       	movw	r30, r24
     fa8:	20 83       	st	Z, r18
    }
   
    //start measurement only if correct channel has been selected
    if( channel >= BATTERY_VOLTAGE && channel <= CONSUMER_CURRENT)
     faa:	8d 81       	ldd	r24, Y+5	; 0x05
     fac:	85 30       	cpi	r24, 0x05	; 5
     fae:	08 f0       	brcs	.+2      	; 0xfb2 <adcRead+0x70>
     fb0:	3f c0       	rjmp	.+126    	; 0x1030 <adcRead+0xee>
    {
	    /* Single Konvertierung anstoﬂen */
  	    ADCSRA |= (1<<ADSC);	
     fb2:	8a e7       	ldi	r24, 0x7A	; 122
     fb4:	90 e0       	ldi	r25, 0x00	; 0
     fb6:	2a e7       	ldi	r18, 0x7A	; 122
     fb8:	30 e0       	ldi	r19, 0x00	; 0
     fba:	f9 01       	movw	r30, r18
     fbc:	20 81       	ld	r18, Z
     fbe:	20 64       	ori	r18, 0x40	; 64
     fc0:	fc 01       	movw	r30, r24
     fc2:	20 83       	st	Z, r18
    

  	    /* Auf Abschluss der Konvertierung warten */
 	    while (ADCSRA & (1<<ADSC) ) {}
     fc4:	00 00       	nop
     fc6:	8a e7       	ldi	r24, 0x7A	; 122
     fc8:	90 e0       	ldi	r25, 0x00	; 0
     fca:	fc 01       	movw	r30, r24
     fcc:	80 81       	ld	r24, Z
     fce:	88 2f       	mov	r24, r24
     fd0:	90 e0       	ldi	r25, 0x00	; 0
     fd2:	80 74       	andi	r24, 0x40	; 64
     fd4:	90 70       	andi	r25, 0x00	; 0
     fd6:	00 97       	sbiw	r24, 0x00	; 0
     fd8:	b1 f7       	brne	.-20     	; 0xfc6 <adcRead+0x84>
	

	    /* Ergebnis als Bitwert */
	    result = (uint32_t) ADCW;
     fda:	88 e7       	ldi	r24, 0x78	; 120
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	fc 01       	movw	r30, r24
     fe0:	80 81       	ld	r24, Z
     fe2:	91 81       	ldd	r25, Z+1	; 0x01
     fe4:	cc 01       	movw	r24, r24
     fe6:	a0 e0       	ldi	r26, 0x00	; 0
     fe8:	b0 e0       	ldi	r27, 0x00	; 0
     fea:	89 83       	std	Y+1, r24	; 0x01
     fec:	9a 83       	std	Y+2, r25	; 0x02
     fee:	ab 83       	std	Y+3, r26	; 0x03
     ff0:	bc 83       	std	Y+4, r27	; 0x04

	    /* Wandlungsergebnis in die Realspannung umrechnen 
            -> + 512 -> Korrekte Rundung durch Addition des halben Divisors    
        */
        result = ( (18696 * result ) + 512 ) / 1023; 
     ff2:	89 81       	ldd	r24, Y+1	; 0x01
     ff4:	9a 81       	ldd	r25, Y+2	; 0x02
     ff6:	ab 81       	ldd	r26, Y+3	; 0x03
     ff8:	bc 81       	ldd	r27, Y+4	; 0x04
     ffa:	28 e0       	ldi	r18, 0x08	; 8
     ffc:	39 e4       	ldi	r19, 0x49	; 73
     ffe:	40 e0       	ldi	r20, 0x00	; 0
    1000:	50 e0       	ldi	r21, 0x00	; 0
    1002:	bc 01       	movw	r22, r24
    1004:	cd 01       	movw	r24, r26
    1006:	0e 94 29 36 	call	0x6c52	; 0x6c52 <__mulsi3>
    100a:	dc 01       	movw	r26, r24
    100c:	cb 01       	movw	r24, r22
    100e:	80 50       	subi	r24, 0x00	; 0
    1010:	9e 4f       	sbci	r25, 0xFE	; 254
    1012:	af 4f       	sbci	r26, 0xFF	; 255
    1014:	bf 4f       	sbci	r27, 0xFF	; 255
    1016:	2f ef       	ldi	r18, 0xFF	; 255
    1018:	33 e0       	ldi	r19, 0x03	; 3
    101a:	40 e0       	ldi	r20, 0x00	; 0
    101c:	50 e0       	ldi	r21, 0x00	; 0
    101e:	bc 01       	movw	r22, r24
    1020:	cd 01       	movw	r24, r26
    1022:	0e 94 68 36 	call	0x6cd0	; 0x6cd0 <__udivmodsi4>
    1026:	29 83       	std	Y+1, r18	; 0x01
    1028:	3a 83       	std	Y+2, r19	; 0x02
    102a:	4b 83       	std	Y+3, r20	; 0x03
    102c:	5c 83       	std	Y+4, r21	; 0x04
    102e:	08 c0       	rjmp	.+16     	; 0x1040 <adcRead+0xfe>
    }
    else
    {
        result = 0xFFFF;
    1030:	8f ef       	ldi	r24, 0xFF	; 255
    1032:	9f ef       	ldi	r25, 0xFF	; 255
    1034:	a0 e0       	ldi	r26, 0x00	; 0
    1036:	b0 e0       	ldi	r27, 0x00	; 0
    1038:	89 83       	std	Y+1, r24	; 0x01
    103a:	9a 83       	std	Y+2, r25	; 0x02
    103c:	ab 83       	std	Y+3, r26	; 0x03
    103e:	bc 83       	std	Y+4, r27	; 0x04
    }        
         
	return (uint16_t) result;
    1040:	89 81       	ldd	r24, Y+1	; 0x01
    1042:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1044:	0f 90       	pop	r0
    1046:	0f 90       	pop	r0
    1048:	0f 90       	pop	r0
    104a:	0f 90       	pop	r0
    104c:	0f 90       	pop	r0
    104e:	df 91       	pop	r29
    1050:	cf 91       	pop	r28
    1052:	08 95       	ret

00001054 <measureBattVoltage>:


uint16_t measureBattVoltage()
{
    1054:	cf 93       	push	r28
    1056:	df 93       	push	r29
    1058:	cd b7       	in	r28, 0x3d	; 61
    105a:	de b7       	in	r29, 0x3e	; 62
    return( adcRead( BATTERY_VOLTAGE ) );    
    105c:	80 e0       	ldi	r24, 0x00	; 0
    105e:	0e 94 a1 07 	call	0xf42	; 0xf42 <adcRead>
}
    1062:	df 91       	pop	r29
    1064:	cf 91       	pop	r28
    1066:	08 95       	ret

00001068 <measureSolarChargeCurrent>:

uint16_t measureSolarChargeCurrent()
{
    1068:	cf 93       	push	r28
    106a:	df 93       	push	r29
    106c:	cd b7       	in	r28, 0x3d	; 61
    106e:	de b7       	in	r29, 0x3e	; 62
    1070:	28 97       	sbiw	r28, 0x08	; 8
    1072:	0f b6       	in	r0, 0x3f	; 63
    1074:	f8 94       	cli
    1076:	de bf       	out	0x3e, r29	; 62
    1078:	0f be       	out	0x3f, r0	; 63
    107a:	cd bf       	out	0x3d, r28	; 61
    uint32_t shuntVoltage;
    uint32_t shuntCurrent;
    
    shuntVoltage = (uint32_t) adcRead( SOLAR_REGULATOR_CURRENT );
    107c:	82 e0       	ldi	r24, 0x02	; 2
    107e:	0e 94 a1 07 	call	0xf42	; 0xf42 <adcRead>
    1082:	cc 01       	movw	r24, r24
    1084:	a0 e0       	ldi	r26, 0x00	; 0
    1086:	b0 e0       	ldi	r27, 0x00	; 0
    1088:	89 83       	std	Y+1, r24	; 0x01
    108a:	9a 83       	std	Y+2, r25	; 0x02
    108c:	ab 83       	std	Y+3, r26	; 0x03
    108e:	bc 83       	std	Y+4, r27	; 0x04
    
    //calculate current flow through shunt resistor [mA]
    //-> *1000 because result has to be in mA (otherwise the 10^-3 of mV and mOhm would cancel each other)
    //shuntCurrent = ( 1000 * shuntVoltage + ( SOLAR_REGULATOR_SHUNT_mOHM >> 2 ) ) / SOLAR_REGULATOR_SHUNT_mOHM; 
    
    shuntCurrent = ( 1000 * shuntVoltage );
    1090:	89 81       	ldd	r24, Y+1	; 0x01
    1092:	9a 81       	ldd	r25, Y+2	; 0x02
    1094:	ab 81       	ldd	r26, Y+3	; 0x03
    1096:	bc 81       	ldd	r27, Y+4	; 0x04
    1098:	28 ee       	ldi	r18, 0xE8	; 232
    109a:	33 e0       	ldi	r19, 0x03	; 3
    109c:	40 e0       	ldi	r20, 0x00	; 0
    109e:	50 e0       	ldi	r21, 0x00	; 0
    10a0:	bc 01       	movw	r22, r24
    10a2:	cd 01       	movw	r24, r26
    10a4:	0e 94 29 36 	call	0x6c52	; 0x6c52 <__mulsi3>
    10a8:	dc 01       	movw	r26, r24
    10aa:	cb 01       	movw	r24, r22
    10ac:	8d 83       	std	Y+5, r24	; 0x05
    10ae:	9e 83       	std	Y+6, r25	; 0x06
    10b0:	af 83       	std	Y+7, r26	; 0x07
    10b2:	b8 87       	std	Y+8, r27	; 0x08
    shuntCurrent = ( shuntCurrent + ( SOLAR_REGULATOR_SHUNT_mOHM >> 2 ) ) / SOLAR_REGULATOR_SHUNT_mOHM;
    10b4:	8d 81       	ldd	r24, Y+5	; 0x05
    10b6:	9e 81       	ldd	r25, Y+6	; 0x06
    10b8:	af 81       	ldd	r26, Y+7	; 0x07
    10ba:	b8 85       	ldd	r27, Y+8	; 0x08
    10bc:	85 54       	subi	r24, 0x45	; 69
    10be:	9f 4f       	sbci	r25, 0xFF	; 255
    10c0:	af 4f       	sbci	r26, 0xFF	; 255
    10c2:	bf 4f       	sbci	r27, 0xFF	; 255
    10c4:	2e ee       	ldi	r18, 0xEE	; 238
    10c6:	32 e0       	ldi	r19, 0x02	; 2
    10c8:	40 e0       	ldi	r20, 0x00	; 0
    10ca:	50 e0       	ldi	r21, 0x00	; 0
    10cc:	bc 01       	movw	r22, r24
    10ce:	cd 01       	movw	r24, r26
    10d0:	0e 94 68 36 	call	0x6cd0	; 0x6cd0 <__udivmodsi4>
    10d4:	2d 83       	std	Y+5, r18	; 0x05
    10d6:	3e 83       	std	Y+6, r19	; 0x06
    10d8:	4f 83       	std	Y+7, r20	; 0x07
    10da:	58 87       	std	Y+8, r21	; 0x08
    
    return( (uint16_t) shuntCurrent );  
    10dc:	8d 81       	ldd	r24, Y+5	; 0x05
    10de:	9e 81       	ldd	r25, Y+6	; 0x06
}
    10e0:	28 96       	adiw	r28, 0x08	; 8
    10e2:	0f b6       	in	r0, 0x3f	; 63
    10e4:	f8 94       	cli
    10e6:	de bf       	out	0x3e, r29	; 62
    10e8:	0f be       	out	0x3f, r0	; 63
    10ea:	cd bf       	out	0x3d, r28	; 61
    10ec:	df 91       	pop	r29
    10ee:	cf 91       	pop	r28
    10f0:	08 95       	ret

000010f2 <measureConsumerCurrent>:

uint16_t measureConsumerCurrent()
{
    10f2:	cf 93       	push	r28
    10f4:	df 93       	push	r29
    10f6:	00 d0       	rcall	.+0      	; 0x10f8 <measureConsumerCurrent+0x6>
    10f8:	00 d0       	rcall	.+0      	; 0x10fa <measureConsumerCurrent+0x8>
    10fa:	00 d0       	rcall	.+0      	; 0x10fc <measureConsumerCurrent+0xa>
    10fc:	cd b7       	in	r28, 0x3d	; 61
    10fe:	de b7       	in	r29, 0x3e	; 62
    uint16_t shuntVoltage;
    uint32_t shuntCurrent;
    
    shuntVoltage = adcRead( CONSUMER_CURRENT );
    1100:	84 e0       	ldi	r24, 0x04	; 4
    1102:	0e 94 a1 07 	call	0xf42	; 0xf42 <adcRead>
    1106:	9a 83       	std	Y+2, r25	; 0x02
    1108:	89 83       	std	Y+1, r24	; 0x01
    
    //calculate current flow through shunt resistor [mA]
    //-> *1000 because result has to be in mA (otherwise the 10^-3 of mV and mOhm would cancel each other)    
    shuntCurrent = ( 1000 * shuntVoltage + ( CONSUMER_CURRENT_SHUNT_mOHM >> 2 ) ) / CONSUMER_CURRENT_SHUNT_mOHM;
    110a:	49 81       	ldd	r20, Y+1	; 0x01
    110c:	5a 81       	ldd	r21, Y+2	; 0x02
    110e:	28 ee       	ldi	r18, 0xE8	; 232
    1110:	33 e0       	ldi	r19, 0x03	; 3
    1112:	42 9f       	mul	r20, r18
    1114:	c0 01       	movw	r24, r0
    1116:	43 9f       	mul	r20, r19
    1118:	90 0d       	add	r25, r0
    111a:	52 9f       	mul	r21, r18
    111c:	90 0d       	add	r25, r0
    111e:	11 24       	eor	r1, r1
    1120:	85 54       	subi	r24, 0x45	; 69
    1122:	9f 4f       	sbci	r25, 0xFF	; 255
    1124:	2e ee       	ldi	r18, 0xEE	; 238
    1126:	32 e0       	ldi	r19, 0x02	; 2
    1128:	b9 01       	movw	r22, r18
    112a:	0e 94 54 36 	call	0x6ca8	; 0x6ca8 <__udivmodhi4>
    112e:	9b 01       	movw	r18, r22
    1130:	c9 01       	movw	r24, r18
    1132:	cc 01       	movw	r24, r24
    1134:	a0 e0       	ldi	r26, 0x00	; 0
    1136:	b0 e0       	ldi	r27, 0x00	; 0
    1138:	8b 83       	std	Y+3, r24	; 0x03
    113a:	9c 83       	std	Y+4, r25	; 0x04
    113c:	ad 83       	std	Y+5, r26	; 0x05
    113e:	be 83       	std	Y+6, r27	; 0x06
    
    return( (uint16_t) shuntCurrent );
    1140:	8b 81       	ldd	r24, Y+3	; 0x03
    1142:	9c 81       	ldd	r25, Y+4	; 0x04
    1144:	26 96       	adiw	r28, 0x06	; 6
    1146:	0f b6       	in	r0, 0x3f	; 63
    1148:	f8 94       	cli
    114a:	de bf       	out	0x3e, r29	; 62
    114c:	0f be       	out	0x3f, r0	; 63
    114e:	cd bf       	out	0x3d, r28	; 61
    1150:	df 91       	pop	r29
    1152:	cf 91       	pop	r28
    1154:	08 95       	ret

00001156 <lcd_get_position_page>:


//Function to read the current position
extern uint8_t lcd_current_page;
extern uint8_t lcd_current_column;
static inline uint8_t lcd_get_position_page()   {return lcd_current_page;};
    1156:	cf 93       	push	r28
    1158:	df 93       	push	r29
    115a:	cd b7       	in	r28, 0x3d	; 61
    115c:	de b7       	in	r29, 0x3e	; 62
    115e:	80 91 58 01 	lds	r24, 0x0158
    1162:	df 91       	pop	r29
    1164:	cf 91       	pop	r28
    1166:	08 95       	ret

00001168 <lcd_get_position_column>:
static inline uint8_t lcd_get_position_column() {return lcd_current_column;};
    1168:	cf 93       	push	r28
    116a:	df 93       	push	r29
    116c:	cd b7       	in	r28, 0x3d	; 61
    116e:	de b7       	in	r29, 0x3e	; 62
    1170:	80 91 59 01 	lds	r24, 0x0159
    1174:	df 91       	pop	r29
    1176:	cf 91       	pop	r28
    1178:	08 95       	ret

0000117a <lcd_inc_page>:

/******************************************************************************
 * Changes the internal cursor by s pages
 * s             - number of pages to move
 */ 
uint8_t lcd_inc_page(int8_t s) {
    117a:	cf 93       	push	r28
    117c:	df 93       	push	r29
    117e:	00 d0       	rcall	.+0      	; 0x1180 <lcd_inc_page+0x6>
    1180:	cd b7       	in	r28, 0x3d	; 61
    1182:	de b7       	in	r29, 0x3e	; 62
    1184:	8a 83       	std	Y+2, r24	; 0x02
  uint8_t p = lcd_current_page;
    1186:	80 91 58 01 	lds	r24, 0x0158
    118a:	89 83       	std	Y+1, r24	; 0x01
  p += s;
    118c:	8a 81       	ldd	r24, Y+2	; 0x02
    118e:	99 81       	ldd	r25, Y+1	; 0x01
    1190:	89 0f       	add	r24, r25
    1192:	89 83       	std	Y+1, r24	; 0x01
  p %= LCD_RAM_PAGES;    //all lcd have lcd_ram_pages which is power of two
    1194:	89 81       	ldd	r24, Y+1	; 0x01
    1196:	83 70       	andi	r24, 0x03	; 3
    1198:	89 83       	std	Y+1, r24	; 0x01
  lcd_current_page = p;
    119a:	89 81       	ldd	r24, Y+1	; 0x01
    119c:	80 93 58 01 	sts	0x0158, r24
  return p;
    11a0:	89 81       	ldd	r24, Y+1	; 0x01
  }
    11a2:	0f 90       	pop	r0
    11a4:	0f 90       	pop	r0
    11a6:	df 91       	pop	r29
    11a8:	cf 91       	pop	r28
    11aa:	08 95       	ret

000011ac <lcd_inc_column>:

/******************************************************************************
 * Changes the internal cursor by s columns, including wrapping (if selected)
 * s             - number of columns to move
 */ 
uint8_t lcd_inc_column(int16_t s) {
    11ac:	cf 93       	push	r28
    11ae:	df 93       	push	r29
    11b0:	00 d0       	rcall	.+0      	; 0x11b2 <lcd_inc_column+0x6>
    11b2:	00 d0       	rcall	.+0      	; 0x11b4 <lcd_inc_column+0x8>
    11b4:	cd b7       	in	r28, 0x3d	; 61
    11b6:	de b7       	in	r29, 0x3e	; 62
    11b8:	9c 83       	std	Y+4, r25	; 0x04
    11ba:	8b 83       	std	Y+3, r24	; 0x03
  uint16_t c = lcd_current_column;
    11bc:	80 91 59 01 	lds	r24, 0x0159
    11c0:	88 2f       	mov	r24, r24
    11c2:	90 e0       	ldi	r25, 0x00	; 0
    11c4:	9a 83       	std	Y+2, r25	; 0x02
    11c6:	89 83       	std	Y+1, r24	; 0x01
  c += s;
    11c8:	8b 81       	ldd	r24, Y+3	; 0x03
    11ca:	9c 81       	ldd	r25, Y+4	; 0x04
    11cc:	29 81       	ldd	r18, Y+1	; 0x01
    11ce:	3a 81       	ldd	r19, Y+2	; 0x02
    11d0:	82 0f       	add	r24, r18
    11d2:	93 1f       	adc	r25, r19
    11d4:	9a 83       	std	Y+2, r25	; 0x02
    11d6:	89 83       	std	Y+1, r24	; 0x01
#if LCD_WRAP_AROUND == 1
  while (c >= LCD_WIDTH) {
    11d8:	1e c0       	rjmp	.+60     	; 0x1216 <lcd_inc_column+0x6a>
    if (s > 0) lcd_inc_page(1);
    11da:	8b 81       	ldd	r24, Y+3	; 0x03
    11dc:	9c 81       	ldd	r25, Y+4	; 0x04
    11de:	18 16       	cp	r1, r24
    11e0:	19 06       	cpc	r1, r25
    11e2:	24 f4       	brge	.+8      	; 0x11ec <lcd_inc_column+0x40>
    11e4:	81 e0       	ldi	r24, 0x01	; 1
    11e6:	0e 94 bd 08 	call	0x117a	; 0x117a <lcd_inc_page>
    11ea:	03 c0       	rjmp	.+6      	; 0x11f2 <lcd_inc_column+0x46>
    else       lcd_inc_page(-1);
    11ec:	8f ef       	ldi	r24, 0xFF	; 255
    11ee:	0e 94 bd 08 	call	0x117a	; 0x117a <lcd_inc_page>
    if (s > 0) c -= LCD_WIDTH;
    11f2:	8b 81       	ldd	r24, Y+3	; 0x03
    11f4:	9c 81       	ldd	r25, Y+4	; 0x04
    11f6:	18 16       	cp	r1, r24
    11f8:	19 06       	cpc	r1, r25
    11fa:	3c f4       	brge	.+14     	; 0x120a <lcd_inc_column+0x5e>
    11fc:	89 81       	ldd	r24, Y+1	; 0x01
    11fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1200:	84 58       	subi	r24, 0x84	; 132
    1202:	90 40       	sbci	r25, 0x00	; 0
    1204:	9a 83       	std	Y+2, r25	; 0x02
    1206:	89 83       	std	Y+1, r24	; 0x01
    1208:	06 c0       	rjmp	.+12     	; 0x1216 <lcd_inc_column+0x6a>
    else       c += LCD_WIDTH;
    120a:	89 81       	ldd	r24, Y+1	; 0x01
    120c:	9a 81       	ldd	r25, Y+2	; 0x02
    120e:	8c 57       	subi	r24, 0x7C	; 124
    1210:	9f 4f       	sbci	r25, 0xFF	; 255
    1212:	9a 83       	std	Y+2, r25	; 0x02
    1214:	89 83       	std	Y+1, r24	; 0x01
 */ 
uint8_t lcd_inc_column(int16_t s) {
  uint16_t c = lcd_current_column;
  c += s;
#if LCD_WRAP_AROUND == 1
  while (c >= LCD_WIDTH) {
    1216:	89 81       	ldd	r24, Y+1	; 0x01
    1218:	9a 81       	ldd	r25, Y+2	; 0x02
    121a:	84 38       	cpi	r24, 0x84	; 132
    121c:	91 05       	cpc	r25, r1
    121e:	e8 f6       	brcc	.-70     	; 0x11da <lcd_inc_column+0x2e>
    else       lcd_inc_page(-1);
    if (s > 0) c -= LCD_WIDTH;
    else       c += LCD_WIDTH;
    }
#endif
  lcd_current_column = c;
    1220:	89 81       	ldd	r24, Y+1	; 0x01
    1222:	80 93 59 01 	sts	0x0159, r24
  return c;
    1226:	89 81       	ldd	r24, Y+1	; 0x01
  }
    1228:	0f 90       	pop	r0
    122a:	0f 90       	pop	r0
    122c:	0f 90       	pop	r0
    122e:	0f 90       	pop	r0
    1230:	df 91       	pop	r29
    1232:	cf 91       	pop	r28
    1234:	08 95       	ret

00001236 <lcd_moveto_xy>:
/******************************************************************************
 * Moves the cursor to the given position
 * pages         - page to move to
 * columns       - column to move to
 */ 
void lcd_moveto_xy(uint8_t page, uint8_t column) {
    1236:	cf 93       	push	r28
    1238:	df 93       	push	r29
    123a:	00 d0       	rcall	.+0      	; 0x123c <lcd_moveto_xy+0x6>
    123c:	cd b7       	in	r28, 0x3d	; 61
    123e:	de b7       	in	r29, 0x3e	; 62
    1240:	89 83       	std	Y+1, r24	; 0x01
    1242:	6a 83       	std	Y+2, r22	; 0x02
  LCD_GOTO_ADDRESS(page,column);
    1244:	89 81       	ldd	r24, Y+1	; 0x01
    1246:	8f 70       	andi	r24, 0x0F	; 15
    1248:	80 6b       	ori	r24, 0xB0	; 176
    124a:	0e 94 8e 09 	call	0x131c	; 0x131c <lcd_command>
    124e:	8a 81       	ldd	r24, Y+2	; 0x02
    1250:	82 95       	swap	r24
    1252:	8f 70       	andi	r24, 0x0F	; 15
    1254:	80 61       	ori	r24, 0x10	; 16
    1256:	0e 94 8e 09 	call	0x131c	; 0x131c <lcd_command>
    125a:	8a 81       	ldd	r24, Y+2	; 0x02
    125c:	8f 70       	andi	r24, 0x0F	; 15
    125e:	0e 94 8e 09 	call	0x131c	; 0x131c <lcd_command>
  lcd_current_column = column; 
    1262:	8a 81       	ldd	r24, Y+2	; 0x02
    1264:	80 93 59 01 	sts	0x0159, r24
  lcd_current_page = page;
    1268:	89 81       	ldd	r24, Y+1	; 0x01
    126a:	80 93 58 01 	sts	0x0158, r24
  }
    126e:	0f 90       	pop	r0
    1270:	0f 90       	pop	r0
    1272:	df 91       	pop	r29
    1274:	cf 91       	pop	r28
    1276:	08 95       	ret

00001278 <lcd_move_xy>:
/******************************************************************************
 * Moves the cursor relative to the current position
 * pages         - number of pages to move
 * columns       - number of columns to move
 */  
void lcd_move_xy(int8_t pages, int16_t columns) {
    1278:	1f 93       	push	r17
    127a:	cf 93       	push	r28
    127c:	df 93       	push	r29
    127e:	00 d0       	rcall	.+0      	; 0x1280 <lcd_move_xy+0x8>
    1280:	0f 92       	push	r0
    1282:	cd b7       	in	r28, 0x3d	; 61
    1284:	de b7       	in	r29, 0x3e	; 62
    1286:	89 83       	std	Y+1, r24	; 0x01
    1288:	7b 83       	std	Y+3, r23	; 0x03
    128a:	6a 83       	std	Y+2, r22	; 0x02
  lcd_moveto_xy(lcd_inc_page(pages),lcd_inc_column(columns));
    128c:	89 81       	ldd	r24, Y+1	; 0x01
    128e:	0e 94 bd 08 	call	0x117a	; 0x117a <lcd_inc_page>
    1292:	18 2f       	mov	r17, r24
    1294:	8a 81       	ldd	r24, Y+2	; 0x02
    1296:	9b 81       	ldd	r25, Y+3	; 0x03
    1298:	0e 94 d6 08 	call	0x11ac	; 0x11ac <lcd_inc_column>
    129c:	98 2f       	mov	r25, r24
    129e:	81 2f       	mov	r24, r17
    12a0:	69 2f       	mov	r22, r25
    12a2:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
  }
    12a6:	0f 90       	pop	r0
    12a8:	0f 90       	pop	r0
    12aa:	0f 90       	pop	r0
    12ac:	df 91       	pop	r29
    12ae:	cf 91       	pop	r28
    12b0:	1f 91       	pop	r17
    12b2:	08 95       	ret

000012b4 <lcd_data>:

/******************************************************************************
 * Writes one data byte
 * data          - the data byte
 */
void lcd_data(uint8_t data) {
    12b4:	cf 93       	push	r28
    12b6:	df 93       	push	r29
    12b8:	0f 92       	push	r0
    12ba:	cd b7       	in	r28, 0x3d	; 61
    12bc:	de b7       	in	r29, 0x3e	; 62
    12be:	89 83       	std	Y+1, r24	; 0x01
  LCD_SELECT();
    12c0:	85 e2       	ldi	r24, 0x25	; 37
    12c2:	90 e0       	ldi	r25, 0x00	; 0
    12c4:	25 e2       	ldi	r18, 0x25	; 37
    12c6:	30 e0       	ldi	r19, 0x00	; 0
    12c8:	f9 01       	movw	r30, r18
    12ca:	20 81       	ld	r18, Z
    12cc:	2f 7e       	andi	r18, 0xEF	; 239
    12ce:	fc 01       	movw	r30, r24
    12d0:	20 83       	st	Z, r18
  LCD_DRAM();
    12d2:	85 e2       	ldi	r24, 0x25	; 37
    12d4:	90 e0       	ldi	r25, 0x00	; 0
    12d6:	25 e2       	ldi	r18, 0x25	; 37
    12d8:	30 e0       	ldi	r19, 0x00	; 0
    12da:	f9 01       	movw	r30, r18
    12dc:	20 81       	ld	r18, Z
    12de:	24 60       	ori	r18, 0x04	; 4
    12e0:	fc 01       	movw	r30, r24
    12e2:	20 83       	st	Z, r18
  spi_write(data);
    12e4:	8e e4       	ldi	r24, 0x4E	; 78
    12e6:	90 e0       	ldi	r25, 0x00	; 0
    12e8:	29 81       	ldd	r18, Y+1	; 0x01
    12ea:	fc 01       	movw	r30, r24
    12ec:	20 83       	st	Z, r18
  LCD_UNSELECT();
    12ee:	8d e4       	ldi	r24, 0x4D	; 77
    12f0:	90 e0       	ldi	r25, 0x00	; 0
    12f2:	fc 01       	movw	r30, r24
    12f4:	80 81       	ld	r24, Z
    12f6:	88 23       	and	r24, r24
    12f8:	d4 f7       	brge	.-12     	; 0x12ee <lcd_data+0x3a>
    12fa:	85 e2       	ldi	r24, 0x25	; 37
    12fc:	90 e0       	ldi	r25, 0x00	; 0
    12fe:	25 e2       	ldi	r18, 0x25	; 37
    1300:	30 e0       	ldi	r19, 0x00	; 0
    1302:	f9 01       	movw	r30, r18
    1304:	20 81       	ld	r18, Z
    1306:	20 61       	ori	r18, 0x10	; 16
    1308:	fc 01       	movw	r30, r24
    130a:	20 83       	st	Z, r18
  lcd_inc_column(1);
    130c:	81 e0       	ldi	r24, 0x01	; 1
    130e:	90 e0       	ldi	r25, 0x00	; 0
    1310:	0e 94 d6 08 	call	0x11ac	; 0x11ac <lcd_inc_column>
  }
    1314:	0f 90       	pop	r0
    1316:	df 91       	pop	r29
    1318:	cf 91       	pop	r28
    131a:	08 95       	ret

0000131c <lcd_command>:

/******************************************************************************
 * Writes one command byte
 * cmd           - the command byte
 */
void lcd_command(uint8_t cmd) {
    131c:	cf 93       	push	r28
    131e:	df 93       	push	r29
    1320:	0f 92       	push	r0
    1322:	cd b7       	in	r28, 0x3d	; 61
    1324:	de b7       	in	r29, 0x3e	; 62
    1326:	89 83       	std	Y+1, r24	; 0x01
  LCD_SELECT();
    1328:	85 e2       	ldi	r24, 0x25	; 37
    132a:	90 e0       	ldi	r25, 0x00	; 0
    132c:	25 e2       	ldi	r18, 0x25	; 37
    132e:	30 e0       	ldi	r19, 0x00	; 0
    1330:	f9 01       	movw	r30, r18
    1332:	20 81       	ld	r18, Z
    1334:	2f 7e       	andi	r18, 0xEF	; 239
    1336:	fc 01       	movw	r30, r24
    1338:	20 83       	st	Z, r18
  LCD_CMD();
    133a:	85 e2       	ldi	r24, 0x25	; 37
    133c:	90 e0       	ldi	r25, 0x00	; 0
    133e:	25 e2       	ldi	r18, 0x25	; 37
    1340:	30 e0       	ldi	r19, 0x00	; 0
    1342:	f9 01       	movw	r30, r18
    1344:	20 81       	ld	r18, Z
    1346:	2b 7f       	andi	r18, 0xFB	; 251
    1348:	fc 01       	movw	r30, r24
    134a:	20 83       	st	Z, r18
   
  spi_write(cmd);
    134c:	8e e4       	ldi	r24, 0x4E	; 78
    134e:	90 e0       	ldi	r25, 0x00	; 0
    1350:	29 81       	ldd	r18, Y+1	; 0x01
    1352:	fc 01       	movw	r30, r24
    1354:	20 83       	st	Z, r18
  
  
  //LCD_UNSELECT();
  while(!(SPSR & (1<<SPIF)));
    1356:	00 00       	nop
    1358:	8d e4       	ldi	r24, 0x4D	; 77
    135a:	90 e0       	ldi	r25, 0x00	; 0
    135c:	fc 01       	movw	r30, r24
    135e:	80 81       	ld	r24, Z
    1360:	88 23       	and	r24, r24
    1362:	d4 f7       	brge	.-12     	; 0x1358 <lcd_command+0x3c>
  PORT_CS |= _BV(PIN_CS);
    1364:	85 e2       	ldi	r24, 0x25	; 37
    1366:	90 e0       	ldi	r25, 0x00	; 0
    1368:	25 e2       	ldi	r18, 0x25	; 37
    136a:	30 e0       	ldi	r19, 0x00	; 0
    136c:	f9 01       	movw	r30, r18
    136e:	20 81       	ld	r18, Z
    1370:	20 61       	ori	r18, 0x10	; 16
    1372:	fc 01       	movw	r30, r24
    1374:	20 83       	st	Z, r18
  }
    1376:	0f 90       	pop	r0
    1378:	df 91       	pop	r29
    137a:	cf 91       	pop	r28
    137c:	08 95       	ret

0000137e <lcd_draw_image_P>:
 * progmem_image - prog_uint8_t array of columns aka the bitmap image
 * pages         - height of image in pages
 * columns       - width of image in pixels (or columns)
 * style         - Bit2: sets inverse mode
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
    137e:	1f 93       	push	r17
    1380:	cf 93       	push	r28
    1382:	df 93       	push	r29
    1384:	cd b7       	in	r28, 0x3d	; 61
    1386:	de b7       	in	r29, 0x3e	; 62
    1388:	2c 97       	sbiw	r28, 0x0c	; 12
    138a:	0f b6       	in	r0, 0x3f	; 63
    138c:	f8 94       	cli
    138e:	de bf       	out	0x3e, r29	; 62
    1390:	0f be       	out	0x3f, r0	; 63
    1392:	cd bf       	out	0x3d, r28	; 61
    1394:	99 87       	std	Y+9, r25	; 0x09
    1396:	88 87       	std	Y+8, r24	; 0x08
    1398:	6a 87       	std	Y+10, r22	; 0x0a
    139a:	4b 87       	std	Y+11, r20	; 0x0b
    139c:	2c 87       	std	Y+12, r18	; 0x0c
	uint8_t i,j = 0;
    139e:	1a 82       	std	Y+2, r1	; 0x02
  uint8_t inv = (style & INVERT_BIT);
    13a0:	8c 85       	ldd	r24, Y+12	; 0x0c
    13a2:	84 70       	andi	r24, 0x04	; 4
    13a4:	8b 83       	std	Y+3, r24	; 0x03
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
    13a6:	3a c0       	rjmp	.+116    	; 0x141c <lcd_draw_image_P+0x9e>
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++) {
    13a8:	19 82       	std	Y+1, r1	; 0x01
    13aa:	1e c0       	rjmp	.+60     	; 0x13e8 <lcd_draw_image_P+0x6a>
      uint8_t tmp = pgm_read_byte(progmem_image++);
    13ac:	88 85       	ldd	r24, Y+8	; 0x08
    13ae:	99 85       	ldd	r25, Y+9	; 0x09
    13b0:	9d 83       	std	Y+5, r25	; 0x05
    13b2:	8c 83       	std	Y+4, r24	; 0x04
    13b4:	88 85       	ldd	r24, Y+8	; 0x08
    13b6:	99 85       	ldd	r25, Y+9	; 0x09
    13b8:	01 96       	adiw	r24, 0x01	; 1
    13ba:	99 87       	std	Y+9, r25	; 0x09
    13bc:	88 87       	std	Y+8, r24	; 0x08
    13be:	8c 81       	ldd	r24, Y+4	; 0x04
    13c0:	9d 81       	ldd	r25, Y+5	; 0x05
    13c2:	fc 01       	movw	r30, r24
    13c4:	14 91       	lpm	r17, Z
    13c6:	1e 83       	std	Y+6, r17	; 0x06
    13c8:	8e 81       	ldd	r24, Y+6	; 0x06
    13ca:	8f 83       	std	Y+7, r24	; 0x07
			if(!inv)
    13cc:	8b 81       	ldd	r24, Y+3	; 0x03
    13ce:	88 23       	and	r24, r24
    13d0:	21 f4       	brne	.+8      	; 0x13da <lcd_draw_image_P+0x5c>
				lcd_data(tmp);
    13d2:	8f 81       	ldd	r24, Y+7	; 0x07
    13d4:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <lcd_data>
    13d8:	04 c0       	rjmp	.+8      	; 0x13e2 <lcd_draw_image_P+0x64>
			else
				lcd_data(~tmp);
    13da:	8f 81       	ldd	r24, Y+7	; 0x07
    13dc:	80 95       	com	r24
    13de:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <lcd_data>
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++) {
    13e2:	89 81       	ldd	r24, Y+1	; 0x01
    13e4:	8f 5f       	subi	r24, 0xFF	; 255
    13e6:	89 83       	std	Y+1, r24	; 0x01
    13e8:	99 81       	ldd	r25, Y+1	; 0x01
    13ea:	8b 85       	ldd	r24, Y+11	; 0x0b
    13ec:	98 17       	cp	r25, r24
    13ee:	20 f4       	brcc	.+8      	; 0x13f8 <lcd_draw_image_P+0x7a>
    13f0:	0e 94 b4 08 	call	0x1168	; 0x1168 <lcd_get_position_column>
    13f4:	84 38       	cpi	r24, 0x84	; 132
    13f6:	d0 f2       	brcs	.-76     	; 0x13ac <lcd_draw_image_P+0x2e>
			if(!inv)
				lcd_data(tmp);
			else
				lcd_data(~tmp);
      }
    if(++j != pages)
    13f8:	8a 81       	ldd	r24, Y+2	; 0x02
    13fa:	8f 5f       	subi	r24, 0xFF	; 255
    13fc:	8a 83       	std	Y+2, r24	; 0x02
    13fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1400:	8a 85       	ldd	r24, Y+10	; 0x0a
    1402:	98 17       	cp	r25, r24
    1404:	59 f0       	breq	.+22     	; 0x141c <lcd_draw_image_P+0x9e>
      lcd_move_xy(1,-columns);
    1406:	8b 85       	ldd	r24, Y+11	; 0x0b
    1408:	88 2f       	mov	r24, r24
    140a:	90 e0       	ldi	r25, 0x00	; 0
    140c:	22 27       	eor	r18, r18
    140e:	33 27       	eor	r19, r19
    1410:	28 1b       	sub	r18, r24
    1412:	39 0b       	sbc	r19, r25
    1414:	81 e0       	ldi	r24, 0x01	; 1
    1416:	b9 01       	movw	r22, r18
    1418:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_move_xy>
 * style         - Bit2: sets inverse mode
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
    141c:	9a 81       	ldd	r25, Y+2	; 0x02
    141e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1420:	98 17       	cp	r25, r24
    1422:	28 f4       	brcc	.+10     	; 0x142e <lcd_draw_image_P+0xb0>
    1424:	0e 94 ab 08 	call	0x1156	; 0x1156 <lcd_get_position_page>
    1428:	84 30       	cpi	r24, 0x04	; 4
    142a:	08 f4       	brcc	.+2      	; 0x142e <lcd_draw_image_P+0xb0>
    142c:	bd cf       	rjmp	.-134    	; 0x13a8 <lcd_draw_image_P+0x2a>
				lcd_data(~tmp);
      }
    if(++j != pages)
      lcd_move_xy(1,-columns);
    }
  }
    142e:	2c 96       	adiw	r28, 0x0c	; 12
    1430:	0f b6       	in	r0, 0x3f	; 63
    1432:	f8 94       	cli
    1434:	de bf       	out	0x3e, r29	; 62
    1436:	0f be       	out	0x3f, r0	; 63
    1438:	cd bf       	out	0x3d, r28	; 61
    143a:	df 91       	pop	r29
    143c:	cf 91       	pop	r28
    143e:	1f 91       	pop	r17
    1440:	08 95       	ret

00001442 <lcd_draw_image_xy_P>:
 * y             - y start coordinate on the screen (in pixel)
 * pages         - height of image in pages
 * columns       - width of image in pixels
 * style         - Bit2: sets inverse mode
 */
void lcd_draw_image_xy_P(PGM_P progmem_image, uint8_t x, uint8_t y, uint8_t pages, uint8_t columns, uint8_t style) {
    1442:	ef 92       	push	r14
    1444:	0f 93       	push	r16
    1446:	1f 93       	push	r17
    1448:	cf 93       	push	r28
    144a:	df 93       	push	r29
    144c:	cd b7       	in	r28, 0x3d	; 61
    144e:	de b7       	in	r29, 0x3e	; 62
    1450:	64 97       	sbiw	r28, 0x14	; 20
    1452:	0f b6       	in	r0, 0x3f	; 63
    1454:	f8 94       	cli
    1456:	de bf       	out	0x3e, r29	; 62
    1458:	0f be       	out	0x3f, r0	; 63
    145a:	cd bf       	out	0x3d, r28	; 61
    145c:	9f 87       	std	Y+15, r25	; 0x0f
    145e:	8e 87       	std	Y+14, r24	; 0x0e
    1460:	68 8b       	std	Y+16, r22	; 0x10
    1462:	49 8b       	std	Y+17, r20	; 0x11
    1464:	2a 8b       	std	Y+18, r18	; 0x12
    1466:	0b 8b       	std	Y+19, r16	; 0x13
    1468:	ec 8a       	std	Y+20, r14	; 0x14
	uint16_t i,j;
  uint8_t data   = 0;
    146a:	1d 82       	std	Y+5, r1	; 0x05
  uint8_t inv    = style & INVERT_BIT;
    146c:	8c 89       	ldd	r24, Y+20	; 0x14
    146e:	84 70       	andi	r24, 0x04	; 4
    1470:	8e 83       	std	Y+6, r24	; 0x06
	uint8_t offset = y & 0x7; //Optimized modulo 8
    1472:	89 89       	ldd	r24, Y+17	; 0x11
    1474:	87 70       	andi	r24, 0x07	; 7
    1476:	8f 83       	std	Y+7, r24	; 0x07
	//If there is an offset, we must use an additional page
	if(offset)  
    1478:	8f 81       	ldd	r24, Y+7	; 0x07
    147a:	88 23       	and	r24, r24
    147c:	19 f0       	breq	.+6      	; 0x1484 <lcd_draw_image_xy_P+0x42>
    pages++;
    147e:	8a 89       	ldd	r24, Y+18	; 0x12
    1480:	8f 5f       	subi	r24, 0xFF	; 255
    1482:	8a 8b       	std	Y+18, r24	; 0x12
  //If there is not enough vertical space -> cut image
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
    1484:	8a 89       	ldd	r24, Y+18	; 0x12
    1486:	08 2f       	mov	r16, r24
    1488:	10 e0       	ldi	r17, 0x00	; 0
    148a:	0e 94 ab 08 	call	0x1156	; 0x1156 <lcd_get_position_page>
    148e:	88 2f       	mov	r24, r24
    1490:	90 e0       	ldi	r25, 0x00	; 0
    1492:	24 e0       	ldi	r18, 0x04	; 4
    1494:	30 e0       	ldi	r19, 0x00	; 0
    1496:	a9 01       	movw	r20, r18
    1498:	48 1b       	sub	r20, r24
    149a:	59 0b       	sbc	r21, r25
    149c:	ca 01       	movw	r24, r20
    149e:	80 17       	cp	r24, r16
    14a0:	91 07       	cpc	r25, r17
    14a2:	3c f4       	brge	.+14     	; 0x14b2 <lcd_draw_image_xy_P+0x70>
    pages = LCD_RAM_PAGES - lcd_get_position_page();
    14a4:	0e 94 ab 08 	call	0x1156	; 0x1156 <lcd_get_position_page>
    14a8:	94 e0       	ldi	r25, 0x04	; 4
    14aa:	59 2f       	mov	r21, r25
    14ac:	58 1b       	sub	r21, r24
    14ae:	85 2f       	mov	r24, r21
    14b0:	8a 8b       	std	Y+18, r24	; 0x12
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
    14b2:	89 89       	ldd	r24, Y+17	; 0x11
    14b4:	86 95       	lsr	r24
    14b6:	86 95       	lsr	r24
    14b8:	86 95       	lsr	r24
    14ba:	68 89       	ldd	r22, Y+16	; 0x10
    14bc:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
	for (j=0; j<pages; j++) {
    14c0:	1c 82       	std	Y+4, r1	; 0x04
    14c2:	1b 82       	std	Y+3, r1	; 0x03
    14c4:	ad c0       	rjmp	.+346    	; 0x1620 <lcd_draw_image_xy_P+0x1de>
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
    14c6:	1a 82       	std	Y+2, r1	; 0x02
    14c8:	19 82       	std	Y+1, r1	; 0x01
    14ca:	82 c0       	rjmp	.+260    	; 0x15d0 <lcd_draw_image_xy_P+0x18e>
      data = 0;
    14cc:	1d 82       	std	Y+5, r1	; 0x05
      if (!offset || j+1 != pages)
    14ce:	8f 81       	ldd	r24, Y+7	; 0x07
    14d0:	88 23       	and	r24, r24
    14d2:	59 f0       	breq	.+22     	; 0x14ea <lcd_draw_image_xy_P+0xa8>
    14d4:	8b 81       	ldd	r24, Y+3	; 0x03
    14d6:	9c 81       	ldd	r25, Y+4	; 0x04
    14d8:	9c 01       	movw	r18, r24
    14da:	2f 5f       	subi	r18, 0xFF	; 255
    14dc:	3f 4f       	sbci	r19, 0xFF	; 255
    14de:	8a 89       	ldd	r24, Y+18	; 0x12
    14e0:	88 2f       	mov	r24, r24
    14e2:	90 e0       	ldi	r25, 0x00	; 0
    14e4:	28 17       	cp	r18, r24
    14e6:	39 07       	cpc	r19, r25
    14e8:	41 f1       	breq	.+80     	; 0x153a <lcd_draw_image_xy_P+0xf8>
        data = pgm_read_byte(&progmem_image[j*columns + i]) << offset;
    14ea:	8b 89       	ldd	r24, Y+19	; 0x13
    14ec:	48 2f       	mov	r20, r24
    14ee:	50 e0       	ldi	r21, 0x00	; 0
    14f0:	8b 81       	ldd	r24, Y+3	; 0x03
    14f2:	9c 81       	ldd	r25, Y+4	; 0x04
    14f4:	48 9f       	mul	r20, r24
    14f6:	90 01       	movw	r18, r0
    14f8:	49 9f       	mul	r20, r25
    14fa:	30 0d       	add	r19, r0
    14fc:	58 9f       	mul	r21, r24
    14fe:	30 0d       	add	r19, r0
    1500:	11 24       	eor	r1, r1
    1502:	89 81       	ldd	r24, Y+1	; 0x01
    1504:	9a 81       	ldd	r25, Y+2	; 0x02
    1506:	82 0f       	add	r24, r18
    1508:	93 1f       	adc	r25, r19
    150a:	2e 85       	ldd	r18, Y+14	; 0x0e
    150c:	3f 85       	ldd	r19, Y+15	; 0x0f
    150e:	82 0f       	add	r24, r18
    1510:	93 1f       	adc	r25, r19
    1512:	99 87       	std	Y+9, r25	; 0x09
    1514:	88 87       	std	Y+8, r24	; 0x08
    1516:	88 85       	ldd	r24, Y+8	; 0x08
    1518:	99 85       	ldd	r25, Y+9	; 0x09
    151a:	fc 01       	movw	r30, r24
    151c:	14 91       	lpm	r17, Z
    151e:	1a 87       	std	Y+10, r17	; 0x0a
    1520:	8a 85       	ldd	r24, Y+10	; 0x0a
    1522:	88 2f       	mov	r24, r24
    1524:	90 e0       	ldi	r25, 0x00	; 0
    1526:	2f 81       	ldd	r18, Y+7	; 0x07
    1528:	22 2f       	mov	r18, r18
    152a:	30 e0       	ldi	r19, 0x00	; 0
    152c:	02 2e       	mov	r0, r18
    152e:	02 c0       	rjmp	.+4      	; 0x1534 <lcd_draw_image_xy_P+0xf2>
    1530:	88 0f       	add	r24, r24
    1532:	99 1f       	adc	r25, r25
    1534:	0a 94       	dec	r0
    1536:	e2 f7       	brpl	.-8      	; 0x1530 <lcd_draw_image_xy_P+0xee>
    1538:	8d 83       	std	Y+5, r24	; 0x05
			if(j > 0 && offset)
    153a:	8b 81       	ldd	r24, Y+3	; 0x03
    153c:	9c 81       	ldd	r25, Y+4	; 0x04
    153e:	00 97       	sbiw	r24, 0x00	; 0
    1540:	b9 f1       	breq	.+110    	; 0x15b0 <lcd_draw_image_xy_P+0x16e>
    1542:	8f 81       	ldd	r24, Y+7	; 0x07
    1544:	88 23       	and	r24, r24
    1546:	a1 f1       	breq	.+104    	; 0x15b0 <lcd_draw_image_xy_P+0x16e>
				data |= pgm_read_byte(&progmem_image[(j-1)*columns + i]) >> (8-offset);
    1548:	8b 81       	ldd	r24, Y+3	; 0x03
    154a:	9c 81       	ldd	r25, Y+4	; 0x04
    154c:	ac 01       	movw	r20, r24
    154e:	41 50       	subi	r20, 0x01	; 1
    1550:	50 40       	sbci	r21, 0x00	; 0
    1552:	8b 89       	ldd	r24, Y+19	; 0x13
    1554:	88 2f       	mov	r24, r24
    1556:	90 e0       	ldi	r25, 0x00	; 0
    1558:	48 9f       	mul	r20, r24
    155a:	90 01       	movw	r18, r0
    155c:	49 9f       	mul	r20, r25
    155e:	30 0d       	add	r19, r0
    1560:	58 9f       	mul	r21, r24
    1562:	30 0d       	add	r19, r0
    1564:	11 24       	eor	r1, r1
    1566:	89 81       	ldd	r24, Y+1	; 0x01
    1568:	9a 81       	ldd	r25, Y+2	; 0x02
    156a:	82 0f       	add	r24, r18
    156c:	93 1f       	adc	r25, r19
    156e:	2e 85       	ldd	r18, Y+14	; 0x0e
    1570:	3f 85       	ldd	r19, Y+15	; 0x0f
    1572:	82 0f       	add	r24, r18
    1574:	93 1f       	adc	r25, r19
    1576:	9c 87       	std	Y+12, r25	; 0x0c
    1578:	8b 87       	std	Y+11, r24	; 0x0b
    157a:	8b 85       	ldd	r24, Y+11	; 0x0b
    157c:	9c 85       	ldd	r25, Y+12	; 0x0c
    157e:	fc 01       	movw	r30, r24
    1580:	14 91       	lpm	r17, Z
    1582:	1d 87       	std	Y+13, r17	; 0x0d
    1584:	8d 85       	ldd	r24, Y+13	; 0x0d
    1586:	88 2f       	mov	r24, r24
    1588:	90 e0       	ldi	r25, 0x00	; 0
    158a:	2f 81       	ldd	r18, Y+7	; 0x07
    158c:	22 2f       	mov	r18, r18
    158e:	30 e0       	ldi	r19, 0x00	; 0
    1590:	48 e0       	ldi	r20, 0x08	; 8
    1592:	50 e0       	ldi	r21, 0x00	; 0
    1594:	ba 01       	movw	r22, r20
    1596:	62 1b       	sub	r22, r18
    1598:	73 0b       	sbc	r23, r19
    159a:	9b 01       	movw	r18, r22
    159c:	02 2e       	mov	r0, r18
    159e:	02 c0       	rjmp	.+4      	; 0x15a4 <lcd_draw_image_xy_P+0x162>
    15a0:	95 95       	asr	r25
    15a2:	87 95       	ror	r24
    15a4:	0a 94       	dec	r0
    15a6:	e2 f7       	brpl	.-8      	; 0x15a0 <lcd_draw_image_xy_P+0x15e>
    15a8:	98 2f       	mov	r25, r24
    15aa:	8d 81       	ldd	r24, Y+5	; 0x05
    15ac:	89 2b       	or	r24, r25
    15ae:	8d 83       	std	Y+5, r24	; 0x05
			if(inv)	lcd_data(~data);
    15b0:	8e 81       	ldd	r24, Y+6	; 0x06
    15b2:	88 23       	and	r24, r24
    15b4:	29 f0       	breq	.+10     	; 0x15c0 <lcd_draw_image_xy_P+0x17e>
    15b6:	8d 81       	ldd	r24, Y+5	; 0x05
    15b8:	80 95       	com	r24
    15ba:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <lcd_data>
    15be:	03 c0       	rjmp	.+6      	; 0x15c6 <lcd_draw_image_xy_P+0x184>
      else 		lcd_data(data);
    15c0:	8d 81       	ldd	r24, Y+5	; 0x05
    15c2:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <lcd_data>
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
    pages = LCD_RAM_PAGES - lcd_get_position_page();
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
	for (j=0; j<pages; j++) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
    15c6:	89 81       	ldd	r24, Y+1	; 0x01
    15c8:	9a 81       	ldd	r25, Y+2	; 0x02
    15ca:	01 96       	adiw	r24, 0x01	; 1
    15cc:	9a 83       	std	Y+2, r25	; 0x02
    15ce:	89 83       	std	Y+1, r24	; 0x01
    15d0:	8b 89       	ldd	r24, Y+19	; 0x13
    15d2:	28 2f       	mov	r18, r24
    15d4:	30 e0       	ldi	r19, 0x00	; 0
    15d6:	89 81       	ldd	r24, Y+1	; 0x01
    15d8:	9a 81       	ldd	r25, Y+2	; 0x02
    15da:	82 17       	cp	r24, r18
    15dc:	93 07       	cpc	r25, r19
    15de:	28 f4       	brcc	.+10     	; 0x15ea <lcd_draw_image_xy_P+0x1a8>
    15e0:	0e 94 b4 08 	call	0x1168	; 0x1168 <lcd_get_position_column>
    15e4:	84 38       	cpi	r24, 0x84	; 132
    15e6:	08 f4       	brcc	.+2      	; 0x15ea <lcd_draw_image_xy_P+0x1a8>
    15e8:	71 cf       	rjmp	.-286    	; 0x14cc <lcd_draw_image_xy_P+0x8a>
			if(j > 0 && offset)
				data |= pgm_read_byte(&progmem_image[(j-1)*columns + i]) >> (8-offset);
			if(inv)	lcd_data(~data);
      else 		lcd_data(data);
		  }
		if(j+1 != pages)
    15ea:	8b 81       	ldd	r24, Y+3	; 0x03
    15ec:	9c 81       	ldd	r25, Y+4	; 0x04
    15ee:	9c 01       	movw	r18, r24
    15f0:	2f 5f       	subi	r18, 0xFF	; 255
    15f2:	3f 4f       	sbci	r19, 0xFF	; 255
    15f4:	8a 89       	ldd	r24, Y+18	; 0x12
    15f6:	88 2f       	mov	r24, r24
    15f8:	90 e0       	ldi	r25, 0x00	; 0
    15fa:	28 17       	cp	r18, r24
    15fc:	39 07       	cpc	r19, r25
    15fe:	59 f0       	breq	.+22     	; 0x1616 <lcd_draw_image_xy_P+0x1d4>
			lcd_move_xy(1,-columns);
    1600:	8b 89       	ldd	r24, Y+19	; 0x13
    1602:	88 2f       	mov	r24, r24
    1604:	90 e0       	ldi	r25, 0x00	; 0
    1606:	22 27       	eor	r18, r18
    1608:	33 27       	eor	r19, r19
    160a:	28 1b       	sub	r18, r24
    160c:	39 0b       	sbc	r19, r25
    160e:	81 e0       	ldi	r24, 0x01	; 1
    1610:	b9 01       	movw	r22, r18
    1612:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_move_xy>
  //If there is not enough vertical space -> cut image
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
    pages = LCD_RAM_PAGES - lcd_get_position_page();
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
	for (j=0; j<pages; j++) {
    1616:	8b 81       	ldd	r24, Y+3	; 0x03
    1618:	9c 81       	ldd	r25, Y+4	; 0x04
    161a:	01 96       	adiw	r24, 0x01	; 1
    161c:	9c 83       	std	Y+4, r25	; 0x04
    161e:	8b 83       	std	Y+3, r24	; 0x03
    1620:	8a 89       	ldd	r24, Y+18	; 0x12
    1622:	28 2f       	mov	r18, r24
    1624:	30 e0       	ldi	r19, 0x00	; 0
    1626:	8b 81       	ldd	r24, Y+3	; 0x03
    1628:	9c 81       	ldd	r25, Y+4	; 0x04
    162a:	82 17       	cp	r24, r18
    162c:	93 07       	cpc	r25, r19
    162e:	08 f4       	brcc	.+2      	; 0x1632 <lcd_draw_image_xy_P+0x1f0>
    1630:	4a cf       	rjmp	.-364    	; 0x14c6 <lcd_draw_image_xy_P+0x84>
      else 		lcd_data(data);
		  }
		if(j+1 != pages)
			lcd_move_xy(1,-columns);
	  }
  }
    1632:	64 96       	adiw	r28, 0x14	; 20
    1634:	0f b6       	in	r0, 0x3f	; 63
    1636:	f8 94       	cli
    1638:	de bf       	out	0x3e, r29	; 62
    163a:	0f be       	out	0x3f, r0	; 63
    163c:	cd bf       	out	0x3d, r28	; 61
    163e:	df 91       	pop	r29
    1640:	cf 91       	pop	r28
    1642:	1f 91       	pop	r17
    1644:	0f 91       	pop	r16
    1646:	ef 90       	pop	r14
    1648:	08 95       	ret

0000164a <lcd_clear_area>:
 * pages         - height of area in pages
 * columns       - width of area in pixels
 * style         - Bit2: sets inverse mode
 * Cursor is moved to start of area after clear
 */
void lcd_clear_area(uint8_t pages, uint8_t columns, uint8_t style) {
    164a:	cf 93       	push	r28
    164c:	df 93       	push	r29
    164e:	cd b7       	in	r28, 0x3d	; 61
    1650:	de b7       	in	r29, 0x3e	; 62
    1652:	27 97       	sbiw	r28, 0x07	; 7
    1654:	0f b6       	in	r0, 0x3f	; 63
    1656:	f8 94       	cli
    1658:	de bf       	out	0x3e, r29	; 62
    165a:	0f be       	out	0x3f, r0	; 63
    165c:	cd bf       	out	0x3d, r28	; 61
    165e:	8d 83       	std	Y+5, r24	; 0x05
    1660:	6e 83       	std	Y+6, r22	; 0x06
    1662:	4f 83       	std	Y+7, r20	; 0x07
  uint8_t i,j,max;
  uint8_t inv = (style & INVERT_BIT)?0xFF:0;
    1664:	8f 81       	ldd	r24, Y+7	; 0x07
    1666:	88 2f       	mov	r24, r24
    1668:	90 e0       	ldi	r25, 0x00	; 0
    166a:	84 70       	andi	r24, 0x04	; 4
    166c:	90 70       	andi	r25, 0x00	; 0
    166e:	00 97       	sbiw	r24, 0x00	; 0
    1670:	11 f0       	breq	.+4      	; 0x1676 <lcd_clear_area+0x2c>
    1672:	8f ef       	ldi	r24, 0xFF	; 255
    1674:	01 c0       	rjmp	.+2      	; 0x1678 <lcd_clear_area+0x2e>
    1676:	80 e0       	ldi	r24, 0x00	; 0
    1678:	8b 83       	std	Y+3, r24	; 0x03
  
  if(pages > (max = LCD_RAM_PAGES - lcd_get_position_page()))   
    167a:	0e 94 ab 08 	call	0x1156	; 0x1156 <lcd_get_position_page>
    167e:	94 e0       	ldi	r25, 0x04	; 4
    1680:	29 2f       	mov	r18, r25
    1682:	28 1b       	sub	r18, r24
    1684:	82 2f       	mov	r24, r18
    1686:	8c 83       	std	Y+4, r24	; 0x04
    1688:	9c 81       	ldd	r25, Y+4	; 0x04
    168a:	8d 81       	ldd	r24, Y+5	; 0x05
    168c:	98 17       	cp	r25, r24
    168e:	10 f4       	brcc	.+4      	; 0x1694 <lcd_clear_area+0x4a>
    pages = max;
    1690:	8c 81       	ldd	r24, Y+4	; 0x04
    1692:	8d 83       	std	Y+5, r24	; 0x05
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
    1694:	0e 94 b4 08 	call	0x1168	; 0x1168 <lcd_get_position_column>
    1698:	94 e8       	ldi	r25, 0x84	; 132
    169a:	29 2f       	mov	r18, r25
    169c:	28 1b       	sub	r18, r24
    169e:	82 2f       	mov	r24, r18
    16a0:	8c 83       	std	Y+4, r24	; 0x04
    16a2:	9c 81       	ldd	r25, Y+4	; 0x04
    16a4:	8e 81       	ldd	r24, Y+6	; 0x06
    16a6:	98 17       	cp	r25, r24
    16a8:	10 f4       	brcc	.+4      	; 0x16ae <lcd_clear_area+0x64>
    columns = max;
    16aa:	8c 81       	ldd	r24, Y+4	; 0x04
    16ac:	8e 83       	std	Y+6, r24	; 0x06
  
  for(j=0; j<pages; j++) {
    16ae:	1a 82       	std	Y+2, r1	; 0x02
    16b0:	1a c0       	rjmp	.+52     	; 0x16e6 <lcd_clear_area+0x9c>
    for(i=0; i<columns; i++) {
    16b2:	19 82       	std	Y+1, r1	; 0x01
    16b4:	06 c0       	rjmp	.+12     	; 0x16c2 <lcd_clear_area+0x78>
      lcd_data(inv);
    16b6:	8b 81       	ldd	r24, Y+3	; 0x03
    16b8:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <lcd_data>
    pages = max;
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
    columns = max;
  
  for(j=0; j<pages; j++) {
    for(i=0; i<columns; i++) {
    16bc:	89 81       	ldd	r24, Y+1	; 0x01
    16be:	8f 5f       	subi	r24, 0xFF	; 255
    16c0:	89 83       	std	Y+1, r24	; 0x01
    16c2:	99 81       	ldd	r25, Y+1	; 0x01
    16c4:	8e 81       	ldd	r24, Y+6	; 0x06
    16c6:	98 17       	cp	r25, r24
    16c8:	b0 f3       	brcs	.-20     	; 0x16b6 <lcd_clear_area+0x6c>
      lcd_data(inv);
      }
    lcd_move_xy(1,-columns);
    16ca:	8e 81       	ldd	r24, Y+6	; 0x06
    16cc:	88 2f       	mov	r24, r24
    16ce:	90 e0       	ldi	r25, 0x00	; 0
    16d0:	22 27       	eor	r18, r18
    16d2:	33 27       	eor	r19, r19
    16d4:	28 1b       	sub	r18, r24
    16d6:	39 0b       	sbc	r19, r25
    16d8:	81 e0       	ldi	r24, 0x01	; 1
    16da:	b9 01       	movw	r22, r18
    16dc:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_move_xy>
  if(pages > (max = LCD_RAM_PAGES - lcd_get_position_page()))   
    pages = max;
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
    columns = max;
  
  for(j=0; j<pages; j++) {
    16e0:	8a 81       	ldd	r24, Y+2	; 0x02
    16e2:	8f 5f       	subi	r24, 0xFF	; 255
    16e4:	8a 83       	std	Y+2, r24	; 0x02
    16e6:	9a 81       	ldd	r25, Y+2	; 0x02
    16e8:	8d 81       	ldd	r24, Y+5	; 0x05
    16ea:	98 17       	cp	r25, r24
    16ec:	10 f3       	brcs	.-60     	; 0x16b2 <lcd_clear_area+0x68>
    for(i=0; i<columns; i++) {
      lcd_data(inv);
      }
    lcd_move_xy(1,-columns);
    }
  lcd_move_xy(-pages,0);
    16ee:	8d 81       	ldd	r24, Y+5	; 0x05
    16f0:	81 95       	neg	r24
    16f2:	60 e0       	ldi	r22, 0x00	; 0
    16f4:	70 e0       	ldi	r23, 0x00	; 0
    16f6:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_move_xy>
  }
    16fa:	27 96       	adiw	r28, 0x07	; 7
    16fc:	0f b6       	in	r0, 0x3f	; 63
    16fe:	f8 94       	cli
    1700:	de bf       	out	0x3e, r29	; 62
    1702:	0f be       	out	0x3f, r0	; 63
    1704:	cd bf       	out	0x3d, r28	; 61
    1706:	df 91       	pop	r29
    1708:	cf 91       	pop	r28
    170a:	08 95       	ret

0000170c <lcd_clear_all>:


void lcd_clear_all( void )
{
    170c:	cf 93       	push	r28
    170e:	df 93       	push	r29
    1710:	cd b7       	in	r28, 0x3d	; 61
    1712:	de b7       	in	r29, 0x3e	; 62
    lcd_moveto_xy  ( 0, 0 );
    1714:	80 e0       	ldi	r24, 0x00	; 0
    1716:	60 e0       	ldi	r22, 0x00	; 0
    1718:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
    lcd_clear_area( 1, 132, NORMAL );
    171c:	81 e0       	ldi	r24, 0x01	; 1
    171e:	64 e8       	ldi	r22, 0x84	; 132
    1720:	40 e0       	ldi	r20, 0x00	; 0
    1722:	0e 94 25 0b 	call	0x164a	; 0x164a <lcd_clear_area>
    lcd_moveto_xy  ( 1, 0 );
    1726:	81 e0       	ldi	r24, 0x01	; 1
    1728:	60 e0       	ldi	r22, 0x00	; 0
    172a:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
    lcd_clear_area( 1, 132, NORMAL );
    172e:	81 e0       	ldi	r24, 0x01	; 1
    1730:	64 e8       	ldi	r22, 0x84	; 132
    1732:	40 e0       	ldi	r20, 0x00	; 0
    1734:	0e 94 25 0b 	call	0x164a	; 0x164a <lcd_clear_area>
    lcd_moveto_xy  ( 2, 0 );
    1738:	82 e0       	ldi	r24, 0x02	; 2
    173a:	60 e0       	ldi	r22, 0x00	; 0
    173c:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
    lcd_clear_area( 1, 132, NORMAL );
    1740:	81 e0       	ldi	r24, 0x01	; 1
    1742:	64 e8       	ldi	r22, 0x84	; 132
    1744:	40 e0       	ldi	r20, 0x00	; 0
    1746:	0e 94 25 0b 	call	0x164a	; 0x164a <lcd_clear_area>
    lcd_moveto_xy  ( 3, 0 );
    174a:	83 e0       	ldi	r24, 0x03	; 3
    174c:	60 e0       	ldi	r22, 0x00	; 0
    174e:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
    lcd_clear_area( 1, 132, NORMAL );
    1752:	81 e0       	ldi	r24, 0x01	; 1
    1754:	64 e8       	ldi	r22, 0x84	; 132
    1756:	40 e0       	ldi	r20, 0x00	; 0
    1758:	0e 94 25 0b 	call	0x164a	; 0x164a <lcd_clear_area>
}
    175c:	df 91       	pop	r29
    175e:	cf 91       	pop	r28
    1760:	08 95       	ret

00001762 <lcd_clear_area_xy>:
 * style         - style modifier
 * col           - column of upper left corner
 * page          - page of upper left corner
 * Cursor is moved to start of area after clear
 */
void lcd_clear_area_xy(uint8_t pages, uint8_t columns, uint8_t style, uint8_t col, uint8_t page) {
    1762:	0f 93       	push	r16
    1764:	cf 93       	push	r28
    1766:	df 93       	push	r29
    1768:	00 d0       	rcall	.+0      	; 0x176a <lcd_clear_area_xy+0x8>
    176a:	00 d0       	rcall	.+0      	; 0x176c <lcd_clear_area_xy+0xa>
    176c:	0f 92       	push	r0
    176e:	cd b7       	in	r28, 0x3d	; 61
    1770:	de b7       	in	r29, 0x3e	; 62
    1772:	89 83       	std	Y+1, r24	; 0x01
    1774:	6a 83       	std	Y+2, r22	; 0x02
    1776:	4b 83       	std	Y+3, r20	; 0x03
    1778:	2c 83       	std	Y+4, r18	; 0x04
    177a:	0d 83       	std	Y+5, r16	; 0x05
  lcd_moveto_xy(col,page);
    177c:	8c 81       	ldd	r24, Y+4	; 0x04
    177e:	6d 81       	ldd	r22, Y+5	; 0x05
    1780:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
  lcd_clear_area(pages,columns,style);
    1784:	89 81       	ldd	r24, Y+1	; 0x01
    1786:	6a 81       	ldd	r22, Y+2	; 0x02
    1788:	4b 81       	ldd	r20, Y+3	; 0x03
    178a:	0e 94 25 0b 	call	0x164a	; 0x164a <lcd_clear_area>
  }
    178e:	0f 90       	pop	r0
    1790:	0f 90       	pop	r0
    1792:	0f 90       	pop	r0
    1794:	0f 90       	pop	r0
    1796:	0f 90       	pop	r0
    1798:	df 91       	pop	r29
    179a:	cf 91       	pop	r28
    179c:	0f 91       	pop	r16
    179e:	08 95       	ret

000017a0 <lcd_init>:
/******************************************************************************
  * Initializes the display in 6 o'clock mode, 4x booster for 2.4-3.3V supply voltage
  * scheme according to datasheet
  * Suitable for all DOGS, DOGM and DOGL displays.
  */
void lcd_init() {
    17a0:	0f 93       	push	r16
    17a2:	1f 93       	push	r17
    17a4:	cf 93       	push	r28
    17a6:	df 93       	push	r29
    17a8:	cd b7       	in	r28, 0x3d	; 61
    17aa:	de b7       	in	r29, 0x3e	; 62
    17ac:	ac 97       	sbiw	r28, 0x2c	; 44
    17ae:	0f b6       	in	r0, 0x3f	; 63
    17b0:	f8 94       	cli
    17b2:	de bf       	out	0x3e, r29	; 62
    17b4:	0f be       	out	0x3f, r0	; 63
    17b6:	cd bf       	out	0x3d, r28	; 61

    
    
  //set outputs
  //LCD_SET_PIN_DIRECTIONS();
  DDR_A0 |= (1<<PIN_A0);
    17b8:	84 e2       	ldi	r24, 0x24	; 36
    17ba:	90 e0       	ldi	r25, 0x00	; 0
    17bc:	24 e2       	ldi	r18, 0x24	; 36
    17be:	30 e0       	ldi	r19, 0x00	; 0
    17c0:	f9 01       	movw	r30, r18
    17c2:	20 81       	ld	r18, Z
    17c4:	24 60       	ori	r18, 0x04	; 4
    17c6:	fc 01       	movw	r30, r24
    17c8:	20 83       	st	Z, r18
  DDR_RST |= (1<<PIN_RST);
    17ca:	87 e2       	ldi	r24, 0x27	; 39
    17cc:	90 e0       	ldi	r25, 0x00	; 0
    17ce:	27 e2       	ldi	r18, 0x27	; 39
    17d0:	30 e0       	ldi	r19, 0x00	; 0
    17d2:	f9 01       	movw	r30, r18
    17d4:	20 81       	ld	r18, Z
    17d6:	21 60       	ori	r18, 0x01	; 1
    17d8:	fc 01       	movw	r30, r24
    17da:	20 83       	st	Z, r18
  DDR_CS  |= (1<<PIN_CS);
    17dc:	84 e2       	ldi	r24, 0x24	; 36
    17de:	90 e0       	ldi	r25, 0x00	; 0
    17e0:	24 e2       	ldi	r18, 0x24	; 36
    17e2:	30 e0       	ldi	r19, 0x00	; 0
    17e4:	f9 01       	movw	r30, r18
    17e6:	20 81       	ld	r18, Z
    17e8:	20 61       	ori	r18, 0x10	; 16
    17ea:	fc 01       	movw	r30, r24
    17ec:	20 83       	st	Z, r18
  
  
  //Initialize SPI Interface
  //LCD_INIT_SPI();   
  init_spi_lcd();
    17ee:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <init_spi_lcd>
    
  
  //Apply Reset to the Display Controller
  //LCD_RESET();
  PORT_RST &= ~(1<<PIN_RST);
    17f2:	88 e2       	ldi	r24, 0x28	; 40
    17f4:	90 e0       	ldi	r25, 0x00	; 0
    17f6:	28 e2       	ldi	r18, 0x28	; 40
    17f8:	30 e0       	ldi	r19, 0x00	; 0
    17fa:	f9 01       	movw	r30, r18
    17fc:	20 81       	ld	r18, Z
    17fe:	2e 7f       	andi	r18, 0xFE	; 254
    1800:	fc 01       	movw	r30, r24
    1802:	20 83       	st	Z, r18
    1804:	80 e0       	ldi	r24, 0x00	; 0
    1806:	90 e0       	ldi	r25, 0x00	; 0
    1808:	a0 e8       	ldi	r26, 0x80	; 128
    180a:	bf e3       	ldi	r27, 0x3F	; 63
    180c:	8b 83       	std	Y+3, r24	; 0x03
    180e:	9c 83       	std	Y+4, r25	; 0x04
    1810:	ad 83       	std	Y+5, r26	; 0x05
    1812:	be 83       	std	Y+6, r27	; 0x06
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    1814:	6b 81       	ldd	r22, Y+3	; 0x03
    1816:	7c 81       	ldd	r23, Y+4	; 0x04
    1818:	8d 81       	ldd	r24, Y+5	; 0x05
    181a:	9e 81       	ldd	r25, Y+6	; 0x06
    181c:	20 e0       	ldi	r18, 0x00	; 0
    181e:	30 e0       	ldi	r19, 0x00	; 0
    1820:	4a e7       	ldi	r20, 0x7A	; 122
    1822:	53 e4       	ldi	r21, 0x43	; 67
    1824:	0e 94 9e 35 	call	0x6b3c	; 0x6b3c <__mulsf3>
    1828:	dc 01       	movw	r26, r24
    182a:	cb 01       	movw	r24, r22
    182c:	8f 83       	std	Y+7, r24	; 0x07
    182e:	98 87       	std	Y+8, r25	; 0x08
    1830:	a9 87       	std	Y+9, r26	; 0x09
    1832:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1834:	11 e0       	ldi	r17, 0x01	; 1
    1836:	6f 81       	ldd	r22, Y+7	; 0x07
    1838:	78 85       	ldd	r23, Y+8	; 0x08
    183a:	89 85       	ldd	r24, Y+9	; 0x09
    183c:	9a 85       	ldd	r25, Y+10	; 0x0a
    183e:	20 e0       	ldi	r18, 0x00	; 0
    1840:	30 e0       	ldi	r19, 0x00	; 0
    1842:	40 e8       	ldi	r20, 0x80	; 128
    1844:	5f e3       	ldi	r21, 0x3F	; 63
    1846:	0e 94 1d 35 	call	0x6a3a	; 0x6a3a <__cmpsf2>
    184a:	88 23       	and	r24, r24
    184c:	0c f0       	brlt	.+2      	; 0x1850 <lcd_init+0xb0>
    184e:	10 e0       	ldi	r17, 0x00	; 0
    1850:	11 23       	and	r17, r17
    1852:	29 f0       	breq	.+10     	; 0x185e <lcd_init+0xbe>
		__ticks = 1;
    1854:	81 e0       	ldi	r24, 0x01	; 1
    1856:	90 e0       	ldi	r25, 0x00	; 0
    1858:	9c 87       	std	Y+12, r25	; 0x0c
    185a:	8b 87       	std	Y+11, r24	; 0x0b
    185c:	46 c0       	rjmp	.+140    	; 0x18ea <lcd_init+0x14a>
	else if (__tmp > 65535)
    185e:	11 e0       	ldi	r17, 0x01	; 1
    1860:	6f 81       	ldd	r22, Y+7	; 0x07
    1862:	78 85       	ldd	r23, Y+8	; 0x08
    1864:	89 85       	ldd	r24, Y+9	; 0x09
    1866:	9a 85       	ldd	r25, Y+10	; 0x0a
    1868:	20 e0       	ldi	r18, 0x00	; 0
    186a:	3f ef       	ldi	r19, 0xFF	; 255
    186c:	4f e7       	ldi	r20, 0x7F	; 127
    186e:	57 e4       	ldi	r21, 0x47	; 71
    1870:	0e 94 9a 35 	call	0x6b34	; 0x6b34 <__gesf2>
    1874:	18 16       	cp	r1, r24
    1876:	0c f0       	brlt	.+2      	; 0x187a <lcd_init+0xda>
    1878:	10 e0       	ldi	r17, 0x00	; 0
    187a:	11 23       	and	r17, r17
    187c:	61 f1       	breq	.+88     	; 0x18d6 <lcd_init+0x136>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    187e:	6b 81       	ldd	r22, Y+3	; 0x03
    1880:	7c 81       	ldd	r23, Y+4	; 0x04
    1882:	8d 81       	ldd	r24, Y+5	; 0x05
    1884:	9e 81       	ldd	r25, Y+6	; 0x06
    1886:	20 e0       	ldi	r18, 0x00	; 0
    1888:	30 e0       	ldi	r19, 0x00	; 0
    188a:	40 e2       	ldi	r20, 0x20	; 32
    188c:	51 e4       	ldi	r21, 0x41	; 65
    188e:	0e 94 9e 35 	call	0x6b3c	; 0x6b3c <__mulsf3>
    1892:	dc 01       	movw	r26, r24
    1894:	cb 01       	movw	r24, r22
    1896:	bc 01       	movw	r22, r24
    1898:	cd 01       	movw	r24, r26
    189a:	0e 94 21 35 	call	0x6a42	; 0x6a42 <__fixunssfsi>
    189e:	dc 01       	movw	r26, r24
    18a0:	cb 01       	movw	r24, r22
    18a2:	9c 87       	std	Y+12, r25	; 0x0c
    18a4:	8b 87       	std	Y+11, r24	; 0x0b
    18a6:	12 c0       	rjmp	.+36     	; 0x18cc <lcd_init+0x12c>
    18a8:	89 e1       	ldi	r24, 0x19	; 25
    18aa:	90 e0       	ldi	r25, 0x00	; 0
    18ac:	9e 87       	std	Y+14, r25	; 0x0e
    18ae:	8d 87       	std	Y+13, r24	; 0x0d
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    18b0:	8d 85       	ldd	r24, Y+13	; 0x0d
    18b2:	9e 85       	ldd	r25, Y+14	; 0x0e
    18b4:	8c 01       	movw	r16, r24
    18b6:	c8 01       	movw	r24, r16
    18b8:	01 97       	sbiw	r24, 0x01	; 1
    18ba:	f1 f7       	brne	.-4      	; 0x18b8 <lcd_init+0x118>
    18bc:	8c 01       	movw	r16, r24
    18be:	1e 87       	std	Y+14, r17	; 0x0e
    18c0:	0d 87       	std	Y+13, r16	; 0x0d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    18c2:	8b 85       	ldd	r24, Y+11	; 0x0b
    18c4:	9c 85       	ldd	r25, Y+12	; 0x0c
    18c6:	01 97       	sbiw	r24, 0x01	; 1
    18c8:	9c 87       	std	Y+12, r25	; 0x0c
    18ca:	8b 87       	std	Y+11, r24	; 0x0b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    18cc:	8b 85       	ldd	r24, Y+11	; 0x0b
    18ce:	9c 85       	ldd	r25, Y+12	; 0x0c
    18d0:	00 97       	sbiw	r24, 0x00	; 0
    18d2:	51 f7       	brne	.-44     	; 0x18a8 <lcd_init+0x108>
    18d4:	17 c0       	rjmp	.+46     	; 0x1904 <lcd_init+0x164>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    18d6:	6f 81       	ldd	r22, Y+7	; 0x07
    18d8:	78 85       	ldd	r23, Y+8	; 0x08
    18da:	89 85       	ldd	r24, Y+9	; 0x09
    18dc:	9a 85       	ldd	r25, Y+10	; 0x0a
    18de:	0e 94 21 35 	call	0x6a42	; 0x6a42 <__fixunssfsi>
    18e2:	dc 01       	movw	r26, r24
    18e4:	cb 01       	movw	r24, r22
    18e6:	9c 87       	std	Y+12, r25	; 0x0c
    18e8:	8b 87       	std	Y+11, r24	; 0x0b
    18ea:	8b 85       	ldd	r24, Y+11	; 0x0b
    18ec:	9c 85       	ldd	r25, Y+12	; 0x0c
    18ee:	98 8b       	std	Y+16, r25	; 0x10
    18f0:	8f 87       	std	Y+15, r24	; 0x0f
    18f2:	8f 85       	ldd	r24, Y+15	; 0x0f
    18f4:	98 89       	ldd	r25, Y+16	; 0x10
    18f6:	8c 01       	movw	r16, r24
    18f8:	f8 01       	movw	r30, r16
    18fa:	31 97       	sbiw	r30, 0x01	; 1
    18fc:	f1 f7       	brne	.-4      	; 0x18fa <lcd_init+0x15a>
    18fe:	8f 01       	movw	r16, r30
    1900:	18 8b       	std	Y+16, r17	; 0x10
    1902:	0f 87       	std	Y+15, r16	; 0x0f
  _delay_ms(1);
  PORT_RST |= (1<<PIN_RST);
    1904:	88 e2       	ldi	r24, 0x28	; 40
    1906:	90 e0       	ldi	r25, 0x00	; 0
    1908:	28 e2       	ldi	r18, 0x28	; 40
    190a:	30 e0       	ldi	r19, 0x00	; 0
    190c:	f9 01       	movw	r30, r18
    190e:	20 81       	ld	r18, Z
    1910:	21 60       	ori	r18, 0x01	; 1
    1912:	fc 01       	movw	r30, r24
    1914:	20 83       	st	Z, r18
  
    
  //Load settings
  
  //(2)
  LCD_SET_FIRST_LINE(0);              //first bit in RAM is on the first line of the LCD
    1916:	80 e4       	ldi	r24, 0x40	; 64
    1918:	0e 94 8e 09 	call	0x131c	; 0x131c <lcd_command>
    191c:	80 e0       	ldi	r24, 0x00	; 0
    191e:	90 e0       	ldi	r25, 0x00	; 0
    1920:	a0 e8       	ldi	r26, 0x80	; 128
    1922:	bf e3       	ldi	r27, 0x3F	; 63
    1924:	89 8b       	std	Y+17, r24	; 0x11
    1926:	9a 8b       	std	Y+18, r25	; 0x12
    1928:	ab 8b       	std	Y+19, r26	; 0x13
    192a:	bc 8b       	std	Y+20, r27	; 0x14
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    192c:	69 89       	ldd	r22, Y+17	; 0x11
    192e:	7a 89       	ldd	r23, Y+18	; 0x12
    1930:	8b 89       	ldd	r24, Y+19	; 0x13
    1932:	9c 89       	ldd	r25, Y+20	; 0x14
    1934:	20 e0       	ldi	r18, 0x00	; 0
    1936:	30 e0       	ldi	r19, 0x00	; 0
    1938:	4a e7       	ldi	r20, 0x7A	; 122
    193a:	53 e4       	ldi	r21, 0x43	; 67
    193c:	0e 94 9e 35 	call	0x6b3c	; 0x6b3c <__mulsf3>
    1940:	dc 01       	movw	r26, r24
    1942:	cb 01       	movw	r24, r22
    1944:	8d 8b       	std	Y+21, r24	; 0x15
    1946:	9e 8b       	std	Y+22, r25	; 0x16
    1948:	af 8b       	std	Y+23, r26	; 0x17
    194a:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    194c:	11 e0       	ldi	r17, 0x01	; 1
    194e:	6d 89       	ldd	r22, Y+21	; 0x15
    1950:	7e 89       	ldd	r23, Y+22	; 0x16
    1952:	8f 89       	ldd	r24, Y+23	; 0x17
    1954:	98 8d       	ldd	r25, Y+24	; 0x18
    1956:	20 e0       	ldi	r18, 0x00	; 0
    1958:	30 e0       	ldi	r19, 0x00	; 0
    195a:	40 e8       	ldi	r20, 0x80	; 128
    195c:	5f e3       	ldi	r21, 0x3F	; 63
    195e:	0e 94 1d 35 	call	0x6a3a	; 0x6a3a <__cmpsf2>
    1962:	88 23       	and	r24, r24
    1964:	0c f0       	brlt	.+2      	; 0x1968 <lcd_init+0x1c8>
    1966:	10 e0       	ldi	r17, 0x00	; 0
    1968:	11 23       	and	r17, r17
    196a:	29 f0       	breq	.+10     	; 0x1976 <lcd_init+0x1d6>
		__ticks = 1;
    196c:	81 e0       	ldi	r24, 0x01	; 1
    196e:	90 e0       	ldi	r25, 0x00	; 0
    1970:	9a 8f       	std	Y+26, r25	; 0x1a
    1972:	89 8f       	std	Y+25, r24	; 0x19
    1974:	46 c0       	rjmp	.+140    	; 0x1a02 <lcd_init+0x262>
	else if (__tmp > 65535)
    1976:	11 e0       	ldi	r17, 0x01	; 1
    1978:	6d 89       	ldd	r22, Y+21	; 0x15
    197a:	7e 89       	ldd	r23, Y+22	; 0x16
    197c:	8f 89       	ldd	r24, Y+23	; 0x17
    197e:	98 8d       	ldd	r25, Y+24	; 0x18
    1980:	20 e0       	ldi	r18, 0x00	; 0
    1982:	3f ef       	ldi	r19, 0xFF	; 255
    1984:	4f e7       	ldi	r20, 0x7F	; 127
    1986:	57 e4       	ldi	r21, 0x47	; 71
    1988:	0e 94 9a 35 	call	0x6b34	; 0x6b34 <__gesf2>
    198c:	18 16       	cp	r1, r24
    198e:	0c f0       	brlt	.+2      	; 0x1992 <lcd_init+0x1f2>
    1990:	10 e0       	ldi	r17, 0x00	; 0
    1992:	11 23       	and	r17, r17
    1994:	61 f1       	breq	.+88     	; 0x19ee <lcd_init+0x24e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1996:	69 89       	ldd	r22, Y+17	; 0x11
    1998:	7a 89       	ldd	r23, Y+18	; 0x12
    199a:	8b 89       	ldd	r24, Y+19	; 0x13
    199c:	9c 89       	ldd	r25, Y+20	; 0x14
    199e:	20 e0       	ldi	r18, 0x00	; 0
    19a0:	30 e0       	ldi	r19, 0x00	; 0
    19a2:	40 e2       	ldi	r20, 0x20	; 32
    19a4:	51 e4       	ldi	r21, 0x41	; 65
    19a6:	0e 94 9e 35 	call	0x6b3c	; 0x6b3c <__mulsf3>
    19aa:	dc 01       	movw	r26, r24
    19ac:	cb 01       	movw	r24, r22
    19ae:	bc 01       	movw	r22, r24
    19b0:	cd 01       	movw	r24, r26
    19b2:	0e 94 21 35 	call	0x6a42	; 0x6a42 <__fixunssfsi>
    19b6:	dc 01       	movw	r26, r24
    19b8:	cb 01       	movw	r24, r22
    19ba:	9a 8f       	std	Y+26, r25	; 0x1a
    19bc:	89 8f       	std	Y+25, r24	; 0x19
    19be:	12 c0       	rjmp	.+36     	; 0x19e4 <lcd_init+0x244>
    19c0:	89 e1       	ldi	r24, 0x19	; 25
    19c2:	90 e0       	ldi	r25, 0x00	; 0
    19c4:	9c 8f       	std	Y+28, r25	; 0x1c
    19c6:	8b 8f       	std	Y+27, r24	; 0x1b
    19c8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    19ca:	9c 8d       	ldd	r25, Y+28	; 0x1c
    19cc:	8c 01       	movw	r16, r24
    19ce:	c8 01       	movw	r24, r16
    19d0:	01 97       	sbiw	r24, 0x01	; 1
    19d2:	f1 f7       	brne	.-4      	; 0x19d0 <lcd_init+0x230>
    19d4:	8c 01       	movw	r16, r24
    19d6:	1c 8f       	std	Y+28, r17	; 0x1c
    19d8:	0b 8f       	std	Y+27, r16	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19da:	89 8d       	ldd	r24, Y+25	; 0x19
    19dc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    19de:	01 97       	sbiw	r24, 0x01	; 1
    19e0:	9a 8f       	std	Y+26, r25	; 0x1a
    19e2:	89 8f       	std	Y+25, r24	; 0x19
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    19e4:	89 8d       	ldd	r24, Y+25	; 0x19
    19e6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    19e8:	00 97       	sbiw	r24, 0x00	; 0
    19ea:	51 f7       	brne	.-44     	; 0x19c0 <lcd_init+0x220>
    19ec:	17 c0       	rjmp	.+46     	; 0x1a1c <lcd_init+0x27c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    19ee:	6d 89       	ldd	r22, Y+21	; 0x15
    19f0:	7e 89       	ldd	r23, Y+22	; 0x16
    19f2:	8f 89       	ldd	r24, Y+23	; 0x17
    19f4:	98 8d       	ldd	r25, Y+24	; 0x18
    19f6:	0e 94 21 35 	call	0x6a42	; 0x6a42 <__fixunssfsi>
    19fa:	dc 01       	movw	r26, r24
    19fc:	cb 01       	movw	r24, r22
    19fe:	9a 8f       	std	Y+26, r25	; 0x1a
    1a00:	89 8f       	std	Y+25, r24	; 0x19
    1a02:	89 8d       	ldd	r24, Y+25	; 0x19
    1a04:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a06:	9e 8f       	std	Y+30, r25	; 0x1e
    1a08:	8d 8f       	std	Y+29, r24	; 0x1d
    1a0a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1a0c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1a0e:	8c 01       	movw	r16, r24
    1a10:	f8 01       	movw	r30, r16
    1a12:	31 97       	sbiw	r30, 0x01	; 1
    1a14:	f1 f7       	brne	.-4      	; 0x1a12 <lcd_init+0x272>
    1a16:	8f 01       	movw	r16, r30
    1a18:	1e 8f       	std	Y+30, r17	; 0x1e
    1a1a:	0d 8f       	std	Y+29, r16	; 0x1d
  //without this delay the content is displayed mirror inverted
  _delay_ms(1); 


  //(8)     
  LCD_SET_BOTTOM_VIEW();              //6 o'clock mode, normal orientation
    1a1c:	81 ea       	ldi	r24, 0xA1	; 161
    1a1e:	0e 94 8e 09 	call	0x131c	; 0x131c <lcd_command>
  // |
  //  --> lcd_command(LCD_BOTTOMVIEW)
  //					-> LCD_BOTTOMVIEW = ADC reverse
  //_delay_ms(1);
  //(15)
  LCD_ORIENTATION_NORMAL();
    1a22:	80 ec       	ldi	r24, 0xC0	; 192
    1a24:	0e 94 8e 09 	call	0x131c	; 0x131c <lcd_command>
    1a28:	80 e0       	ldi	r24, 0x00	; 0
    1a2a:	90 e0       	ldi	r25, 0x00	; 0
    1a2c:	a0 e8       	ldi	r26, 0x80	; 128
    1a2e:	bf e3       	ldi	r27, 0x3F	; 63
    1a30:	8f 8f       	std	Y+31, r24	; 0x1f
    1a32:	98 a3       	lds	r25, 0x58
    1a34:	a9 a3       	lds	r26, 0x59
    1a36:	ba a3       	lds	r27, 0x5a
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    1a38:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1a3a:	78 a1       	lds	r23, 0x48
    1a3c:	89 a1       	lds	r24, 0x49
    1a3e:	9a a1       	lds	r25, 0x4a
    1a40:	20 e0       	ldi	r18, 0x00	; 0
    1a42:	30 e0       	ldi	r19, 0x00	; 0
    1a44:	4a e7       	ldi	r20, 0x7A	; 122
    1a46:	53 e4       	ldi	r21, 0x43	; 67
    1a48:	0e 94 9e 35 	call	0x6b3c	; 0x6b3c <__mulsf3>
    1a4c:	dc 01       	movw	r26, r24
    1a4e:	cb 01       	movw	r24, r22
    1a50:	8b a3       	lds	r24, 0x5b
    1a52:	9c a3       	lds	r25, 0x5c
    1a54:	ad a3       	lds	r26, 0x5d
    1a56:	be a3       	lds	r27, 0x5e
	if (__tmp < 1.0)
    1a58:	11 e0       	ldi	r17, 0x01	; 1
    1a5a:	6b a1       	lds	r22, 0x4b
    1a5c:	7c a1       	lds	r23, 0x4c
    1a5e:	8d a1       	lds	r24, 0x4d
    1a60:	9e a1       	lds	r25, 0x4e
    1a62:	20 e0       	ldi	r18, 0x00	; 0
    1a64:	30 e0       	ldi	r19, 0x00	; 0
    1a66:	40 e8       	ldi	r20, 0x80	; 128
    1a68:	5f e3       	ldi	r21, 0x3F	; 63
    1a6a:	0e 94 1d 35 	call	0x6a3a	; 0x6a3a <__cmpsf2>
    1a6e:	88 23       	and	r24, r24
    1a70:	0c f0       	brlt	.+2      	; 0x1a74 <lcd_init+0x2d4>
    1a72:	10 e0       	ldi	r17, 0x00	; 0
    1a74:	11 23       	and	r17, r17
    1a76:	29 f0       	breq	.+10     	; 0x1a82 <lcd_init+0x2e2>
		__ticks = 1;
    1a78:	81 e0       	ldi	r24, 0x01	; 1
    1a7a:	90 e0       	ldi	r25, 0x00	; 0
    1a7c:	98 a7       	lds	r25, 0x78
    1a7e:	8f a3       	lds	r24, 0x5f
    1a80:	46 c0       	rjmp	.+140    	; 0x1b0e <lcd_init+0x36e>
	else if (__tmp > 65535)
    1a82:	11 e0       	ldi	r17, 0x01	; 1
    1a84:	6b a1       	lds	r22, 0x4b
    1a86:	7c a1       	lds	r23, 0x4c
    1a88:	8d a1       	lds	r24, 0x4d
    1a8a:	9e a1       	lds	r25, 0x4e
    1a8c:	20 e0       	ldi	r18, 0x00	; 0
    1a8e:	3f ef       	ldi	r19, 0xFF	; 255
    1a90:	4f e7       	ldi	r20, 0x7F	; 127
    1a92:	57 e4       	ldi	r21, 0x47	; 71
    1a94:	0e 94 9a 35 	call	0x6b34	; 0x6b34 <__gesf2>
    1a98:	18 16       	cp	r1, r24
    1a9a:	0c f0       	brlt	.+2      	; 0x1a9e <lcd_init+0x2fe>
    1a9c:	10 e0       	ldi	r17, 0x00	; 0
    1a9e:	11 23       	and	r17, r17
    1aa0:	61 f1       	breq	.+88     	; 0x1afa <lcd_init+0x35a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1aa2:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1aa4:	78 a1       	lds	r23, 0x48
    1aa6:	89 a1       	lds	r24, 0x49
    1aa8:	9a a1       	lds	r25, 0x4a
    1aaa:	20 e0       	ldi	r18, 0x00	; 0
    1aac:	30 e0       	ldi	r19, 0x00	; 0
    1aae:	40 e2       	ldi	r20, 0x20	; 32
    1ab0:	51 e4       	ldi	r21, 0x41	; 65
    1ab2:	0e 94 9e 35 	call	0x6b3c	; 0x6b3c <__mulsf3>
    1ab6:	dc 01       	movw	r26, r24
    1ab8:	cb 01       	movw	r24, r22
    1aba:	bc 01       	movw	r22, r24
    1abc:	cd 01       	movw	r24, r26
    1abe:	0e 94 21 35 	call	0x6a42	; 0x6a42 <__fixunssfsi>
    1ac2:	dc 01       	movw	r26, r24
    1ac4:	cb 01       	movw	r24, r22
    1ac6:	98 a7       	lds	r25, 0x78
    1ac8:	8f a3       	lds	r24, 0x5f
    1aca:	12 c0       	rjmp	.+36     	; 0x1af0 <lcd_init+0x350>
    1acc:	89 e1       	ldi	r24, 0x19	; 25
    1ace:	90 e0       	ldi	r25, 0x00	; 0
    1ad0:	9a a7       	lds	r25, 0x7a
    1ad2:	89 a7       	lds	r24, 0x79
    1ad4:	89 a5       	lds	r24, 0x69
    1ad6:	9a a5       	lds	r25, 0x6a
    1ad8:	8c 01       	movw	r16, r24
    1ada:	c8 01       	movw	r24, r16
    1adc:	01 97       	sbiw	r24, 0x01	; 1
    1ade:	f1 f7       	brne	.-4      	; 0x1adc <lcd_init+0x33c>
    1ae0:	8c 01       	movw	r16, r24
    1ae2:	1a a7       	lds	r17, 0x7a
    1ae4:	09 a7       	lds	r16, 0x79
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1ae6:	8f a1       	lds	r24, 0x4f
    1ae8:	98 a5       	lds	r25, 0x68
    1aea:	01 97       	sbiw	r24, 0x01	; 1
    1aec:	98 a7       	lds	r25, 0x78
    1aee:	8f a3       	lds	r24, 0x5f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1af0:	8f a1       	lds	r24, 0x4f
    1af2:	98 a5       	lds	r25, 0x68
    1af4:	00 97       	sbiw	r24, 0x00	; 0
    1af6:	51 f7       	brne	.-44     	; 0x1acc <lcd_init+0x32c>
    1af8:	17 c0       	rjmp	.+46     	; 0x1b28 <lcd_init+0x388>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1afa:	6b a1       	lds	r22, 0x4b
    1afc:	7c a1       	lds	r23, 0x4c
    1afe:	8d a1       	lds	r24, 0x4d
    1b00:	9e a1       	lds	r25, 0x4e
    1b02:	0e 94 21 35 	call	0x6a42	; 0x6a42 <__fixunssfsi>
    1b06:	dc 01       	movw	r26, r24
    1b08:	cb 01       	movw	r24, r22
    1b0a:	98 a7       	lds	r25, 0x78
    1b0c:	8f a3       	lds	r24, 0x5f
    1b0e:	8f a1       	lds	r24, 0x4f
    1b10:	98 a5       	lds	r25, 0x68
    1b12:	9c a7       	lds	r25, 0x7c
    1b14:	8b a7       	lds	r24, 0x7b
    1b16:	8b a5       	lds	r24, 0x6b
    1b18:	9c a5       	lds	r25, 0x6c
    1b1a:	8c 01       	movw	r16, r24
    1b1c:	f8 01       	movw	r30, r16
    1b1e:	31 97       	sbiw	r30, 0x01	; 1
    1b20:	f1 f7       	brne	.-4      	; 0x1b1e <lcd_init+0x37e>
    1b22:	8f 01       	movw	r16, r30
    1b24:	1c a7       	lds	r17, 0x7c
    1b26:	0b a7       	lds	r16, 0x7b
  // |
  //   --> lcd_command(LCD_SHOW_NORMAL)
  //					-> LCD_SHOW_NORMAL = display all points, normal display (10)
    
  //(9)	
  LCD_SET_MODE_POSITIVE();            //positive display
    1b28:	86 ea       	ldi	r24, 0xA6	; 166
    1b2a:	0e 94 8e 09 	call	0x131c	; 0x131c <lcd_command>
  //  --> lcd_command(LCD_DISPLAY_POSITIVE)
  //      				-> LCD_DISPLAY_POSITIVE = sets display normal (9)
   
  #if DISPLAY_TYPE == 132
    //(11)
    LCD_SET_BIAS_RATIO_1_9();           //bias 1/9
    1b2e:	82 ea       	ldi	r24, 0xA2	; 162
    1b30:	0e 94 8e 09 	call	0x131c	; 0x131c <lcd_command>
    // |
	//  --> lcd_command(LCD_BIAS_1_9)
	
    //(16)	
	LCD_SET_POWER_CONTROL(7);           //power control mode: all features on
    1b34:	8f e2       	ldi	r24, 0x2F	; 47
    1b36:	0e 94 8e 09 	call	0x131c	; 0x131c <lcd_command>
	//  --> lcd_command(LCD_POWER_CONTROL | ((i) & 0x07))  
	//						-> command 16 with operating mode = 0b111
	
	
	//(20) -> selbst eingef¸gtes macro
	LCD_SET_BOOSTER_RATIO();
    1b3a:	80 e0       	ldi	r24, 0x00	; 0
    1b3c:	0e 94 8e 09 	call	0x131c	; 0x131c <lcd_command>
	
	
	//(17)
	LCD_SET_BIAS_VOLTAGE(3);            //set voltage regulator R/R
    1b40:	83 e2       	ldi	r24, 0x23	; 35
    1b42:	0e 94 8e 09 	call	0x131c	; 0x131c <lcd_command>
	// |
	//   --> lcd_command(LCD_VOLTAGE | ((i) & 0x07))
	// 						-> command 17 with resistor ration 0b011
    
	//(18)
	LCD_SET_VOLUME_MODE(0x1F);          //volume mode set
    1b46:	81 e8       	ldi	r24, 0x81	; 129
    1b48:	0e 94 8e 09 	call	0x131c	; 0x131c <lcd_command>
    1b4c:	8f e1       	ldi	r24, 0x1F	; 31
    1b4e:	0e 94 8e 09 	call	0x131c	; 0x131c <lcd_command>
	//						-> standard command 18
	//  --> lcd_command(LCD_VOLUME_MODE_2 | ((i) & 0x3F))
	//						-> command 18 with electronic volume value 0b011111
	
	//(19)
	LCD_SET_INDICATOR_OFF();            //switch indicator off, no blinking
    1b52:	8c ea       	ldi	r24, 0xAC	; 172
    1b54:	0e 94 8e 09 	call	0x131c	; 0x131c <lcd_command>
    1b58:	80 e0       	ldi	r24, 0x00	; 0
    1b5a:	0e 94 8e 09 	call	0x131c	; 0x131c <lcd_command>
  #endif
  
  
  uint8_t i,j;                        //clear display content
 
 for(j=0;j<LCD_RAM_PAGES;j++) {
    1b5e:	1a 82       	std	Y+2, r1	; 0x02
    1b60:	12 c0       	rjmp	.+36     	; 0x1b86 <lcd_init+0x3e6>
    lcd_moveto_xy(j,0);   // array (uint8_t page, uint8_t column)
    1b62:	8a 81       	ldd	r24, Y+2	; 0x02
    1b64:	60 e0       	ldi	r22, 0x00	; 0
    1b66:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
    for (i=0;i<LCD_WIDTH;i++)
    1b6a:	19 82       	std	Y+1, r1	; 0x01
    1b6c:	06 c0       	rjmp	.+12     	; 0x1b7a <lcd_init+0x3da>
      lcd_data(0);
    1b6e:	80 e0       	ldi	r24, 0x00	; 0
    1b70:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <lcd_data>
  
  uint8_t i,j;                        //clear display content
 
 for(j=0;j<LCD_RAM_PAGES;j++) {
    lcd_moveto_xy(j,0);   // array (uint8_t page, uint8_t column)
    for (i=0;i<LCD_WIDTH;i++)
    1b74:	89 81       	ldd	r24, Y+1	; 0x01
    1b76:	8f 5f       	subi	r24, 0xFF	; 255
    1b78:	89 83       	std	Y+1, r24	; 0x01
    1b7a:	89 81       	ldd	r24, Y+1	; 0x01
    1b7c:	84 38       	cpi	r24, 0x84	; 132
    1b7e:	b8 f3       	brcs	.-18     	; 0x1b6e <lcd_init+0x3ce>
  #endif
  
  
  uint8_t i,j;                        //clear display content
 
 for(j=0;j<LCD_RAM_PAGES;j++) {
    1b80:	8a 81       	ldd	r24, Y+2	; 0x02
    1b82:	8f 5f       	subi	r24, 0xFF	; 255
    1b84:	8a 83       	std	Y+2, r24	; 0x02
    1b86:	8a 81       	ldd	r24, Y+2	; 0x02
    1b88:	84 30       	cpi	r24, 0x04	; 4
    1b8a:	58 f3       	brcs	.-42     	; 0x1b62 <lcd_init+0x3c2>
    lcd_moveto_xy(j,0);   // array (uint8_t page, uint8_t column)
    for (i=0;i<LCD_WIDTH;i++)
      lcd_data(0);
    }

  lcd_moveto_xy(0,0);                 //Set write pointer
    1b8c:	80 e0       	ldi	r24, 0x00	; 0
    1b8e:	60 e0       	ldi	r22, 0x00	; 0
    1b90:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
  LCD_SWITCH_ON();                    //Switch display on (1)
    1b94:	8f ea       	ldi	r24, 0xAF	; 175
    1b96:	0e 94 8e 09 	call	0x131c	; 0x131c <lcd_command>
  return;
  }
    1b9a:	ac 96       	adiw	r28, 0x2c	; 44
    1b9c:	0f b6       	in	r0, 0x3f	; 63
    1b9e:	f8 94       	cli
    1ba0:	de bf       	out	0x3e, r29	; 62
    1ba2:	0f be       	out	0x3f, r0	; 63
    1ba4:	cd bf       	out	0x3d, r28	; 61
    1ba6:	df 91       	pop	r29
    1ba8:	cf 91       	pop	r28
    1baa:	1f 91       	pop	r17
    1bac:	0f 91       	pop	r16
    1bae:	08 95       	ret

00001bb0 <init_spi_lcd>:
/******************************************************************************
  * This function initializes the SPI device on an atmega8#
  */
void init_spi_lcd() {
    1bb0:	cf 93       	push	r28
    1bb2:	df 93       	push	r29
    1bb4:	cd b7       	in	r28, 0x3d	; 61
    1bb6:	de b7       	in	r29, 0x3e	; 62
   
   
   //set MOSI and SCK as output pins
   DDRB |= (1<<PINB5)|(1<<PINB7);
    1bb8:	84 e2       	ldi	r24, 0x24	; 36
    1bba:	90 e0       	ldi	r25, 0x00	; 0
    1bbc:	24 e2       	ldi	r18, 0x24	; 36
    1bbe:	30 e0       	ldi	r19, 0x00	; 0
    1bc0:	f9 01       	movw	r30, r18
    1bc2:	20 81       	ld	r18, Z
    1bc4:	20 6a       	ori	r18, 0xA0	; 160
    1bc6:	fc 01       	movw	r30, r24
    1bc8:	20 83       	st	Z, r18
   
   //set A0, LCD_Reset as outputs
   //DDRA |= (1<<PINA5) | (1<<PINA4);
   
   //set SS` as an output pin
   DDRB |= (1<<PINB4);
    1bca:	84 e2       	ldi	r24, 0x24	; 36
    1bcc:	90 e0       	ldi	r25, 0x00	; 0
    1bce:	24 e2       	ldi	r18, 0x24	; 36
    1bd0:	30 e0       	ldi	r19, 0x00	; 0
    1bd2:	f9 01       	movw	r30, r18
    1bd4:	20 81       	ld	r18, Z
    1bd6:	20 61       	ori	r18, 0x10	; 16
    1bd8:	fc 01       	movw	r30, r24
    1bda:	20 83       	st	Z, r18
		CPOL:   Clock Polarity -> leading edge  = falling edge
							   -> trailing edge = rising edge
		CPHA:	Clock Phase -> Leading edge  = setup
							   Trailing edge = sample
   */
   SPCR = (0<<SPIE) | (1<<SPE) | (0<<DORD) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (0<<SPR1) | (0<<SPR0);
    1bdc:	8c e4       	ldi	r24, 0x4C	; 76
    1bde:	90 e0       	ldi	r25, 0x00	; 0
    1be0:	2c e5       	ldi	r18, 0x5C	; 92
    1be2:	fc 01       	movw	r30, r24
    1be4:	20 83       	st	Z, r18
         
   
   
   //SPI status register
   //SPI2X: Double SPI Speed Bit -> minimum SCK period will be two CPU clock periods
   SPSR = (1<<SPI2X);
    1be6:	8d e4       	ldi	r24, 0x4D	; 77
    1be8:	90 e0       	ldi	r25, 0x00	; 0
    1bea:	21 e0       	ldi	r18, 0x01	; 1
    1bec:	fc 01       	movw	r30, r24
    1bee:	20 83       	st	Z, r18

   SPDR = LCD_NOP; //Do not use 0 here, only LCD_NOP is allowed!
    1bf0:	8e e4       	ldi	r24, 0x4E	; 78
    1bf2:	90 e0       	ldi	r25, 0x00	; 0
    1bf4:	23 ee       	ldi	r18, 0xE3	; 227
    1bf6:	fc 01       	movw	r30, r24
    1bf8:	20 83       	st	Z, r18
   

   
   }
    1bfa:	df 91       	pop	r29
    1bfc:	cf 91       	pop	r28
    1bfe:	08 95       	ret

00001c00 <lcd_get_position_page>:


//Function to read the current position
extern uint8_t lcd_current_page;
extern uint8_t lcd_current_column;
static inline uint8_t lcd_get_position_page()   {return lcd_current_page;};
    1c00:	cf 93       	push	r28
    1c02:	df 93       	push	r29
    1c04:	cd b7       	in	r28, 0x3d	; 61
    1c06:	de b7       	in	r29, 0x3e	; 62
    1c08:	80 91 58 01 	lds	r24, 0x0158
    1c0c:	df 91       	pop	r29
    1c0e:	cf 91       	pop	r28
    1c10:	08 95       	ret

00001c12 <lcd_get_position_column>:
static inline uint8_t lcd_get_position_column() {return lcd_current_column;};
    1c12:	cf 93       	push	r28
    1c14:	df 93       	push	r29
    1c16:	cd b7       	in	r28, 0x3d	; 61
    1c18:	de b7       	in	r29, 0x3e	; 62
    1c1a:	80 91 59 01 	lds	r24, 0x0159
    1c1e:	df 91       	pop	r29
    1c20:	cf 91       	pop	r28
    1c22:	08 95       	ret

00001c24 <lcd_set_font>:
/******************************************************************************
 * Stores the default font type and style in a global variable
 * font          - Font identifier
 * style         - Style Modifier
 */
inline void lcd_set_font(FONT_P font, uint8_t style){
    1c24:	cf 93       	push	r28
    1c26:	df 93       	push	r29
    1c28:	00 d0       	rcall	.+0      	; 0x1c2a <lcd_set_font+0x6>
    1c2a:	0f 92       	push	r0
    1c2c:	cd b7       	in	r28, 0x3d	; 61
    1c2e:	de b7       	in	r29, 0x3e	; 62
    1c30:	9a 83       	std	Y+2, r25	; 0x02
    1c32:	89 83       	std	Y+1, r24	; 0x01
    1c34:	6b 83       	std	Y+3, r22	; 0x03
  global_font_select = font;
    1c36:	89 81       	ldd	r24, Y+1	; 0x01
    1c38:	9a 81       	ldd	r25, Y+2	; 0x02
    1c3a:	90 93 c3 0d 	sts	0x0DC3, r25
    1c3e:	80 93 c2 0d 	sts	0x0DC2, r24
  global_font_style = style;
    1c42:	8b 81       	ldd	r24, Y+3	; 0x03
    1c44:	80 93 c1 0d 	sts	0x0DC1, r24
}
    1c48:	0f 90       	pop	r0
    1c4a:	0f 90       	pop	r0
    1c4c:	0f 90       	pop	r0
    1c4e:	df 91       	pop	r29
    1c50:	cf 91       	pop	r28
    1c52:	08 95       	ret

00001c54 <font_data>:
 *****************************************************************************/

/******************************************************************************
 * Loads the pointer to the selected fonts data
 */
inline PGM_P font_data(FONT_P font) {
    1c54:	ef 92       	push	r14
    1c56:	ff 92       	push	r15
    1c58:	0f 93       	push	r16
    1c5a:	1f 93       	push	r17
    1c5c:	cf 93       	push	r28
    1c5e:	df 93       	push	r29
    1c60:	cd b7       	in	r28, 0x3d	; 61
    1c62:	de b7       	in	r29, 0x3e	; 62
    1c64:	28 97       	sbiw	r28, 0x08	; 8
    1c66:	0f b6       	in	r0, 0x3f	; 63
    1c68:	f8 94       	cli
    1c6a:	de bf       	out	0x3e, r29	; 62
    1c6c:	0f be       	out	0x3f, r0	; 63
    1c6e:	cd bf       	out	0x3d, r28	; 61
    1c70:	98 87       	std	Y+8, r25	; 0x08
    1c72:	8f 83       	std	Y+7, r24	; 0x07
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->data));
    1c74:	8f 81       	ldd	r24, Y+7	; 0x07
    1c76:	98 85       	ldd	r25, Y+8	; 0x08
    1c78:	08 96       	adiw	r24, 0x08	; 8
    1c7a:	9a 83       	std	Y+2, r25	; 0x02
    1c7c:	89 83       	std	Y+1, r24	; 0x01
    1c7e:	89 81       	ldd	r24, Y+1	; 0x01
    1c80:	9a 81       	ldd	r25, Y+2	; 0x02
    1c82:	8c 01       	movw	r16, r24
    1c84:	f8 01       	movw	r30, r16
    1c86:	e5 90       	lpm	r14, Z+
    1c88:	f4 90       	lpm	r15, Z
    1c8a:	8f 01       	movw	r16, r30
    1c8c:	fc 82       	std	Y+4, r15	; 0x04
    1c8e:	eb 82       	std	Y+3, r14	; 0x03
    1c90:	1a 83       	std	Y+2, r17	; 0x02
    1c92:	09 83       	std	Y+1, r16	; 0x01
    1c94:	8b 81       	ldd	r24, Y+3	; 0x03
    1c96:	9c 81       	ldd	r25, Y+4	; 0x04
    1c98:	9e 83       	std	Y+6, r25	; 0x06
    1c9a:	8d 83       	std	Y+5, r24	; 0x05
  else
    memcpy_P((char*)&tmp,&(font->data),sizeof(tmp));
  return tmp;
    1c9c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c9e:	9e 81       	ldd	r25, Y+6	; 0x06
  }
    1ca0:	28 96       	adiw	r28, 0x08	; 8
    1ca2:	0f b6       	in	r0, 0x3f	; 63
    1ca4:	f8 94       	cli
    1ca6:	de bf       	out	0x3e, r29	; 62
    1ca8:	0f be       	out	0x3f, r0	; 63
    1caa:	cd bf       	out	0x3d, r28	; 61
    1cac:	df 91       	pop	r29
    1cae:	cf 91       	pop	r28
    1cb0:	1f 91       	pop	r17
    1cb2:	0f 91       	pop	r16
    1cb4:	ff 90       	pop	r15
    1cb6:	ef 90       	pop	r14
    1cb8:	08 95       	ret

00001cba <font_widthtable>:


/******************************************************************************
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
    1cba:	ef 92       	push	r14
    1cbc:	ff 92       	push	r15
    1cbe:	0f 93       	push	r16
    1cc0:	1f 93       	push	r17
    1cc2:	cf 93       	push	r28
    1cc4:	df 93       	push	r29
    1cc6:	cd b7       	in	r28, 0x3d	; 61
    1cc8:	de b7       	in	r29, 0x3e	; 62
    1cca:	28 97       	sbiw	r28, 0x08	; 8
    1ccc:	0f b6       	in	r0, 0x3f	; 63
    1cce:	f8 94       	cli
    1cd0:	de bf       	out	0x3e, r29	; 62
    1cd2:	0f be       	out	0x3f, r0	; 63
    1cd4:	cd bf       	out	0x3d, r28	; 61
    1cd6:	98 87       	std	Y+8, r25	; 0x08
    1cd8:	8f 83       	std	Y+7, r24	; 0x07
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
    1cda:	8f 81       	ldd	r24, Y+7	; 0x07
    1cdc:	98 85       	ldd	r25, Y+8	; 0x08
    1cde:	06 96       	adiw	r24, 0x06	; 6
    1ce0:	9a 83       	std	Y+2, r25	; 0x02
    1ce2:	89 83       	std	Y+1, r24	; 0x01
    1ce4:	89 81       	ldd	r24, Y+1	; 0x01
    1ce6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ce8:	8c 01       	movw	r16, r24
    1cea:	f8 01       	movw	r30, r16
    1cec:	e5 90       	lpm	r14, Z+
    1cee:	f4 90       	lpm	r15, Z
    1cf0:	8f 01       	movw	r16, r30
    1cf2:	fc 82       	std	Y+4, r15	; 0x04
    1cf4:	eb 82       	std	Y+3, r14	; 0x03
    1cf6:	1a 83       	std	Y+2, r17	; 0x02
    1cf8:	09 83       	std	Y+1, r16	; 0x01
    1cfa:	8b 81       	ldd	r24, Y+3	; 0x03
    1cfc:	9c 81       	ldd	r25, Y+4	; 0x04
    1cfe:	9e 83       	std	Y+6, r25	; 0x06
    1d00:	8d 83       	std	Y+5, r24	; 0x05
  else
    memcpy_P((char*)&tmp,&(font->widthtable),sizeof(tmp));
  return tmp;
    1d02:	8d 81       	ldd	r24, Y+5	; 0x05
    1d04:	9e 81       	ldd	r25, Y+6	; 0x06
  }
    1d06:	28 96       	adiw	r28, 0x08	; 8
    1d08:	0f b6       	in	r0, 0x3f	; 63
    1d0a:	f8 94       	cli
    1d0c:	de bf       	out	0x3e, r29	; 62
    1d0e:	0f be       	out	0x3f, r0	; 63
    1d10:	cd bf       	out	0x3d, r28	; 61
    1d12:	df 91       	pop	r29
    1d14:	cf 91       	pop	r28
    1d16:	1f 91       	pop	r17
    1d18:	0f 91       	pop	r16
    1d1a:	ff 90       	pop	r15
    1d1c:	ef 90       	pop	r14
    1d1e:	08 95       	ret

00001d20 <font_get_height_bytes>:


/******************************************************************************
 * Loads the height (in bytes) of the given font
 */
inline uint8_t font_get_height_bytes(FONT_P font) {
    1d20:	1f 93       	push	r17
    1d22:	cf 93       	push	r28
    1d24:	df 93       	push	r29
    1d26:	cd b7       	in	r28, 0x3d	; 61
    1d28:	de b7       	in	r29, 0x3e	; 62
    1d2a:	28 97       	sbiw	r28, 0x08	; 8
    1d2c:	0f b6       	in	r0, 0x3f	; 63
    1d2e:	f8 94       	cli
    1d30:	de bf       	out	0x3e, r29	; 62
    1d32:	0f be       	out	0x3f, r0	; 63
    1d34:	cd bf       	out	0x3d, r28	; 61
    1d36:	98 87       	std	Y+8, r25	; 0x08
    1d38:	8f 83       	std	Y+7, r24	; 0x07
  FONT_P tmp = font;
    1d3a:	8f 81       	ldd	r24, Y+7	; 0x07
    1d3c:	98 85       	ldd	r25, Y+8	; 0x08
    1d3e:	9a 83       	std	Y+2, r25	; 0x02
    1d40:	89 83       	std	Y+1, r24	; 0x01
  uint8_t t = pgm_read_byte(&tmp->height);
    1d42:	89 81       	ldd	r24, Y+1	; 0x01
    1d44:	9a 81       	ldd	r25, Y+2	; 0x02
    1d46:	03 96       	adiw	r24, 0x03	; 3
    1d48:	9c 83       	std	Y+4, r25	; 0x04
    1d4a:	8b 83       	std	Y+3, r24	; 0x03
    1d4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d4e:	9c 81       	ldd	r25, Y+4	; 0x04
    1d50:	fc 01       	movw	r30, r24
    1d52:	14 91       	lpm	r17, Z
    1d54:	1d 83       	std	Y+5, r17	; 0x05
    1d56:	8d 81       	ldd	r24, Y+5	; 0x05
    1d58:	8e 83       	std	Y+6, r24	; 0x06
  return (((uint8_t)(t-1)>>3)+1);
    1d5a:	8e 81       	ldd	r24, Y+6	; 0x06
    1d5c:	81 50       	subi	r24, 0x01	; 1
    1d5e:	86 95       	lsr	r24
    1d60:	86 95       	lsr	r24
    1d62:	86 95       	lsr	r24
    1d64:	8f 5f       	subi	r24, 0xFF	; 255
  }
    1d66:	28 96       	adiw	r28, 0x08	; 8
    1d68:	0f b6       	in	r0, 0x3f	; 63
    1d6a:	f8 94       	cli
    1d6c:	de bf       	out	0x3e, r29	; 62
    1d6e:	0f be       	out	0x3f, r0	; 63
    1d70:	cd bf       	out	0x3d, r28	; 61
    1d72:	df 91       	pop	r29
    1d74:	cf 91       	pop	r28
    1d76:	1f 91       	pop	r17
    1d78:	08 95       	ret

00001d7a <font_get_add_space>:


/******************************************************************************
 * Decides if an additional space to the right of the character is needed
 */
inline uint8_t font_get_add_space(FONT_P font, char character) {
    1d7a:	cf 93       	push	r28
    1d7c:	df 93       	push	r29
    1d7e:	00 d0       	rcall	.+0      	; 0x1d80 <font_get_add_space+0x6>
    1d80:	00 d0       	rcall	.+0      	; 0x1d82 <font_get_add_space+0x8>
    1d82:	0f 92       	push	r0
    1d84:	cd b7       	in	r28, 0x3d	; 61
    1d86:	de b7       	in	r29, 0x3e	; 62
    1d88:	9c 83       	std	Y+4, r25	; 0x04
    1d8a:	8b 83       	std	Y+3, r24	; 0x03
    1d8c:	6d 83       	std	Y+5, r22	; 0x05
  PGM_P type = font_widthtable(font);
    1d8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d90:	9c 81       	ldd	r25, Y+4	; 0x04
    1d92:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <font_widthtable>
    1d96:	9a 83       	std	Y+2, r25	; 0x02
    1d98:	89 83       	std	Y+1, r24	; 0x01
  if ( type != 0 ) //if there is a width table, then it's a proportional font
    1d9a:	89 81       	ldd	r24, Y+1	; 0x01
    1d9c:	9a 81       	ldd	r25, Y+2	; 0x02
    1d9e:	00 97       	sbiw	r24, 0x00	; 0
    1da0:	11 f0       	breq	.+4      	; 0x1da6 <font_get_add_space+0x2c>
    return 1;
    1da2:	81 e0       	ldi	r24, 0x01	; 1
    1da4:	01 c0       	rjmp	.+2      	; 0x1da8 <font_get_add_space+0x2e>
  else
    return 0;
    1da6:	80 e0       	ldi	r24, 0x00	; 0
  }
    1da8:	0f 90       	pop	r0
    1daa:	0f 90       	pop	r0
    1dac:	0f 90       	pop	r0
    1dae:	0f 90       	pop	r0
    1db0:	0f 90       	pop	r0
    1db2:	df 91       	pop	r29
    1db4:	cf 91       	pop	r28
    1db6:	08 95       	ret

00001db8 <font_get_char_number>:


/******************************************************************************
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
    1db8:	1f 93       	push	r17
    1dba:	cf 93       	push	r28
    1dbc:	df 93       	push	r29
    1dbe:	cd b7       	in	r28, 0x3d	; 61
    1dc0:	de b7       	in	r29, 0x3e	; 62
    1dc2:	2c 97       	sbiw	r28, 0x0c	; 12
    1dc4:	0f b6       	in	r0, 0x3f	; 63
    1dc6:	f8 94       	cli
    1dc8:	de bf       	out	0x3e, r29	; 62
    1dca:	0f be       	out	0x3f, r0	; 63
    1dcc:	cd bf       	out	0x3d, r28	; 61
    1dce:	9b 87       	std	Y+11, r25	; 0x0b
    1dd0:	8a 87       	std	Y+10, r24	; 0x0a
    1dd2:	6c 87       	std	Y+12, r22	; 0x0c
  FONT_P tmp = font;
    1dd4:	8a 85       	ldd	r24, Y+10	; 0x0a
    1dd6:	9b 85       	ldd	r25, Y+11	; 0x0b
    1dd8:	9a 83       	std	Y+2, r25	; 0x02
    1dda:	89 83       	std	Y+1, r24	; 0x01
  if (character > pgm_read_byte(&tmp->lastchar)) 
    1ddc:	89 81       	ldd	r24, Y+1	; 0x01
    1dde:	9a 81       	ldd	r25, Y+2	; 0x02
    1de0:	05 96       	adiw	r24, 0x05	; 5
    1de2:	9c 83       	std	Y+4, r25	; 0x04
    1de4:	8b 83       	std	Y+3, r24	; 0x03
    1de6:	8b 81       	ldd	r24, Y+3	; 0x03
    1de8:	9c 81       	ldd	r25, Y+4	; 0x04
    1dea:	fc 01       	movw	r30, r24
    1dec:	14 91       	lpm	r17, Z
    1dee:	1d 83       	std	Y+5, r17	; 0x05
    1df0:	9d 81       	ldd	r25, Y+5	; 0x05
    1df2:	8c 85       	ldd	r24, Y+12	; 0x0c
    1df4:	98 17       	cp	r25, r24
    1df6:	18 f4       	brcc	.+6      	; 0x1dfe <font_get_char_number+0x46>
    return -1;
    1df8:	8f ef       	ldi	r24, 0xFF	; 255
    1dfa:	9f ef       	ldi	r25, 0xFF	; 255
    1dfc:	1d c0       	rjmp	.+58     	; 0x1e38 <font_get_char_number+0x80>
  uint8_t first = pgm_read_byte(&tmp->firstchar);
    1dfe:	89 81       	ldd	r24, Y+1	; 0x01
    1e00:	9a 81       	ldd	r25, Y+2	; 0x02
    1e02:	04 96       	adiw	r24, 0x04	; 4
    1e04:	9f 83       	std	Y+7, r25	; 0x07
    1e06:	8e 83       	std	Y+6, r24	; 0x06
    1e08:	8e 81       	ldd	r24, Y+6	; 0x06
    1e0a:	9f 81       	ldd	r25, Y+7	; 0x07
    1e0c:	fc 01       	movw	r30, r24
    1e0e:	14 91       	lpm	r17, Z
    1e10:	18 87       	std	Y+8, r17	; 0x08
    1e12:	88 85       	ldd	r24, Y+8	; 0x08
    1e14:	89 87       	std	Y+9, r24	; 0x09
  if (character < first) 
    1e16:	9c 85       	ldd	r25, Y+12	; 0x0c
    1e18:	89 85       	ldd	r24, Y+9	; 0x09
    1e1a:	98 17       	cp	r25, r24
    1e1c:	18 f4       	brcc	.+6      	; 0x1e24 <font_get_char_number+0x6c>
    return -1;
    1e1e:	8f ef       	ldi	r24, 0xFF	; 255
    1e20:	9f ef       	ldi	r25, 0xFF	; 255
    1e22:	0a c0       	rjmp	.+20     	; 0x1e38 <font_get_char_number+0x80>
  return character - first;
    1e24:	8c 85       	ldd	r24, Y+12	; 0x0c
    1e26:	28 2f       	mov	r18, r24
    1e28:	30 e0       	ldi	r19, 0x00	; 0
    1e2a:	89 85       	ldd	r24, Y+9	; 0x09
    1e2c:	88 2f       	mov	r24, r24
    1e2e:	90 e0       	ldi	r25, 0x00	; 0
    1e30:	a9 01       	movw	r20, r18
    1e32:	48 1b       	sub	r20, r24
    1e34:	59 0b       	sbc	r21, r25
    1e36:	ca 01       	movw	r24, r20
  }
    1e38:	2c 96       	adiw	r28, 0x0c	; 12
    1e3a:	0f b6       	in	r0, 0x3f	; 63
    1e3c:	f8 94       	cli
    1e3e:	de bf       	out	0x3e, r29	; 62
    1e40:	0f be       	out	0x3f, r0	; 63
    1e42:	cd bf       	out	0x3d, r28	; 61
    1e44:	df 91       	pop	r29
    1e46:	cf 91       	pop	r28
    1e48:	1f 91       	pop	r17
    1e4a:	08 95       	ret

00001e4c <font_get_char_width>:


/******************************************************************************
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
    1e4c:	1f 93       	push	r17
    1e4e:	cf 93       	push	r28
    1e50:	df 93       	push	r29
    1e52:	cd b7       	in	r28, 0x3d	; 61
    1e54:	de b7       	in	r29, 0x3e	; 62
    1e56:	2b 97       	sbiw	r28, 0x0b	; 11
    1e58:	0f b6       	in	r0, 0x3f	; 63
    1e5a:	f8 94       	cli
    1e5c:	de bf       	out	0x3e, r29	; 62
    1e5e:	0f be       	out	0x3f, r0	; 63
    1e60:	cd bf       	out	0x3d, r28	; 61
    1e62:	9a 87       	std	Y+10, r25	; 0x0a
    1e64:	89 87       	std	Y+9, r24	; 0x09
    1e66:	6b 87       	std	Y+11, r22	; 0x0b
  PGM_P table = font_widthtable(font);
    1e68:	89 85       	ldd	r24, Y+9	; 0x09
    1e6a:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e6c:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <font_widthtable>
    1e70:	9a 83       	std	Y+2, r25	; 0x02
    1e72:	89 83       	std	Y+1, r24	; 0x01
  if (table)
    1e74:	89 81       	ldd	r24, Y+1	; 0x01
    1e76:	9a 81       	ldd	r25, Y+2	; 0x02
    1e78:	00 97       	sbiw	r24, 0x00	; 0
    1e7a:	91 f0       	breq	.+36     	; 0x1ea0 <font_get_char_width+0x54>
    return pgm_read_byte(table+font_get_char_number(font,character));
    1e7c:	89 85       	ldd	r24, Y+9	; 0x09
    1e7e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e80:	6b 85       	ldd	r22, Y+11	; 0x0b
    1e82:	0e 94 dc 0e 	call	0x1db8	; 0x1db8 <font_get_char_number>
    1e86:	29 81       	ldd	r18, Y+1	; 0x01
    1e88:	3a 81       	ldd	r19, Y+2	; 0x02
    1e8a:	82 0f       	add	r24, r18
    1e8c:	93 1f       	adc	r25, r19
    1e8e:	9c 83       	std	Y+4, r25	; 0x04
    1e90:	8b 83       	std	Y+3, r24	; 0x03
    1e92:	8b 81       	ldd	r24, Y+3	; 0x03
    1e94:	9c 81       	ldd	r25, Y+4	; 0x04
    1e96:	fc 01       	movw	r30, r24
    1e98:	14 91       	lpm	r17, Z
    1e9a:	1d 83       	std	Y+5, r17	; 0x05
    1e9c:	8d 81       	ldd	r24, Y+5	; 0x05
    1e9e:	0b c0       	rjmp	.+22     	; 0x1eb6 <font_get_char_width+0x6a>
  else
    return pgm_read_byte(&font->width);
    1ea0:	89 85       	ldd	r24, Y+9	; 0x09
    1ea2:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ea4:	02 96       	adiw	r24, 0x02	; 2
    1ea6:	9f 83       	std	Y+7, r25	; 0x07
    1ea8:	8e 83       	std	Y+6, r24	; 0x06
    1eaa:	8e 81       	ldd	r24, Y+6	; 0x06
    1eac:	9f 81       	ldd	r25, Y+7	; 0x07
    1eae:	fc 01       	movw	r30, r24
    1eb0:	14 91       	lpm	r17, Z
    1eb2:	18 87       	std	Y+8, r17	; 0x08
    1eb4:	88 85       	ldd	r24, Y+8	; 0x08
  }
    1eb6:	2b 96       	adiw	r28, 0x0b	; 11
    1eb8:	0f b6       	in	r0, 0x3f	; 63
    1eba:	f8 94       	cli
    1ebc:	de bf       	out	0x3e, r29	; 62
    1ebe:	0f be       	out	0x3f, r0	; 63
    1ec0:	cd bf       	out	0x3d, r28	; 61
    1ec2:	df 91       	pop	r29
    1ec4:	cf 91       	pop	r28
    1ec6:	1f 91       	pop	r17
    1ec8:	08 95       	ret

00001eca <font_get_char_position>:


/******************************************************************************
 * Calculate the pointer to the requested character inside the Flash ROM
 */
PGM_P font_get_char_position(FONT_P font, char character) {
    1eca:	df 92       	push	r13
    1ecc:	ef 92       	push	r14
    1ece:	ff 92       	push	r15
    1ed0:	0f 93       	push	r16
    1ed2:	1f 93       	push	r17
    1ed4:	cf 93       	push	r28
    1ed6:	df 93       	push	r29
    1ed8:	cd b7       	in	r28, 0x3d	; 61
    1eda:	de b7       	in	r29, 0x3e	; 62
    1edc:	2d 97       	sbiw	r28, 0x0d	; 13
    1ede:	0f b6       	in	r0, 0x3f	; 63
    1ee0:	f8 94       	cli
    1ee2:	de bf       	out	0x3e, r29	; 62
    1ee4:	0f be       	out	0x3f, r0	; 63
    1ee6:	cd bf       	out	0x3d, r28	; 61
    1ee8:	9c 87       	std	Y+12, r25	; 0x0c
    1eea:	8b 87       	std	Y+11, r24	; 0x0b
    1eec:	6d 87       	std	Y+13, r22	; 0x0d
  uint16_t ret         = 0;
    1eee:	1a 82       	std	Y+2, r1	; 0x02
    1ef0:	19 82       	std	Y+1, r1	; 0x01
  int16_t  charnum_ret = font_get_char_number(font, character);
    1ef2:	8b 85       	ldd	r24, Y+11	; 0x0b
    1ef4:	9c 85       	ldd	r25, Y+12	; 0x0c
    1ef6:	6d 85       	ldd	r22, Y+13	; 0x0d
    1ef8:	0e 94 dc 0e 	call	0x1db8	; 0x1db8 <font_get_char_number>
    1efc:	9f 83       	std	Y+7, r25	; 0x07
    1efe:	8e 83       	std	Y+6, r24	; 0x06
  uint8_t  charnum     = charnum_ret;
    1f00:	8e 81       	ldd	r24, Y+6	; 0x06
    1f02:	8b 83       	std	Y+3, r24	; 0x03
  PGM_P    base        = font_widthtable(font);
    1f04:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f06:	9c 85       	ldd	r25, Y+12	; 0x0c
    1f08:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <font_widthtable>
    1f0c:	9d 83       	std	Y+5, r25	; 0x05
    1f0e:	8c 83       	std	Y+4, r24	; 0x04

  if (charnum_ret < 0)     //char not found
    1f10:	8e 81       	ldd	r24, Y+6	; 0x06
    1f12:	9f 81       	ldd	r25, Y+7	; 0x07
    1f14:	99 23       	and	r25, r25
    1f16:	1c f4       	brge	.+6      	; 0x1f1e <font_get_char_position+0x54>
    return 0;
    1f18:	80 e0       	ldi	r24, 0x00	; 0
    1f1a:	90 e0       	ldi	r25, 0x00	; 0
    1f1c:	60 c0       	rjmp	.+192    	; 0x1fde <font_get_char_position+0x114>
  if(base == 0)            //fixed width
    1f1e:	8c 81       	ldd	r24, Y+4	; 0x04
    1f20:	9d 81       	ldd	r25, Y+5	; 0x05
    1f22:	00 97       	sbiw	r24, 0x00	; 0
    1f24:	09 f5       	brne	.+66     	; 0x1f68 <font_get_char_position+0x9e>
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
    1f26:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f28:	9c 85       	ldd	r25, Y+12	; 0x0c
    1f2a:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <font_data>
    1f2e:	8c 01       	movw	r16, r24
    1f30:	8b 81       	ldd	r24, Y+3	; 0x03
    1f32:	e8 2e       	mov	r14, r24
    1f34:	ff 24       	eor	r15, r15
    1f36:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f38:	9c 85       	ldd	r25, Y+12	; 0x0c
    1f3a:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <font_get_height_bytes>
    1f3e:	d8 2e       	mov	r13, r24
    1f40:	8b 85       	ldd	r24, Y+11	; 0x0b
    1f42:	9c 85       	ldd	r25, Y+12	; 0x0c
    1f44:	6d 85       	ldd	r22, Y+13	; 0x0d
    1f46:	0e 94 26 0f 	call	0x1e4c	; 0x1e4c <font_get_char_width>
    1f4a:	d8 9e       	mul	r13, r24
    1f4c:	80 2d       	mov	r24, r0
    1f4e:	11 24       	eor	r1, r1
    1f50:	28 2f       	mov	r18, r24
    1f52:	30 e0       	ldi	r19, 0x00	; 0
    1f54:	e2 9e       	mul	r14, r18
    1f56:	c0 01       	movw	r24, r0
    1f58:	e3 9e       	mul	r14, r19
    1f5a:	90 0d       	add	r25, r0
    1f5c:	f2 9e       	mul	r15, r18
    1f5e:	90 0d       	add	r25, r0
    1f60:	11 24       	eor	r1, r1
    1f62:	80 0f       	add	r24, r16
    1f64:	91 1f       	adc	r25, r17
    1f66:	3b c0       	rjmp	.+118    	; 0x1fde <font_get_char_position+0x114>
  if (charnum)             //proportional width
    1f68:	8b 81       	ldd	r24, Y+3	; 0x03
    1f6a:	88 23       	and	r24, r24
    1f6c:	11 f1       	breq	.+68     	; 0x1fb2 <font_get_char_position+0xe8>
    while(charnum--)
    1f6e:	17 c0       	rjmp	.+46     	; 0x1f9e <font_get_char_position+0xd4>
      ret += pgm_read_byte(base++);
    1f70:	8c 81       	ldd	r24, Y+4	; 0x04
    1f72:	9d 81       	ldd	r25, Y+5	; 0x05
    1f74:	99 87       	std	Y+9, r25	; 0x09
    1f76:	88 87       	std	Y+8, r24	; 0x08
    1f78:	8c 81       	ldd	r24, Y+4	; 0x04
    1f7a:	9d 81       	ldd	r25, Y+5	; 0x05
    1f7c:	01 96       	adiw	r24, 0x01	; 1
    1f7e:	9d 83       	std	Y+5, r25	; 0x05
    1f80:	8c 83       	std	Y+4, r24	; 0x04
    1f82:	88 85       	ldd	r24, Y+8	; 0x08
    1f84:	99 85       	ldd	r25, Y+9	; 0x09
    1f86:	fc 01       	movw	r30, r24
    1f88:	14 91       	lpm	r17, Z
    1f8a:	1a 87       	std	Y+10, r17	; 0x0a
    1f8c:	8a 85       	ldd	r24, Y+10	; 0x0a
    1f8e:	88 2f       	mov	r24, r24
    1f90:	90 e0       	ldi	r25, 0x00	; 0
    1f92:	29 81       	ldd	r18, Y+1	; 0x01
    1f94:	3a 81       	ldd	r19, Y+2	; 0x02
    1f96:	82 0f       	add	r24, r18
    1f98:	93 1f       	adc	r25, r19
    1f9a:	9a 83       	std	Y+2, r25	; 0x02
    1f9c:	89 83       	std	Y+1, r24	; 0x01
  if (charnum_ret < 0)     //char not found
    return 0;
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
  if (charnum)             //proportional width
    while(charnum--)
    1f9e:	81 e0       	ldi	r24, 0x01	; 1
    1fa0:	9b 81       	ldd	r25, Y+3	; 0x03
    1fa2:	99 23       	and	r25, r25
    1fa4:	09 f4       	brne	.+2      	; 0x1fa8 <font_get_char_position+0xde>
    1fa6:	80 e0       	ldi	r24, 0x00	; 0
    1fa8:	9b 81       	ldd	r25, Y+3	; 0x03
    1faa:	91 50       	subi	r25, 0x01	; 1
    1fac:	9b 83       	std	Y+3, r25	; 0x03
    1fae:	88 23       	and	r24, r24
    1fb0:	f9 f6       	brne	.-66     	; 0x1f70 <font_get_char_position+0xa6>
      ret += pgm_read_byte(base++);
  return (font_data(font))+ret*font_get_height_bytes(font);
    1fb2:	8b 85       	ldd	r24, Y+11	; 0x0b
    1fb4:	9c 85       	ldd	r25, Y+12	; 0x0c
    1fb6:	0e 94 2a 0e 	call	0x1c54	; 0x1c54 <font_data>
    1fba:	8c 01       	movw	r16, r24
    1fbc:	8b 85       	ldd	r24, Y+11	; 0x0b
    1fbe:	9c 85       	ldd	r25, Y+12	; 0x0c
    1fc0:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <font_get_height_bytes>
    1fc4:	48 2f       	mov	r20, r24
    1fc6:	50 e0       	ldi	r21, 0x00	; 0
    1fc8:	29 81       	ldd	r18, Y+1	; 0x01
    1fca:	3a 81       	ldd	r19, Y+2	; 0x02
    1fcc:	42 9f       	mul	r20, r18
    1fce:	c0 01       	movw	r24, r0
    1fd0:	43 9f       	mul	r20, r19
    1fd2:	90 0d       	add	r25, r0
    1fd4:	52 9f       	mul	r21, r18
    1fd6:	90 0d       	add	r25, r0
    1fd8:	11 24       	eor	r1, r1
    1fda:	80 0f       	add	r24, r16
    1fdc:	91 1f       	adc	r25, r17
  }
    1fde:	2d 96       	adiw	r28, 0x0d	; 13
    1fe0:	0f b6       	in	r0, 0x3f	; 63
    1fe2:	f8 94       	cli
    1fe4:	de bf       	out	0x3e, r29	; 62
    1fe6:	0f be       	out	0x3f, r0	; 63
    1fe8:	cd bf       	out	0x3d, r28	; 61
    1fea:	df 91       	pop	r29
    1fec:	cf 91       	pop	r28
    1fee:	1f 91       	pop	r17
    1ff0:	0f 91       	pop	r16
    1ff2:	ff 90       	pop	r15
    1ff4:	ef 90       	pop	r14
    1ff6:	df 90       	pop	r13
    1ff8:	08 95       	ret

00001ffa <double_bits>:
 * part = 0:  abcdefgh -> eeffgghh
 * part = 1:  abcdefgh -> aabbccdd
 * Used for double height font
 */
//mod Andreas -> add static keyword
static inline unsigned char double_bits(uint8_t part, char c) {	
    1ffa:	cf 93       	push	r28
    1ffc:	df 93       	push	r29
    1ffe:	00 d0       	rcall	.+0      	; 0x2000 <double_bits+0x6>
    2000:	0f 92       	push	r0
    2002:	cd b7       	in	r28, 0x3d	; 61
    2004:	de b7       	in	r29, 0x3e	; 62
    2006:	8a 83       	std	Y+2, r24	; 0x02
    2008:	6b 83       	std	Y+3, r22	; 0x03
  char t = 0;
    200a:	19 82       	std	Y+1, r1	; 0x01
  if (part) c = c>>4;
    200c:	8a 81       	ldd	r24, Y+2	; 0x02
    200e:	88 23       	and	r24, r24
    2010:	21 f0       	breq	.+8      	; 0x201a <double_bits+0x20>
    2012:	8b 81       	ldd	r24, Y+3	; 0x03
    2014:	82 95       	swap	r24
    2016:	8f 70       	andi	r24, 0x0F	; 15
    2018:	8b 83       	std	Y+3, r24	; 0x03
  if (c & 0x08) t  = 0xC0;
    201a:	8b 81       	ldd	r24, Y+3	; 0x03
    201c:	88 2f       	mov	r24, r24
    201e:	90 e0       	ldi	r25, 0x00	; 0
    2020:	88 70       	andi	r24, 0x08	; 8
    2022:	90 70       	andi	r25, 0x00	; 0
    2024:	00 97       	sbiw	r24, 0x00	; 0
    2026:	11 f0       	breq	.+4      	; 0x202c <double_bits+0x32>
    2028:	80 ec       	ldi	r24, 0xC0	; 192
    202a:	89 83       	std	Y+1, r24	; 0x01
  if (c & 0x04) t |= 0x30;
    202c:	8b 81       	ldd	r24, Y+3	; 0x03
    202e:	88 2f       	mov	r24, r24
    2030:	90 e0       	ldi	r25, 0x00	; 0
    2032:	84 70       	andi	r24, 0x04	; 4
    2034:	90 70       	andi	r25, 0x00	; 0
    2036:	00 97       	sbiw	r24, 0x00	; 0
    2038:	19 f0       	breq	.+6      	; 0x2040 <double_bits+0x46>
    203a:	89 81       	ldd	r24, Y+1	; 0x01
    203c:	80 63       	ori	r24, 0x30	; 48
    203e:	89 83       	std	Y+1, r24	; 0x01
  if (c & 0x02) t |= 0x0C;
    2040:	8b 81       	ldd	r24, Y+3	; 0x03
    2042:	88 2f       	mov	r24, r24
    2044:	90 e0       	ldi	r25, 0x00	; 0
    2046:	82 70       	andi	r24, 0x02	; 2
    2048:	90 70       	andi	r25, 0x00	; 0
    204a:	00 97       	sbiw	r24, 0x00	; 0
    204c:	19 f0       	breq	.+6      	; 0x2054 <double_bits+0x5a>
    204e:	89 81       	ldd	r24, Y+1	; 0x01
    2050:	8c 60       	ori	r24, 0x0C	; 12
    2052:	89 83       	std	Y+1, r24	; 0x01
  if (c & 0x01) t |= 0x03;
    2054:	8b 81       	ldd	r24, Y+3	; 0x03
    2056:	88 2f       	mov	r24, r24
    2058:	90 e0       	ldi	r25, 0x00	; 0
    205a:	81 70       	andi	r24, 0x01	; 1
    205c:	90 70       	andi	r25, 0x00	; 0
    205e:	88 23       	and	r24, r24
    2060:	19 f0       	breq	.+6      	; 0x2068 <double_bits+0x6e>
    2062:	89 81       	ldd	r24, Y+1	; 0x01
    2064:	83 60       	ori	r24, 0x03	; 3
    2066:	89 83       	std	Y+1, r24	; 0x01
  return t;
    2068:	89 81       	ldd	r24, Y+1	; 0x01
  }
    206a:	0f 90       	pop	r0
    206c:	0f 90       	pop	r0
    206e:	0f 90       	pop	r0
    2070:	df 91       	pop	r29
    2072:	cf 91       	pop	r28
    2074:	08 95       	ret

00002076 <lcd_put_char>:
 *****************************************************************************/

/******************************************************************************
 * Outputs a character on the display, using the given font and style
 */
uint8_t lcd_put_char(FONT_P font, uint8_t style, char character) {
    2076:	1f 93       	push	r17
    2078:	cf 93       	push	r28
    207a:	df 93       	push	r29
    207c:	cd b7       	in	r28, 0x3d	; 61
    207e:	de b7       	in	r29, 0x3e	; 62
    2080:	66 97       	sbiw	r28, 0x16	; 22
    2082:	0f b6       	in	r0, 0x3f	; 63
    2084:	f8 94       	cli
    2086:	de bf       	out	0x3e, r29	; 62
    2088:	0f be       	out	0x3f, r0	; 63
    208a:	cd bf       	out	0x3d, r28	; 61
    208c:	9c 8b       	std	Y+20, r25	; 0x14
    208e:	8b 8b       	std	Y+19, r24	; 0x13
    2090:	6d 8b       	std	Y+21, r22	; 0x15
    2092:	4e 8b       	std	Y+22, r20	; 0x16
  int8_t  i;
  uint8_t row  = 0;                             //current row of char
    2094:	1a 82       	std	Y+2, r1	; 0x02
  uint8_t hc   = (style & DOUBLE_HEIGHT)?1:0;   //height changed
    2096:	8d 89       	ldd	r24, Y+21	; 0x15
    2098:	81 70       	andi	r24, 0x01	; 1
    209a:	8d 83       	std	Y+5, r24	; 0x05
  uint8_t wc   = (style & DOUBLE_WIDTH)?1:0;    //width changed
    209c:	8d 89       	ldd	r24, Y+21	; 0x15
    209e:	88 2f       	mov	r24, r24
    20a0:	90 e0       	ldi	r25, 0x00	; 0
    20a2:	82 70       	andi	r24, 0x02	; 2
    20a4:	90 70       	andi	r25, 0x00	; 0
    20a6:	21 e0       	ldi	r18, 0x01	; 1
    20a8:	00 97       	sbiw	r24, 0x00	; 0
    20aa:	09 f4       	brne	.+2      	; 0x20ae <lcd_put_char+0x38>
    20ac:	20 e0       	ldi	r18, 0x00	; 0
    20ae:	2e 83       	std	Y+6, r18	; 0x06
  uint8_t ul   = (style & UNDERLINE)?0x80:0x00; //underline
    20b0:	8d 89       	ldd	r24, Y+21	; 0x15
    20b2:	88 2f       	mov	r24, r24
    20b4:	90 e0       	ldi	r25, 0x00	; 0
    20b6:	80 71       	andi	r24, 0x10	; 16
    20b8:	90 70       	andi	r25, 0x00	; 0
    20ba:	00 97       	sbiw	r24, 0x00	; 0
    20bc:	11 f0       	breq	.+4      	; 0x20c2 <lcd_put_char+0x4c>
    20be:	80 e8       	ldi	r24, 0x80	; 128
    20c0:	01 c0       	rjmp	.+2      	; 0x20c4 <lcd_put_char+0x4e>
    20c2:	80 e0       	ldi	r24, 0x00	; 0
    20c4:	8f 83       	std	Y+7, r24	; 0x07
  uint8_t inv  = (style & INVERT)?0xFF:0;       //inverted
    20c6:	8d 89       	ldd	r24, Y+21	; 0x15
    20c8:	88 2f       	mov	r24, r24
    20ca:	90 e0       	ldi	r25, 0x00	; 0
    20cc:	84 70       	andi	r24, 0x04	; 4
    20ce:	90 70       	andi	r25, 0x00	; 0
    20d0:	00 97       	sbiw	r24, 0x00	; 0
    20d2:	11 f0       	breq	.+4      	; 0x20d8 <lcd_put_char+0x62>
    20d4:	8f ef       	ldi	r24, 0xFF	; 255
    20d6:	01 c0       	rjmp	.+2      	; 0x20da <lcd_put_char+0x64>
    20d8:	80 e0       	ldi	r24, 0x00	; 0
    20da:	88 87       	std	Y+8, r24	; 0x08
  uint8_t tmp;

  //load information about character
   uint8_t char_width    = font_get_char_width(font,character); 
    20dc:	8b 89       	ldd	r24, Y+19	; 0x13
    20de:	9c 89       	ldd	r25, Y+20	; 0x14
    20e0:	6e 89       	ldd	r22, Y+22	; 0x16
    20e2:	0e 94 26 0f 	call	0x1e4c	; 0x1e4c <font_get_char_width>
    20e6:	89 87       	std	Y+9, r24	; 0x09
   uint8_t font_height   = font_get_height_bytes(font);
    20e8:	8b 89       	ldd	r24, Y+19	; 0x13
    20ea:	9c 89       	ldd	r25, Y+20	; 0x14
    20ec:	0e 94 90 0e 	call	0x1d20	; 0x1d20 <font_get_height_bytes>
    20f0:	8a 87       	std	Y+10, r24	; 0x0a
   uint8_t free_space    = font_get_add_space(font,character);
    20f2:	8b 89       	ldd	r24, Y+19	; 0x13
    20f4:	9c 89       	ldd	r25, Y+20	; 0x14
    20f6:	6e 89       	ldd	r22, Y+22	; 0x16
    20f8:	0e 94 bd 0e 	call	0x1d7a	; 0x1d7a <font_get_add_space>
    20fc:	8b 87       	std	Y+11, r24	; 0x0b
   PGM_P   tableposition = font_get_char_position(font,character);
    20fe:	8b 89       	ldd	r24, Y+19	; 0x13
    2100:	9c 89       	ldd	r25, Y+20	; 0x14
    2102:	6e 89       	ldd	r22, Y+22	; 0x16
    2104:	0e 94 65 0f 	call	0x1eca	; 0x1eca <font_get_char_position>
    2108:	9d 87       	std	Y+13, r25	; 0x0d
    210a:	8c 87       	std	Y+12, r24	; 0x0c

  //final size of character
  uint8_t char_final_width  = (uint8_t)(char_width+free_space) << wc;
    210c:	99 85       	ldd	r25, Y+9	; 0x09
    210e:	8b 85       	ldd	r24, Y+11	; 0x0b
    2110:	89 0f       	add	r24, r25
    2112:	88 2f       	mov	r24, r24
    2114:	90 e0       	ldi	r25, 0x00	; 0
    2116:	2e 81       	ldd	r18, Y+6	; 0x06
    2118:	22 2f       	mov	r18, r18
    211a:	30 e0       	ldi	r19, 0x00	; 0
    211c:	02 c0       	rjmp	.+4      	; 0x2122 <lcd_put_char+0xac>
    211e:	88 0f       	add	r24, r24
    2120:	99 1f       	adc	r25, r25
    2122:	2a 95       	dec	r18
    2124:	e2 f7       	brpl	.-8      	; 0x211e <lcd_put_char+0xa8>
    2126:	8e 87       	std	Y+14, r24	; 0x0e
  uint8_t char_final_height = (uint8_t)font_height << hc; 
    2128:	8a 85       	ldd	r24, Y+10	; 0x0a
    212a:	88 2f       	mov	r24, r24
    212c:	90 e0       	ldi	r25, 0x00	; 0
    212e:	2d 81       	ldd	r18, Y+5	; 0x05
    2130:	22 2f       	mov	r18, r18
    2132:	30 e0       	ldi	r19, 0x00	; 0
    2134:	02 2e       	mov	r0, r18
    2136:	02 c0       	rjmp	.+4      	; 0x213c <lcd_put_char+0xc6>
    2138:	88 0f       	add	r24, r24
    213a:	99 1f       	adc	r25, r25
    213c:	0a 94       	dec	r0
    213e:	e2 f7       	brpl	.-8      	; 0x2138 <lcd_put_char+0xc2>
    2140:	8f 87       	std	Y+15, r24	; 0x0f

  //check for avail. space on display
  if ((style & WRAP) && (LCD_CURRENT_COL() + char_final_width > LCD_WIDTH)) {
    2142:	8d 89       	ldd	r24, Y+21	; 0x15
    2144:	88 2f       	mov	r24, r24
    2146:	90 e0       	ldi	r25, 0x00	; 0
    2148:	88 70       	andi	r24, 0x08	; 8
    214a:	90 70       	andi	r25, 0x00	; 0
    214c:	00 97       	sbiw	r24, 0x00	; 0
    214e:	c9 f0       	breq	.+50     	; 0x2182 <lcd_put_char+0x10c>
    2150:	0e 94 09 0e 	call	0x1c12	; 0x1c12 <lcd_get_position_column>
    2154:	28 2f       	mov	r18, r24
    2156:	30 e0       	ldi	r19, 0x00	; 0
    2158:	8e 85       	ldd	r24, Y+14	; 0x0e
    215a:	88 2f       	mov	r24, r24
    215c:	90 e0       	ldi	r25, 0x00	; 0
    215e:	82 0f       	add	r24, r18
    2160:	93 1f       	adc	r25, r19
    2162:	85 38       	cpi	r24, 0x85	; 133
    2164:	91 05       	cpc	r25, r1
    2166:	6c f0       	brlt	.+26     	; 0x2182 <lcd_put_char+0x10c>
    LCD_MOVE_TO(LCD_CURRENT_PAGE()+char_final_height,0);
    2168:	0e 94 00 0e 	call	0x1c00	; 0x1c00 <lcd_get_position_page>
    216c:	98 2f       	mov	r25, r24
    216e:	8f 85       	ldd	r24, Y+15	; 0x0f
    2170:	89 0f       	add	r24, r25
    2172:	60 e0       	ldi	r22, 0x00	; 0
    2174:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
    if (character == ' ') return 0;
    2178:	8e 89       	ldd	r24, Y+22	; 0x16
    217a:	80 32       	cpi	r24, 0x20	; 32
    217c:	11 f4       	brne	.+4      	; 0x2182 <lcd_put_char+0x10c>
    217e:	80 e0       	ldi	r24, 0x00	; 0
    2180:	9f c0       	rjmp	.+318    	; 0x22c0 <lcd_put_char+0x24a>
    }
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
    2182:	8a 81       	ldd	r24, Y+2	; 0x02
    2184:	88 2f       	mov	r24, r24
    2186:	90 e0       	ldi	r25, 0x00	; 0
    2188:	2d 81       	ldd	r18, Y+5	; 0x05
    218a:	22 2f       	mov	r18, r18
    218c:	30 e0       	ldi	r19, 0x00	; 0
    218e:	02 2e       	mov	r0, r18
    2190:	02 c0       	rjmp	.+4      	; 0x2196 <lcd_put_char+0x120>
    2192:	95 95       	asr	r25
    2194:	87 95       	ror	r24
    2196:	0a 94       	dec	r0
    2198:	e2 f7       	brpl	.-8      	; 0x2192 <lcd_put_char+0x11c>
    219a:	89 83       	std	Y+1, r24	; 0x01
    219c:	3b c0       	rjmp	.+118    	; 0x2214 <lcd_put_char+0x19e>
      tmp = pgm_read_byte(tableposition+i);
    219e:	89 81       	ldd	r24, Y+1	; 0x01
    21a0:	99 27       	eor	r25, r25
    21a2:	87 fd       	sbrc	r24, 7
    21a4:	90 95       	com	r25
    21a6:	2c 85       	ldd	r18, Y+12	; 0x0c
    21a8:	3d 85       	ldd	r19, Y+13	; 0x0d
    21aa:	82 0f       	add	r24, r18
    21ac:	93 1f       	adc	r25, r19
    21ae:	99 8b       	std	Y+17, r25	; 0x11
    21b0:	88 8b       	std	Y+16, r24	; 0x10
    21b2:	88 89       	ldd	r24, Y+16	; 0x10
    21b4:	99 89       	ldd	r25, Y+17	; 0x11
    21b6:	fc 01       	movw	r30, r24
    21b8:	14 91       	lpm	r17, Z
    21ba:	1a 8b       	std	Y+18, r17	; 0x12
    21bc:	8a 89       	ldd	r24, Y+18	; 0x12
    21be:	8b 83       	std	Y+3, r24	; 0x03
      if(row == char_final_height-1) 
    21c0:	8a 81       	ldd	r24, Y+2	; 0x02
    21c2:	28 2f       	mov	r18, r24
    21c4:	30 e0       	ldi	r19, 0x00	; 0
    21c6:	8f 85       	ldd	r24, Y+15	; 0x0f
    21c8:	88 2f       	mov	r24, r24
    21ca:	90 e0       	ldi	r25, 0x00	; 0
    21cc:	01 97       	sbiw	r24, 0x01	; 1
    21ce:	28 17       	cp	r18, r24
    21d0:	39 07       	cpc	r19, r25
    21d2:	21 f4       	brne	.+8      	; 0x21dc <lcd_put_char+0x166>
        tmp |= ul;
    21d4:	9b 81       	ldd	r25, Y+3	; 0x03
    21d6:	8f 81       	ldd	r24, Y+7	; 0x07
    21d8:	89 2b       	or	r24, r25
    21da:	8b 83       	std	Y+3, r24	; 0x03
      if(hc)
    21dc:	8d 81       	ldd	r24, Y+5	; 0x05
    21de:	88 23       	and	r24, r24
    21e0:	31 f0       	breq	.+12     	; 0x21ee <lcd_put_char+0x178>
        tmp = double_bits((row&1),tmp);
    21e2:	8a 81       	ldd	r24, Y+2	; 0x02
    21e4:	81 70       	andi	r24, 0x01	; 1
    21e6:	6b 81       	ldd	r22, Y+3	; 0x03
    21e8:	0e 94 fd 0f 	call	0x1ffa	; 0x1ffa <double_bits>
    21ec:	8b 83       	std	Y+3, r24	; 0x03
      if(inv)
    21ee:	88 85       	ldd	r24, Y+8	; 0x08
    21f0:	88 23       	and	r24, r24
    21f2:	19 f0       	breq	.+6      	; 0x21fa <lcd_put_char+0x184>
        tmp = ~tmp;
    21f4:	8b 81       	ldd	r24, Y+3	; 0x03
    21f6:	80 95       	com	r24
    21f8:	8b 83       	std	Y+3, r24	; 0x03
      LCD_WRITE(tmp);
    21fa:	8b 81       	ldd	r24, Y+3	; 0x03
    21fc:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <lcd_data>
      if(wc) 
    2200:	8e 81       	ldd	r24, Y+6	; 0x06
    2202:	88 23       	and	r24, r24
    2204:	19 f0       	breq	.+6      	; 0x220c <lcd_put_char+0x196>
        LCD_WRITE(tmp);
    2206:	8b 81       	ldd	r24, Y+3	; 0x03
    2208:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <lcd_data>
    if (character == ' ') return 0;
    }
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
    220c:	99 81       	ldd	r25, Y+1	; 0x01
    220e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2210:	89 0f       	add	r24, r25
    2212:	89 83       	std	Y+1, r24	; 0x01
    2214:	89 81       	ldd	r24, Y+1	; 0x01
    2216:	28 2f       	mov	r18, r24
    2218:	33 27       	eor	r19, r19
    221a:	27 fd       	sbrc	r18, 7
    221c:	30 95       	com	r19
    221e:	89 85       	ldd	r24, Y+9	; 0x09
    2220:	68 2f       	mov	r22, r24
    2222:	70 e0       	ldi	r23, 0x00	; 0
    2224:	8a 85       	ldd	r24, Y+10	; 0x0a
    2226:	48 2f       	mov	r20, r24
    2228:	50 e0       	ldi	r21, 0x00	; 0
    222a:	64 9f       	mul	r22, r20
    222c:	c0 01       	movw	r24, r0
    222e:	65 9f       	mul	r22, r21
    2230:	90 0d       	add	r25, r0
    2232:	74 9f       	mul	r23, r20
    2234:	90 0d       	add	r25, r0
    2236:	11 24       	eor	r1, r1
    2238:	28 17       	cp	r18, r24
    223a:	39 07       	cpc	r19, r25
    223c:	0c f4       	brge	.+2      	; 0x2240 <lcd_put_char+0x1ca>
    223e:	af cf       	rjmp	.-162    	; 0x219e <lcd_put_char+0x128>
        tmp = ~tmp;
      LCD_WRITE(tmp);
      if(wc) 
        LCD_WRITE(tmp);
      }
    if (free_space) {
    2240:	8b 85       	ldd	r24, Y+11	; 0x0b
    2242:	88 23       	and	r24, r24
    2244:	09 f1       	breq	.+66     	; 0x2288 <lcd_put_char+0x212>
      uint8_t c = inv;
    2246:	88 85       	ldd	r24, Y+8	; 0x08
    2248:	8c 83       	std	Y+4, r24	; 0x04
      if(row == char_final_height-1) {
    224a:	8a 81       	ldd	r24, Y+2	; 0x02
    224c:	28 2f       	mov	r18, r24
    224e:	30 e0       	ldi	r19, 0x00	; 0
    2250:	8f 85       	ldd	r24, Y+15	; 0x0f
    2252:	88 2f       	mov	r24, r24
    2254:	90 e0       	ldi	r25, 0x00	; 0
    2256:	01 97       	sbiw	r24, 0x01	; 1
    2258:	28 17       	cp	r18, r24
    225a:	39 07       	cpc	r19, r25
    225c:	61 f4       	brne	.+24     	; 0x2276 <lcd_put_char+0x200>
        c ^= ul; 
    225e:	9c 81       	ldd	r25, Y+4	; 0x04
    2260:	8f 81       	ldd	r24, Y+7	; 0x07
    2262:	89 27       	eor	r24, r25
    2264:	8c 83       	std	Y+4, r24	; 0x04
        if(hc)
    2266:	8d 81       	ldd	r24, Y+5	; 0x05
    2268:	88 23       	and	r24, r24
    226a:	29 f0       	breq	.+10     	; 0x2276 <lcd_put_char+0x200>
          c ^= ul>>1;      
    226c:	8f 81       	ldd	r24, Y+7	; 0x07
    226e:	86 95       	lsr	r24
    2270:	9c 81       	ldd	r25, Y+4	; 0x04
    2272:	89 27       	eor	r24, r25
    2274:	8c 83       	std	Y+4, r24	; 0x04
        }
      LCD_WRITE(c);
    2276:	8c 81       	ldd	r24, Y+4	; 0x04
    2278:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <lcd_data>
      if(wc) 
    227c:	8e 81       	ldd	r24, Y+6	; 0x06
    227e:	88 23       	and	r24, r24
    2280:	19 f0       	breq	.+6      	; 0x2288 <lcd_put_char+0x212>
        LCD_WRITE(c);
    2282:	8c 81       	ldd	r24, Y+4	; 0x04
    2284:	0e 94 5a 09 	call	0x12b4	; 0x12b4 <lcd_data>
      }
    LCD_MOVE(1,-char_final_width);
    2288:	8e 85       	ldd	r24, Y+14	; 0x0e
    228a:	88 2f       	mov	r24, r24
    228c:	90 e0       	ldi	r25, 0x00	; 0
    228e:	22 27       	eor	r18, r18
    2290:	33 27       	eor	r19, r19
    2292:	28 1b       	sub	r18, r24
    2294:	39 0b       	sbc	r19, r25
    2296:	81 e0       	ldi	r24, 0x01	; 1
    2298:	b9 01       	movw	r22, r18
    229a:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_move_xy>
    } while (++row < char_final_height);
    229e:	8a 81       	ldd	r24, Y+2	; 0x02
    22a0:	8f 5f       	subi	r24, 0xFF	; 255
    22a2:	8a 83       	std	Y+2, r24	; 0x02
    22a4:	9a 81       	ldd	r25, Y+2	; 0x02
    22a6:	8f 85       	ldd	r24, Y+15	; 0x0f
    22a8:	98 17       	cp	r25, r24
    22aa:	08 f4       	brcc	.+2      	; 0x22ae <lcd_put_char+0x238>
    22ac:	6a cf       	rjmp	.-300    	; 0x2182 <lcd_put_char+0x10c>

  //move cursor to upper right corner of character
  LCD_MOVE(-char_final_height,char_final_width);
    22ae:	8f 85       	ldd	r24, Y+15	; 0x0f
    22b0:	81 95       	neg	r24
    22b2:	9e 85       	ldd	r25, Y+14	; 0x0e
    22b4:	29 2f       	mov	r18, r25
    22b6:	30 e0       	ldi	r19, 0x00	; 0
    22b8:	b9 01       	movw	r22, r18
    22ba:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_move_xy>
  return char_final_width;
    22be:	8e 85       	ldd	r24, Y+14	; 0x0e
  }
    22c0:	66 96       	adiw	r28, 0x16	; 22
    22c2:	0f b6       	in	r0, 0x3f	; 63
    22c4:	f8 94       	cli
    22c6:	de bf       	out	0x3e, r29	; 62
    22c8:	0f be       	out	0x3f, r0	; 63
    22ca:	cd bf       	out	0x3d, r28	; 61
    22cc:	df 91       	pop	r29
    22ce:	cf 91       	pop	r28
    22d0:	1f 91       	pop	r17
    22d2:	08 95       	ret

000022d4 <lcd_put_string_P>:

/******************************************************************************
 * Outputs a string on the display, loading it from the program memory,
 * using the given font and style
 */
uint16_t lcd_put_string_P(FONT_P font, uint8_t style, PGM_P str) {
    22d4:	1f 93       	push	r17
    22d6:	cf 93       	push	r28
    22d8:	df 93       	push	r29
    22da:	cd b7       	in	r28, 0x3d	; 61
    22dc:	de b7       	in	r29, 0x3e	; 62
    22de:	2b 97       	sbiw	r28, 0x0b	; 11
    22e0:	0f b6       	in	r0, 0x3f	; 63
    22e2:	f8 94       	cli
    22e4:	de bf       	out	0x3e, r29	; 62
    22e6:	0f be       	out	0x3f, r0	; 63
    22e8:	cd bf       	out	0x3d, r28	; 61
    22ea:	98 87       	std	Y+8, r25	; 0x08
    22ec:	8f 83       	std	Y+7, r24	; 0x07
    22ee:	69 87       	std	Y+9, r22	; 0x09
    22f0:	5b 87       	std	Y+11, r21	; 0x0b
    22f2:	4a 87       	std	Y+10, r20	; 0x0a
  unsigned char t;
  uint16_t length = 0;
    22f4:	1a 82       	std	Y+2, r1	; 0x02
    22f6:	19 82       	std	Y+1, r1	; 0x01
  while((t = pgm_read_byte(str++))) 
    22f8:	0e c0       	rjmp	.+28     	; 0x2316 <lcd_put_string_P+0x42>
    length += lcd_put_char(font,style,t);
    22fa:	8f 81       	ldd	r24, Y+7	; 0x07
    22fc:	98 85       	ldd	r25, Y+8	; 0x08
    22fe:	69 85       	ldd	r22, Y+9	; 0x09
    2300:	4e 81       	ldd	r20, Y+6	; 0x06
    2302:	0e 94 3b 10 	call	0x2076	; 0x2076 <lcd_put_char>
    2306:	88 2f       	mov	r24, r24
    2308:	90 e0       	ldi	r25, 0x00	; 0
    230a:	29 81       	ldd	r18, Y+1	; 0x01
    230c:	3a 81       	ldd	r19, Y+2	; 0x02
    230e:	82 0f       	add	r24, r18
    2310:	93 1f       	adc	r25, r19
    2312:	9a 83       	std	Y+2, r25	; 0x02
    2314:	89 83       	std	Y+1, r24	; 0x01
 * using the given font and style
 */
uint16_t lcd_put_string_P(FONT_P font, uint8_t style, PGM_P str) {
  unsigned char t;
  uint16_t length = 0;
  while((t = pgm_read_byte(str++))) 
    2316:	8a 85       	ldd	r24, Y+10	; 0x0a
    2318:	9b 85       	ldd	r25, Y+11	; 0x0b
    231a:	9c 83       	std	Y+4, r25	; 0x04
    231c:	8b 83       	std	Y+3, r24	; 0x03
    231e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2320:	9b 85       	ldd	r25, Y+11	; 0x0b
    2322:	01 96       	adiw	r24, 0x01	; 1
    2324:	9b 87       	std	Y+11, r25	; 0x0b
    2326:	8a 87       	std	Y+10, r24	; 0x0a
    2328:	8b 81       	ldd	r24, Y+3	; 0x03
    232a:	9c 81       	ldd	r25, Y+4	; 0x04
    232c:	fc 01       	movw	r30, r24
    232e:	14 91       	lpm	r17, Z
    2330:	1d 83       	std	Y+5, r17	; 0x05
    2332:	8d 81       	ldd	r24, Y+5	; 0x05
    2334:	8e 83       	std	Y+6, r24	; 0x06
    2336:	8e 81       	ldd	r24, Y+6	; 0x06
    2338:	88 23       	and	r24, r24
    233a:	f9 f6       	brne	.-66     	; 0x22fa <lcd_put_string_P+0x26>
    length += lcd_put_char(font,style,t);
  return length;
    233c:	89 81       	ldd	r24, Y+1	; 0x01
    233e:	9a 81       	ldd	r25, Y+2	; 0x02
  }
    2340:	2b 96       	adiw	r28, 0x0b	; 11
    2342:	0f b6       	in	r0, 0x3f	; 63
    2344:	f8 94       	cli
    2346:	de bf       	out	0x3e, r29	; 62
    2348:	0f be       	out	0x3f, r0	; 63
    234a:	cd bf       	out	0x3d, r28	; 61
    234c:	df 91       	pop	r29
    234e:	cf 91       	pop	r28
    2350:	1f 91       	pop	r17
    2352:	08 95       	ret

00002354 <lcd_put_string>:

  
/******************************************************************************
 * Outputs a string on the display, using the given font and style
 */
uint16_t lcd_put_string(FONT_P font, uint8_t style, char* str) {
    2354:	cf 93       	push	r28
    2356:	df 93       	push	r29
    2358:	cd b7       	in	r28, 0x3d	; 61
    235a:	de b7       	in	r29, 0x3e	; 62
    235c:	28 97       	sbiw	r28, 0x08	; 8
    235e:	0f b6       	in	r0, 0x3f	; 63
    2360:	f8 94       	cli
    2362:	de bf       	out	0x3e, r29	; 62
    2364:	0f be       	out	0x3f, r0	; 63
    2366:	cd bf       	out	0x3d, r28	; 61
    2368:	9d 83       	std	Y+5, r25	; 0x05
    236a:	8c 83       	std	Y+4, r24	; 0x04
    236c:	6e 83       	std	Y+6, r22	; 0x06
    236e:	58 87       	std	Y+8, r21	; 0x08
    2370:	4f 83       	std	Y+7, r20	; 0x07
  unsigned char t;
  uint16_t length = 0;
    2372:	1a 82       	std	Y+2, r1	; 0x02
    2374:	19 82       	std	Y+1, r1	; 0x01
  while((t = *str++))
    2376:	0e c0       	rjmp	.+28     	; 0x2394 <lcd_put_string+0x40>
    length += lcd_put_char(font,style,t);
    2378:	8c 81       	ldd	r24, Y+4	; 0x04
    237a:	9d 81       	ldd	r25, Y+5	; 0x05
    237c:	6e 81       	ldd	r22, Y+6	; 0x06
    237e:	4b 81       	ldd	r20, Y+3	; 0x03
    2380:	0e 94 3b 10 	call	0x2076	; 0x2076 <lcd_put_char>
    2384:	88 2f       	mov	r24, r24
    2386:	90 e0       	ldi	r25, 0x00	; 0
    2388:	29 81       	ldd	r18, Y+1	; 0x01
    238a:	3a 81       	ldd	r19, Y+2	; 0x02
    238c:	82 0f       	add	r24, r18
    238e:	93 1f       	adc	r25, r19
    2390:	9a 83       	std	Y+2, r25	; 0x02
    2392:	89 83       	std	Y+1, r24	; 0x01
 * Outputs a string on the display, using the given font and style
 */
uint16_t lcd_put_string(FONT_P font, uint8_t style, char* str) {
  unsigned char t;
  uint16_t length = 0;
  while((t = *str++))
    2394:	8f 81       	ldd	r24, Y+7	; 0x07
    2396:	98 85       	ldd	r25, Y+8	; 0x08
    2398:	fc 01       	movw	r30, r24
    239a:	80 81       	ld	r24, Z
    239c:	8b 83       	std	Y+3, r24	; 0x03
    239e:	21 e0       	ldi	r18, 0x01	; 1
    23a0:	8b 81       	ldd	r24, Y+3	; 0x03
    23a2:	88 23       	and	r24, r24
    23a4:	09 f4       	brne	.+2      	; 0x23a8 <lcd_put_string+0x54>
    23a6:	20 e0       	ldi	r18, 0x00	; 0
    23a8:	8f 81       	ldd	r24, Y+7	; 0x07
    23aa:	98 85       	ldd	r25, Y+8	; 0x08
    23ac:	01 96       	adiw	r24, 0x01	; 1
    23ae:	98 87       	std	Y+8, r25	; 0x08
    23b0:	8f 83       	std	Y+7, r24	; 0x07
    23b2:	22 23       	and	r18, r18
    23b4:	09 f7       	brne	.-62     	; 0x2378 <lcd_put_string+0x24>
    length += lcd_put_char(font,style,t);
  return length;
    23b6:	89 81       	ldd	r24, Y+1	; 0x01
    23b8:	9a 81       	ldd	r25, Y+2	; 0x02
  }
    23ba:	28 96       	adiw	r28, 0x08	; 8
    23bc:	0f b6       	in	r0, 0x3f	; 63
    23be:	f8 94       	cli
    23c0:	de bf       	out	0x3e, r29	; 62
    23c2:	0f be       	out	0x3f, r0	; 63
    23c4:	cd bf       	out	0x3d, r28	; 61
    23c6:	df 91       	pop	r29
    23c8:	cf 91       	pop	r28
    23ca:	08 95       	ret

000023cc <lcd_put_string_length>:
  
/******************************************************************************
 * Outputs a string on the display, using the given font and style, reading
 * length characters from the memory
 */ 
uint16_t lcd_put_string_length(FONT_P font, uint8_t style, char* str, uint8_t length) {
    23cc:	cf 93       	push	r28
    23ce:	df 93       	push	r29
    23d0:	cd b7       	in	r28, 0x3d	; 61
    23d2:	de b7       	in	r29, 0x3e	; 62
    23d4:	29 97       	sbiw	r28, 0x09	; 9
    23d6:	0f b6       	in	r0, 0x3f	; 63
    23d8:	f8 94       	cli
    23da:	de bf       	out	0x3e, r29	; 62
    23dc:	0f be       	out	0x3f, r0	; 63
    23de:	cd bf       	out	0x3d, r28	; 61
    23e0:	9d 83       	std	Y+5, r25	; 0x05
    23e2:	8c 83       	std	Y+4, r24	; 0x04
    23e4:	6e 83       	std	Y+6, r22	; 0x06
    23e6:	58 87       	std	Y+8, r21	; 0x08
    23e8:	4f 83       	std	Y+7, r20	; 0x07
    23ea:	29 87       	std	Y+9, r18	; 0x09
  unsigned char t;
  uint16_t total_len = 0;
    23ec:	1b 82       	std	Y+3, r1	; 0x03
    23ee:	1a 82       	std	Y+2, r1	; 0x02
  for(t=0;t<length;t++)
    23f0:	19 82       	std	Y+1, r1	; 0x01
    23f2:	1a c0       	rjmp	.+52     	; 0x2428 <lcd_put_string_length+0x5c>
    total_len += lcd_put_char(font,style,*str++);
    23f4:	8f 81       	ldd	r24, Y+7	; 0x07
    23f6:	98 85       	ldd	r25, Y+8	; 0x08
    23f8:	fc 01       	movw	r30, r24
    23fa:	20 81       	ld	r18, Z
    23fc:	8f 81       	ldd	r24, Y+7	; 0x07
    23fe:	98 85       	ldd	r25, Y+8	; 0x08
    2400:	01 96       	adiw	r24, 0x01	; 1
    2402:	98 87       	std	Y+8, r25	; 0x08
    2404:	8f 83       	std	Y+7, r24	; 0x07
    2406:	8c 81       	ldd	r24, Y+4	; 0x04
    2408:	9d 81       	ldd	r25, Y+5	; 0x05
    240a:	6e 81       	ldd	r22, Y+6	; 0x06
    240c:	42 2f       	mov	r20, r18
    240e:	0e 94 3b 10 	call	0x2076	; 0x2076 <lcd_put_char>
    2412:	88 2f       	mov	r24, r24
    2414:	90 e0       	ldi	r25, 0x00	; 0
    2416:	2a 81       	ldd	r18, Y+2	; 0x02
    2418:	3b 81       	ldd	r19, Y+3	; 0x03
    241a:	82 0f       	add	r24, r18
    241c:	93 1f       	adc	r25, r19
    241e:	9b 83       	std	Y+3, r25	; 0x03
    2420:	8a 83       	std	Y+2, r24	; 0x02
 * length characters from the memory
 */ 
uint16_t lcd_put_string_length(FONT_P font, uint8_t style, char* str, uint8_t length) {
  unsigned char t;
  uint16_t total_len = 0;
  for(t=0;t<length;t++)
    2422:	89 81       	ldd	r24, Y+1	; 0x01
    2424:	8f 5f       	subi	r24, 0xFF	; 255
    2426:	89 83       	std	Y+1, r24	; 0x01
    2428:	99 81       	ldd	r25, Y+1	; 0x01
    242a:	89 85       	ldd	r24, Y+9	; 0x09
    242c:	98 17       	cp	r25, r24
    242e:	10 f3       	brcs	.-60     	; 0x23f4 <lcd_put_string_length+0x28>
    total_len += lcd_put_char(font,style,*str++);
  return total_len;
    2430:	8a 81       	ldd	r24, Y+2	; 0x02
    2432:	9b 81       	ldd	r25, Y+3	; 0x03
  }
    2434:	29 96       	adiw	r28, 0x09	; 9
    2436:	0f b6       	in	r0, 0x3f	; 63
    2438:	f8 94       	cli
    243a:	de bf       	out	0x3e, r29	; 62
    243c:	0f be       	out	0x3f, r0	; 63
    243e:	cd bf       	out	0x3d, r28	; 61
    2440:	df 91       	pop	r29
    2442:	cf 91       	pop	r28
    2444:	08 95       	ret

00002446 <lcd_put_string_xy_P>:
/******************************************************************************
 * Outputs a string on the display, using the given font and style, reading
 * the string from program memory. The position of the string on the display
 * is selected by page / col.
 */ 
uint16_t lcd_put_string_xy_P(FONT_P font, uint8_t style, PGM_P str,uint8_t page, uint8_t col) {
    2446:	0f 93       	push	r16
    2448:	cf 93       	push	r28
    244a:	df 93       	push	r29
    244c:	cd b7       	in	r28, 0x3d	; 61
    244e:	de b7       	in	r29, 0x3e	; 62
    2450:	27 97       	sbiw	r28, 0x07	; 7
    2452:	0f b6       	in	r0, 0x3f	; 63
    2454:	f8 94       	cli
    2456:	de bf       	out	0x3e, r29	; 62
    2458:	0f be       	out	0x3f, r0	; 63
    245a:	cd bf       	out	0x3d, r28	; 61
    245c:	9a 83       	std	Y+2, r25	; 0x02
    245e:	89 83       	std	Y+1, r24	; 0x01
    2460:	6b 83       	std	Y+3, r22	; 0x03
    2462:	5d 83       	std	Y+5, r21	; 0x05
    2464:	4c 83       	std	Y+4, r20	; 0x04
    2466:	2e 83       	std	Y+6, r18	; 0x06
    2468:	0f 83       	std	Y+7, r16	; 0x07
  LCD_MOVE_TO(page,col);
    246a:	8e 81       	ldd	r24, Y+6	; 0x06
    246c:	6f 81       	ldd	r22, Y+7	; 0x07
    246e:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
  return lcd_put_string_P(font,style,str);
    2472:	89 81       	ldd	r24, Y+1	; 0x01
    2474:	9a 81       	ldd	r25, Y+2	; 0x02
    2476:	2c 81       	ldd	r18, Y+4	; 0x04
    2478:	3d 81       	ldd	r19, Y+5	; 0x05
    247a:	6b 81       	ldd	r22, Y+3	; 0x03
    247c:	a9 01       	movw	r20, r18
    247e:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
  }
    2482:	27 96       	adiw	r28, 0x07	; 7
    2484:	0f b6       	in	r0, 0x3f	; 63
    2486:	f8 94       	cli
    2488:	de bf       	out	0x3e, r29	; 62
    248a:	0f be       	out	0x3f, r0	; 63
    248c:	cd bf       	out	0x3d, r28	; 61
    248e:	df 91       	pop	r29
    2490:	cf 91       	pop	r28
    2492:	0f 91       	pop	r16
    2494:	08 95       	ret

00002496 <lcd_put_char_xy>:
/******************************************************************************
 * Outputs a string on the display, using the given font and style, reading
 * the string from main memory. The position of the string on the display
 * is selected by page / col.
 */ 
uint8_t lcd_put_char_xy(FONT_P font, uint8_t style, char character, uint8_t page, uint8_t col) {
    2496:	0f 93       	push	r16
    2498:	cf 93       	push	r28
    249a:	df 93       	push	r29
    249c:	00 d0       	rcall	.+0      	; 0x249e <lcd_put_char_xy+0x8>
    249e:	00 d0       	rcall	.+0      	; 0x24a0 <lcd_put_char_xy+0xa>
    24a0:	00 d0       	rcall	.+0      	; 0x24a2 <lcd_put_char_xy+0xc>
    24a2:	cd b7       	in	r28, 0x3d	; 61
    24a4:	de b7       	in	r29, 0x3e	; 62
    24a6:	9a 83       	std	Y+2, r25	; 0x02
    24a8:	89 83       	std	Y+1, r24	; 0x01
    24aa:	6b 83       	std	Y+3, r22	; 0x03
    24ac:	4c 83       	std	Y+4, r20	; 0x04
    24ae:	2d 83       	std	Y+5, r18	; 0x05
    24b0:	0e 83       	std	Y+6, r16	; 0x06
  LCD_MOVE_TO(page,col);
    24b2:	8d 81       	ldd	r24, Y+5	; 0x05
    24b4:	6e 81       	ldd	r22, Y+6	; 0x06
    24b6:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
  return lcd_put_char(font,style,character);
    24ba:	89 81       	ldd	r24, Y+1	; 0x01
    24bc:	9a 81       	ldd	r25, Y+2	; 0x02
    24be:	6b 81       	ldd	r22, Y+3	; 0x03
    24c0:	4c 81       	ldd	r20, Y+4	; 0x04
    24c2:	0e 94 3b 10 	call	0x2076	; 0x2076 <lcd_put_char>
  }
    24c6:	26 96       	adiw	r28, 0x06	; 6
    24c8:	0f b6       	in	r0, 0x3f	; 63
    24ca:	f8 94       	cli
    24cc:	de bf       	out	0x3e, r29	; 62
    24ce:	0f be       	out	0x3f, r0	; 63
    24d0:	cd bf       	out	0x3d, r28	; 61
    24d2:	df 91       	pop	r29
    24d4:	cf 91       	pop	r28
    24d6:	0f 91       	pop	r16
    24d8:	08 95       	ret

000024da <lcd_putc>:


/******************************************************************************
 * Outputs a character on the display, using the global font and style
 */ 
uint8_t  lcd_putc(char c) {
    24da:	cf 93       	push	r28
    24dc:	df 93       	push	r29
    24de:	0f 92       	push	r0
    24e0:	cd b7       	in	r28, 0x3d	; 61
    24e2:	de b7       	in	r29, 0x3e	; 62
    24e4:	89 83       	std	Y+1, r24	; 0x01
  return lcd_put_char(global_font_select, global_font_style, c);
    24e6:	80 91 c2 0d 	lds	r24, 0x0DC2
    24ea:	90 91 c3 0d 	lds	r25, 0x0DC3
    24ee:	20 91 c1 0d 	lds	r18, 0x0DC1
    24f2:	62 2f       	mov	r22, r18
    24f4:	49 81       	ldd	r20, Y+1	; 0x01
    24f6:	0e 94 3b 10 	call	0x2076	; 0x2076 <lcd_put_char>
  }
    24fa:	0f 90       	pop	r0
    24fc:	df 91       	pop	r29
    24fe:	cf 91       	pop	r28
    2500:	08 95       	ret

00002502 <lcd_putc_xy>:

/******************************************************************************
 * Outputs a character on the display, using the global font and style
 */ 
uint8_t  lcd_putc_xy(char c, uint8_t page, uint8_t col) {
    2502:	0f 93       	push	r16
    2504:	cf 93       	push	r28
    2506:	df 93       	push	r29
    2508:	00 d0       	rcall	.+0      	; 0x250a <lcd_putc_xy+0x8>
    250a:	0f 92       	push	r0
    250c:	cd b7       	in	r28, 0x3d	; 61
    250e:	de b7       	in	r29, 0x3e	; 62
    2510:	89 83       	std	Y+1, r24	; 0x01
    2512:	6a 83       	std	Y+2, r22	; 0x02
    2514:	4b 83       	std	Y+3, r20	; 0x03
  return lcd_put_char_xy(global_font_select, global_font_style, c, page, col);
    2516:	80 91 c2 0d 	lds	r24, 0x0DC2
    251a:	90 91 c3 0d 	lds	r25, 0x0DC3
    251e:	20 91 c1 0d 	lds	r18, 0x0DC1
    2522:	62 2f       	mov	r22, r18
    2524:	49 81       	ldd	r20, Y+1	; 0x01
    2526:	2a 81       	ldd	r18, Y+2	; 0x02
    2528:	0b 81       	ldd	r16, Y+3	; 0x03
    252a:	0e 94 4b 12 	call	0x2496	; 0x2496 <lcd_put_char_xy>
  }  
    252e:	0f 90       	pop	r0
    2530:	0f 90       	pop	r0
    2532:	0f 90       	pop	r0
    2534:	df 91       	pop	r29
    2536:	cf 91       	pop	r28
    2538:	0f 91       	pop	r16
    253a:	08 95       	ret

0000253c <lcd_putstr>:
  
  
/******************************************************************************
 * Outputs a string on the display, using the global font and style
 */   
uint16_t lcd_putstr(char* str) {
    253c:	cf 93       	push	r28
    253e:	df 93       	push	r29
    2540:	00 d0       	rcall	.+0      	; 0x2542 <lcd_putstr+0x6>
    2542:	cd b7       	in	r28, 0x3d	; 61
    2544:	de b7       	in	r29, 0x3e	; 62
    2546:	9a 83       	std	Y+2, r25	; 0x02
    2548:	89 83       	std	Y+1, r24	; 0x01
  return lcd_put_string(global_font_select, global_font_style, str);
    254a:	80 91 c2 0d 	lds	r24, 0x0DC2
    254e:	90 91 c3 0d 	lds	r25, 0x0DC3
    2552:	40 91 c1 0d 	lds	r20, 0x0DC1
    2556:	29 81       	ldd	r18, Y+1	; 0x01
    2558:	3a 81       	ldd	r19, Y+2	; 0x02
    255a:	64 2f       	mov	r22, r20
    255c:	a9 01       	movw	r20, r18
    255e:	0e 94 aa 11 	call	0x2354	; 0x2354 <lcd_put_string>
  }
    2562:	0f 90       	pop	r0
    2564:	0f 90       	pop	r0
    2566:	df 91       	pop	r29
    2568:	cf 91       	pop	r28
    256a:	08 95       	ret

0000256c <lcd_putstr_P>:
  
/******************************************************************************
 * Outputs a string stored in program memory on the display, using the global 
 * font and style
 */   
uint16_t lcd_putstr_P(PGM_P str) {
    256c:	cf 93       	push	r28
    256e:	df 93       	push	r29
    2570:	00 d0       	rcall	.+0      	; 0x2572 <lcd_putstr_P+0x6>
    2572:	cd b7       	in	r28, 0x3d	; 61
    2574:	de b7       	in	r29, 0x3e	; 62
    2576:	9a 83       	std	Y+2, r25	; 0x02
    2578:	89 83       	std	Y+1, r24	; 0x01
  return lcd_put_string_P(global_font_select, global_font_style, str);
    257a:	80 91 c2 0d 	lds	r24, 0x0DC2
    257e:	90 91 c3 0d 	lds	r25, 0x0DC3
    2582:	40 91 c1 0d 	lds	r20, 0x0DC1
    2586:	29 81       	ldd	r18, Y+1	; 0x01
    2588:	3a 81       	ldd	r19, Y+2	; 0x02
    258a:	64 2f       	mov	r22, r20
    258c:	a9 01       	movw	r20, r18
    258e:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
  }
    2592:	0f 90       	pop	r0
    2594:	0f 90       	pop	r0
    2596:	df 91       	pop	r29
    2598:	cf 91       	pop	r28
    259a:	08 95       	ret

0000259c <lcd_putstr_xy_P>:

/******************************************************************************
 * Outputs a string on the display, using the global font and style at the 
 * given position
 */   
uint16_t lcd_putstr_xy_P(PGM_P  str, uint8_t page, uint8_t col) {
    259c:	0f 93       	push	r16
    259e:	cf 93       	push	r28
    25a0:	df 93       	push	r29
    25a2:	00 d0       	rcall	.+0      	; 0x25a4 <lcd_putstr_xy_P+0x8>
    25a4:	00 d0       	rcall	.+0      	; 0x25a6 <lcd_putstr_xy_P+0xa>
    25a6:	cd b7       	in	r28, 0x3d	; 61
    25a8:	de b7       	in	r29, 0x3e	; 62
    25aa:	9a 83       	std	Y+2, r25	; 0x02
    25ac:	89 83       	std	Y+1, r24	; 0x01
    25ae:	6b 83       	std	Y+3, r22	; 0x03
    25b0:	4c 83       	std	Y+4, r20	; 0x04
  return lcd_put_string_xy_P(global_font_select, global_font_style, str, page, col);
    25b2:	80 91 c2 0d 	lds	r24, 0x0DC2
    25b6:	90 91 c3 0d 	lds	r25, 0x0DC3
    25ba:	40 91 c1 0d 	lds	r20, 0x0DC1
    25be:	29 81       	ldd	r18, Y+1	; 0x01
    25c0:	3a 81       	ldd	r19, Y+2	; 0x02
    25c2:	64 2f       	mov	r22, r20
    25c4:	a9 01       	movw	r20, r18
    25c6:	2b 81       	ldd	r18, Y+3	; 0x03
    25c8:	0c 81       	ldd	r16, Y+4	; 0x04
    25ca:	0e 94 23 12 	call	0x2446	; 0x2446 <lcd_put_string_xy_P>
  }  
    25ce:	0f 90       	pop	r0
    25d0:	0f 90       	pop	r0
    25d2:	0f 90       	pop	r0
    25d4:	0f 90       	pop	r0
    25d6:	df 91       	pop	r29
    25d8:	cf 91       	pop	r28
    25da:	0f 91       	pop	r16
    25dc:	08 95       	ret

000025de <lcd_put_long>:

#if INCLUDE_INTEGER_OUTPUT == 1
/******************************************************************************
 * Outputs a 32bit signed integer on the display // Added by Olli S.
 */ 
uint16_t lcd_put_long  (int32_t integer) {
    25de:	cf 93       	push	r28
    25e0:	df 93       	push	r29
    25e2:	cd b7       	in	r28, 0x3d	; 61
    25e4:	de b7       	in	r29, 0x3e	; 62
    25e6:	2e 97       	sbiw	r28, 0x0e	; 14
    25e8:	0f b6       	in	r0, 0x3f	; 63
    25ea:	f8 94       	cli
    25ec:	de bf       	out	0x3e, r29	; 62
    25ee:	0f be       	out	0x3f, r0	; 63
    25f0:	cd bf       	out	0x3d, r28	; 61
    25f2:	6b 87       	std	Y+11, r22	; 0x0b
    25f4:	7c 87       	std	Y+12, r23	; 0x0c
    25f6:	8d 87       	std	Y+13, r24	; 0x0d
    25f8:	9e 87       	std	Y+14, r25	; 0x0e
  char buffer[10];
	ltoa(integer, buffer, 10);
    25fa:	8b 85       	ldd	r24, Y+11	; 0x0b
    25fc:	9c 85       	ldd	r25, Y+12	; 0x0c
    25fe:	ad 85       	ldd	r26, Y+13	; 0x0d
    2600:	be 85       	ldd	r27, Y+14	; 0x0e
    2602:	bc 01       	movw	r22, r24
    2604:	cd 01       	movw	r24, r26
    2606:	9e 01       	movw	r18, r28
    2608:	2f 5f       	subi	r18, 0xFF	; 255
    260a:	3f 4f       	sbci	r19, 0xFF	; 255
    260c:	a9 01       	movw	r20, r18
    260e:	2a e0       	ldi	r18, 0x0A	; 10
    2610:	30 e0       	ldi	r19, 0x00	; 0
    2612:	0e 94 e5 36 	call	0x6dca	; 0x6dca <ltoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    2616:	80 91 c2 0d 	lds	r24, 0x0DC2
    261a:	90 91 c3 0d 	lds	r25, 0x0DC3
    261e:	20 91 c1 0d 	lds	r18, 0x0DC1
    2622:	62 2f       	mov	r22, r18
    2624:	9e 01       	movw	r18, r28
    2626:	2f 5f       	subi	r18, 0xFF	; 255
    2628:	3f 4f       	sbci	r19, 0xFF	; 255
    262a:	a9 01       	movw	r20, r18
    262c:	0e 94 aa 11 	call	0x2354	; 0x2354 <lcd_put_string>
  }
    2630:	2e 96       	adiw	r28, 0x0e	; 14
    2632:	0f b6       	in	r0, 0x3f	; 63
    2634:	f8 94       	cli
    2636:	de bf       	out	0x3e, r29	; 62
    2638:	0f be       	out	0x3f, r0	; 63
    263a:	cd bf       	out	0x3d, r28	; 61
    263c:	df 91       	pop	r29
    263e:	cf 91       	pop	r28
    2640:	08 95       	ret

00002642 <lcd_put_int>:

  
/******************************************************************************
 * Outputs a 16bit signed integer on the display // Added by Olli S.
 */   
uint16_t lcd_put_int (int16_t integer) {
    2642:	cf 93       	push	r28
    2644:	df 93       	push	r29
    2646:	cd b7       	in	r28, 0x3d	; 61
    2648:	de b7       	in	r29, 0x3e	; 62
    264a:	2c 97       	sbiw	r28, 0x0c	; 12
    264c:	0f b6       	in	r0, 0x3f	; 63
    264e:	f8 94       	cli
    2650:	de bf       	out	0x3e, r29	; 62
    2652:	0f be       	out	0x3f, r0	; 63
    2654:	cd bf       	out	0x3d, r28	; 61
    2656:	9c 87       	std	Y+12, r25	; 0x0c
    2658:	8b 87       	std	Y+11, r24	; 0x0b
  char buffer[10];
	itoa(integer, buffer, 10);
    265a:	8b 85       	ldd	r24, Y+11	; 0x0b
    265c:	9c 85       	ldd	r25, Y+12	; 0x0c
    265e:	9e 01       	movw	r18, r28
    2660:	2f 5f       	subi	r18, 0xFF	; 255
    2662:	3f 4f       	sbci	r19, 0xFF	; 255
    2664:	b9 01       	movw	r22, r18
    2666:	4a e0       	ldi	r20, 0x0A	; 10
    2668:	50 e0       	ldi	r21, 0x00	; 0
    266a:	0e 94 c4 36 	call	0x6d88	; 0x6d88 <itoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    266e:	80 91 c2 0d 	lds	r24, 0x0DC2
    2672:	90 91 c3 0d 	lds	r25, 0x0DC3
    2676:	20 91 c1 0d 	lds	r18, 0x0DC1
    267a:	62 2f       	mov	r22, r18
    267c:	9e 01       	movw	r18, r28
    267e:	2f 5f       	subi	r18, 0xFF	; 255
    2680:	3f 4f       	sbci	r19, 0xFF	; 255
    2682:	a9 01       	movw	r20, r18
    2684:	0e 94 aa 11 	call	0x2354	; 0x2354 <lcd_put_string>
  }  
    2688:	2c 96       	adiw	r28, 0x0c	; 12
    268a:	0f b6       	in	r0, 0x3f	; 63
    268c:	f8 94       	cli
    268e:	de bf       	out	0x3e, r29	; 62
    2690:	0f be       	out	0x3f, r0	; 63
    2692:	cd bf       	out	0x3d, r28	; 61
    2694:	df 91       	pop	r29
    2696:	cf 91       	pop	r28
    2698:	08 95       	ret

0000269a <lcd_put_uint>:

  
/******************************************************************************
 * Outputs a 16bit unsigned integer on the display // Added by Olli S.
 */   
uint16_t lcd_put_uint  (uint16_t integer) {
    269a:	cf 93       	push	r28
    269c:	df 93       	push	r29
    269e:	cd b7       	in	r28, 0x3d	; 61
    26a0:	de b7       	in	r29, 0x3e	; 62
    26a2:	2c 97       	sbiw	r28, 0x0c	; 12
    26a4:	0f b6       	in	r0, 0x3f	; 63
    26a6:	f8 94       	cli
    26a8:	de bf       	out	0x3e, r29	; 62
    26aa:	0f be       	out	0x3f, r0	; 63
    26ac:	cd bf       	out	0x3d, r28	; 61
    26ae:	9c 87       	std	Y+12, r25	; 0x0c
    26b0:	8b 87       	std	Y+11, r24	; 0x0b
  char buffer[10];
	utoa(integer, buffer, 10);
    26b2:	8b 85       	ldd	r24, Y+11	; 0x0b
    26b4:	9c 85       	ldd	r25, Y+12	; 0x0c
    26b6:	9e 01       	movw	r18, r28
    26b8:	2f 5f       	subi	r18, 0xFF	; 255
    26ba:	3f 4f       	sbci	r19, 0xFF	; 255
    26bc:	b9 01       	movw	r22, r18
    26be:	4a e0       	ldi	r20, 0x0A	; 10
    26c0:	50 e0       	ldi	r21, 0x00	; 0
    26c2:	0e 94 19 37 	call	0x6e32	; 0x6e32 <utoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    26c6:	80 91 c2 0d 	lds	r24, 0x0DC2
    26ca:	90 91 c3 0d 	lds	r25, 0x0DC3
    26ce:	20 91 c1 0d 	lds	r18, 0x0DC1
    26d2:	62 2f       	mov	r22, r18
    26d4:	9e 01       	movw	r18, r28
    26d6:	2f 5f       	subi	r18, 0xFF	; 255
    26d8:	3f 4f       	sbci	r19, 0xFF	; 255
    26da:	a9 01       	movw	r20, r18
    26dc:	0e 94 aa 11 	call	0x2354	; 0x2354 <lcd_put_string>
  }  
    26e0:	2c 96       	adiw	r28, 0x0c	; 12
    26e2:	0f b6       	in	r0, 0x3f	; 63
    26e4:	f8 94       	cli
    26e6:	de bf       	out	0x3e, r29	; 62
    26e8:	0f be       	out	0x3f, r0	; 63
    26ea:	cd bf       	out	0x3d, r28	; 61
    26ec:	df 91       	pop	r29
    26ee:	cf 91       	pop	r28
    26f0:	08 95       	ret

000026f2 <lcd_put_short>:
  
/******************************************************************************
 * Outputs a 8bit signed integer on the display
 */   
uint16_t lcd_put_short (int8_t integer) {
    26f2:	cf 93       	push	r28
    26f4:	df 93       	push	r29
    26f6:	cd b7       	in	r28, 0x3d	; 61
    26f8:	de b7       	in	r29, 0x3e	; 62
    26fa:	2b 97       	sbiw	r28, 0x0b	; 11
    26fc:	0f b6       	in	r0, 0x3f	; 63
    26fe:	f8 94       	cli
    2700:	de bf       	out	0x3e, r29	; 62
    2702:	0f be       	out	0x3f, r0	; 63
    2704:	cd bf       	out	0x3d, r28	; 61
    2706:	8b 87       	std	Y+11, r24	; 0x0b
  char buffer[10];
	itoa(integer, buffer, 10);
    2708:	8b 85       	ldd	r24, Y+11	; 0x0b
    270a:	99 27       	eor	r25, r25
    270c:	87 fd       	sbrc	r24, 7
    270e:	90 95       	com	r25
    2710:	9e 01       	movw	r18, r28
    2712:	2f 5f       	subi	r18, 0xFF	; 255
    2714:	3f 4f       	sbci	r19, 0xFF	; 255
    2716:	b9 01       	movw	r22, r18
    2718:	4a e0       	ldi	r20, 0x0A	; 10
    271a:	50 e0       	ldi	r21, 0x00	; 0
    271c:	0e 94 c4 36 	call	0x6d88	; 0x6d88 <itoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    2720:	80 91 c2 0d 	lds	r24, 0x0DC2
    2724:	90 91 c3 0d 	lds	r25, 0x0DC3
    2728:	20 91 c1 0d 	lds	r18, 0x0DC1
    272c:	62 2f       	mov	r22, r18
    272e:	9e 01       	movw	r18, r28
    2730:	2f 5f       	subi	r18, 0xFF	; 255
    2732:	3f 4f       	sbci	r19, 0xFF	; 255
    2734:	a9 01       	movw	r20, r18
    2736:	0e 94 aa 11 	call	0x2354	; 0x2354 <lcd_put_string>
  }    
    273a:	2b 96       	adiw	r28, 0x0b	; 11
    273c:	0f b6       	in	r0, 0x3f	; 63
    273e:	f8 94       	cli
    2740:	de bf       	out	0x3e, r29	; 62
    2742:	0f be       	out	0x3f, r0	; 63
    2744:	cd bf       	out	0x3d, r28	; 61
    2746:	df 91       	pop	r29
    2748:	cf 91       	pop	r28
    274a:	08 95       	ret

0000274c <main>:
void vApplicationIdleHook( void );

/*-----------------------------------------------------------*/

int main( void )
{  
    274c:	cf 93       	push	r28
    274e:	df 93       	push	r29
    2750:	00 d0       	rcall	.+0      	; 0x2752 <main+0x6>
    2752:	00 d0       	rcall	.+0      	; 0x2754 <main+0x8>
    2754:	00 d0       	rcall	.+0      	; 0x2756 <main+0xa>
    2756:	cd b7       	in	r28, 0x3d	; 61
    2758:	de b7       	in	r29, 0x3e	; 62
    //set the length of the queues -> how many items the queue can hold
    const unsigned portBASE_TYPE measurementQueueLength = 5;
    275a:	85 e0       	ldi	r24, 0x05	; 5
    275c:	89 83       	std	Y+1, r24	; 0x01
    const unsigned portBASE_TYPE statusQueueLength = 5;
    275e:	85 e0       	ldi	r24, 0x05	; 5
    2760:	8a 83       	std	Y+2, r24	; 0x02
    
    xQueueHandle measurementQueue;
    xQueueHandle statusQueue;
    
    //configure time measurment pin as output
    DDRD |= (1<<PB7);
    2762:	8a e2       	ldi	r24, 0x2A	; 42
    2764:	90 e0       	ldi	r25, 0x00	; 0
    2766:	2a e2       	ldi	r18, 0x2A	; 42
    2768:	30 e0       	ldi	r19, 0x00	; 0
    276a:	f9 01       	movw	r30, r18
    276c:	20 81       	ld	r18, Z
    276e:	20 68       	ori	r18, 0x80	; 128
    2770:	fc 01       	movw	r30, r24
    2772:	20 83       	st	Z, r18

	//prvIncrementResetCount();
    
    
    lcd_init();
    2774:	0e 94 d0 0b 	call	0x17a0	; 0x17a0 <lcd_init>
        //}
    //}
//}
    
    //create queues for intertask communication
    measurementQueue = xQueueCreate( measurementQueueLength, ( unsigned portBASE_TYPE ) sizeof( measurementQueueMsg * ) );
    2778:	89 81       	ldd	r24, Y+1	; 0x01
    277a:	62 e0       	ldi	r22, 0x02	; 2
    277c:	40 e0       	ldi	r20, 0x00	; 0
    277e:	0e 94 c2 1c 	call	0x3984	; 0x3984 <xQueueGenericCreate>
    2782:	9c 83       	std	Y+4, r25	; 0x04
    2784:	8b 83       	std	Y+3, r24	; 0x03
    statusQueue = 0;//xQueueCreate( statusQueueLength, ( unsigned portBASE_TYPE ) sizeof( statusQueueMsg * ) );
    2786:	1e 82       	std	Y+6, r1	; 0x06
    2788:	1d 82       	std	Y+5, r1	; 0x05
        
	/* Create the tasks. */
    startUserInterfaceTask( mainUSERINTERFACE_TASK_PRIORITY, &measurementQueue );
    278a:	9e 01       	movw	r18, r28
    278c:	2d 5f       	subi	r18, 0xFD	; 253
    278e:	3f 4f       	sbci	r19, 0xFF	; 255
    2790:	82 e0       	ldi	r24, 0x02	; 2
    2792:	b9 01       	movw	r22, r18
    2794:	0e 94 56 31 	call	0x62ac	; 0x62ac <startUserInterfaceTask>
    startSystemStatusTask( mainSYSTEMSTATUS_TASK_PRIORITY, &statusQueue );
    2798:	9e 01       	movw	r18, r28
    279a:	2b 5f       	subi	r18, 0xFB	; 251
    279c:	3f 4f       	sbci	r19, 0xFF	; 255
    279e:	81 e0       	ldi	r24, 0x01	; 1
    27a0:	b9 01       	movw	r22, r18
    27a2:	0e 94 9e 30 	call	0x613c	; 0x613c <startSystemStatusTask>
    startSystemControlTask( mainSYSTEMCONTROL_TASK_PRIORITY, &measurementQueue, &statusQueue );
    27a6:	ae 01       	movw	r20, r28
    27a8:	4d 5f       	subi	r20, 0xFD	; 253
    27aa:	5f 4f       	sbci	r21, 0xFF	; 255
    27ac:	9e 01       	movw	r18, r28
    27ae:	2b 5f       	subi	r18, 0xFB	; 251
    27b0:	3f 4f       	sbci	r19, 0xFF	; 255
    27b2:	83 e0       	ldi	r24, 0x03	; 3
    27b4:	ba 01       	movw	r22, r20
    27b6:	a9 01       	movw	r20, r18
    27b8:	0e 94 e3 2f 	call	0x5fc6	; 0x5fc6 <startSystemControlTask>
	//vStartFlashCoRoutines( mainNUM_FLASH_COROUTINES );
	
	/* In this port, to use preemptive scheduler define configUSE_PREEMPTION 
	as 1 in portmacro.h.  To use the cooperative scheduler define 
	configUSE_PREEMPTION as 0. */
	vTaskStartScheduler();
    27bc:	0e 94 a4 23 	call	0x4748	; 0x4748 <vTaskStartScheduler>

	return 0;
    27c0:	80 e0       	ldi	r24, 0x00	; 0
    27c2:	90 e0       	ldi	r25, 0x00	; 0
}
    27c4:	26 96       	adiw	r28, 0x06	; 6
    27c6:	0f b6       	in	r0, 0x3f	; 63
    27c8:	f8 94       	cli
    27ca:	de bf       	out	0x3e, r29	; 62
    27cc:	0f be       	out	0x3f, r0	; 63
    27ce:	cd bf       	out	0x3d, r28	; 61
    27d0:	df 91       	pop	r29
    27d2:	cf 91       	pop	r28
    27d4:	08 95       	ret

000027d6 <prvIncrementResetCount>:
	//}
//}
/*-----------------------------------------------------------*/

static void prvIncrementResetCount( void )
{
    27d6:	cf 93       	push	r28
    27d8:	df 93       	push	r29
    27da:	0f 92       	push	r0
    27dc:	cd b7       	in	r28, 0x3d	; 61
    27de:	de b7       	in	r29, 0x3e	; 62
unsigned char ucCount;

	eeprom_read_block( &ucCount, mainRESET_COUNT_ADDRESS, sizeof( ucCount ) );
    27e0:	ce 01       	movw	r24, r28
    27e2:	01 96       	adiw	r24, 0x01	; 1
    27e4:	60 e5       	ldi	r22, 0x50	; 80
    27e6:	70 e0       	ldi	r23, 0x00	; 0
    27e8:	41 e0       	ldi	r20, 0x01	; 1
    27ea:	50 e0       	ldi	r21, 0x00	; 0
    27ec:	0e 94 2f 37 	call	0x6e5e	; 0x6e5e <__eerd_block_m1284p>
	ucCount++;
    27f0:	89 81       	ldd	r24, Y+1	; 0x01
    27f2:	8f 5f       	subi	r24, 0xFF	; 255
    27f4:	89 83       	std	Y+1, r24	; 0x01
	eeprom_write_byte( mainRESET_COUNT_ADDRESS, ucCount );
    27f6:	29 81       	ldd	r18, Y+1	; 0x01
    27f8:	80 e5       	ldi	r24, 0x50	; 80
    27fa:	90 e0       	ldi	r25, 0x00	; 0
    27fc:	62 2f       	mov	r22, r18
    27fe:	0e 94 3f 37 	call	0x6e7e	; 0x6e7e <__eewr_byte_m1284p>
}
    2802:	0f 90       	pop	r0
    2804:	df 91       	pop	r29
    2806:	cf 91       	pop	r28
    2808:	08 95       	ret

0000280a <vApplicationIdleHook>:
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
    280a:	cf 93       	push	r28
    280c:	df 93       	push	r29
    280e:	cd b7       	in	r28, 0x3d	; 61
    2810:	de b7       	in	r29, 0x3e	; 62
	//vCoRoutineSchedule();
}
    2812:	df 91       	pop	r29
    2814:	cf 91       	pop	r28
    2816:	08 95       	ret

00002818 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    2818:	cf 93       	push	r28
    281a:	df 93       	push	r29
    281c:	cd b7       	in	r28, 0x3d	; 61
    281e:	de b7       	in	r29, 0x3e	; 62
    2820:	27 97       	sbiw	r28, 0x07	; 7
    2822:	0f b6       	in	r0, 0x3f	; 63
    2824:	f8 94       	cli
    2826:	de bf       	out	0x3e, r29	; 62
    2828:	0f be       	out	0x3f, r0	; 63
    282a:	cd bf       	out	0x3d, r28	; 61
    282c:	9d 83       	std	Y+5, r25	; 0x05
    282e:	8c 83       	std	Y+4, r24	; 0x04
    2830:	6e 83       	std	Y+6, r22	; 0x06
    2832:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    2834:	8a e1       	ldi	r24, 0x1A	; 26
    2836:	90 e0       	ldi	r25, 0x00	; 0
    2838:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <pvPortMalloc>
    283c:	9b 83       	std	Y+3, r25	; 0x03
    283e:	8a 83       	std	Y+2, r24	; 0x02
	if( pxCoRoutine )
    2840:	8a 81       	ldd	r24, Y+2	; 0x02
    2842:	9b 81       	ldd	r25, Y+3	; 0x03
    2844:	00 97       	sbiw	r24, 0x00	; 0
    2846:	09 f4       	brne	.+2      	; 0x284a <xCoRoutineCreate+0x32>
    2848:	76 c0       	rjmp	.+236    	; 0x2936 <xCoRoutineCreate+0x11e>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    284a:	80 91 5a 01 	lds	r24, 0x015A
    284e:	90 91 5b 01 	lds	r25, 0x015B
    2852:	00 97       	sbiw	r24, 0x00	; 0
    2854:	41 f4       	brne	.+16     	; 0x2866 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    2856:	8a 81       	ldd	r24, Y+2	; 0x02
    2858:	9b 81       	ldd	r25, Y+3	; 0x03
    285a:	90 93 5b 01 	sts	0x015B, r25
    285e:	80 93 5a 01 	sts	0x015A, r24
			prvInitialiseCoRoutineLists();
    2862:	0e 94 f0 16 	call	0x2de0	; 0x2de0 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    2866:	8e 81       	ldd	r24, Y+6	; 0x06
    2868:	82 30       	cpi	r24, 0x02	; 2
    286a:	10 f0       	brcs	.+4      	; 0x2870 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    286c:	81 e0       	ldi	r24, 0x01	; 1
    286e:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    2870:	8a 81       	ldd	r24, Y+2	; 0x02
    2872:	9b 81       	ldd	r25, Y+3	; 0x03
    2874:	fc 01       	movw	r30, r24
    2876:	11 8e       	std	Z+25, r1	; 0x19
    2878:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    287a:	8a 81       	ldd	r24, Y+2	; 0x02
    287c:	9b 81       	ldd	r25, Y+3	; 0x03
    287e:	2e 81       	ldd	r18, Y+6	; 0x06
    2880:	fc 01       	movw	r30, r24
    2882:	26 8b       	std	Z+22, r18	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2884:	8a 81       	ldd	r24, Y+2	; 0x02
    2886:	9b 81       	ldd	r25, Y+3	; 0x03
    2888:	2f 81       	ldd	r18, Y+7	; 0x07
    288a:	fc 01       	movw	r30, r24
    288c:	27 8b       	std	Z+23, r18	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    288e:	8a 81       	ldd	r24, Y+2	; 0x02
    2890:	9b 81       	ldd	r25, Y+3	; 0x03
    2892:	2c 81       	ldd	r18, Y+4	; 0x04
    2894:	3d 81       	ldd	r19, Y+5	; 0x05
    2896:	fc 01       	movw	r30, r24
    2898:	31 83       	std	Z+1, r19	; 0x01
    289a:	20 83       	st	Z, r18

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    289c:	8a 81       	ldd	r24, Y+2	; 0x02
    289e:	9b 81       	ldd	r25, Y+3	; 0x03
    28a0:	02 96       	adiw	r24, 0x02	; 2
    28a2:	0e 94 17 18 	call	0x302e	; 0x302e <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    28a6:	8a 81       	ldd	r24, Y+2	; 0x02
    28a8:	9b 81       	ldd	r25, Y+3	; 0x03
    28aa:	0c 96       	adiw	r24, 0x0c	; 12
    28ac:	0e 94 17 18 	call	0x302e	; 0x302e <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    28b0:	8a 81       	ldd	r24, Y+2	; 0x02
    28b2:	9b 81       	ldd	r25, Y+3	; 0x03
    28b4:	2a 81       	ldd	r18, Y+2	; 0x02
    28b6:	3b 81       	ldd	r19, Y+3	; 0x03
    28b8:	fc 01       	movw	r30, r24
    28ba:	31 87       	std	Z+9, r19	; 0x09
    28bc:	20 87       	std	Z+8, r18	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    28be:	8a 81       	ldd	r24, Y+2	; 0x02
    28c0:	9b 81       	ldd	r25, Y+3	; 0x03
    28c2:	2a 81       	ldd	r18, Y+2	; 0x02
    28c4:	3b 81       	ldd	r19, Y+3	; 0x03
    28c6:	fc 01       	movw	r30, r24
    28c8:	33 8b       	std	Z+19, r19	; 0x13
    28ca:	22 8b       	std	Z+18, r18	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( uint32_t ) uxPriority );
    28cc:	8e 81       	ldd	r24, Y+6	; 0x06
    28ce:	88 2f       	mov	r24, r24
    28d0:	90 e0       	ldi	r25, 0x00	; 0
    28d2:	24 e0       	ldi	r18, 0x04	; 4
    28d4:	30 e0       	ldi	r19, 0x00	; 0
    28d6:	28 1b       	sub	r18, r24
    28d8:	39 0b       	sbc	r19, r25
    28da:	8a 81       	ldd	r24, Y+2	; 0x02
    28dc:	9b 81       	ldd	r25, Y+3	; 0x03
    28de:	fc 01       	movw	r30, r24
    28e0:	35 87       	std	Z+13, r19	; 0x0d
    28e2:	24 87       	std	Z+12, r18	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    28e4:	8a 81       	ldd	r24, Y+2	; 0x02
    28e6:	9b 81       	ldd	r25, Y+3	; 0x03
    28e8:	fc 01       	movw	r30, r24
    28ea:	96 89       	ldd	r25, Z+22	; 0x16
    28ec:	80 91 8d 01 	lds	r24, 0x018D
    28f0:	89 17       	cp	r24, r25
    28f2:	30 f4       	brcc	.+12     	; 0x2900 <xCoRoutineCreate+0xe8>
    28f4:	8a 81       	ldd	r24, Y+2	; 0x02
    28f6:	9b 81       	ldd	r25, Y+3	; 0x03
    28f8:	fc 01       	movw	r30, r24
    28fa:	86 89       	ldd	r24, Z+22	; 0x16
    28fc:	80 93 8d 01 	sts	0x018D, r24
    2900:	8a 81       	ldd	r24, Y+2	; 0x02
    2902:	9b 81       	ldd	r25, Y+3	; 0x03
    2904:	fc 01       	movw	r30, r24
    2906:	86 89       	ldd	r24, Z+22	; 0x16
    2908:	28 2f       	mov	r18, r24
    290a:	30 e0       	ldi	r19, 0x00	; 0
    290c:	c9 01       	movw	r24, r18
    290e:	88 0f       	add	r24, r24
    2910:	99 1f       	adc	r25, r25
    2912:	88 0f       	add	r24, r24
    2914:	99 1f       	adc	r25, r25
    2916:	88 0f       	add	r24, r24
    2918:	99 1f       	adc	r25, r25
    291a:	82 0f       	add	r24, r18
    291c:	93 1f       	adc	r25, r19
    291e:	84 5a       	subi	r24, 0xA4	; 164
    2920:	9e 4f       	sbci	r25, 0xFE	; 254
    2922:	2a 81       	ldd	r18, Y+2	; 0x02
    2924:	3b 81       	ldd	r19, Y+3	; 0x03
    2926:	2e 5f       	subi	r18, 0xFE	; 254
    2928:	3f 4f       	sbci	r19, 0xFF	; 255
    292a:	b9 01       	movw	r22, r18
    292c:	0e 94 28 18 	call	0x3050	; 0x3050 <vListInsertEnd>

		xReturn = pdPASS;
    2930:	81 e0       	ldi	r24, 0x01	; 1
    2932:	89 83       	std	Y+1, r24	; 0x01
    2934:	02 c0       	rjmp	.+4      	; 0x293a <xCoRoutineCreate+0x122>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2936:	8f ef       	ldi	r24, 0xFF	; 255
    2938:	89 83       	std	Y+1, r24	; 0x01
	}

	return xReturn;
    293a:	89 81       	ldd	r24, Y+1	; 0x01
}
    293c:	27 96       	adiw	r28, 0x07	; 7
    293e:	0f b6       	in	r0, 0x3f	; 63
    2940:	f8 94       	cli
    2942:	de bf       	out	0x3e, r29	; 62
    2944:	0f be       	out	0x3f, r0	; 63
    2946:	cd bf       	out	0x3d, r28	; 61
    2948:	df 91       	pop	r29
    294a:	cf 91       	pop	r28
    294c:	08 95       	ret

0000294e <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( uint32_t xTicksToDelay, xList *pxEventList )
{
    294e:	cf 93       	push	r28
    2950:	df 93       	push	r29
    2952:	cd b7       	in	r28, 0x3d	; 61
    2954:	de b7       	in	r29, 0x3e	; 62
    2956:	2a 97       	sbiw	r28, 0x0a	; 10
    2958:	0f b6       	in	r0, 0x3f	; 63
    295a:	f8 94       	cli
    295c:	de bf       	out	0x3e, r29	; 62
    295e:	0f be       	out	0x3f, r0	; 63
    2960:	cd bf       	out	0x3d, r28	; 61
    2962:	6d 83       	std	Y+5, r22	; 0x05
    2964:	7e 83       	std	Y+6, r23	; 0x06
    2966:	8f 83       	std	Y+7, r24	; 0x07
    2968:	98 87       	std	Y+8, r25	; 0x08
    296a:	5a 87       	std	Y+10, r21	; 0x0a
    296c:	49 87       	std	Y+9, r20	; 0x09
uint32_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    296e:	20 91 8e 01 	lds	r18, 0x018E
    2972:	30 91 8f 01 	lds	r19, 0x018F
    2976:	40 91 90 01 	lds	r20, 0x0190
    297a:	50 91 91 01 	lds	r21, 0x0191
    297e:	8d 81       	ldd	r24, Y+5	; 0x05
    2980:	9e 81       	ldd	r25, Y+6	; 0x06
    2982:	af 81       	ldd	r26, Y+7	; 0x07
    2984:	b8 85       	ldd	r27, Y+8	; 0x08
    2986:	82 0f       	add	r24, r18
    2988:	93 1f       	adc	r25, r19
    298a:	a4 1f       	adc	r26, r20
    298c:	b5 1f       	adc	r27, r21
    298e:	89 83       	std	Y+1, r24	; 0x01
    2990:	9a 83       	std	Y+2, r25	; 0x02
    2992:	ab 83       	std	Y+3, r26	; 0x03
    2994:	bc 83       	std	Y+4, r27	; 0x04

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2996:	80 91 5a 01 	lds	r24, 0x015A
    299a:	90 91 5b 01 	lds	r25, 0x015B
    299e:	02 96       	adiw	r24, 0x02	; 2
    29a0:	0e 94 0b 19 	call	0x3216	; 0x3216 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    29a4:	80 91 5a 01 	lds	r24, 0x015A
    29a8:	90 91 5b 01 	lds	r25, 0x015B
    29ac:	29 81       	ldd	r18, Y+1	; 0x01
    29ae:	3a 81       	ldd	r19, Y+2	; 0x02
    29b0:	fc 01       	movw	r30, r24
    29b2:	33 83       	std	Z+3, r19	; 0x03
    29b4:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    29b6:	80 91 8e 01 	lds	r24, 0x018E
    29ba:	90 91 8f 01 	lds	r25, 0x018F
    29be:	a0 91 90 01 	lds	r26, 0x0190
    29c2:	b0 91 91 01 	lds	r27, 0x0191
    29c6:	29 81       	ldd	r18, Y+1	; 0x01
    29c8:	3a 81       	ldd	r19, Y+2	; 0x02
    29ca:	4b 81       	ldd	r20, Y+3	; 0x03
    29cc:	5c 81       	ldd	r21, Y+4	; 0x04
    29ce:	28 17       	cp	r18, r24
    29d0:	39 07       	cpc	r19, r25
    29d2:	4a 07       	cpc	r20, r26
    29d4:	5b 07       	cpc	r21, r27
    29d6:	70 f4       	brcc	.+28     	; 0x29f4 <vCoRoutineAddToDelayedList+0xa6>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    29d8:	80 91 82 01 	lds	r24, 0x0182
    29dc:	90 91 83 01 	lds	r25, 0x0183
    29e0:	20 91 5a 01 	lds	r18, 0x015A
    29e4:	30 91 5b 01 	lds	r19, 0x015B
    29e8:	2e 5f       	subi	r18, 0xFE	; 254
    29ea:	3f 4f       	sbci	r19, 0xFF	; 255
    29ec:	b9 01       	movw	r22, r18
    29ee:	0e 94 80 18 	call	0x3100	; 0x3100 <vListInsert>
    29f2:	0d c0       	rjmp	.+26     	; 0x2a0e <vCoRoutineAddToDelayedList+0xc0>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    29f4:	80 91 80 01 	lds	r24, 0x0180
    29f8:	90 91 81 01 	lds	r25, 0x0181
    29fc:	20 91 5a 01 	lds	r18, 0x015A
    2a00:	30 91 5b 01 	lds	r19, 0x015B
    2a04:	2e 5f       	subi	r18, 0xFE	; 254
    2a06:	3f 4f       	sbci	r19, 0xFF	; 255
    2a08:	b9 01       	movw	r22, r18
    2a0a:	0e 94 80 18 	call	0x3100	; 0x3100 <vListInsert>
	}

	if( pxEventList )
    2a0e:	89 85       	ldd	r24, Y+9	; 0x09
    2a10:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a12:	00 97       	sbiw	r24, 0x00	; 0
    2a14:	61 f0       	breq	.+24     	; 0x2a2e <vCoRoutineAddToDelayedList+0xe0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    2a16:	80 91 5a 01 	lds	r24, 0x015A
    2a1a:	90 91 5b 01 	lds	r25, 0x015B
    2a1e:	9c 01       	movw	r18, r24
    2a20:	24 5f       	subi	r18, 0xF4	; 244
    2a22:	3f 4f       	sbci	r19, 0xFF	; 255
    2a24:	89 85       	ldd	r24, Y+9	; 0x09
    2a26:	9a 85       	ldd	r25, Y+10	; 0x0a
    2a28:	b9 01       	movw	r22, r18
    2a2a:	0e 94 80 18 	call	0x3100	; 0x3100 <vListInsert>
	}
}
    2a2e:	2a 96       	adiw	r28, 0x0a	; 10
    2a30:	0f b6       	in	r0, 0x3f	; 63
    2a32:	f8 94       	cli
    2a34:	de bf       	out	0x3e, r29	; 62
    2a36:	0f be       	out	0x3f, r0	; 63
    2a38:	cd bf       	out	0x3d, r28	; 61
    2a3a:	df 91       	pop	r29
    2a3c:	cf 91       	pop	r28
    2a3e:	08 95       	ret

00002a40 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    2a40:	cf 93       	push	r28
    2a42:	df 93       	push	r29
    2a44:	00 d0       	rcall	.+0      	; 0x2a46 <prvCheckPendingReadyList+0x6>
    2a46:	cd b7       	in	r28, 0x3d	; 61
    2a48:	de b7       	in	r29, 0x3e	; 62
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2a4a:	3b c0       	rjmp	.+118    	; 0x2ac2 <prvCheckPendingReadyList+0x82>
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    2a4c:	f8 94       	cli
		{
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    2a4e:	80 91 89 01 	lds	r24, 0x0189
    2a52:	90 91 8a 01 	lds	r25, 0x018A
    2a56:	fc 01       	movw	r30, r24
    2a58:	86 81       	ldd	r24, Z+6	; 0x06
    2a5a:	97 81       	ldd	r25, Z+7	; 0x07
    2a5c:	9a 83       	std	Y+2, r25	; 0x02
    2a5e:	89 83       	std	Y+1, r24	; 0x01
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2a60:	89 81       	ldd	r24, Y+1	; 0x01
    2a62:	9a 81       	ldd	r25, Y+2	; 0x02
    2a64:	0c 96       	adiw	r24, 0x0c	; 12
    2a66:	0e 94 0b 19 	call	0x3216	; 0x3216 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    2a6a:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    2a6c:	89 81       	ldd	r24, Y+1	; 0x01
    2a6e:	9a 81       	ldd	r25, Y+2	; 0x02
    2a70:	02 96       	adiw	r24, 0x02	; 2
    2a72:	0e 94 0b 19 	call	0x3216	; 0x3216 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    2a76:	89 81       	ldd	r24, Y+1	; 0x01
    2a78:	9a 81       	ldd	r25, Y+2	; 0x02
    2a7a:	fc 01       	movw	r30, r24
    2a7c:	96 89       	ldd	r25, Z+22	; 0x16
    2a7e:	80 91 8d 01 	lds	r24, 0x018D
    2a82:	89 17       	cp	r24, r25
    2a84:	30 f4       	brcc	.+12     	; 0x2a92 <prvCheckPendingReadyList+0x52>
    2a86:	89 81       	ldd	r24, Y+1	; 0x01
    2a88:	9a 81       	ldd	r25, Y+2	; 0x02
    2a8a:	fc 01       	movw	r30, r24
    2a8c:	86 89       	ldd	r24, Z+22	; 0x16
    2a8e:	80 93 8d 01 	sts	0x018D, r24
    2a92:	89 81       	ldd	r24, Y+1	; 0x01
    2a94:	9a 81       	ldd	r25, Y+2	; 0x02
    2a96:	fc 01       	movw	r30, r24
    2a98:	86 89       	ldd	r24, Z+22	; 0x16
    2a9a:	28 2f       	mov	r18, r24
    2a9c:	30 e0       	ldi	r19, 0x00	; 0
    2a9e:	c9 01       	movw	r24, r18
    2aa0:	88 0f       	add	r24, r24
    2aa2:	99 1f       	adc	r25, r25
    2aa4:	88 0f       	add	r24, r24
    2aa6:	99 1f       	adc	r25, r25
    2aa8:	88 0f       	add	r24, r24
    2aaa:	99 1f       	adc	r25, r25
    2aac:	82 0f       	add	r24, r18
    2aae:	93 1f       	adc	r25, r19
    2ab0:	84 5a       	subi	r24, 0xA4	; 164
    2ab2:	9e 4f       	sbci	r25, 0xFE	; 254
    2ab4:	29 81       	ldd	r18, Y+1	; 0x01
    2ab6:	3a 81       	ldd	r19, Y+2	; 0x02
    2ab8:	2e 5f       	subi	r18, 0xFE	; 254
    2aba:	3f 4f       	sbci	r19, 0xFF	; 255
    2abc:	b9 01       	movw	r22, r18
    2abe:	0e 94 28 18 	call	0x3050	; 0x3050 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2ac2:	80 91 84 01 	lds	r24, 0x0184
    2ac6:	88 23       	and	r24, r24
    2ac8:	09 f0       	breq	.+2      	; 0x2acc <prvCheckPendingReadyList+0x8c>
    2aca:	c0 cf       	rjmp	.-128    	; 0x2a4c <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
	}
}
    2acc:	0f 90       	pop	r0
    2ace:	0f 90       	pop	r0
    2ad0:	df 91       	pop	r29
    2ad2:	cf 91       	pop	r28
    2ad4:	08 95       	ret

00002ad6 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    2ad6:	ef 92       	push	r14
    2ad8:	ff 92       	push	r15
    2ada:	0f 93       	push	r16
    2adc:	1f 93       	push	r17
    2ade:	cf 93       	push	r28
    2ae0:	df 93       	push	r29
    2ae2:	00 d0       	rcall	.+0      	; 0x2ae4 <prvCheckDelayedList+0xe>
    2ae4:	00 d0       	rcall	.+0      	; 0x2ae6 <prvCheckDelayedList+0x10>
    2ae6:	cd b7       	in	r28, 0x3d	; 61
    2ae8:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2aea:	0e 94 76 24 	call	0x48ec	; 0x48ec <xTaskGetTickCount>
    2aee:	9c 01       	movw	r18, r24
    2af0:	40 e0       	ldi	r20, 0x00	; 0
    2af2:	50 e0       	ldi	r21, 0x00	; 0
    2af4:	80 91 92 01 	lds	r24, 0x0192
    2af8:	90 91 93 01 	lds	r25, 0x0193
    2afc:	a0 91 94 01 	lds	r26, 0x0194
    2b00:	b0 91 95 01 	lds	r27, 0x0195
    2b04:	79 01       	movw	r14, r18
    2b06:	8a 01       	movw	r16, r20
    2b08:	e8 1a       	sub	r14, r24
    2b0a:	f9 0a       	sbc	r15, r25
    2b0c:	0a 0b       	sbc	r16, r26
    2b0e:	1b 0b       	sbc	r17, r27
    2b10:	d8 01       	movw	r26, r16
    2b12:	c7 01       	movw	r24, r14
    2b14:	80 93 96 01 	sts	0x0196, r24
    2b18:	90 93 97 01 	sts	0x0197, r25
    2b1c:	a0 93 98 01 	sts	0x0198, r26
    2b20:	b0 93 99 01 	sts	0x0199, r27
	while( xPassedTicks )
    2b24:	b0 c0       	rjmp	.+352    	; 0x2c86 <prvCheckDelayedList+0x1b0>
	{
		xCoRoutineTickCount++;
    2b26:	80 91 8e 01 	lds	r24, 0x018E
    2b2a:	90 91 8f 01 	lds	r25, 0x018F
    2b2e:	a0 91 90 01 	lds	r26, 0x0190
    2b32:	b0 91 91 01 	lds	r27, 0x0191
    2b36:	01 96       	adiw	r24, 0x01	; 1
    2b38:	a1 1d       	adc	r26, r1
    2b3a:	b1 1d       	adc	r27, r1
    2b3c:	80 93 8e 01 	sts	0x018E, r24
    2b40:	90 93 8f 01 	sts	0x018F, r25
    2b44:	a0 93 90 01 	sts	0x0190, r26
    2b48:	b0 93 91 01 	sts	0x0191, r27
		xPassedTicks--;
    2b4c:	80 91 96 01 	lds	r24, 0x0196
    2b50:	90 91 97 01 	lds	r25, 0x0197
    2b54:	a0 91 98 01 	lds	r26, 0x0198
    2b58:	b0 91 99 01 	lds	r27, 0x0199
    2b5c:	01 97       	sbiw	r24, 0x01	; 1
    2b5e:	a1 09       	sbc	r26, r1
    2b60:	b1 09       	sbc	r27, r1
    2b62:	80 93 96 01 	sts	0x0196, r24
    2b66:	90 93 97 01 	sts	0x0197, r25
    2b6a:	a0 93 98 01 	sts	0x0198, r26
    2b6e:	b0 93 99 01 	sts	0x0199, r27

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    2b72:	80 91 8e 01 	lds	r24, 0x018E
    2b76:	90 91 8f 01 	lds	r25, 0x018F
    2b7a:	a0 91 90 01 	lds	r26, 0x0190
    2b7e:	b0 91 91 01 	lds	r27, 0x0191
    2b82:	00 97       	sbiw	r24, 0x00	; 0
    2b84:	a1 05       	cpc	r26, r1
    2b86:	b1 05       	cpc	r27, r1
    2b88:	09 f0       	breq	.+2      	; 0x2b8c <prvCheckDelayedList+0xb6>
    2b8a:	71 c0       	rjmp	.+226    	; 0x2c6e <prvCheckDelayedList+0x198>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    2b8c:	80 91 80 01 	lds	r24, 0x0180
    2b90:	90 91 81 01 	lds	r25, 0x0181
    2b94:	9a 83       	std	Y+2, r25	; 0x02
    2b96:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    2b98:	80 91 82 01 	lds	r24, 0x0182
    2b9c:	90 91 83 01 	lds	r25, 0x0183
    2ba0:	90 93 81 01 	sts	0x0181, r25
    2ba4:	80 93 80 01 	sts	0x0180, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    2ba8:	89 81       	ldd	r24, Y+1	; 0x01
    2baa:	9a 81       	ldd	r25, Y+2	; 0x02
    2bac:	90 93 83 01 	sts	0x0183, r25
    2bb0:	80 93 82 01 	sts	0x0182, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2bb4:	5c c0       	rjmp	.+184    	; 0x2c6e <prvCheckDelayedList+0x198>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    2bb6:	80 91 80 01 	lds	r24, 0x0180
    2bba:	90 91 81 01 	lds	r25, 0x0181
    2bbe:	fc 01       	movw	r30, r24
    2bc0:	85 81       	ldd	r24, Z+5	; 0x05
    2bc2:	96 81       	ldd	r25, Z+6	; 0x06
    2bc4:	fc 01       	movw	r30, r24
    2bc6:	86 81       	ldd	r24, Z+6	; 0x06
    2bc8:	97 81       	ldd	r25, Z+7	; 0x07
    2bca:	9c 83       	std	Y+4, r25	; 0x04
    2bcc:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    2bce:	8b 81       	ldd	r24, Y+3	; 0x03
    2bd0:	9c 81       	ldd	r25, Y+4	; 0x04
    2bd2:	fc 01       	movw	r30, r24
    2bd4:	82 81       	ldd	r24, Z+2	; 0x02
    2bd6:	93 81       	ldd	r25, Z+3	; 0x03
    2bd8:	9c 01       	movw	r18, r24
    2bda:	40 e0       	ldi	r20, 0x00	; 0
    2bdc:	50 e0       	ldi	r21, 0x00	; 0
    2bde:	80 91 8e 01 	lds	r24, 0x018E
    2be2:	90 91 8f 01 	lds	r25, 0x018F
    2be6:	a0 91 90 01 	lds	r26, 0x0190
    2bea:	b0 91 91 01 	lds	r27, 0x0191
    2bee:	82 17       	cp	r24, r18
    2bf0:	93 07       	cpc	r25, r19
    2bf2:	a4 07       	cpc	r26, r20
    2bf4:	b5 07       	cpc	r27, r21
    2bf6:	08 f4       	brcc	.+2      	; 0x2bfa <prvCheckDelayedList+0x124>
    2bf8:	45 c0       	rjmp	.+138    	; 0x2c84 <prvCheckDelayedList+0x1ae>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    2bfa:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );
    2bfc:	8b 81       	ldd	r24, Y+3	; 0x03
    2bfe:	9c 81       	ldd	r25, Y+4	; 0x04
    2c00:	02 96       	adiw	r24, 0x02	; 2
    2c02:	0e 94 0b 19 	call	0x3216	; 0x3216 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    2c06:	8b 81       	ldd	r24, Y+3	; 0x03
    2c08:	9c 81       	ldd	r25, Y+4	; 0x04
    2c0a:	fc 01       	movw	r30, r24
    2c0c:	84 89       	ldd	r24, Z+20	; 0x14
    2c0e:	95 89       	ldd	r25, Z+21	; 0x15
    2c10:	00 97       	sbiw	r24, 0x00	; 0
    2c12:	29 f0       	breq	.+10     	; 0x2c1e <prvCheckDelayedList+0x148>
				{
					uxListRemove( &( pxCRCB->xEventListItem ) );
    2c14:	8b 81       	ldd	r24, Y+3	; 0x03
    2c16:	9c 81       	ldd	r25, Y+4	; 0x04
    2c18:	0c 96       	adiw	r24, 0x0c	; 12
    2c1a:	0e 94 0b 19 	call	0x3216	; 0x3216 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2c1e:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    2c20:	8b 81       	ldd	r24, Y+3	; 0x03
    2c22:	9c 81       	ldd	r25, Y+4	; 0x04
    2c24:	fc 01       	movw	r30, r24
    2c26:	96 89       	ldd	r25, Z+22	; 0x16
    2c28:	80 91 8d 01 	lds	r24, 0x018D
    2c2c:	89 17       	cp	r24, r25
    2c2e:	30 f4       	brcc	.+12     	; 0x2c3c <prvCheckDelayedList+0x166>
    2c30:	8b 81       	ldd	r24, Y+3	; 0x03
    2c32:	9c 81       	ldd	r25, Y+4	; 0x04
    2c34:	fc 01       	movw	r30, r24
    2c36:	86 89       	ldd	r24, Z+22	; 0x16
    2c38:	80 93 8d 01 	sts	0x018D, r24
    2c3c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c3e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c40:	fc 01       	movw	r30, r24
    2c42:	86 89       	ldd	r24, Z+22	; 0x16
    2c44:	28 2f       	mov	r18, r24
    2c46:	30 e0       	ldi	r19, 0x00	; 0
    2c48:	c9 01       	movw	r24, r18
    2c4a:	88 0f       	add	r24, r24
    2c4c:	99 1f       	adc	r25, r25
    2c4e:	88 0f       	add	r24, r24
    2c50:	99 1f       	adc	r25, r25
    2c52:	88 0f       	add	r24, r24
    2c54:	99 1f       	adc	r25, r25
    2c56:	82 0f       	add	r24, r18
    2c58:	93 1f       	adc	r25, r19
    2c5a:	84 5a       	subi	r24, 0xA4	; 164
    2c5c:	9e 4f       	sbci	r25, 0xFE	; 254
    2c5e:	2b 81       	ldd	r18, Y+3	; 0x03
    2c60:	3c 81       	ldd	r19, Y+4	; 0x04
    2c62:	2e 5f       	subi	r18, 0xFE	; 254
    2c64:	3f 4f       	sbci	r19, 0xFF	; 255
    2c66:	b9 01       	movw	r22, r18
    2c68:	0e 94 28 18 	call	0x3050	; 0x3050 <vListInsertEnd>
    2c6c:	01 c0       	rjmp	.+2      	; 0x2c70 <prvCheckDelayedList+0x19a>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2c6e:	00 00       	nop
    2c70:	80 91 80 01 	lds	r24, 0x0180
    2c74:	90 91 81 01 	lds	r25, 0x0181
    2c78:	fc 01       	movw	r30, r24
    2c7a:	80 81       	ld	r24, Z
    2c7c:	88 23       	and	r24, r24
    2c7e:	09 f0       	breq	.+2      	; 0x2c82 <prvCheckDelayedList+0x1ac>
    2c80:	9a cf       	rjmp	.-204    	; 0x2bb6 <prvCheckDelayedList+0xe0>
    2c82:	01 c0       	rjmp	.+2      	; 0x2c86 <prvCheckDelayedList+0x1b0>
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
			{
				/* Timeout not yet expired. */
				break;
    2c84:	00 00       	nop
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    2c86:	80 91 96 01 	lds	r24, 0x0196
    2c8a:	90 91 97 01 	lds	r25, 0x0197
    2c8e:	a0 91 98 01 	lds	r26, 0x0198
    2c92:	b0 91 99 01 	lds	r27, 0x0199
    2c96:	00 97       	sbiw	r24, 0x00	; 0
    2c98:	a1 05       	cpc	r26, r1
    2c9a:	b1 05       	cpc	r27, r1
    2c9c:	09 f0       	breq	.+2      	; 0x2ca0 <prvCheckDelayedList+0x1ca>
    2c9e:	43 cf       	rjmp	.-378    	; 0x2b26 <prvCheckDelayedList+0x50>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    2ca0:	80 91 8e 01 	lds	r24, 0x018E
    2ca4:	90 91 8f 01 	lds	r25, 0x018F
    2ca8:	a0 91 90 01 	lds	r26, 0x0190
    2cac:	b0 91 91 01 	lds	r27, 0x0191
    2cb0:	80 93 92 01 	sts	0x0192, r24
    2cb4:	90 93 93 01 	sts	0x0193, r25
    2cb8:	a0 93 94 01 	sts	0x0194, r26
    2cbc:	b0 93 95 01 	sts	0x0195, r27
}
    2cc0:	0f 90       	pop	r0
    2cc2:	0f 90       	pop	r0
    2cc4:	0f 90       	pop	r0
    2cc6:	0f 90       	pop	r0
    2cc8:	df 91       	pop	r29
    2cca:	cf 91       	pop	r28
    2ccc:	1f 91       	pop	r17
    2cce:	0f 91       	pop	r16
    2cd0:	ff 90       	pop	r15
    2cd2:	ef 90       	pop	r14
    2cd4:	08 95       	ret

00002cd6 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    2cd6:	cf 93       	push	r28
    2cd8:	df 93       	push	r29
    2cda:	00 d0       	rcall	.+0      	; 0x2cdc <vCoRoutineSchedule+0x6>
    2cdc:	cd b7       	in	r28, 0x3d	; 61
    2cde:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    2ce0:	0e 94 20 15 	call	0x2a40	; 0x2a40 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    2ce4:	0e 94 6b 15 	call	0x2ad6	; 0x2ad6 <prvCheckDelayedList>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2ce8:	0a c0       	rjmp	.+20     	; 0x2cfe <vCoRoutineSchedule+0x28>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    2cea:	80 91 8d 01 	lds	r24, 0x018D
    2cee:	88 23       	and	r24, r24
    2cf0:	09 f4       	brne	.+2      	; 0x2cf4 <vCoRoutineSchedule+0x1e>
    2cf2:	70 c0       	rjmp	.+224    	; 0x2dd4 <vCoRoutineSchedule+0xfe>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    2cf4:	80 91 8d 01 	lds	r24, 0x018D
    2cf8:	81 50       	subi	r24, 0x01	; 1
    2cfa:	80 93 8d 01 	sts	0x018D, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    2cfe:	80 91 8d 01 	lds	r24, 0x018D
    2d02:	28 2f       	mov	r18, r24
    2d04:	30 e0       	ldi	r19, 0x00	; 0
    2d06:	c9 01       	movw	r24, r18
    2d08:	88 0f       	add	r24, r24
    2d0a:	99 1f       	adc	r25, r25
    2d0c:	88 0f       	add	r24, r24
    2d0e:	99 1f       	adc	r25, r25
    2d10:	88 0f       	add	r24, r24
    2d12:	99 1f       	adc	r25, r25
    2d14:	82 0f       	add	r24, r18
    2d16:	93 1f       	adc	r25, r19
    2d18:	84 5a       	subi	r24, 0xA4	; 164
    2d1a:	9e 4f       	sbci	r25, 0xFE	; 254
    2d1c:	fc 01       	movw	r30, r24
    2d1e:	80 81       	ld	r24, Z
    2d20:	88 23       	and	r24, r24
    2d22:	19 f3       	breq	.-58     	; 0x2cea <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2d24:	80 91 8d 01 	lds	r24, 0x018D
    2d28:	28 2f       	mov	r18, r24
    2d2a:	30 e0       	ldi	r19, 0x00	; 0
    2d2c:	c9 01       	movw	r24, r18
    2d2e:	88 0f       	add	r24, r24
    2d30:	99 1f       	adc	r25, r25
    2d32:	88 0f       	add	r24, r24
    2d34:	99 1f       	adc	r25, r25
    2d36:	88 0f       	add	r24, r24
    2d38:	99 1f       	adc	r25, r25
    2d3a:	82 0f       	add	r24, r18
    2d3c:	93 1f       	adc	r25, r19
    2d3e:	84 5a       	subi	r24, 0xA4	; 164
    2d40:	9e 4f       	sbci	r25, 0xFE	; 254
    2d42:	9a 83       	std	Y+2, r25	; 0x02
    2d44:	89 83       	std	Y+1, r24	; 0x01
    2d46:	89 81       	ldd	r24, Y+1	; 0x01
    2d48:	9a 81       	ldd	r25, Y+2	; 0x02
    2d4a:	fc 01       	movw	r30, r24
    2d4c:	81 81       	ldd	r24, Z+1	; 0x01
    2d4e:	92 81       	ldd	r25, Z+2	; 0x02
    2d50:	fc 01       	movw	r30, r24
    2d52:	22 81       	ldd	r18, Z+2	; 0x02
    2d54:	33 81       	ldd	r19, Z+3	; 0x03
    2d56:	89 81       	ldd	r24, Y+1	; 0x01
    2d58:	9a 81       	ldd	r25, Y+2	; 0x02
    2d5a:	fc 01       	movw	r30, r24
    2d5c:	32 83       	std	Z+2, r19	; 0x02
    2d5e:	21 83       	std	Z+1, r18	; 0x01
    2d60:	89 81       	ldd	r24, Y+1	; 0x01
    2d62:	9a 81       	ldd	r25, Y+2	; 0x02
    2d64:	fc 01       	movw	r30, r24
    2d66:	21 81       	ldd	r18, Z+1	; 0x01
    2d68:	32 81       	ldd	r19, Z+2	; 0x02
    2d6a:	89 81       	ldd	r24, Y+1	; 0x01
    2d6c:	9a 81       	ldd	r25, Y+2	; 0x02
    2d6e:	03 96       	adiw	r24, 0x03	; 3
    2d70:	28 17       	cp	r18, r24
    2d72:	39 07       	cpc	r19, r25
    2d74:	69 f4       	brne	.+26     	; 0x2d90 <vCoRoutineSchedule+0xba>
    2d76:	89 81       	ldd	r24, Y+1	; 0x01
    2d78:	9a 81       	ldd	r25, Y+2	; 0x02
    2d7a:	fc 01       	movw	r30, r24
    2d7c:	81 81       	ldd	r24, Z+1	; 0x01
    2d7e:	92 81       	ldd	r25, Z+2	; 0x02
    2d80:	fc 01       	movw	r30, r24
    2d82:	22 81       	ldd	r18, Z+2	; 0x02
    2d84:	33 81       	ldd	r19, Z+3	; 0x03
    2d86:	89 81       	ldd	r24, Y+1	; 0x01
    2d88:	9a 81       	ldd	r25, Y+2	; 0x02
    2d8a:	fc 01       	movw	r30, r24
    2d8c:	32 83       	std	Z+2, r19	; 0x02
    2d8e:	21 83       	std	Z+1, r18	; 0x01
    2d90:	89 81       	ldd	r24, Y+1	; 0x01
    2d92:	9a 81       	ldd	r25, Y+2	; 0x02
    2d94:	fc 01       	movw	r30, r24
    2d96:	81 81       	ldd	r24, Z+1	; 0x01
    2d98:	92 81       	ldd	r25, Z+2	; 0x02
    2d9a:	fc 01       	movw	r30, r24
    2d9c:	86 81       	ldd	r24, Z+6	; 0x06
    2d9e:	97 81       	ldd	r25, Z+7	; 0x07
    2da0:	90 93 5b 01 	sts	0x015B, r25
    2da4:	80 93 5a 01 	sts	0x015A, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2da8:	80 91 5a 01 	lds	r24, 0x015A
    2dac:	90 91 5b 01 	lds	r25, 0x015B
    2db0:	fc 01       	movw	r30, r24
    2db2:	20 81       	ld	r18, Z
    2db4:	31 81       	ldd	r19, Z+1	; 0x01
    2db6:	80 91 5a 01 	lds	r24, 0x015A
    2dba:	90 91 5b 01 	lds	r25, 0x015B
    2dbe:	40 91 5a 01 	lds	r20, 0x015A
    2dc2:	50 91 5b 01 	lds	r21, 0x015B
    2dc6:	fa 01       	movw	r30, r20
    2dc8:	47 89       	ldd	r20, Z+23	; 0x17
    2dca:	64 2f       	mov	r22, r20
    2dcc:	f9 01       	movw	r30, r18
    2dce:	09 95       	icall

	return;
    2dd0:	00 00       	nop
    2dd2:	01 c0       	rjmp	.+2      	; 0x2dd6 <vCoRoutineSchedule+0x100>
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
		{
			/* No more co-routines to check. */
			return;
    2dd4:	00 00       	nop

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );

	return;
}
    2dd6:	0f 90       	pop	r0
    2dd8:	0f 90       	pop	r0
    2dda:	df 91       	pop	r29
    2ddc:	cf 91       	pop	r28
    2dde:	08 95       	ret

00002de0 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2de0:	cf 93       	push	r28
    2de2:	df 93       	push	r29
    2de4:	0f 92       	push	r0
    2de6:	cd b7       	in	r28, 0x3d	; 61
    2de8:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2dea:	19 82       	std	Y+1, r1	; 0x01
    2dec:	13 c0       	rjmp	.+38     	; 0x2e14 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2dee:	89 81       	ldd	r24, Y+1	; 0x01
    2df0:	28 2f       	mov	r18, r24
    2df2:	30 e0       	ldi	r19, 0x00	; 0
    2df4:	c9 01       	movw	r24, r18
    2df6:	88 0f       	add	r24, r24
    2df8:	99 1f       	adc	r25, r25
    2dfa:	88 0f       	add	r24, r24
    2dfc:	99 1f       	adc	r25, r25
    2dfe:	88 0f       	add	r24, r24
    2e00:	99 1f       	adc	r25, r25
    2e02:	82 0f       	add	r24, r18
    2e04:	93 1f       	adc	r25, r19
    2e06:	84 5a       	subi	r24, 0xA4	; 164
    2e08:	9e 4f       	sbci	r25, 0xFE	; 254
    2e0a:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2e0e:	89 81       	ldd	r24, Y+1	; 0x01
    2e10:	8f 5f       	subi	r24, 0xFF	; 255
    2e12:	89 83       	std	Y+1, r24	; 0x01
    2e14:	89 81       	ldd	r24, Y+1	; 0x01
    2e16:	82 30       	cpi	r24, 0x02	; 2
    2e18:	50 f3       	brcs	.-44     	; 0x2dee <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2e1a:	8e e6       	ldi	r24, 0x6E	; 110
    2e1c:	91 e0       	ldi	r25, 0x01	; 1
    2e1e:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2e22:	87 e7       	ldi	r24, 0x77	; 119
    2e24:	91 e0       	ldi	r25, 0x01	; 1
    2e26:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2e2a:	84 e8       	ldi	r24, 0x84	; 132
    2e2c:	91 e0       	ldi	r25, 0x01	; 1
    2e2e:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2e32:	8e e6       	ldi	r24, 0x6E	; 110
    2e34:	91 e0       	ldi	r25, 0x01	; 1
    2e36:	90 93 81 01 	sts	0x0181, r25
    2e3a:	80 93 80 01 	sts	0x0180, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2e3e:	87 e7       	ldi	r24, 0x77	; 119
    2e40:	91 e0       	ldi	r25, 0x01	; 1
    2e42:	90 93 83 01 	sts	0x0183, r25
    2e46:	80 93 82 01 	sts	0x0182, r24
}
    2e4a:	0f 90       	pop	r0
    2e4c:	df 91       	pop	r29
    2e4e:	cf 91       	pop	r28
    2e50:	08 95       	ret

00002e52 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2e52:	cf 93       	push	r28
    2e54:	df 93       	push	r29
    2e56:	00 d0       	rcall	.+0      	; 0x2e58 <xCoRoutineRemoveFromEventList+0x6>
    2e58:	00 d0       	rcall	.+0      	; 0x2e5a <xCoRoutineRemoveFromEventList+0x8>
    2e5a:	0f 92       	push	r0
    2e5c:	cd b7       	in	r28, 0x3d	; 61
    2e5e:	de b7       	in	r29, 0x3e	; 62
    2e60:	9d 83       	std	Y+5, r25	; 0x05
    2e62:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2e64:	8c 81       	ldd	r24, Y+4	; 0x04
    2e66:	9d 81       	ldd	r25, Y+5	; 0x05
    2e68:	fc 01       	movw	r30, r24
    2e6a:	85 81       	ldd	r24, Z+5	; 0x05
    2e6c:	96 81       	ldd	r25, Z+6	; 0x06
    2e6e:	fc 01       	movw	r30, r24
    2e70:	86 81       	ldd	r24, Z+6	; 0x06
    2e72:	97 81       	ldd	r25, Z+7	; 0x07
    2e74:	9b 83       	std	Y+3, r25	; 0x03
    2e76:	8a 83       	std	Y+2, r24	; 0x02
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2e78:	8a 81       	ldd	r24, Y+2	; 0x02
    2e7a:	9b 81       	ldd	r25, Y+3	; 0x03
    2e7c:	0c 96       	adiw	r24, 0x0c	; 12
    2e7e:	0e 94 0b 19 	call	0x3216	; 0x3216 <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2e82:	8a 81       	ldd	r24, Y+2	; 0x02
    2e84:	9b 81       	ldd	r25, Y+3	; 0x03
    2e86:	9c 01       	movw	r18, r24
    2e88:	24 5f       	subi	r18, 0xF4	; 244
    2e8a:	3f 4f       	sbci	r19, 0xFF	; 255
    2e8c:	84 e8       	ldi	r24, 0x84	; 132
    2e8e:	91 e0       	ldi	r25, 0x01	; 1
    2e90:	b9 01       	movw	r22, r18
    2e92:	0e 94 28 18 	call	0x3050	; 0x3050 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2e96:	8a 81       	ldd	r24, Y+2	; 0x02
    2e98:	9b 81       	ldd	r25, Y+3	; 0x03
    2e9a:	fc 01       	movw	r30, r24
    2e9c:	26 89       	ldd	r18, Z+22	; 0x16
    2e9e:	80 91 5a 01 	lds	r24, 0x015A
    2ea2:	90 91 5b 01 	lds	r25, 0x015B
    2ea6:	fc 01       	movw	r30, r24
    2ea8:	86 89       	ldd	r24, Z+22	; 0x16
    2eaa:	28 17       	cp	r18, r24
    2eac:	18 f0       	brcs	.+6      	; 0x2eb4 <xCoRoutineRemoveFromEventList+0x62>
	{
		xReturn = pdTRUE;
    2eae:	81 e0       	ldi	r24, 0x01	; 1
    2eb0:	89 83       	std	Y+1, r24	; 0x01
    2eb2:	01 c0       	rjmp	.+2      	; 0x2eb6 <xCoRoutineRemoveFromEventList+0x64>
	}
	else
	{
		xReturn = pdFALSE;
    2eb4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2eb6:	89 81       	ldd	r24, Y+1	; 0x01
}
    2eb8:	0f 90       	pop	r0
    2eba:	0f 90       	pop	r0
    2ebc:	0f 90       	pop	r0
    2ebe:	0f 90       	pop	r0
    2ec0:	0f 90       	pop	r0
    2ec2:	df 91       	pop	r29
    2ec4:	cf 91       	pop	r28
    2ec6:	08 95       	ret

00002ec8 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2ec8:	cf 93       	push	r28
    2eca:	df 93       	push	r29
    2ecc:	00 d0       	rcall	.+0      	; 0x2ece <pvPortMalloc+0x6>
    2ece:	00 d0       	rcall	.+0      	; 0x2ed0 <pvPortMalloc+0x8>
    2ed0:	cd b7       	in	r28, 0x3d	; 61
    2ed2:	de b7       	in	r29, 0x3e	; 62
    2ed4:	9c 83       	std	Y+4, r25	; 0x04
    2ed6:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    2ed8:	1a 82       	std	Y+2, r1	; 0x02
    2eda:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2edc:	0e 94 e7 23 	call	0x47ce	; 0x47ce <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    2ee0:	80 91 54 0d 	lds	r24, 0x0D54
    2ee4:	90 91 55 0d 	lds	r25, 0x0D55
    2ee8:	00 97       	sbiw	r24, 0x00	; 0
    2eea:	31 f4       	brne	.+12     	; 0x2ef8 <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    2eec:	8b e9       	ldi	r24, 0x9B	; 155
    2eee:	91 e0       	ldi	r25, 0x01	; 1
    2ef0:	90 93 55 0d 	sts	0x0D55, r25
    2ef4:	80 93 54 0d 	sts	0x0D54, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2ef8:	20 91 52 0d 	lds	r18, 0x0D52
    2efc:	30 91 53 0d 	lds	r19, 0x0D53
    2f00:	8b 81       	ldd	r24, Y+3	; 0x03
    2f02:	9c 81       	ldd	r25, Y+4	; 0x04
    2f04:	82 0f       	add	r24, r18
    2f06:	93 1f       	adc	r25, r19
    2f08:	2b e0       	ldi	r18, 0x0B	; 11
    2f0a:	87 3b       	cpi	r24, 0xB7	; 183
    2f0c:	92 07       	cpc	r25, r18
    2f0e:	38 f5       	brcc	.+78     	; 0x2f5e <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
    2f10:	20 91 52 0d 	lds	r18, 0x0D52
    2f14:	30 91 53 0d 	lds	r19, 0x0D53
    2f18:	8b 81       	ldd	r24, Y+3	; 0x03
    2f1a:	9c 81       	ldd	r25, Y+4	; 0x04
    2f1c:	28 0f       	add	r18, r24
    2f1e:	39 1f       	adc	r19, r25
    2f20:	80 91 52 0d 	lds	r24, 0x0D52
    2f24:	90 91 53 0d 	lds	r25, 0x0D53
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    2f28:	82 17       	cp	r24, r18
    2f2a:	93 07       	cpc	r25, r19
    2f2c:	c0 f4       	brcc	.+48     	; 0x2f5e <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    2f2e:	20 91 54 0d 	lds	r18, 0x0D54
    2f32:	30 91 55 0d 	lds	r19, 0x0D55
    2f36:	80 91 52 0d 	lds	r24, 0x0D52
    2f3a:	90 91 53 0d 	lds	r25, 0x0D53
    2f3e:	82 0f       	add	r24, r18
    2f40:	93 1f       	adc	r25, r19
    2f42:	9a 83       	std	Y+2, r25	; 0x02
    2f44:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    2f46:	20 91 52 0d 	lds	r18, 0x0D52
    2f4a:	30 91 53 0d 	lds	r19, 0x0D53
    2f4e:	8b 81       	ldd	r24, Y+3	; 0x03
    2f50:	9c 81       	ldd	r25, Y+4	; 0x04
    2f52:	82 0f       	add	r24, r18
    2f54:	93 1f       	adc	r25, r19
    2f56:	90 93 53 0d 	sts	0x0D53, r25
    2f5a:	80 93 52 0d 	sts	0x0D52, r24
		}
	}
	xTaskResumeAll();
    2f5e:	0e 94 f3 23 	call	0x47e6	; 0x47e6 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    2f62:	89 81       	ldd	r24, Y+1	; 0x01
    2f64:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2f66:	0f 90       	pop	r0
    2f68:	0f 90       	pop	r0
    2f6a:	0f 90       	pop	r0
    2f6c:	0f 90       	pop	r0
    2f6e:	df 91       	pop	r29
    2f70:	cf 91       	pop	r28
    2f72:	08 95       	ret

00002f74 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2f74:	cf 93       	push	r28
    2f76:	df 93       	push	r29
    2f78:	00 d0       	rcall	.+0      	; 0x2f7a <vPortFree+0x6>
    2f7a:	cd b7       	in	r28, 0x3d	; 61
    2f7c:	de b7       	in	r29, 0x3e	; 62
    2f7e:	9a 83       	std	Y+2, r25	; 0x02
    2f80:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    2f82:	0f 90       	pop	r0
    2f84:	0f 90       	pop	r0
    2f86:	df 91       	pop	r29
    2f88:	cf 91       	pop	r28
    2f8a:	08 95       	ret

00002f8c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2f8c:	cf 93       	push	r28
    2f8e:	df 93       	push	r29
    2f90:	cd b7       	in	r28, 0x3d	; 61
    2f92:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2f94:	10 92 53 0d 	sts	0x0D53, r1
    2f98:	10 92 52 0d 	sts	0x0D52, r1
}
    2f9c:	df 91       	pop	r29
    2f9e:	cf 91       	pop	r28
    2fa0:	08 95       	ret

00002fa2 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2fa2:	cf 93       	push	r28
    2fa4:	df 93       	push	r29
    2fa6:	cd b7       	in	r28, 0x3d	; 61
    2fa8:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    2faa:	80 91 52 0d 	lds	r24, 0x0D52
    2fae:	90 91 53 0d 	lds	r25, 0x0D53
    2fb2:	27 eb       	ldi	r18, 0xB7	; 183
    2fb4:	3b e0       	ldi	r19, 0x0B	; 11
    2fb6:	a9 01       	movw	r20, r18
    2fb8:	48 1b       	sub	r20, r24
    2fba:	59 0b       	sbc	r21, r25
    2fbc:	ca 01       	movw	r24, r20
}
    2fbe:	df 91       	pop	r29
    2fc0:	cf 91       	pop	r28
    2fc2:	08 95       	ret

00002fc4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2fc4:	cf 93       	push	r28
    2fc6:	df 93       	push	r29
    2fc8:	00 d0       	rcall	.+0      	; 0x2fca <vListInitialise+0x6>
    2fca:	cd b7       	in	r28, 0x3d	; 61
    2fcc:	de b7       	in	r29, 0x3e	; 62
    2fce:	9a 83       	std	Y+2, r25	; 0x02
    2fd0:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2fd2:	89 81       	ldd	r24, Y+1	; 0x01
    2fd4:	9a 81       	ldd	r25, Y+2	; 0x02
    2fd6:	9c 01       	movw	r18, r24
    2fd8:	2d 5f       	subi	r18, 0xFD	; 253
    2fda:	3f 4f       	sbci	r19, 0xFF	; 255
    2fdc:	89 81       	ldd	r24, Y+1	; 0x01
    2fde:	9a 81       	ldd	r25, Y+2	; 0x02
    2fe0:	fc 01       	movw	r30, r24
    2fe2:	32 83       	std	Z+2, r19	; 0x02
    2fe4:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2fe6:	89 81       	ldd	r24, Y+1	; 0x01
    2fe8:	9a 81       	ldd	r25, Y+2	; 0x02
    2fea:	2f ef       	ldi	r18, 0xFF	; 255
    2fec:	3f ef       	ldi	r19, 0xFF	; 255
    2fee:	fc 01       	movw	r30, r24
    2ff0:	34 83       	std	Z+4, r19	; 0x04
    2ff2:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2ff4:	89 81       	ldd	r24, Y+1	; 0x01
    2ff6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ff8:	9c 01       	movw	r18, r24
    2ffa:	2d 5f       	subi	r18, 0xFD	; 253
    2ffc:	3f 4f       	sbci	r19, 0xFF	; 255
    2ffe:	89 81       	ldd	r24, Y+1	; 0x01
    3000:	9a 81       	ldd	r25, Y+2	; 0x02
    3002:	fc 01       	movw	r30, r24
    3004:	36 83       	std	Z+6, r19	; 0x06
    3006:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    3008:	89 81       	ldd	r24, Y+1	; 0x01
    300a:	9a 81       	ldd	r25, Y+2	; 0x02
    300c:	9c 01       	movw	r18, r24
    300e:	2d 5f       	subi	r18, 0xFD	; 253
    3010:	3f 4f       	sbci	r19, 0xFF	; 255
    3012:	89 81       	ldd	r24, Y+1	; 0x01
    3014:	9a 81       	ldd	r25, Y+2	; 0x02
    3016:	fc 01       	movw	r30, r24
    3018:	30 87       	std	Z+8, r19	; 0x08
    301a:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    301c:	89 81       	ldd	r24, Y+1	; 0x01
    301e:	9a 81       	ldd	r25, Y+2	; 0x02
    3020:	fc 01       	movw	r30, r24
    3022:	10 82       	st	Z, r1
}
    3024:	0f 90       	pop	r0
    3026:	0f 90       	pop	r0
    3028:	df 91       	pop	r29
    302a:	cf 91       	pop	r28
    302c:	08 95       	ret

0000302e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    302e:	cf 93       	push	r28
    3030:	df 93       	push	r29
    3032:	00 d0       	rcall	.+0      	; 0x3034 <vListInitialiseItem+0x6>
    3034:	cd b7       	in	r28, 0x3d	; 61
    3036:	de b7       	in	r29, 0x3e	; 62
    3038:	9a 83       	std	Y+2, r25	; 0x02
    303a:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    303c:	89 81       	ldd	r24, Y+1	; 0x01
    303e:	9a 81       	ldd	r25, Y+2	; 0x02
    3040:	fc 01       	movw	r30, r24
    3042:	11 86       	std	Z+9, r1	; 0x09
    3044:	10 86       	std	Z+8, r1	; 0x08
}
    3046:	0f 90       	pop	r0
    3048:	0f 90       	pop	r0
    304a:	df 91       	pop	r29
    304c:	cf 91       	pop	r28
    304e:	08 95       	ret

00003050 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    3050:	cf 93       	push	r28
    3052:	df 93       	push	r29
    3054:	00 d0       	rcall	.+0      	; 0x3056 <vListInsertEnd+0x6>
    3056:	00 d0       	rcall	.+0      	; 0x3058 <vListInsertEnd+0x8>
    3058:	00 d0       	rcall	.+0      	; 0x305a <vListInsertEnd+0xa>
    305a:	cd b7       	in	r28, 0x3d	; 61
    305c:	de b7       	in	r29, 0x3e	; 62
    305e:	9c 83       	std	Y+4, r25	; 0x04
    3060:	8b 83       	std	Y+3, r24	; 0x03
    3062:	7e 83       	std	Y+6, r23	; 0x06
    3064:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    3066:	8b 81       	ldd	r24, Y+3	; 0x03
    3068:	9c 81       	ldd	r25, Y+4	; 0x04
    306a:	fc 01       	movw	r30, r24
    306c:	81 81       	ldd	r24, Z+1	; 0x01
    306e:	92 81       	ldd	r25, Z+2	; 0x02
    3070:	9a 83       	std	Y+2, r25	; 0x02
    3072:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    3074:	89 81       	ldd	r24, Y+1	; 0x01
    3076:	9a 81       	ldd	r25, Y+2	; 0x02
    3078:	fc 01       	movw	r30, r24
    307a:	22 81       	ldd	r18, Z+2	; 0x02
    307c:	33 81       	ldd	r19, Z+3	; 0x03
    307e:	8d 81       	ldd	r24, Y+5	; 0x05
    3080:	9e 81       	ldd	r25, Y+6	; 0x06
    3082:	fc 01       	movw	r30, r24
    3084:	33 83       	std	Z+3, r19	; 0x03
    3086:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    3088:	8b 81       	ldd	r24, Y+3	; 0x03
    308a:	9c 81       	ldd	r25, Y+4	; 0x04
    308c:	fc 01       	movw	r30, r24
    308e:	21 81       	ldd	r18, Z+1	; 0x01
    3090:	32 81       	ldd	r19, Z+2	; 0x02
    3092:	8d 81       	ldd	r24, Y+5	; 0x05
    3094:	9e 81       	ldd	r25, Y+6	; 0x06
    3096:	fc 01       	movw	r30, r24
    3098:	35 83       	std	Z+5, r19	; 0x05
    309a:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    309c:	89 81       	ldd	r24, Y+1	; 0x01
    309e:	9a 81       	ldd	r25, Y+2	; 0x02
    30a0:	fc 01       	movw	r30, r24
    30a2:	82 81       	ldd	r24, Z+2	; 0x02
    30a4:	93 81       	ldd	r25, Z+3	; 0x03
    30a6:	2d 81       	ldd	r18, Y+5	; 0x05
    30a8:	3e 81       	ldd	r19, Y+6	; 0x06
    30aa:	fc 01       	movw	r30, r24
    30ac:	35 83       	std	Z+5, r19	; 0x05
    30ae:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    30b0:	89 81       	ldd	r24, Y+1	; 0x01
    30b2:	9a 81       	ldd	r25, Y+2	; 0x02
    30b4:	2d 81       	ldd	r18, Y+5	; 0x05
    30b6:	3e 81       	ldd	r19, Y+6	; 0x06
    30b8:	fc 01       	movw	r30, r24
    30ba:	33 83       	std	Z+3, r19	; 0x03
    30bc:	22 83       	std	Z+2, r18	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    30be:	8b 81       	ldd	r24, Y+3	; 0x03
    30c0:	9c 81       	ldd	r25, Y+4	; 0x04
    30c2:	2d 81       	ldd	r18, Y+5	; 0x05
    30c4:	3e 81       	ldd	r19, Y+6	; 0x06
    30c6:	fc 01       	movw	r30, r24
    30c8:	32 83       	std	Z+2, r19	; 0x02
    30ca:	21 83       	std	Z+1, r18	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    30cc:	8d 81       	ldd	r24, Y+5	; 0x05
    30ce:	9e 81       	ldd	r25, Y+6	; 0x06
    30d0:	2b 81       	ldd	r18, Y+3	; 0x03
    30d2:	3c 81       	ldd	r19, Y+4	; 0x04
    30d4:	fc 01       	movw	r30, r24
    30d6:	31 87       	std	Z+9, r19	; 0x09
    30d8:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    30da:	8b 81       	ldd	r24, Y+3	; 0x03
    30dc:	9c 81       	ldd	r25, Y+4	; 0x04
    30de:	fc 01       	movw	r30, r24
    30e0:	80 81       	ld	r24, Z
    30e2:	28 2f       	mov	r18, r24
    30e4:	2f 5f       	subi	r18, 0xFF	; 255
    30e6:	8b 81       	ldd	r24, Y+3	; 0x03
    30e8:	9c 81       	ldd	r25, Y+4	; 0x04
    30ea:	fc 01       	movw	r30, r24
    30ec:	20 83       	st	Z, r18
}
    30ee:	26 96       	adiw	r28, 0x06	; 6
    30f0:	0f b6       	in	r0, 0x3f	; 63
    30f2:	f8 94       	cli
    30f4:	de bf       	out	0x3e, r29	; 62
    30f6:	0f be       	out	0x3f, r0	; 63
    30f8:	cd bf       	out	0x3d, r28	; 61
    30fa:	df 91       	pop	r29
    30fc:	cf 91       	pop	r28
    30fe:	08 95       	ret

00003100 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    3100:	cf 93       	push	r28
    3102:	df 93       	push	r29
    3104:	cd b7       	in	r28, 0x3d	; 61
    3106:	de b7       	in	r29, 0x3e	; 62
    3108:	2a 97       	sbiw	r28, 0x0a	; 10
    310a:	0f b6       	in	r0, 0x3f	; 63
    310c:	f8 94       	cli
    310e:	de bf       	out	0x3e, r29	; 62
    3110:	0f be       	out	0x3f, r0	; 63
    3112:	cd bf       	out	0x3d, r28	; 61
    3114:	98 87       	std	Y+8, r25	; 0x08
    3116:	8f 83       	std	Y+7, r24	; 0x07
    3118:	7a 87       	std	Y+10, r23	; 0x0a
    311a:	69 87       	std	Y+9, r22	; 0x09
volatile xListItem *pxIterator;
uint32_t xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    311c:	89 85       	ldd	r24, Y+9	; 0x09
    311e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3120:	fc 01       	movw	r30, r24
    3122:	80 81       	ld	r24, Z
    3124:	91 81       	ldd	r25, Z+1	; 0x01
    3126:	cc 01       	movw	r24, r24
    3128:	a0 e0       	ldi	r26, 0x00	; 0
    312a:	b0 e0       	ldi	r27, 0x00	; 0
    312c:	8b 83       	std	Y+3, r24	; 0x03
    312e:	9c 83       	std	Y+4, r25	; 0x04
    3130:	ad 83       	std	Y+5, r26	; 0x05
    3132:	be 83       	std	Y+6, r27	; 0x06
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    3134:	8b 81       	ldd	r24, Y+3	; 0x03
    3136:	9c 81       	ldd	r25, Y+4	; 0x04
    3138:	ad 81       	ldd	r26, Y+5	; 0x05
    313a:	be 81       	ldd	r27, Y+6	; 0x06
    313c:	8f 3f       	cpi	r24, 0xFF	; 255
    313e:	ff ef       	ldi	r31, 0xFF	; 255
    3140:	9f 07       	cpc	r25, r31
    3142:	f0 e0       	ldi	r31, 0x00	; 0
    3144:	af 07       	cpc	r26, r31
    3146:	f0 e0       	ldi	r31, 0x00	; 0
    3148:	bf 07       	cpc	r27, r31
    314a:	41 f4       	brne	.+16     	; 0x315c <vListInsert+0x5c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    314c:	8f 81       	ldd	r24, Y+7	; 0x07
    314e:	98 85       	ldd	r25, Y+8	; 0x08
    3150:	fc 01       	movw	r30, r24
    3152:	87 81       	ldd	r24, Z+7	; 0x07
    3154:	90 85       	ldd	r25, Z+8	; 0x08
    3156:	9a 83       	std	Y+2, r25	; 0x02
    3158:	89 83       	std	Y+1, r24	; 0x01
    315a:	21 c0       	rjmp	.+66     	; 0x319e <vListInsert+0x9e>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    315c:	8f 81       	ldd	r24, Y+7	; 0x07
    315e:	98 85       	ldd	r25, Y+8	; 0x08
    3160:	03 96       	adiw	r24, 0x03	; 3
    3162:	9a 83       	std	Y+2, r25	; 0x02
    3164:	89 83       	std	Y+1, r24	; 0x01
    3166:	07 c0       	rjmp	.+14     	; 0x3176 <vListInsert+0x76>
    3168:	89 81       	ldd	r24, Y+1	; 0x01
    316a:	9a 81       	ldd	r25, Y+2	; 0x02
    316c:	fc 01       	movw	r30, r24
    316e:	82 81       	ldd	r24, Z+2	; 0x02
    3170:	93 81       	ldd	r25, Z+3	; 0x03
    3172:	9a 83       	std	Y+2, r25	; 0x02
    3174:	89 83       	std	Y+1, r24	; 0x01
    3176:	89 81       	ldd	r24, Y+1	; 0x01
    3178:	9a 81       	ldd	r25, Y+2	; 0x02
    317a:	fc 01       	movw	r30, r24
    317c:	82 81       	ldd	r24, Z+2	; 0x02
    317e:	93 81       	ldd	r25, Z+3	; 0x03
    3180:	fc 01       	movw	r30, r24
    3182:	80 81       	ld	r24, Z
    3184:	91 81       	ldd	r25, Z+1	; 0x01
    3186:	9c 01       	movw	r18, r24
    3188:	40 e0       	ldi	r20, 0x00	; 0
    318a:	50 e0       	ldi	r21, 0x00	; 0
    318c:	8b 81       	ldd	r24, Y+3	; 0x03
    318e:	9c 81       	ldd	r25, Y+4	; 0x04
    3190:	ad 81       	ldd	r26, Y+5	; 0x05
    3192:	be 81       	ldd	r27, Y+6	; 0x06
    3194:	82 17       	cp	r24, r18
    3196:	93 07       	cpc	r25, r19
    3198:	a4 07       	cpc	r26, r20
    319a:	b5 07       	cpc	r27, r21
    319c:	28 f7       	brcc	.-54     	; 0x3168 <vListInsert+0x68>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    319e:	89 81       	ldd	r24, Y+1	; 0x01
    31a0:	9a 81       	ldd	r25, Y+2	; 0x02
    31a2:	fc 01       	movw	r30, r24
    31a4:	22 81       	ldd	r18, Z+2	; 0x02
    31a6:	33 81       	ldd	r19, Z+3	; 0x03
    31a8:	89 85       	ldd	r24, Y+9	; 0x09
    31aa:	9a 85       	ldd	r25, Y+10	; 0x0a
    31ac:	fc 01       	movw	r30, r24
    31ae:	33 83       	std	Z+3, r19	; 0x03
    31b0:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    31b2:	89 85       	ldd	r24, Y+9	; 0x09
    31b4:	9a 85       	ldd	r25, Y+10	; 0x0a
    31b6:	fc 01       	movw	r30, r24
    31b8:	82 81       	ldd	r24, Z+2	; 0x02
    31ba:	93 81       	ldd	r25, Z+3	; 0x03
    31bc:	29 85       	ldd	r18, Y+9	; 0x09
    31be:	3a 85       	ldd	r19, Y+10	; 0x0a
    31c0:	fc 01       	movw	r30, r24
    31c2:	35 83       	std	Z+5, r19	; 0x05
    31c4:	24 83       	std	Z+4, r18	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    31c6:	89 85       	ldd	r24, Y+9	; 0x09
    31c8:	9a 85       	ldd	r25, Y+10	; 0x0a
    31ca:	29 81       	ldd	r18, Y+1	; 0x01
    31cc:	3a 81       	ldd	r19, Y+2	; 0x02
    31ce:	fc 01       	movw	r30, r24
    31d0:	35 83       	std	Z+5, r19	; 0x05
    31d2:	24 83       	std	Z+4, r18	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    31d4:	89 81       	ldd	r24, Y+1	; 0x01
    31d6:	9a 81       	ldd	r25, Y+2	; 0x02
    31d8:	29 85       	ldd	r18, Y+9	; 0x09
    31da:	3a 85       	ldd	r19, Y+10	; 0x0a
    31dc:	fc 01       	movw	r30, r24
    31de:	33 83       	std	Z+3, r19	; 0x03
    31e0:	22 83       	std	Z+2, r18	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    31e2:	89 85       	ldd	r24, Y+9	; 0x09
    31e4:	9a 85       	ldd	r25, Y+10	; 0x0a
    31e6:	2f 81       	ldd	r18, Y+7	; 0x07
    31e8:	38 85       	ldd	r19, Y+8	; 0x08
    31ea:	fc 01       	movw	r30, r24
    31ec:	31 87       	std	Z+9, r19	; 0x09
    31ee:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    31f0:	8f 81       	ldd	r24, Y+7	; 0x07
    31f2:	98 85       	ldd	r25, Y+8	; 0x08
    31f4:	fc 01       	movw	r30, r24
    31f6:	80 81       	ld	r24, Z
    31f8:	28 2f       	mov	r18, r24
    31fa:	2f 5f       	subi	r18, 0xFF	; 255
    31fc:	8f 81       	ldd	r24, Y+7	; 0x07
    31fe:	98 85       	ldd	r25, Y+8	; 0x08
    3200:	fc 01       	movw	r30, r24
    3202:	20 83       	st	Z, r18
}
    3204:	2a 96       	adiw	r28, 0x0a	; 10
    3206:	0f b6       	in	r0, 0x3f	; 63
    3208:	f8 94       	cli
    320a:	de bf       	out	0x3e, r29	; 62
    320c:	0f be       	out	0x3f, r0	; 63
    320e:	cd bf       	out	0x3d, r28	; 61
    3210:	df 91       	pop	r29
    3212:	cf 91       	pop	r28
    3214:	08 95       	ret

00003216 <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
    3216:	cf 93       	push	r28
    3218:	df 93       	push	r29
    321a:	00 d0       	rcall	.+0      	; 0x321c <uxListRemove+0x6>
    321c:	00 d0       	rcall	.+0      	; 0x321e <uxListRemove+0x8>
    321e:	cd b7       	in	r28, 0x3d	; 61
    3220:	de b7       	in	r29, 0x3e	; 62
    3222:	9c 83       	std	Y+4, r25	; 0x04
    3224:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3226:	8b 81       	ldd	r24, Y+3	; 0x03
    3228:	9c 81       	ldd	r25, Y+4	; 0x04
    322a:	fc 01       	movw	r30, r24
    322c:	82 81       	ldd	r24, Z+2	; 0x02
    322e:	93 81       	ldd	r25, Z+3	; 0x03
    3230:	2b 81       	ldd	r18, Y+3	; 0x03
    3232:	3c 81       	ldd	r19, Y+4	; 0x04
    3234:	f9 01       	movw	r30, r18
    3236:	24 81       	ldd	r18, Z+4	; 0x04
    3238:	35 81       	ldd	r19, Z+5	; 0x05
    323a:	fc 01       	movw	r30, r24
    323c:	35 83       	std	Z+5, r19	; 0x05
    323e:	24 83       	std	Z+4, r18	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3240:	8b 81       	ldd	r24, Y+3	; 0x03
    3242:	9c 81       	ldd	r25, Y+4	; 0x04
    3244:	fc 01       	movw	r30, r24
    3246:	84 81       	ldd	r24, Z+4	; 0x04
    3248:	95 81       	ldd	r25, Z+5	; 0x05
    324a:	2b 81       	ldd	r18, Y+3	; 0x03
    324c:	3c 81       	ldd	r19, Y+4	; 0x04
    324e:	f9 01       	movw	r30, r18
    3250:	22 81       	ldd	r18, Z+2	; 0x02
    3252:	33 81       	ldd	r19, Z+3	; 0x03
    3254:	fc 01       	movw	r30, r24
    3256:	33 83       	std	Z+3, r19	; 0x03
    3258:	22 83       	std	Z+2, r18	; 0x02

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    325a:	8b 81       	ldd	r24, Y+3	; 0x03
    325c:	9c 81       	ldd	r25, Y+4	; 0x04
    325e:	fc 01       	movw	r30, r24
    3260:	80 85       	ldd	r24, Z+8	; 0x08
    3262:	91 85       	ldd	r25, Z+9	; 0x09
    3264:	9a 83       	std	Y+2, r25	; 0x02
    3266:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    3268:	89 81       	ldd	r24, Y+1	; 0x01
    326a:	9a 81       	ldd	r25, Y+2	; 0x02
    326c:	fc 01       	movw	r30, r24
    326e:	21 81       	ldd	r18, Z+1	; 0x01
    3270:	32 81       	ldd	r19, Z+2	; 0x02
    3272:	8b 81       	ldd	r24, Y+3	; 0x03
    3274:	9c 81       	ldd	r25, Y+4	; 0x04
    3276:	28 17       	cp	r18, r24
    3278:	39 07       	cpc	r19, r25
    327a:	51 f4       	brne	.+20     	; 0x3290 <uxListRemove+0x7a>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    327c:	8b 81       	ldd	r24, Y+3	; 0x03
    327e:	9c 81       	ldd	r25, Y+4	; 0x04
    3280:	fc 01       	movw	r30, r24
    3282:	24 81       	ldd	r18, Z+4	; 0x04
    3284:	35 81       	ldd	r19, Z+5	; 0x05
    3286:	89 81       	ldd	r24, Y+1	; 0x01
    3288:	9a 81       	ldd	r25, Y+2	; 0x02
    328a:	fc 01       	movw	r30, r24
    328c:	32 83       	std	Z+2, r19	; 0x02
    328e:	21 83       	std	Z+1, r18	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    3290:	8b 81       	ldd	r24, Y+3	; 0x03
    3292:	9c 81       	ldd	r25, Y+4	; 0x04
    3294:	fc 01       	movw	r30, r24
    3296:	11 86       	std	Z+9, r1	; 0x09
    3298:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    329a:	89 81       	ldd	r24, Y+1	; 0x01
    329c:	9a 81       	ldd	r25, Y+2	; 0x02
    329e:	fc 01       	movw	r30, r24
    32a0:	80 81       	ld	r24, Z
    32a2:	28 2f       	mov	r18, r24
    32a4:	21 50       	subi	r18, 0x01	; 1
    32a6:	89 81       	ldd	r24, Y+1	; 0x01
    32a8:	9a 81       	ldd	r25, Y+2	; 0x02
    32aa:	fc 01       	movw	r30, r24
    32ac:	20 83       	st	Z, r18

	return pxList->uxNumberOfItems;
    32ae:	89 81       	ldd	r24, Y+1	; 0x01
    32b0:	9a 81       	ldd	r25, Y+2	; 0x02
    32b2:	fc 01       	movw	r30, r24
    32b4:	80 81       	ld	r24, Z
}
    32b6:	0f 90       	pop	r0
    32b8:	0f 90       	pop	r0
    32ba:	0f 90       	pop	r0
    32bc:	0f 90       	pop	r0
    32be:	df 91       	pop	r29
    32c0:	cf 91       	pop	r28
    32c2:	08 95       	ret

000032c4 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    32c4:	cf 93       	push	r28
    32c6:	df 93       	push	r29
    32c8:	cd b7       	in	r28, 0x3d	; 61
    32ca:	de b7       	in	r29, 0x3e	; 62
    32cc:	28 97       	sbiw	r28, 0x08	; 8
    32ce:	0f b6       	in	r0, 0x3f	; 63
    32d0:	f8 94       	cli
    32d2:	de bf       	out	0x3e, r29	; 62
    32d4:	0f be       	out	0x3f, r0	; 63
    32d6:	cd bf       	out	0x3d, r28	; 61
    32d8:	9c 83       	std	Y+4, r25	; 0x04
    32da:	8b 83       	std	Y+3, r24	; 0x03
    32dc:	7e 83       	std	Y+6, r23	; 0x06
    32de:	6d 83       	std	Y+5, r22	; 0x05
    32e0:	58 87       	std	Y+8, r21	; 0x08
    32e2:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    32e4:	8b 81       	ldd	r24, Y+3	; 0x03
    32e6:	9c 81       	ldd	r25, Y+4	; 0x04
    32e8:	21 e1       	ldi	r18, 0x11	; 17
    32ea:	fc 01       	movw	r30, r24
    32ec:	20 83       	st	Z, r18
	pxTopOfStack--;
    32ee:	8b 81       	ldd	r24, Y+3	; 0x03
    32f0:	9c 81       	ldd	r25, Y+4	; 0x04
    32f2:	01 97       	sbiw	r24, 0x01	; 1
    32f4:	9c 83       	std	Y+4, r25	; 0x04
    32f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    32f8:	8b 81       	ldd	r24, Y+3	; 0x03
    32fa:	9c 81       	ldd	r25, Y+4	; 0x04
    32fc:	22 e2       	ldi	r18, 0x22	; 34
    32fe:	fc 01       	movw	r30, r24
    3300:	20 83       	st	Z, r18
	pxTopOfStack--;
    3302:	8b 81       	ldd	r24, Y+3	; 0x03
    3304:	9c 81       	ldd	r25, Y+4	; 0x04
    3306:	01 97       	sbiw	r24, 0x01	; 1
    3308:	9c 83       	std	Y+4, r25	; 0x04
    330a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    330c:	8b 81       	ldd	r24, Y+3	; 0x03
    330e:	9c 81       	ldd	r25, Y+4	; 0x04
    3310:	23 e3       	ldi	r18, 0x33	; 51
    3312:	fc 01       	movw	r30, r24
    3314:	20 83       	st	Z, r18
	pxTopOfStack--;
    3316:	8b 81       	ldd	r24, Y+3	; 0x03
    3318:	9c 81       	ldd	r25, Y+4	; 0x04
    331a:	01 97       	sbiw	r24, 0x01	; 1
    331c:	9c 83       	std	Y+4, r25	; 0x04
    331e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    3320:	8d 81       	ldd	r24, Y+5	; 0x05
    3322:	9e 81       	ldd	r25, Y+6	; 0x06
    3324:	9a 83       	std	Y+2, r25	; 0x02
    3326:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3328:	29 81       	ldd	r18, Y+1	; 0x01
    332a:	8b 81       	ldd	r24, Y+3	; 0x03
    332c:	9c 81       	ldd	r25, Y+4	; 0x04
    332e:	fc 01       	movw	r30, r24
    3330:	20 83       	st	Z, r18
	pxTopOfStack--;
    3332:	8b 81       	ldd	r24, Y+3	; 0x03
    3334:	9c 81       	ldd	r25, Y+4	; 0x04
    3336:	01 97       	sbiw	r24, 0x01	; 1
    3338:	9c 83       	std	Y+4, r25	; 0x04
    333a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    333c:	89 81       	ldd	r24, Y+1	; 0x01
    333e:	9a 81       	ldd	r25, Y+2	; 0x02
    3340:	89 2f       	mov	r24, r25
    3342:	99 27       	eor	r25, r25
    3344:	9a 83       	std	Y+2, r25	; 0x02
    3346:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3348:	29 81       	ldd	r18, Y+1	; 0x01
    334a:	8b 81       	ldd	r24, Y+3	; 0x03
    334c:	9c 81       	ldd	r25, Y+4	; 0x04
    334e:	fc 01       	movw	r30, r24
    3350:	20 83       	st	Z, r18
	pxTopOfStack--;
    3352:	8b 81       	ldd	r24, Y+3	; 0x03
    3354:	9c 81       	ldd	r25, Y+4	; 0x04
    3356:	01 97       	sbiw	r24, 0x01	; 1
    3358:	9c 83       	std	Y+4, r25	; 0x04
    335a:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    335c:	8b 81       	ldd	r24, Y+3	; 0x03
    335e:	9c 81       	ldd	r25, Y+4	; 0x04
    3360:	fc 01       	movw	r30, r24
    3362:	10 82       	st	Z, r1
	pxTopOfStack--;
    3364:	8b 81       	ldd	r24, Y+3	; 0x03
    3366:	9c 81       	ldd	r25, Y+4	; 0x04
    3368:	01 97       	sbiw	r24, 0x01	; 1
    336a:	9c 83       	std	Y+4, r25	; 0x04
    336c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    336e:	8b 81       	ldd	r24, Y+3	; 0x03
    3370:	9c 81       	ldd	r25, Y+4	; 0x04
    3372:	20 e8       	ldi	r18, 0x80	; 128
    3374:	fc 01       	movw	r30, r24
    3376:	20 83       	st	Z, r18
	pxTopOfStack--;
    3378:	8b 81       	ldd	r24, Y+3	; 0x03
    337a:	9c 81       	ldd	r25, Y+4	; 0x04
    337c:	01 97       	sbiw	r24, 0x01	; 1
    337e:	9c 83       	std	Y+4, r25	; 0x04
    3380:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    3382:	8b 81       	ldd	r24, Y+3	; 0x03
    3384:	9c 81       	ldd	r25, Y+4	; 0x04
    3386:	fc 01       	movw	r30, r24
    3388:	10 82       	st	Z, r1
	pxTopOfStack--;
    338a:	8b 81       	ldd	r24, Y+3	; 0x03
    338c:	9c 81       	ldd	r25, Y+4	; 0x04
    338e:	01 97       	sbiw	r24, 0x01	; 1
    3390:	9c 83       	std	Y+4, r25	; 0x04
    3392:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    3394:	8b 81       	ldd	r24, Y+3	; 0x03
    3396:	9c 81       	ldd	r25, Y+4	; 0x04
    3398:	22 e0       	ldi	r18, 0x02	; 2
    339a:	fc 01       	movw	r30, r24
    339c:	20 83       	st	Z, r18
	pxTopOfStack--;
    339e:	8b 81       	ldd	r24, Y+3	; 0x03
    33a0:	9c 81       	ldd	r25, Y+4	; 0x04
    33a2:	01 97       	sbiw	r24, 0x01	; 1
    33a4:	9c 83       	std	Y+4, r25	; 0x04
    33a6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    33a8:	8b 81       	ldd	r24, Y+3	; 0x03
    33aa:	9c 81       	ldd	r25, Y+4	; 0x04
    33ac:	23 e0       	ldi	r18, 0x03	; 3
    33ae:	fc 01       	movw	r30, r24
    33b0:	20 83       	st	Z, r18
	pxTopOfStack--;
    33b2:	8b 81       	ldd	r24, Y+3	; 0x03
    33b4:	9c 81       	ldd	r25, Y+4	; 0x04
    33b6:	01 97       	sbiw	r24, 0x01	; 1
    33b8:	9c 83       	std	Y+4, r25	; 0x04
    33ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    33bc:	8b 81       	ldd	r24, Y+3	; 0x03
    33be:	9c 81       	ldd	r25, Y+4	; 0x04
    33c0:	24 e0       	ldi	r18, 0x04	; 4
    33c2:	fc 01       	movw	r30, r24
    33c4:	20 83       	st	Z, r18
	pxTopOfStack--;
    33c6:	8b 81       	ldd	r24, Y+3	; 0x03
    33c8:	9c 81       	ldd	r25, Y+4	; 0x04
    33ca:	01 97       	sbiw	r24, 0x01	; 1
    33cc:	9c 83       	std	Y+4, r25	; 0x04
    33ce:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    33d0:	8b 81       	ldd	r24, Y+3	; 0x03
    33d2:	9c 81       	ldd	r25, Y+4	; 0x04
    33d4:	25 e0       	ldi	r18, 0x05	; 5
    33d6:	fc 01       	movw	r30, r24
    33d8:	20 83       	st	Z, r18
	pxTopOfStack--;
    33da:	8b 81       	ldd	r24, Y+3	; 0x03
    33dc:	9c 81       	ldd	r25, Y+4	; 0x04
    33de:	01 97       	sbiw	r24, 0x01	; 1
    33e0:	9c 83       	std	Y+4, r25	; 0x04
    33e2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    33e4:	8b 81       	ldd	r24, Y+3	; 0x03
    33e6:	9c 81       	ldd	r25, Y+4	; 0x04
    33e8:	26 e0       	ldi	r18, 0x06	; 6
    33ea:	fc 01       	movw	r30, r24
    33ec:	20 83       	st	Z, r18
	pxTopOfStack--;
    33ee:	8b 81       	ldd	r24, Y+3	; 0x03
    33f0:	9c 81       	ldd	r25, Y+4	; 0x04
    33f2:	01 97       	sbiw	r24, 0x01	; 1
    33f4:	9c 83       	std	Y+4, r25	; 0x04
    33f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    33f8:	8b 81       	ldd	r24, Y+3	; 0x03
    33fa:	9c 81       	ldd	r25, Y+4	; 0x04
    33fc:	27 e0       	ldi	r18, 0x07	; 7
    33fe:	fc 01       	movw	r30, r24
    3400:	20 83       	st	Z, r18
	pxTopOfStack--;
    3402:	8b 81       	ldd	r24, Y+3	; 0x03
    3404:	9c 81       	ldd	r25, Y+4	; 0x04
    3406:	01 97       	sbiw	r24, 0x01	; 1
    3408:	9c 83       	std	Y+4, r25	; 0x04
    340a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    340c:	8b 81       	ldd	r24, Y+3	; 0x03
    340e:	9c 81       	ldd	r25, Y+4	; 0x04
    3410:	28 e0       	ldi	r18, 0x08	; 8
    3412:	fc 01       	movw	r30, r24
    3414:	20 83       	st	Z, r18
	pxTopOfStack--;
    3416:	8b 81       	ldd	r24, Y+3	; 0x03
    3418:	9c 81       	ldd	r25, Y+4	; 0x04
    341a:	01 97       	sbiw	r24, 0x01	; 1
    341c:	9c 83       	std	Y+4, r25	; 0x04
    341e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    3420:	8b 81       	ldd	r24, Y+3	; 0x03
    3422:	9c 81       	ldd	r25, Y+4	; 0x04
    3424:	29 e0       	ldi	r18, 0x09	; 9
    3426:	fc 01       	movw	r30, r24
    3428:	20 83       	st	Z, r18
	pxTopOfStack--;
    342a:	8b 81       	ldd	r24, Y+3	; 0x03
    342c:	9c 81       	ldd	r25, Y+4	; 0x04
    342e:	01 97       	sbiw	r24, 0x01	; 1
    3430:	9c 83       	std	Y+4, r25	; 0x04
    3432:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    3434:	8b 81       	ldd	r24, Y+3	; 0x03
    3436:	9c 81       	ldd	r25, Y+4	; 0x04
    3438:	20 e1       	ldi	r18, 0x10	; 16
    343a:	fc 01       	movw	r30, r24
    343c:	20 83       	st	Z, r18
	pxTopOfStack--;
    343e:	8b 81       	ldd	r24, Y+3	; 0x03
    3440:	9c 81       	ldd	r25, Y+4	; 0x04
    3442:	01 97       	sbiw	r24, 0x01	; 1
    3444:	9c 83       	std	Y+4, r25	; 0x04
    3446:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    3448:	8b 81       	ldd	r24, Y+3	; 0x03
    344a:	9c 81       	ldd	r25, Y+4	; 0x04
    344c:	21 e1       	ldi	r18, 0x11	; 17
    344e:	fc 01       	movw	r30, r24
    3450:	20 83       	st	Z, r18
	pxTopOfStack--;
    3452:	8b 81       	ldd	r24, Y+3	; 0x03
    3454:	9c 81       	ldd	r25, Y+4	; 0x04
    3456:	01 97       	sbiw	r24, 0x01	; 1
    3458:	9c 83       	std	Y+4, r25	; 0x04
    345a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    345c:	8b 81       	ldd	r24, Y+3	; 0x03
    345e:	9c 81       	ldd	r25, Y+4	; 0x04
    3460:	22 e1       	ldi	r18, 0x12	; 18
    3462:	fc 01       	movw	r30, r24
    3464:	20 83       	st	Z, r18
	pxTopOfStack--;
    3466:	8b 81       	ldd	r24, Y+3	; 0x03
    3468:	9c 81       	ldd	r25, Y+4	; 0x04
    346a:	01 97       	sbiw	r24, 0x01	; 1
    346c:	9c 83       	std	Y+4, r25	; 0x04
    346e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    3470:	8b 81       	ldd	r24, Y+3	; 0x03
    3472:	9c 81       	ldd	r25, Y+4	; 0x04
    3474:	23 e1       	ldi	r18, 0x13	; 19
    3476:	fc 01       	movw	r30, r24
    3478:	20 83       	st	Z, r18
	pxTopOfStack--;
    347a:	8b 81       	ldd	r24, Y+3	; 0x03
    347c:	9c 81       	ldd	r25, Y+4	; 0x04
    347e:	01 97       	sbiw	r24, 0x01	; 1
    3480:	9c 83       	std	Y+4, r25	; 0x04
    3482:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    3484:	8b 81       	ldd	r24, Y+3	; 0x03
    3486:	9c 81       	ldd	r25, Y+4	; 0x04
    3488:	24 e1       	ldi	r18, 0x14	; 20
    348a:	fc 01       	movw	r30, r24
    348c:	20 83       	st	Z, r18
	pxTopOfStack--;
    348e:	8b 81       	ldd	r24, Y+3	; 0x03
    3490:	9c 81       	ldd	r25, Y+4	; 0x04
    3492:	01 97       	sbiw	r24, 0x01	; 1
    3494:	9c 83       	std	Y+4, r25	; 0x04
    3496:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    3498:	8b 81       	ldd	r24, Y+3	; 0x03
    349a:	9c 81       	ldd	r25, Y+4	; 0x04
    349c:	25 e1       	ldi	r18, 0x15	; 21
    349e:	fc 01       	movw	r30, r24
    34a0:	20 83       	st	Z, r18
	pxTopOfStack--;
    34a2:	8b 81       	ldd	r24, Y+3	; 0x03
    34a4:	9c 81       	ldd	r25, Y+4	; 0x04
    34a6:	01 97       	sbiw	r24, 0x01	; 1
    34a8:	9c 83       	std	Y+4, r25	; 0x04
    34aa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    34ac:	8b 81       	ldd	r24, Y+3	; 0x03
    34ae:	9c 81       	ldd	r25, Y+4	; 0x04
    34b0:	26 e1       	ldi	r18, 0x16	; 22
    34b2:	fc 01       	movw	r30, r24
    34b4:	20 83       	st	Z, r18
	pxTopOfStack--;
    34b6:	8b 81       	ldd	r24, Y+3	; 0x03
    34b8:	9c 81       	ldd	r25, Y+4	; 0x04
    34ba:	01 97       	sbiw	r24, 0x01	; 1
    34bc:	9c 83       	std	Y+4, r25	; 0x04
    34be:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    34c0:	8b 81       	ldd	r24, Y+3	; 0x03
    34c2:	9c 81       	ldd	r25, Y+4	; 0x04
    34c4:	27 e1       	ldi	r18, 0x17	; 23
    34c6:	fc 01       	movw	r30, r24
    34c8:	20 83       	st	Z, r18
	pxTopOfStack--;
    34ca:	8b 81       	ldd	r24, Y+3	; 0x03
    34cc:	9c 81       	ldd	r25, Y+4	; 0x04
    34ce:	01 97       	sbiw	r24, 0x01	; 1
    34d0:	9c 83       	std	Y+4, r25	; 0x04
    34d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    34d4:	8b 81       	ldd	r24, Y+3	; 0x03
    34d6:	9c 81       	ldd	r25, Y+4	; 0x04
    34d8:	28 e1       	ldi	r18, 0x18	; 24
    34da:	fc 01       	movw	r30, r24
    34dc:	20 83       	st	Z, r18
	pxTopOfStack--;
    34de:	8b 81       	ldd	r24, Y+3	; 0x03
    34e0:	9c 81       	ldd	r25, Y+4	; 0x04
    34e2:	01 97       	sbiw	r24, 0x01	; 1
    34e4:	9c 83       	std	Y+4, r25	; 0x04
    34e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    34e8:	8b 81       	ldd	r24, Y+3	; 0x03
    34ea:	9c 81       	ldd	r25, Y+4	; 0x04
    34ec:	29 e1       	ldi	r18, 0x19	; 25
    34ee:	fc 01       	movw	r30, r24
    34f0:	20 83       	st	Z, r18
	pxTopOfStack--;
    34f2:	8b 81       	ldd	r24, Y+3	; 0x03
    34f4:	9c 81       	ldd	r25, Y+4	; 0x04
    34f6:	01 97       	sbiw	r24, 0x01	; 1
    34f8:	9c 83       	std	Y+4, r25	; 0x04
    34fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    34fc:	8b 81       	ldd	r24, Y+3	; 0x03
    34fe:	9c 81       	ldd	r25, Y+4	; 0x04
    3500:	20 e2       	ldi	r18, 0x20	; 32
    3502:	fc 01       	movw	r30, r24
    3504:	20 83       	st	Z, r18
	pxTopOfStack--;
    3506:	8b 81       	ldd	r24, Y+3	; 0x03
    3508:	9c 81       	ldd	r25, Y+4	; 0x04
    350a:	01 97       	sbiw	r24, 0x01	; 1
    350c:	9c 83       	std	Y+4, r25	; 0x04
    350e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    3510:	8b 81       	ldd	r24, Y+3	; 0x03
    3512:	9c 81       	ldd	r25, Y+4	; 0x04
    3514:	21 e2       	ldi	r18, 0x21	; 33
    3516:	fc 01       	movw	r30, r24
    3518:	20 83       	st	Z, r18
	pxTopOfStack--;
    351a:	8b 81       	ldd	r24, Y+3	; 0x03
    351c:	9c 81       	ldd	r25, Y+4	; 0x04
    351e:	01 97       	sbiw	r24, 0x01	; 1
    3520:	9c 83       	std	Y+4, r25	; 0x04
    3522:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    3524:	8b 81       	ldd	r24, Y+3	; 0x03
    3526:	9c 81       	ldd	r25, Y+4	; 0x04
    3528:	22 e2       	ldi	r18, 0x22	; 34
    352a:	fc 01       	movw	r30, r24
    352c:	20 83       	st	Z, r18
	pxTopOfStack--;
    352e:	8b 81       	ldd	r24, Y+3	; 0x03
    3530:	9c 81       	ldd	r25, Y+4	; 0x04
    3532:	01 97       	sbiw	r24, 0x01	; 1
    3534:	9c 83       	std	Y+4, r25	; 0x04
    3536:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    3538:	8b 81       	ldd	r24, Y+3	; 0x03
    353a:	9c 81       	ldd	r25, Y+4	; 0x04
    353c:	23 e2       	ldi	r18, 0x23	; 35
    353e:	fc 01       	movw	r30, r24
    3540:	20 83       	st	Z, r18
	pxTopOfStack--;
    3542:	8b 81       	ldd	r24, Y+3	; 0x03
    3544:	9c 81       	ldd	r25, Y+4	; 0x04
    3546:	01 97       	sbiw	r24, 0x01	; 1
    3548:	9c 83       	std	Y+4, r25	; 0x04
    354a:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    354c:	8f 81       	ldd	r24, Y+7	; 0x07
    354e:	98 85       	ldd	r25, Y+8	; 0x08
    3550:	9a 83       	std	Y+2, r25	; 0x02
    3552:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3554:	29 81       	ldd	r18, Y+1	; 0x01
    3556:	8b 81       	ldd	r24, Y+3	; 0x03
    3558:	9c 81       	ldd	r25, Y+4	; 0x04
    355a:	fc 01       	movw	r30, r24
    355c:	20 83       	st	Z, r18
	pxTopOfStack--;
    355e:	8b 81       	ldd	r24, Y+3	; 0x03
    3560:	9c 81       	ldd	r25, Y+4	; 0x04
    3562:	01 97       	sbiw	r24, 0x01	; 1
    3564:	9c 83       	std	Y+4, r25	; 0x04
    3566:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    3568:	89 81       	ldd	r24, Y+1	; 0x01
    356a:	9a 81       	ldd	r25, Y+2	; 0x02
    356c:	89 2f       	mov	r24, r25
    356e:	99 27       	eor	r25, r25
    3570:	9a 83       	std	Y+2, r25	; 0x02
    3572:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    3574:	29 81       	ldd	r18, Y+1	; 0x01
    3576:	8b 81       	ldd	r24, Y+3	; 0x03
    3578:	9c 81       	ldd	r25, Y+4	; 0x04
    357a:	fc 01       	movw	r30, r24
    357c:	20 83       	st	Z, r18
	pxTopOfStack--;
    357e:	8b 81       	ldd	r24, Y+3	; 0x03
    3580:	9c 81       	ldd	r25, Y+4	; 0x04
    3582:	01 97       	sbiw	r24, 0x01	; 1
    3584:	9c 83       	std	Y+4, r25	; 0x04
    3586:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    3588:	8b 81       	ldd	r24, Y+3	; 0x03
    358a:	9c 81       	ldd	r25, Y+4	; 0x04
    358c:	26 e2       	ldi	r18, 0x26	; 38
    358e:	fc 01       	movw	r30, r24
    3590:	20 83       	st	Z, r18
	pxTopOfStack--;
    3592:	8b 81       	ldd	r24, Y+3	; 0x03
    3594:	9c 81       	ldd	r25, Y+4	; 0x04
    3596:	01 97       	sbiw	r24, 0x01	; 1
    3598:	9c 83       	std	Y+4, r25	; 0x04
    359a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    359c:	8b 81       	ldd	r24, Y+3	; 0x03
    359e:	9c 81       	ldd	r25, Y+4	; 0x04
    35a0:	27 e2       	ldi	r18, 0x27	; 39
    35a2:	fc 01       	movw	r30, r24
    35a4:	20 83       	st	Z, r18
	pxTopOfStack--;
    35a6:	8b 81       	ldd	r24, Y+3	; 0x03
    35a8:	9c 81       	ldd	r25, Y+4	; 0x04
    35aa:	01 97       	sbiw	r24, 0x01	; 1
    35ac:	9c 83       	std	Y+4, r25	; 0x04
    35ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    35b0:	8b 81       	ldd	r24, Y+3	; 0x03
    35b2:	9c 81       	ldd	r25, Y+4	; 0x04
    35b4:	28 e2       	ldi	r18, 0x28	; 40
    35b6:	fc 01       	movw	r30, r24
    35b8:	20 83       	st	Z, r18
	pxTopOfStack--;
    35ba:	8b 81       	ldd	r24, Y+3	; 0x03
    35bc:	9c 81       	ldd	r25, Y+4	; 0x04
    35be:	01 97       	sbiw	r24, 0x01	; 1
    35c0:	9c 83       	std	Y+4, r25	; 0x04
    35c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    35c4:	8b 81       	ldd	r24, Y+3	; 0x03
    35c6:	9c 81       	ldd	r25, Y+4	; 0x04
    35c8:	29 e2       	ldi	r18, 0x29	; 41
    35ca:	fc 01       	movw	r30, r24
    35cc:	20 83       	st	Z, r18
	pxTopOfStack--;
    35ce:	8b 81       	ldd	r24, Y+3	; 0x03
    35d0:	9c 81       	ldd	r25, Y+4	; 0x04
    35d2:	01 97       	sbiw	r24, 0x01	; 1
    35d4:	9c 83       	std	Y+4, r25	; 0x04
    35d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    35d8:	8b 81       	ldd	r24, Y+3	; 0x03
    35da:	9c 81       	ldd	r25, Y+4	; 0x04
    35dc:	20 e3       	ldi	r18, 0x30	; 48
    35de:	fc 01       	movw	r30, r24
    35e0:	20 83       	st	Z, r18
	pxTopOfStack--;
    35e2:	8b 81       	ldd	r24, Y+3	; 0x03
    35e4:	9c 81       	ldd	r25, Y+4	; 0x04
    35e6:	01 97       	sbiw	r24, 0x01	; 1
    35e8:	9c 83       	std	Y+4, r25	; 0x04
    35ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    35ec:	8b 81       	ldd	r24, Y+3	; 0x03
    35ee:	9c 81       	ldd	r25, Y+4	; 0x04
    35f0:	21 e3       	ldi	r18, 0x31	; 49
    35f2:	fc 01       	movw	r30, r24
    35f4:	20 83       	st	Z, r18
	pxTopOfStack--;
    35f6:	8b 81       	ldd	r24, Y+3	; 0x03
    35f8:	9c 81       	ldd	r25, Y+4	; 0x04
    35fa:	01 97       	sbiw	r24, 0x01	; 1
    35fc:	9c 83       	std	Y+4, r25	; 0x04
    35fe:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    3600:	8b 81       	ldd	r24, Y+3	; 0x03
    3602:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3604:	28 96       	adiw	r28, 0x08	; 8
    3606:	0f b6       	in	r0, 0x3f	; 63
    3608:	f8 94       	cli
    360a:	de bf       	out	0x3e, r29	; 62
    360c:	0f be       	out	0x3f, r0	; 63
    360e:	cd bf       	out	0x3d, r28	; 61
    3610:	df 91       	pop	r29
    3612:	cf 91       	pop	r28
    3614:	08 95       	ret

00003616 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    3616:	cf 93       	push	r28
    3618:	df 93       	push	r29
    361a:	cd b7       	in	r28, 0x3d	; 61
    361c:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    361e:	0e 94 fb 1b 	call	0x37f6	; 0x37f6 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3622:	a0 91 56 0d 	lds	r26, 0x0D56
    3626:	b0 91 57 0d 	lds	r27, 0x0D57
    362a:	cd 91       	ld	r28, X+
    362c:	cd bf       	out	0x3d, r28	; 61
    362e:	dd 91       	ld	r29, X+
    3630:	de bf       	out	0x3e, r29	; 62
    3632:	ff 91       	pop	r31
    3634:	ef 91       	pop	r30
    3636:	df 91       	pop	r29
    3638:	cf 91       	pop	r28
    363a:	bf 91       	pop	r27
    363c:	af 91       	pop	r26
    363e:	9f 91       	pop	r25
    3640:	8f 91       	pop	r24
    3642:	7f 91       	pop	r23
    3644:	6f 91       	pop	r22
    3646:	5f 91       	pop	r21
    3648:	4f 91       	pop	r20
    364a:	3f 91       	pop	r19
    364c:	2f 91       	pop	r18
    364e:	1f 91       	pop	r17
    3650:	0f 91       	pop	r16
    3652:	ff 90       	pop	r15
    3654:	ef 90       	pop	r14
    3656:	df 90       	pop	r13
    3658:	cf 90       	pop	r12
    365a:	bf 90       	pop	r11
    365c:	af 90       	pop	r10
    365e:	9f 90       	pop	r9
    3660:	8f 90       	pop	r8
    3662:	7f 90       	pop	r7
    3664:	6f 90       	pop	r6
    3666:	5f 90       	pop	r5
    3668:	4f 90       	pop	r4
    366a:	3f 90       	pop	r3
    366c:	2f 90       	pop	r2
    366e:	1f 90       	pop	r1
    3670:	0f 90       	pop	r0
    3672:	0f be       	out	0x3f, r0	; 63
    3674:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3676:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    3678:	81 e0       	ldi	r24, 0x01	; 1
}
    367a:	df 91       	pop	r29
    367c:	cf 91       	pop	r28
    367e:	08 95       	ret

00003680 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    3680:	cf 93       	push	r28
    3682:	df 93       	push	r29
    3684:	cd b7       	in	r28, 0x3d	; 61
    3686:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    3688:	df 91       	pop	r29
    368a:	cf 91       	pop	r28
    368c:	08 95       	ret

0000368e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    368e:	0f 92       	push	r0
    3690:	0f b6       	in	r0, 0x3f	; 63
    3692:	f8 94       	cli
    3694:	0f 92       	push	r0
    3696:	1f 92       	push	r1
    3698:	11 24       	eor	r1, r1
    369a:	2f 92       	push	r2
    369c:	3f 92       	push	r3
    369e:	4f 92       	push	r4
    36a0:	5f 92       	push	r5
    36a2:	6f 92       	push	r6
    36a4:	7f 92       	push	r7
    36a6:	8f 92       	push	r8
    36a8:	9f 92       	push	r9
    36aa:	af 92       	push	r10
    36ac:	bf 92       	push	r11
    36ae:	cf 92       	push	r12
    36b0:	df 92       	push	r13
    36b2:	ef 92       	push	r14
    36b4:	ff 92       	push	r15
    36b6:	0f 93       	push	r16
    36b8:	1f 93       	push	r17
    36ba:	2f 93       	push	r18
    36bc:	3f 93       	push	r19
    36be:	4f 93       	push	r20
    36c0:	5f 93       	push	r21
    36c2:	6f 93       	push	r22
    36c4:	7f 93       	push	r23
    36c6:	8f 93       	push	r24
    36c8:	9f 93       	push	r25
    36ca:	af 93       	push	r26
    36cc:	bf 93       	push	r27
    36ce:	cf 93       	push	r28
    36d0:	df 93       	push	r29
    36d2:	ef 93       	push	r30
    36d4:	ff 93       	push	r31
    36d6:	a0 91 56 0d 	lds	r26, 0x0D56
    36da:	b0 91 57 0d 	lds	r27, 0x0D57
    36de:	0d b6       	in	r0, 0x3d	; 61
    36e0:	0d 92       	st	X+, r0
    36e2:	0e b6       	in	r0, 0x3e	; 62
    36e4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    36e6:	0e 94 90 25 	call	0x4b20	; 0x4b20 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    36ea:	a0 91 56 0d 	lds	r26, 0x0D56
    36ee:	b0 91 57 0d 	lds	r27, 0x0D57
    36f2:	cd 91       	ld	r28, X+
    36f4:	cd bf       	out	0x3d, r28	; 61
    36f6:	dd 91       	ld	r29, X+
    36f8:	de bf       	out	0x3e, r29	; 62
    36fa:	ff 91       	pop	r31
    36fc:	ef 91       	pop	r30
    36fe:	df 91       	pop	r29
    3700:	cf 91       	pop	r28
    3702:	bf 91       	pop	r27
    3704:	af 91       	pop	r26
    3706:	9f 91       	pop	r25
    3708:	8f 91       	pop	r24
    370a:	7f 91       	pop	r23
    370c:	6f 91       	pop	r22
    370e:	5f 91       	pop	r21
    3710:	4f 91       	pop	r20
    3712:	3f 91       	pop	r19
    3714:	2f 91       	pop	r18
    3716:	1f 91       	pop	r17
    3718:	0f 91       	pop	r16
    371a:	ff 90       	pop	r15
    371c:	ef 90       	pop	r14
    371e:	df 90       	pop	r13
    3720:	cf 90       	pop	r12
    3722:	bf 90       	pop	r11
    3724:	af 90       	pop	r10
    3726:	9f 90       	pop	r9
    3728:	8f 90       	pop	r8
    372a:	7f 90       	pop	r7
    372c:	6f 90       	pop	r6
    372e:	5f 90       	pop	r5
    3730:	4f 90       	pop	r4
    3732:	3f 90       	pop	r3
    3734:	2f 90       	pop	r2
    3736:	1f 90       	pop	r1
    3738:	0f 90       	pop	r0
    373a:	0f be       	out	0x3f, r0	; 63
    373c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    373e:	08 95       	ret

00003740 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3740:	0f 92       	push	r0
    3742:	0f b6       	in	r0, 0x3f	; 63
    3744:	f8 94       	cli
    3746:	0f 92       	push	r0
    3748:	1f 92       	push	r1
    374a:	11 24       	eor	r1, r1
    374c:	2f 92       	push	r2
    374e:	3f 92       	push	r3
    3750:	4f 92       	push	r4
    3752:	5f 92       	push	r5
    3754:	6f 92       	push	r6
    3756:	7f 92       	push	r7
    3758:	8f 92       	push	r8
    375a:	9f 92       	push	r9
    375c:	af 92       	push	r10
    375e:	bf 92       	push	r11
    3760:	cf 92       	push	r12
    3762:	df 92       	push	r13
    3764:	ef 92       	push	r14
    3766:	ff 92       	push	r15
    3768:	0f 93       	push	r16
    376a:	1f 93       	push	r17
    376c:	2f 93       	push	r18
    376e:	3f 93       	push	r19
    3770:	4f 93       	push	r20
    3772:	5f 93       	push	r21
    3774:	6f 93       	push	r22
    3776:	7f 93       	push	r23
    3778:	8f 93       	push	r24
    377a:	9f 93       	push	r25
    377c:	af 93       	push	r26
    377e:	bf 93       	push	r27
    3780:	cf 93       	push	r28
    3782:	df 93       	push	r29
    3784:	ef 93       	push	r30
    3786:	ff 93       	push	r31
    3788:	a0 91 56 0d 	lds	r26, 0x0D56
    378c:	b0 91 57 0d 	lds	r27, 0x0D57
    3790:	0d b6       	in	r0, 0x3d	; 61
    3792:	0d 92       	st	X+, r0
    3794:	0e b6       	in	r0, 0x3e	; 62
    3796:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    3798:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskIncrementTick>
	vTaskSwitchContext();
    379c:	0e 94 90 25 	call	0x4b20	; 0x4b20 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    37a0:	a0 91 56 0d 	lds	r26, 0x0D56
    37a4:	b0 91 57 0d 	lds	r27, 0x0D57
    37a8:	cd 91       	ld	r28, X+
    37aa:	cd bf       	out	0x3d, r28	; 61
    37ac:	dd 91       	ld	r29, X+
    37ae:	de bf       	out	0x3e, r29	; 62
    37b0:	ff 91       	pop	r31
    37b2:	ef 91       	pop	r30
    37b4:	df 91       	pop	r29
    37b6:	cf 91       	pop	r28
    37b8:	bf 91       	pop	r27
    37ba:	af 91       	pop	r26
    37bc:	9f 91       	pop	r25
    37be:	8f 91       	pop	r24
    37c0:	7f 91       	pop	r23
    37c2:	6f 91       	pop	r22
    37c4:	5f 91       	pop	r21
    37c6:	4f 91       	pop	r20
    37c8:	3f 91       	pop	r19
    37ca:	2f 91       	pop	r18
    37cc:	1f 91       	pop	r17
    37ce:	0f 91       	pop	r16
    37d0:	ff 90       	pop	r15
    37d2:	ef 90       	pop	r14
    37d4:	df 90       	pop	r13
    37d6:	cf 90       	pop	r12
    37d8:	bf 90       	pop	r11
    37da:	af 90       	pop	r10
    37dc:	9f 90       	pop	r9
    37de:	8f 90       	pop	r8
    37e0:	7f 90       	pop	r7
    37e2:	6f 90       	pop	r6
    37e4:	5f 90       	pop	r5
    37e6:	4f 90       	pop	r4
    37e8:	3f 90       	pop	r3
    37ea:	2f 90       	pop	r2
    37ec:	1f 90       	pop	r1
    37ee:	0f 90       	pop	r0
    37f0:	0f be       	out	0x3f, r0	; 63
    37f2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    37f4:	08 95       	ret

000037f6 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    37f6:	cf 93       	push	r28
    37f8:	df 93       	push	r29
    37fa:	00 d0       	rcall	.+0      	; 0x37fc <prvSetupTimerInterrupt+0x6>
    37fc:	00 d0       	rcall	.+0      	; 0x37fe <prvSetupTimerInterrupt+0x8>
    37fe:	0f 92       	push	r0
    3800:	cd b7       	in	r28, 0x3d	; 61
    3802:	de b7       	in	r29, 0x3e	; 62

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */
    
    //here: 8.000.000 / 1.000 = 8000
	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3804:	80 e4       	ldi	r24, 0x40	; 64
    3806:	9f e1       	ldi	r25, 0x1F	; 31
    3808:	a0 e0       	ldi	r26, 0x00	; 0
    380a:	b0 e0       	ldi	r27, 0x00	; 0
    380c:	89 83       	std	Y+1, r24	; 0x01
    380e:	9a 83       	std	Y+2, r25	; 0x02
    3810:	ab 83       	std	Y+3, r26	; 0x03
    3812:	bc 83       	std	Y+4, r27	; 0x04
	//ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	//ulCompareMatch >>= 8;
	//ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	//OCR1AH = ucHighByte;
	//OCR1AL = ucLowByte;
    OCR1A = ulCompareMatch; 
    3814:	88 e8       	ldi	r24, 0x88	; 136
    3816:	90 e0       	ldi	r25, 0x00	; 0
    3818:	29 81       	ldd	r18, Y+1	; 0x01
    381a:	3a 81       	ldd	r19, Y+2	; 0x02
    381c:	fc 01       	movw	r30, r24
    381e:	31 83       	std	Z+1, r19	; 0x01
    3820:	20 83       	st	Z, r18

	/* Setup clock source and compare match behaviour. */
	//MOD: atmega1284p
	//ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	//TCCR1B = ucLowByte;
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_1;
    3822:	89 e0       	ldi	r24, 0x09	; 9
    3824:	8d 83       	std	Y+5, r24	; 0x05
	TCCR1B = ucLowByte;
    3826:	81 e8       	ldi	r24, 0x81	; 129
    3828:	90 e0       	ldi	r25, 0x00	; 0
    382a:	2d 81       	ldd	r18, Y+5	; 0x05
    382c:	fc 01       	movw	r30, r24
    382e:	20 83       	st	Z, r18
	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	//MOD: atmega1284p
	//ucLowByte = TIMSK;
	//-> enable Timer1 Output Compare A
	ucLowByte = TIMSK1;
    3830:	8f e6       	ldi	r24, 0x6F	; 111
    3832:	90 e0       	ldi	r25, 0x00	; 0
    3834:	fc 01       	movw	r30, r24
    3836:	80 81       	ld	r24, Z
    3838:	8d 83       	std	Y+5, r24	; 0x05
	
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    383a:	8d 81       	ldd	r24, Y+5	; 0x05
    383c:	82 60       	ori	r24, 0x02	; 2
    383e:	8d 83       	std	Y+5, r24	; 0x05
	
	//MOD: atmega1284p
	//TIMSK = ucLowByte;
	TIMSK1 = ucLowByte;
    3840:	8f e6       	ldi	r24, 0x6F	; 111
    3842:	90 e0       	ldi	r25, 0x00	; 0
    3844:	2d 81       	ldd	r18, Y+5	; 0x05
    3846:	fc 01       	movw	r30, r24
    3848:	20 83       	st	Z, r18
}
    384a:	0f 90       	pop	r0
    384c:	0f 90       	pop	r0
    384e:	0f 90       	pop	r0
    3850:	0f 90       	pop	r0
    3852:	0f 90       	pop	r0
    3854:	df 91       	pop	r29
    3856:	cf 91       	pop	r28
    3858:	08 95       	ret

0000385a <__vector_13>:
	 */
	ISR (TIMER1_COMPA_vect) __attribute__ ( ( signal, naked ) );
	ISR (TIMER1_COMPA_vect)
	{
        //PORTB ^= (1<<PB0);
		vPortYieldFromTick();
    385a:	0e 94 a0 1b 	call	0x3740	; 0x3740 <vPortYieldFromTick>
		asm volatile ( "reti" );
    385e:	18 95       	reti

00003860 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
    3860:	cf 93       	push	r28
    3862:	df 93       	push	r29
    3864:	00 d0       	rcall	.+0      	; 0x3866 <xQueueGenericReset+0x6>
    3866:	00 d0       	rcall	.+0      	; 0x3868 <xQueueGenericReset+0x8>
    3868:	0f 92       	push	r0
    386a:	cd b7       	in	r28, 0x3d	; 61
    386c:	de b7       	in	r29, 0x3e	; 62
    386e:	9c 83       	std	Y+4, r25	; 0x04
    3870:	8b 83       	std	Y+3, r24	; 0x03
    3872:	6d 83       	std	Y+5, r22	; 0x05
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
    3874:	8b 81       	ldd	r24, Y+3	; 0x03
    3876:	9c 81       	ldd	r25, Y+4	; 0x04
    3878:	9a 83       	std	Y+2, r25	; 0x02
    387a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    387c:	0f b6       	in	r0, 0x3f	; 63
    387e:	f8 94       	cli
    3880:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    3882:	89 81       	ldd	r24, Y+1	; 0x01
    3884:	9a 81       	ldd	r25, Y+2	; 0x02
    3886:	fc 01       	movw	r30, r24
    3888:	20 81       	ld	r18, Z
    388a:	31 81       	ldd	r19, Z+1	; 0x01
    388c:	89 81       	ldd	r24, Y+1	; 0x01
    388e:	9a 81       	ldd	r25, Y+2	; 0x02
    3890:	fc 01       	movw	r30, r24
    3892:	83 8d       	ldd	r24, Z+27	; 0x1b
    3894:	68 2f       	mov	r22, r24
    3896:	70 e0       	ldi	r23, 0x00	; 0
    3898:	89 81       	ldd	r24, Y+1	; 0x01
    389a:	9a 81       	ldd	r25, Y+2	; 0x02
    389c:	fc 01       	movw	r30, r24
    389e:	84 8d       	ldd	r24, Z+28	; 0x1c
    38a0:	48 2f       	mov	r20, r24
    38a2:	50 e0       	ldi	r21, 0x00	; 0
    38a4:	64 9f       	mul	r22, r20
    38a6:	c0 01       	movw	r24, r0
    38a8:	65 9f       	mul	r22, r21
    38aa:	90 0d       	add	r25, r0
    38ac:	74 9f       	mul	r23, r20
    38ae:	90 0d       	add	r25, r0
    38b0:	11 24       	eor	r1, r1
    38b2:	28 0f       	add	r18, r24
    38b4:	39 1f       	adc	r19, r25
    38b6:	89 81       	ldd	r24, Y+1	; 0x01
    38b8:	9a 81       	ldd	r25, Y+2	; 0x02
    38ba:	fc 01       	movw	r30, r24
    38bc:	33 83       	std	Z+3, r19	; 0x03
    38be:	22 83       	std	Z+2, r18	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    38c0:	89 81       	ldd	r24, Y+1	; 0x01
    38c2:	9a 81       	ldd	r25, Y+2	; 0x02
    38c4:	fc 01       	movw	r30, r24
    38c6:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    38c8:	89 81       	ldd	r24, Y+1	; 0x01
    38ca:	9a 81       	ldd	r25, Y+2	; 0x02
    38cc:	fc 01       	movw	r30, r24
    38ce:	20 81       	ld	r18, Z
    38d0:	31 81       	ldd	r19, Z+1	; 0x01
    38d2:	89 81       	ldd	r24, Y+1	; 0x01
    38d4:	9a 81       	ldd	r25, Y+2	; 0x02
    38d6:	fc 01       	movw	r30, r24
    38d8:	35 83       	std	Z+5, r19	; 0x05
    38da:	24 83       	std	Z+4, r18	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    38dc:	89 81       	ldd	r24, Y+1	; 0x01
    38de:	9a 81       	ldd	r25, Y+2	; 0x02
    38e0:	fc 01       	movw	r30, r24
    38e2:	20 81       	ld	r18, Z
    38e4:	31 81       	ldd	r19, Z+1	; 0x01
    38e6:	89 81       	ldd	r24, Y+1	; 0x01
    38e8:	9a 81       	ldd	r25, Y+2	; 0x02
    38ea:	fc 01       	movw	r30, r24
    38ec:	83 8d       	ldd	r24, Z+27	; 0x1b
    38ee:	88 2f       	mov	r24, r24
    38f0:	90 e0       	ldi	r25, 0x00	; 0
    38f2:	bc 01       	movw	r22, r24
    38f4:	61 50       	subi	r22, 0x01	; 1
    38f6:	70 40       	sbci	r23, 0x00	; 0
    38f8:	89 81       	ldd	r24, Y+1	; 0x01
    38fa:	9a 81       	ldd	r25, Y+2	; 0x02
    38fc:	fc 01       	movw	r30, r24
    38fe:	84 8d       	ldd	r24, Z+28	; 0x1c
    3900:	48 2f       	mov	r20, r24
    3902:	50 e0       	ldi	r21, 0x00	; 0
    3904:	64 9f       	mul	r22, r20
    3906:	c0 01       	movw	r24, r0
    3908:	65 9f       	mul	r22, r21
    390a:	90 0d       	add	r25, r0
    390c:	74 9f       	mul	r23, r20
    390e:	90 0d       	add	r25, r0
    3910:	11 24       	eor	r1, r1
    3912:	28 0f       	add	r18, r24
    3914:	39 1f       	adc	r19, r25
    3916:	89 81       	ldd	r24, Y+1	; 0x01
    3918:	9a 81       	ldd	r25, Y+2	; 0x02
    391a:	fc 01       	movw	r30, r24
    391c:	37 83       	std	Z+7, r19	; 0x07
    391e:	26 83       	std	Z+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    3920:	89 81       	ldd	r24, Y+1	; 0x01
    3922:	9a 81       	ldd	r25, Y+2	; 0x02
    3924:	2f ef       	ldi	r18, 0xFF	; 255
    3926:	fc 01       	movw	r30, r24
    3928:	25 8f       	std	Z+29, r18	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    392a:	89 81       	ldd	r24, Y+1	; 0x01
    392c:	9a 81       	ldd	r25, Y+2	; 0x02
    392e:	2f ef       	ldi	r18, 0xFF	; 255
    3930:	fc 01       	movw	r30, r24
    3932:	26 8f       	std	Z+30, r18	; 0x1e

		if( xNewQueue == pdFALSE )
    3934:	8d 81       	ldd	r24, Y+5	; 0x05
    3936:	88 23       	and	r24, r24
    3938:	81 f4       	brne	.+32     	; 0x395a <xQueueGenericReset+0xfa>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    393a:	89 81       	ldd	r24, Y+1	; 0x01
    393c:	9a 81       	ldd	r25, Y+2	; 0x02
    393e:	fc 01       	movw	r30, r24
    3940:	80 85       	ldd	r24, Z+8	; 0x08
    3942:	88 23       	and	r24, r24
    3944:	a1 f0       	breq	.+40     	; 0x396e <xQueueGenericReset+0x10e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    3946:	89 81       	ldd	r24, Y+1	; 0x01
    3948:	9a 81       	ldd	r25, Y+2	; 0x02
    394a:	08 96       	adiw	r24, 0x08	; 8
    394c:	0e 94 31 26 	call	0x4c62	; 0x4c62 <xTaskRemoveFromEventList>
    3950:	81 30       	cpi	r24, 0x01	; 1
    3952:	69 f4       	brne	.+26     	; 0x396e <xQueueGenericReset+0x10e>
				{
					portYIELD_WITHIN_API();
    3954:	0e 94 47 1b 	call	0x368e	; 0x368e <vPortYield>
    3958:	0a c0       	rjmp	.+20     	; 0x396e <xQueueGenericReset+0x10e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    395a:	89 81       	ldd	r24, Y+1	; 0x01
    395c:	9a 81       	ldd	r25, Y+2	; 0x02
    395e:	08 96       	adiw	r24, 0x08	; 8
    3960:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    3964:	89 81       	ldd	r24, Y+1	; 0x01
    3966:	9a 81       	ldd	r25, Y+2	; 0x02
    3968:	41 96       	adiw	r24, 0x11	; 17
    396a:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    396e:	0f 90       	pop	r0
    3970:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    3972:	81 e0       	ldi	r24, 0x01	; 1
}
    3974:	0f 90       	pop	r0
    3976:	0f 90       	pop	r0
    3978:	0f 90       	pop	r0
    397a:	0f 90       	pop	r0
    397c:	0f 90       	pop	r0
    397e:	df 91       	pop	r29
    3980:	cf 91       	pop	r28
    3982:	08 95       	ret

00003984 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    3984:	cf 93       	push	r28
    3986:	df 93       	push	r29
    3988:	cd b7       	in	r28, 0x3d	; 61
    398a:	de b7       	in	r29, 0x3e	; 62
    398c:	29 97       	sbiw	r28, 0x09	; 9
    398e:	0f b6       	in	r0, 0x3f	; 63
    3990:	f8 94       	cli
    3992:	de bf       	out	0x3e, r29	; 62
    3994:	0f be       	out	0x3f, r0	; 63
    3996:	cd bf       	out	0x3d, r28	; 61
    3998:	8f 83       	std	Y+7, r24	; 0x07
    399a:	68 87       	std	Y+8, r22	; 0x08
    399c:	49 87       	std	Y+9, r20	; 0x09
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    399e:	1a 82       	std	Y+2, r1	; 0x02
    39a0:	19 82       	std	Y+1, r1	; 0x01
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    39a2:	8f 81       	ldd	r24, Y+7	; 0x07
    39a4:	88 23       	and	r24, r24
    39a6:	09 f4       	brne	.+2      	; 0x39aa <xQueueGenericCreate+0x26>
    39a8:	43 c0       	rjmp	.+134    	; 0x3a30 <xQueueGenericCreate+0xac>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    39aa:	8f e1       	ldi	r24, 0x1F	; 31
    39ac:	90 e0       	ldi	r25, 0x00	; 0
    39ae:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <pvPortMalloc>
    39b2:	9c 83       	std	Y+4, r25	; 0x04
    39b4:	8b 83       	std	Y+3, r24	; 0x03
		if( pxNewQueue != NULL )
    39b6:	8b 81       	ldd	r24, Y+3	; 0x03
    39b8:	9c 81       	ldd	r25, Y+4	; 0x04
    39ba:	00 97       	sbiw	r24, 0x00	; 0
    39bc:	c9 f1       	breq	.+114    	; 0x3a30 <xQueueGenericCreate+0xac>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    39be:	8f 81       	ldd	r24, Y+7	; 0x07
    39c0:	48 2f       	mov	r20, r24
    39c2:	50 e0       	ldi	r21, 0x00	; 0
    39c4:	88 85       	ldd	r24, Y+8	; 0x08
    39c6:	28 2f       	mov	r18, r24
    39c8:	30 e0       	ldi	r19, 0x00	; 0
    39ca:	42 9f       	mul	r20, r18
    39cc:	c0 01       	movw	r24, r0
    39ce:	43 9f       	mul	r20, r19
    39d0:	90 0d       	add	r25, r0
    39d2:	52 9f       	mul	r21, r18
    39d4:	90 0d       	add	r25, r0
    39d6:	11 24       	eor	r1, r1
    39d8:	01 96       	adiw	r24, 0x01	; 1
    39da:	9e 83       	std	Y+6, r25	; 0x06
    39dc:	8d 83       	std	Y+5, r24	; 0x05

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    39de:	8d 81       	ldd	r24, Y+5	; 0x05
    39e0:	9e 81       	ldd	r25, Y+6	; 0x06
    39e2:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <pvPortMalloc>
    39e6:	9c 01       	movw	r18, r24
    39e8:	8b 81       	ldd	r24, Y+3	; 0x03
    39ea:	9c 81       	ldd	r25, Y+4	; 0x04
    39ec:	fc 01       	movw	r30, r24
    39ee:	31 83       	std	Z+1, r19	; 0x01
    39f0:	20 83       	st	Z, r18
			if( pxNewQueue->pcHead != NULL )
    39f2:	8b 81       	ldd	r24, Y+3	; 0x03
    39f4:	9c 81       	ldd	r25, Y+4	; 0x04
    39f6:	fc 01       	movw	r30, r24
    39f8:	80 81       	ld	r24, Z
    39fa:	91 81       	ldd	r25, Z+1	; 0x01
    39fc:	00 97       	sbiw	r24, 0x00	; 0
    39fe:	a1 f0       	breq	.+40     	; 0x3a28 <xQueueGenericCreate+0xa4>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    3a00:	8b 81       	ldd	r24, Y+3	; 0x03
    3a02:	9c 81       	ldd	r25, Y+4	; 0x04
    3a04:	2f 81       	ldd	r18, Y+7	; 0x07
    3a06:	fc 01       	movw	r30, r24
    3a08:	23 8f       	std	Z+27, r18	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    3a0a:	8b 81       	ldd	r24, Y+3	; 0x03
    3a0c:	9c 81       	ldd	r25, Y+4	; 0x04
    3a0e:	28 85       	ldd	r18, Y+8	; 0x08
    3a10:	fc 01       	movw	r30, r24
    3a12:	24 8f       	std	Z+28, r18	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
    3a14:	8b 81       	ldd	r24, Y+3	; 0x03
    3a16:	9c 81       	ldd	r25, Y+4	; 0x04
    3a18:	61 e0       	ldi	r22, 0x01	; 1
    3a1a:	0e 94 30 1c 	call	0x3860	; 0x3860 <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    3a1e:	8b 81       	ldd	r24, Y+3	; 0x03
    3a20:	9c 81       	ldd	r25, Y+4	; 0x04
    3a22:	9a 83       	std	Y+2, r25	; 0x02
    3a24:	89 83       	std	Y+1, r24	; 0x01
    3a26:	04 c0       	rjmp	.+8      	; 0x3a30 <xQueueGenericCreate+0xac>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    3a28:	8b 81       	ldd	r24, Y+3	; 0x03
    3a2a:	9c 81       	ldd	r25, Y+4	; 0x04
    3a2c:	0e 94 ba 17 	call	0x2f74	; 0x2f74 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    3a30:	89 81       	ldd	r24, Y+1	; 0x01
    3a32:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3a34:	29 96       	adiw	r28, 0x09	; 9
    3a36:	0f b6       	in	r0, 0x3f	; 63
    3a38:	f8 94       	cli
    3a3a:	de bf       	out	0x3e, r29	; 62
    3a3c:	0f be       	out	0x3f, r0	; 63
    3a3e:	cd bf       	out	0x3d, r28	; 61
    3a40:	df 91       	pop	r29
    3a42:	cf 91       	pop	r28
    3a44:	08 95       	ret

00003a46 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, uint32_t xTicksToWait, portBASE_TYPE xCopyPosition )
{
    3a46:	0f 93       	push	r16
    3a48:	cf 93       	push	r28
    3a4a:	df 93       	push	r29
    3a4c:	cd b7       	in	r28, 0x3d	; 61
    3a4e:	de b7       	in	r29, 0x3e	; 62
    3a50:	61 97       	sbiw	r28, 0x11	; 17
    3a52:	0f b6       	in	r0, 0x3f	; 63
    3a54:	f8 94       	cli
    3a56:	de bf       	out	0x3e, r29	; 62
    3a58:	0f be       	out	0x3f, r0	; 63
    3a5a:	cd bf       	out	0x3d, r28	; 61
    3a5c:	9a 87       	std	Y+10, r25	; 0x0a
    3a5e:	89 87       	std	Y+9, r24	; 0x09
    3a60:	7c 87       	std	Y+12, r23	; 0x0c
    3a62:	6b 87       	std	Y+11, r22	; 0x0b
    3a64:	2d 87       	std	Y+13, r18	; 0x0d
    3a66:	3e 87       	std	Y+14, r19	; 0x0e
    3a68:	4f 87       	std	Y+15, r20	; 0x0f
    3a6a:	58 8b       	std	Y+16, r21	; 0x10
    3a6c:	09 8b       	std	Y+17, r16	; 0x11
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    3a6e:	19 82       	std	Y+1, r1	; 0x01
xTimeOutType xTimeOut;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
    3a70:	89 85       	ldd	r24, Y+9	; 0x09
    3a72:	9a 85       	ldd	r25, Y+10	; 0x0a
    3a74:	9b 83       	std	Y+3, r25	; 0x03
    3a76:	8a 83       	std	Y+2, r24	; 0x02
    3a78:	01 c0       	rjmp	.+2      	; 0x3a7c <xQueueGenericSend+0x36>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    3a7a:	00 00       	nop
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3a7c:	0f b6       	in	r0, 0x3f	; 63
    3a7e:	f8 94       	cli
    3a80:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3a82:	8a 81       	ldd	r24, Y+2	; 0x02
    3a84:	9b 81       	ldd	r25, Y+3	; 0x03
    3a86:	fc 01       	movw	r30, r24
    3a88:	22 8d       	ldd	r18, Z+26	; 0x1a
    3a8a:	8a 81       	ldd	r24, Y+2	; 0x02
    3a8c:	9b 81       	ldd	r25, Y+3	; 0x03
    3a8e:	fc 01       	movw	r30, r24
    3a90:	83 8d       	ldd	r24, Z+27	; 0x1b
    3a92:	28 17       	cp	r18, r24
    3a94:	d8 f4       	brcc	.+54     	; 0x3acc <xQueueGenericSend+0x86>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3a96:	8a 81       	ldd	r24, Y+2	; 0x02
    3a98:	9b 81       	ldd	r25, Y+3	; 0x03
    3a9a:	2b 85       	ldd	r18, Y+11	; 0x0b
    3a9c:	3c 85       	ldd	r19, Y+12	; 0x0c
    3a9e:	b9 01       	movw	r22, r18
    3aa0:	49 89       	ldd	r20, Y+17	; 0x11
    3aa2:	0e 94 c1 1f 	call	0x3f82	; 0x3f82 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3aa6:	8a 81       	ldd	r24, Y+2	; 0x02
    3aa8:	9b 81       	ldd	r25, Y+3	; 0x03
    3aaa:	fc 01       	movw	r30, r24
    3aac:	81 89       	ldd	r24, Z+17	; 0x11
    3aae:	88 23       	and	r24, r24
    3ab0:	49 f0       	breq	.+18     	; 0x3ac4 <xQueueGenericSend+0x7e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    3ab2:	8a 81       	ldd	r24, Y+2	; 0x02
    3ab4:	9b 81       	ldd	r25, Y+3	; 0x03
    3ab6:	41 96       	adiw	r24, 0x11	; 17
    3ab8:	0e 94 31 26 	call	0x4c62	; 0x4c62 <xTaskRemoveFromEventList>
    3abc:	81 30       	cpi	r24, 0x01	; 1
    3abe:	11 f4       	brne	.+4      	; 0x3ac4 <xQueueGenericSend+0x7e>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							portYIELD_WITHIN_API();
    3ac0:	0e 94 47 1b 	call	0x368e	; 0x368e <vPortYield>
						}
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    3ac4:	0f 90       	pop	r0
    3ac6:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    3ac8:	81 e0       	ldi	r24, 0x01	; 1
    3aca:	6a c0       	rjmp	.+212    	; 0x3ba0 <xQueueGenericSend+0x15a>
			}
			else
			{
				if( xTicksToWait == ( uint32_t ) 0 )
    3acc:	8d 85       	ldd	r24, Y+13	; 0x0d
    3ace:	9e 85       	ldd	r25, Y+14	; 0x0e
    3ad0:	af 85       	ldd	r26, Y+15	; 0x0f
    3ad2:	b8 89       	ldd	r27, Y+16	; 0x10
    3ad4:	00 97       	sbiw	r24, 0x00	; 0
    3ad6:	a1 05       	cpc	r26, r1
    3ad8:	b1 05       	cpc	r27, r1
    3ada:	21 f4       	brne	.+8      	; 0x3ae4 <xQueueGenericSend+0x9e>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3adc:	0f 90       	pop	r0
    3ade:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3ae0:	80 e0       	ldi	r24, 0x00	; 0
    3ae2:	5e c0       	rjmp	.+188    	; 0x3ba0 <xQueueGenericSend+0x15a>
				}
				else if( xEntryTimeSet == pdFALSE )
    3ae4:	89 81       	ldd	r24, Y+1	; 0x01
    3ae6:	88 23       	and	r24, r24
    3ae8:	31 f4       	brne	.+12     	; 0x3af6 <xQueueGenericSend+0xb0>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3aea:	ce 01       	movw	r24, r28
    3aec:	04 96       	adiw	r24, 0x04	; 4
    3aee:	0e 94 9c 26 	call	0x4d38	; 0x4d38 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3af2:	81 e0       	ldi	r24, 0x01	; 1
    3af4:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    3af6:	0f 90       	pop	r0
    3af8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3afa:	0e 94 e7 23 	call	0x47ce	; 0x47ce <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3afe:	0f b6       	in	r0, 0x3f	; 63
    3b00:	f8 94       	cli
    3b02:	0f 92       	push	r0
    3b04:	8a 81       	ldd	r24, Y+2	; 0x02
    3b06:	9b 81       	ldd	r25, Y+3	; 0x03
    3b08:	fc 01       	movw	r30, r24
    3b0a:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b0c:	8f 3f       	cpi	r24, 0xFF	; 255
    3b0e:	21 f4       	brne	.+8      	; 0x3b18 <xQueueGenericSend+0xd2>
    3b10:	8a 81       	ldd	r24, Y+2	; 0x02
    3b12:	9b 81       	ldd	r25, Y+3	; 0x03
    3b14:	fc 01       	movw	r30, r24
    3b16:	15 8e       	std	Z+29, r1	; 0x1d
    3b18:	8a 81       	ldd	r24, Y+2	; 0x02
    3b1a:	9b 81       	ldd	r25, Y+3	; 0x03
    3b1c:	fc 01       	movw	r30, r24
    3b1e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3b20:	8f 3f       	cpi	r24, 0xFF	; 255
    3b22:	21 f4       	brne	.+8      	; 0x3b2c <xQueueGenericSend+0xe6>
    3b24:	8a 81       	ldd	r24, Y+2	; 0x02
    3b26:	9b 81       	ldd	r25, Y+3	; 0x03
    3b28:	fc 01       	movw	r30, r24
    3b2a:	16 8e       	std	Z+30, r1	; 0x1e
    3b2c:	0f 90       	pop	r0
    3b2e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3b30:	ce 01       	movw	r24, r28
    3b32:	04 96       	adiw	r24, 0x04	; 4
    3b34:	9e 01       	movw	r18, r28
    3b36:	23 5f       	subi	r18, 0xF3	; 243
    3b38:	3f 4f       	sbci	r19, 0xFF	; 255
    3b3a:	b9 01       	movw	r22, r18
    3b3c:	0e 94 bc 26 	call	0x4d78	; 0x4d78 <xTaskCheckForTimeOut>
    3b40:	88 23       	and	r24, r24
    3b42:	39 f5       	brne	.+78     	; 0x3b92 <xQueueGenericSend+0x14c>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3b44:	8a 81       	ldd	r24, Y+2	; 0x02
    3b46:	9b 81       	ldd	r25, Y+3	; 0x03
    3b48:	0e 94 5a 21 	call	0x42b4	; 0x42b4 <prvIsQueueFull>
    3b4c:	88 23       	and	r24, r24
    3b4e:	d1 f0       	breq	.+52     	; 0x3b84 <xQueueGenericSend+0x13e>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3b50:	8a 81       	ldd	r24, Y+2	; 0x02
    3b52:	9b 81       	ldd	r25, Y+3	; 0x03
    3b54:	ac 01       	movw	r20, r24
    3b56:	48 5f       	subi	r20, 0xF8	; 248
    3b58:	5f 4f       	sbci	r21, 0xFF	; 255
    3b5a:	8d 85       	ldd	r24, Y+13	; 0x0d
    3b5c:	9e 85       	ldd	r25, Y+14	; 0x0e
    3b5e:	af 85       	ldd	r26, Y+15	; 0x0f
    3b60:	b8 89       	ldd	r27, Y+16	; 0x10
    3b62:	9c 01       	movw	r18, r24
    3b64:	ca 01       	movw	r24, r20
    3b66:	b9 01       	movw	r22, r18
    3b68:	0e 94 fc 25 	call	0x4bf8	; 0x4bf8 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    3b6c:	8a 81       	ldd	r24, Y+2	; 0x02
    3b6e:	9b 81       	ldd	r25, Y+3	; 0x03
    3b70:	0e 94 bf 20 	call	0x417e	; 0x417e <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3b74:	0e 94 f3 23 	call	0x47e6	; 0x47e6 <xTaskResumeAll>
    3b78:	88 23       	and	r24, r24
    3b7a:	09 f0       	breq	.+2      	; 0x3b7e <xQueueGenericSend+0x138>
    3b7c:	7e cf       	rjmp	.-260    	; 0x3a7a <xQueueGenericSend+0x34>
				{
					portYIELD_WITHIN_API();
    3b7e:	0e 94 47 1b 	call	0x368e	; 0x368e <vPortYield>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    3b82:	7b cf       	rjmp	.-266    	; 0x3a7a <xQueueGenericSend+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3b84:	8a 81       	ldd	r24, Y+2	; 0x02
    3b86:	9b 81       	ldd	r25, Y+3	; 0x03
    3b88:	0e 94 bf 20 	call	0x417e	; 0x417e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3b8c:	0e 94 f3 23 	call	0x47e6	; 0x47e6 <xTaskResumeAll>
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
    3b90:	74 cf       	rjmp	.-280    	; 0x3a7a <xQueueGenericSend+0x34>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3b92:	8a 81       	ldd	r24, Y+2	; 0x02
    3b94:	9b 81       	ldd	r25, Y+3	; 0x03
    3b96:	0e 94 bf 20 	call	0x417e	; 0x417e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3b9a:	0e 94 f3 23 	call	0x47e6	; 0x47e6 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    3b9e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    3ba0:	61 96       	adiw	r28, 0x11	; 17
    3ba2:	0f b6       	in	r0, 0x3f	; 63
    3ba4:	f8 94       	cli
    3ba6:	de bf       	out	0x3e, r29	; 62
    3ba8:	0f be       	out	0x3f, r0	; 63
    3baa:	cd bf       	out	0x3d, r28	; 61
    3bac:	df 91       	pop	r29
    3bae:	cf 91       	pop	r28
    3bb0:	0f 91       	pop	r16
    3bb2:	08 95       	ret

00003bb4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    3bb4:	cf 93       	push	r28
    3bb6:	df 93       	push	r29
    3bb8:	cd b7       	in	r28, 0x3d	; 61
    3bba:	de b7       	in	r29, 0x3e	; 62
    3bbc:	2b 97       	sbiw	r28, 0x0b	; 11
    3bbe:	0f b6       	in	r0, 0x3f	; 63
    3bc0:	f8 94       	cli
    3bc2:	de bf       	out	0x3e, r29	; 62
    3bc4:	0f be       	out	0x3f, r0	; 63
    3bc6:	cd bf       	out	0x3d, r28	; 61
    3bc8:	9e 83       	std	Y+6, r25	; 0x06
    3bca:	8d 83       	std	Y+5, r24	; 0x05
    3bcc:	78 87       	std	Y+8, r23	; 0x08
    3bce:	6f 83       	std	Y+7, r22	; 0x07
    3bd0:	5a 87       	std	Y+10, r21	; 0x0a
    3bd2:	49 87       	std	Y+9, r20	; 0x09
    3bd4:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
    3bd6:	8d 81       	ldd	r24, Y+5	; 0x05
    3bd8:	9e 81       	ldd	r25, Y+6	; 0x06
    3bda:	9b 83       	std	Y+3, r25	; 0x03
    3bdc:	8a 83       	std	Y+2, r24	; 0x02
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3bde:	1c 82       	std	Y+4, r1	; 0x04
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3be0:	8a 81       	ldd	r24, Y+2	; 0x02
    3be2:	9b 81       	ldd	r25, Y+3	; 0x03
    3be4:	fc 01       	movw	r30, r24
    3be6:	22 8d       	ldd	r18, Z+26	; 0x1a
    3be8:	8a 81       	ldd	r24, Y+2	; 0x02
    3bea:	9b 81       	ldd	r25, Y+3	; 0x03
    3bec:	fc 01       	movw	r30, r24
    3bee:	83 8d       	ldd	r24, Z+27	; 0x1b
    3bf0:	28 17       	cp	r18, r24
    3bf2:	90 f5       	brcc	.+100    	; 0x3c58 <xQueueGenericSendFromISR+0xa4>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3bf4:	8a 81       	ldd	r24, Y+2	; 0x02
    3bf6:	9b 81       	ldd	r25, Y+3	; 0x03
    3bf8:	2f 81       	ldd	r18, Y+7	; 0x07
    3bfa:	38 85       	ldd	r19, Y+8	; 0x08
    3bfc:	b9 01       	movw	r22, r18
    3bfe:	4b 85       	ldd	r20, Y+11	; 0x0b
    3c00:	0e 94 c1 1f 	call	0x3f82	; 0x3f82 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3c04:	8a 81       	ldd	r24, Y+2	; 0x02
    3c06:	9b 81       	ldd	r25, Y+3	; 0x03
    3c08:	fc 01       	movw	r30, r24
    3c0a:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c0c:	8f 3f       	cpi	r24, 0xFF	; 255
    3c0e:	b9 f4       	brne	.+46     	; 0x3c3e <xQueueGenericSendFromISR+0x8a>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3c10:	8a 81       	ldd	r24, Y+2	; 0x02
    3c12:	9b 81       	ldd	r25, Y+3	; 0x03
    3c14:	fc 01       	movw	r30, r24
    3c16:	81 89       	ldd	r24, Z+17	; 0x11
    3c18:	88 23       	and	r24, r24
    3c1a:	d9 f0       	breq	.+54     	; 0x3c52 <xQueueGenericSendFromISR+0x9e>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3c1c:	8a 81       	ldd	r24, Y+2	; 0x02
    3c1e:	9b 81       	ldd	r25, Y+3	; 0x03
    3c20:	41 96       	adiw	r24, 0x11	; 17
    3c22:	0e 94 31 26 	call	0x4c62	; 0x4c62 <xTaskRemoveFromEventList>
    3c26:	88 23       	and	r24, r24
    3c28:	a1 f0       	breq	.+40     	; 0x3c52 <xQueueGenericSendFromISR+0x9e>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3c2a:	89 85       	ldd	r24, Y+9	; 0x09
    3c2c:	9a 85       	ldd	r25, Y+10	; 0x0a
    3c2e:	00 97       	sbiw	r24, 0x00	; 0
    3c30:	81 f0       	breq	.+32     	; 0x3c52 <xQueueGenericSendFromISR+0x9e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    3c32:	89 85       	ldd	r24, Y+9	; 0x09
    3c34:	9a 85       	ldd	r25, Y+10	; 0x0a
    3c36:	21 e0       	ldi	r18, 0x01	; 1
    3c38:	fc 01       	movw	r30, r24
    3c3a:	20 83       	st	Z, r18
    3c3c:	0a c0       	rjmp	.+20     	; 0x3c52 <xQueueGenericSendFromISR+0x9e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3c3e:	8a 81       	ldd	r24, Y+2	; 0x02
    3c40:	9b 81       	ldd	r25, Y+3	; 0x03
    3c42:	fc 01       	movw	r30, r24
    3c44:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c46:	28 2f       	mov	r18, r24
    3c48:	2f 5f       	subi	r18, 0xFF	; 255
    3c4a:	8a 81       	ldd	r24, Y+2	; 0x02
    3c4c:	9b 81       	ldd	r25, Y+3	; 0x03
    3c4e:	fc 01       	movw	r30, r24
    3c50:	26 8f       	std	Z+30, r18	; 0x1e
			}

			xReturn = pdPASS;
    3c52:	81 e0       	ldi	r24, 0x01	; 1
    3c54:	89 83       	std	Y+1, r24	; 0x01
    3c56:	01 c0       	rjmp	.+2      	; 0x3c5a <xQueueGenericSendFromISR+0xa6>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3c58:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3c5a:	89 81       	ldd	r24, Y+1	; 0x01
}
    3c5c:	2b 96       	adiw	r28, 0x0b	; 11
    3c5e:	0f b6       	in	r0, 0x3f	; 63
    3c60:	f8 94       	cli
    3c62:	de bf       	out	0x3e, r29	; 62
    3c64:	0f be       	out	0x3f, r0	; 63
    3c66:	cd bf       	out	0x3d, r28	; 61
    3c68:	df 91       	pop	r29
    3c6a:	cf 91       	pop	r28
    3c6c:	08 95       	ret

00003c6e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, uint32_t xTicksToWait, portBASE_TYPE xJustPeeking )
{
    3c6e:	0f 93       	push	r16
    3c70:	cf 93       	push	r28
    3c72:	df 93       	push	r29
    3c74:	cd b7       	in	r28, 0x3d	; 61
    3c76:	de b7       	in	r29, 0x3e	; 62
    3c78:	63 97       	sbiw	r28, 0x13	; 19
    3c7a:	0f b6       	in	r0, 0x3f	; 63
    3c7c:	f8 94       	cli
    3c7e:	de bf       	out	0x3e, r29	; 62
    3c80:	0f be       	out	0x3f, r0	; 63
    3c82:	cd bf       	out	0x3d, r28	; 61
    3c84:	9c 87       	std	Y+12, r25	; 0x0c
    3c86:	8b 87       	std	Y+11, r24	; 0x0b
    3c88:	7e 87       	std	Y+14, r23	; 0x0e
    3c8a:	6d 87       	std	Y+13, r22	; 0x0d
    3c8c:	2f 87       	std	Y+15, r18	; 0x0f
    3c8e:	38 8b       	std	Y+16, r19	; 0x10
    3c90:	49 8b       	std	Y+17, r20	; 0x11
    3c92:	5a 8b       	std	Y+18, r21	; 0x12
    3c94:	0b 8b       	std	Y+19, r16	; 0x13
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    3c96:	19 82       	std	Y+1, r1	; 0x01
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
    3c98:	8b 85       	ldd	r24, Y+11	; 0x0b
    3c9a:	9c 85       	ldd	r25, Y+12	; 0x0c
    3c9c:	9b 83       	std	Y+3, r25	; 0x03
    3c9e:	8a 83       	std	Y+2, r24	; 0x02
    3ca0:	01 c0       	rjmp	.+2      	; 0x3ca4 <xQueueGenericReceive+0x36>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    3ca2:	00 00       	nop
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    3ca4:	0f b6       	in	r0, 0x3f	; 63
    3ca6:	f8 94       	cli
    3ca8:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3caa:	8a 81       	ldd	r24, Y+2	; 0x02
    3cac:	9b 81       	ldd	r25, Y+3	; 0x03
    3cae:	fc 01       	movw	r30, r24
    3cb0:	82 8d       	ldd	r24, Z+26	; 0x1a
    3cb2:	88 23       	and	r24, r24
    3cb4:	09 f4       	brne	.+2      	; 0x3cb8 <xQueueGenericReceive+0x4a>
    3cb6:	45 c0       	rjmp	.+138    	; 0x3d42 <xQueueGenericReceive+0xd4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    3cb8:	8a 81       	ldd	r24, Y+2	; 0x02
    3cba:	9b 81       	ldd	r25, Y+3	; 0x03
    3cbc:	fc 01       	movw	r30, r24
    3cbe:	86 81       	ldd	r24, Z+6	; 0x06
    3cc0:	97 81       	ldd	r25, Z+7	; 0x07
    3cc2:	9d 83       	std	Y+5, r25	; 0x05
    3cc4:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3cc6:	8a 81       	ldd	r24, Y+2	; 0x02
    3cc8:	9b 81       	ldd	r25, Y+3	; 0x03
    3cca:	2d 85       	ldd	r18, Y+13	; 0x0d
    3ccc:	3e 85       	ldd	r19, Y+14	; 0x0e
    3cce:	b9 01       	movw	r22, r18
    3cd0:	0e 94 6d 20 	call	0x40da	; 0x40da <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    3cd4:	8b 89       	ldd	r24, Y+19	; 0x13
    3cd6:	88 23       	and	r24, r24
    3cd8:	d1 f4       	brne	.+52     	; 0x3d0e <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    3cda:	8a 81       	ldd	r24, Y+2	; 0x02
    3cdc:	9b 81       	ldd	r25, Y+3	; 0x03
    3cde:	fc 01       	movw	r30, r24
    3ce0:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ce2:	28 2f       	mov	r18, r24
    3ce4:	21 50       	subi	r18, 0x01	; 1
    3ce6:	8a 81       	ldd	r24, Y+2	; 0x02
    3ce8:	9b 81       	ldd	r25, Y+3	; 0x03
    3cea:	fc 01       	movw	r30, r24
    3cec:	22 8f       	std	Z+26, r18	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3cee:	8a 81       	ldd	r24, Y+2	; 0x02
    3cf0:	9b 81       	ldd	r25, Y+3	; 0x03
    3cf2:	fc 01       	movw	r30, r24
    3cf4:	80 85       	ldd	r24, Z+8	; 0x08
    3cf6:	88 23       	and	r24, r24
    3cf8:	01 f1       	breq	.+64     	; 0x3d3a <xQueueGenericReceive+0xcc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    3cfa:	8a 81       	ldd	r24, Y+2	; 0x02
    3cfc:	9b 81       	ldd	r25, Y+3	; 0x03
    3cfe:	08 96       	adiw	r24, 0x08	; 8
    3d00:	0e 94 31 26 	call	0x4c62	; 0x4c62 <xTaskRemoveFromEventList>
    3d04:	81 30       	cpi	r24, 0x01	; 1
    3d06:	c9 f4       	brne	.+50     	; 0x3d3a <xQueueGenericReceive+0xcc>
						{
							portYIELD_WITHIN_API();
    3d08:	0e 94 47 1b 	call	0x368e	; 0x368e <vPortYield>
    3d0c:	16 c0       	rjmp	.+44     	; 0x3d3a <xQueueGenericReceive+0xcc>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    3d0e:	8a 81       	ldd	r24, Y+2	; 0x02
    3d10:	9b 81       	ldd	r25, Y+3	; 0x03
    3d12:	2c 81       	ldd	r18, Y+4	; 0x04
    3d14:	3d 81       	ldd	r19, Y+5	; 0x05
    3d16:	fc 01       	movw	r30, r24
    3d18:	37 83       	std	Z+7, r19	; 0x07
    3d1a:	26 83       	std	Z+6, r18	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3d1c:	8a 81       	ldd	r24, Y+2	; 0x02
    3d1e:	9b 81       	ldd	r25, Y+3	; 0x03
    3d20:	fc 01       	movw	r30, r24
    3d22:	81 89       	ldd	r24, Z+17	; 0x11
    3d24:	88 23       	and	r24, r24
    3d26:	49 f0       	breq	.+18     	; 0x3d3a <xQueueGenericReceive+0xcc>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3d28:	8a 81       	ldd	r24, Y+2	; 0x02
    3d2a:	9b 81       	ldd	r25, Y+3	; 0x03
    3d2c:	41 96       	adiw	r24, 0x11	; 17
    3d2e:	0e 94 31 26 	call	0x4c62	; 0x4c62 <xTaskRemoveFromEventList>
    3d32:	88 23       	and	r24, r24
    3d34:	11 f0       	breq	.+4      	; 0x3d3a <xQueueGenericReceive+0xcc>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    3d36:	0e 94 47 1b 	call	0x368e	; 0x368e <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    3d3a:	0f 90       	pop	r0
    3d3c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3d3e:	81 e0       	ldi	r24, 0x01	; 1
    3d40:	6a c0       	rjmp	.+212    	; 0x3e16 <xQueueGenericReceive+0x1a8>
			}
			else
			{
				if( xTicksToWait == ( uint32_t ) 0 )
    3d42:	8f 85       	ldd	r24, Y+15	; 0x0f
    3d44:	98 89       	ldd	r25, Y+16	; 0x10
    3d46:	a9 89       	ldd	r26, Y+17	; 0x11
    3d48:	ba 89       	ldd	r27, Y+18	; 0x12
    3d4a:	00 97       	sbiw	r24, 0x00	; 0
    3d4c:	a1 05       	cpc	r26, r1
    3d4e:	b1 05       	cpc	r27, r1
    3d50:	21 f4       	brne	.+8      	; 0x3d5a <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3d52:	0f 90       	pop	r0
    3d54:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3d56:	80 e0       	ldi	r24, 0x00	; 0
    3d58:	5e c0       	rjmp	.+188    	; 0x3e16 <xQueueGenericReceive+0x1a8>
				}
				else if( xEntryTimeSet == pdFALSE )
    3d5a:	89 81       	ldd	r24, Y+1	; 0x01
    3d5c:	88 23       	and	r24, r24
    3d5e:	31 f4       	brne	.+12     	; 0x3d6c <xQueueGenericReceive+0xfe>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3d60:	ce 01       	movw	r24, r28
    3d62:	06 96       	adiw	r24, 0x06	; 6
    3d64:	0e 94 9c 26 	call	0x4d38	; 0x4d38 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3d68:	81 e0       	ldi	r24, 0x01	; 1
    3d6a:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    3d6c:	0f 90       	pop	r0
    3d6e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3d70:	0e 94 e7 23 	call	0x47ce	; 0x47ce <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3d74:	0f b6       	in	r0, 0x3f	; 63
    3d76:	f8 94       	cli
    3d78:	0f 92       	push	r0
    3d7a:	8a 81       	ldd	r24, Y+2	; 0x02
    3d7c:	9b 81       	ldd	r25, Y+3	; 0x03
    3d7e:	fc 01       	movw	r30, r24
    3d80:	85 8d       	ldd	r24, Z+29	; 0x1d
    3d82:	8f 3f       	cpi	r24, 0xFF	; 255
    3d84:	21 f4       	brne	.+8      	; 0x3d8e <xQueueGenericReceive+0x120>
    3d86:	8a 81       	ldd	r24, Y+2	; 0x02
    3d88:	9b 81       	ldd	r25, Y+3	; 0x03
    3d8a:	fc 01       	movw	r30, r24
    3d8c:	15 8e       	std	Z+29, r1	; 0x1d
    3d8e:	8a 81       	ldd	r24, Y+2	; 0x02
    3d90:	9b 81       	ldd	r25, Y+3	; 0x03
    3d92:	fc 01       	movw	r30, r24
    3d94:	86 8d       	ldd	r24, Z+30	; 0x1e
    3d96:	8f 3f       	cpi	r24, 0xFF	; 255
    3d98:	21 f4       	brne	.+8      	; 0x3da2 <xQueueGenericReceive+0x134>
    3d9a:	8a 81       	ldd	r24, Y+2	; 0x02
    3d9c:	9b 81       	ldd	r25, Y+3	; 0x03
    3d9e:	fc 01       	movw	r30, r24
    3da0:	16 8e       	std	Z+30, r1	; 0x1e
    3da2:	0f 90       	pop	r0
    3da4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3da6:	ce 01       	movw	r24, r28
    3da8:	06 96       	adiw	r24, 0x06	; 6
    3daa:	9e 01       	movw	r18, r28
    3dac:	21 5f       	subi	r18, 0xF1	; 241
    3dae:	3f 4f       	sbci	r19, 0xFF	; 255
    3db0:	b9 01       	movw	r22, r18
    3db2:	0e 94 bc 26 	call	0x4d78	; 0x4d78 <xTaskCheckForTimeOut>
    3db6:	88 23       	and	r24, r24
    3db8:	39 f5       	brne	.+78     	; 0x3e08 <xQueueGenericReceive+0x19a>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3dba:	8a 81       	ldd	r24, Y+2	; 0x02
    3dbc:	9b 81       	ldd	r25, Y+3	; 0x03
    3dbe:	0e 94 23 21 	call	0x4246	; 0x4246 <prvIsQueueEmpty>
    3dc2:	88 23       	and	r24, r24
    3dc4:	d1 f0       	breq	.+52     	; 0x3dfa <xQueueGenericReceive+0x18c>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3dc6:	8a 81       	ldd	r24, Y+2	; 0x02
    3dc8:	9b 81       	ldd	r25, Y+3	; 0x03
    3dca:	ac 01       	movw	r20, r24
    3dcc:	4f 5e       	subi	r20, 0xEF	; 239
    3dce:	5f 4f       	sbci	r21, 0xFF	; 255
    3dd0:	8f 85       	ldd	r24, Y+15	; 0x0f
    3dd2:	98 89       	ldd	r25, Y+16	; 0x10
    3dd4:	a9 89       	ldd	r26, Y+17	; 0x11
    3dd6:	ba 89       	ldd	r27, Y+18	; 0x12
    3dd8:	9c 01       	movw	r18, r24
    3dda:	ca 01       	movw	r24, r20
    3ddc:	b9 01       	movw	r22, r18
    3dde:	0e 94 fc 25 	call	0x4bf8	; 0x4bf8 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    3de2:	8a 81       	ldd	r24, Y+2	; 0x02
    3de4:	9b 81       	ldd	r25, Y+3	; 0x03
    3de6:	0e 94 bf 20 	call	0x417e	; 0x417e <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    3dea:	0e 94 f3 23 	call	0x47e6	; 0x47e6 <xTaskResumeAll>
    3dee:	88 23       	and	r24, r24
    3df0:	09 f0       	breq	.+2      	; 0x3df4 <xQueueGenericReceive+0x186>
    3df2:	57 cf       	rjmp	.-338    	; 0x3ca2 <xQueueGenericReceive+0x34>
				{
					portYIELD_WITHIN_API();
    3df4:	0e 94 47 1b 	call	0x368e	; 0x368e <vPortYield>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    3df8:	54 cf       	rjmp	.-344    	; 0x3ca2 <xQueueGenericReceive+0x34>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3dfa:	8a 81       	ldd	r24, Y+2	; 0x02
    3dfc:	9b 81       	ldd	r25, Y+3	; 0x03
    3dfe:	0e 94 bf 20 	call	0x417e	; 0x417e <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3e02:	0e 94 f3 23 	call	0x47e6	; 0x47e6 <xTaskResumeAll>
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
    3e06:	4d cf       	rjmp	.-358    	; 0x3ca2 <xQueueGenericReceive+0x34>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    3e08:	8a 81       	ldd	r24, Y+2	; 0x02
    3e0a:	9b 81       	ldd	r25, Y+3	; 0x03
    3e0c:	0e 94 bf 20 	call	0x417e	; 0x417e <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3e10:	0e 94 f3 23 	call	0x47e6	; 0x47e6 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    3e14:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    3e16:	63 96       	adiw	r28, 0x13	; 19
    3e18:	0f b6       	in	r0, 0x3f	; 63
    3e1a:	f8 94       	cli
    3e1c:	de bf       	out	0x3e, r29	; 62
    3e1e:	0f be       	out	0x3f, r0	; 63
    3e20:	cd bf       	out	0x3d, r28	; 61
    3e22:	df 91       	pop	r29
    3e24:	cf 91       	pop	r28
    3e26:	0f 91       	pop	r16
    3e28:	08 95       	ret

00003e2a <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    3e2a:	cf 93       	push	r28
    3e2c:	df 93       	push	r29
    3e2e:	cd b7       	in	r28, 0x3d	; 61
    3e30:	de b7       	in	r29, 0x3e	; 62
    3e32:	2a 97       	sbiw	r28, 0x0a	; 10
    3e34:	0f b6       	in	r0, 0x3f	; 63
    3e36:	f8 94       	cli
    3e38:	de bf       	out	0x3e, r29	; 62
    3e3a:	0f be       	out	0x3f, r0	; 63
    3e3c:	cd bf       	out	0x3d, r28	; 61
    3e3e:	9e 83       	std	Y+6, r25	; 0x06
    3e40:	8d 83       	std	Y+5, r24	; 0x05
    3e42:	78 87       	std	Y+8, r23	; 0x08
    3e44:	6f 83       	std	Y+7, r22	; 0x07
    3e46:	5a 87       	std	Y+10, r21	; 0x0a
    3e48:	49 87       	std	Y+9, r20	; 0x09
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
    3e4a:	8d 81       	ldd	r24, Y+5	; 0x05
    3e4c:	9e 81       	ldd	r25, Y+6	; 0x06
    3e4e:	9b 83       	std	Y+3, r25	; 0x03
    3e50:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxQueue );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3e52:	1c 82       	std	Y+4, r1	; 0x04
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3e54:	8a 81       	ldd	r24, Y+2	; 0x02
    3e56:	9b 81       	ldd	r25, Y+3	; 0x03
    3e58:	fc 01       	movw	r30, r24
    3e5a:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e5c:	88 23       	and	r24, r24
    3e5e:	d9 f1       	breq	.+118    	; 0x3ed6 <xQueueReceiveFromISR+0xac>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    3e60:	8a 81       	ldd	r24, Y+2	; 0x02
    3e62:	9b 81       	ldd	r25, Y+3	; 0x03
    3e64:	2f 81       	ldd	r18, Y+7	; 0x07
    3e66:	38 85       	ldd	r19, Y+8	; 0x08
    3e68:	b9 01       	movw	r22, r18
    3e6a:	0e 94 6d 20 	call	0x40da	; 0x40da <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    3e6e:	8a 81       	ldd	r24, Y+2	; 0x02
    3e70:	9b 81       	ldd	r25, Y+3	; 0x03
    3e72:	fc 01       	movw	r30, r24
    3e74:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e76:	28 2f       	mov	r18, r24
    3e78:	21 50       	subi	r18, 0x01	; 1
    3e7a:	8a 81       	ldd	r24, Y+2	; 0x02
    3e7c:	9b 81       	ldd	r25, Y+3	; 0x03
    3e7e:	fc 01       	movw	r30, r24
    3e80:	22 8f       	std	Z+26, r18	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    3e82:	8a 81       	ldd	r24, Y+2	; 0x02
    3e84:	9b 81       	ldd	r25, Y+3	; 0x03
    3e86:	fc 01       	movw	r30, r24
    3e88:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e8a:	8f 3f       	cpi	r24, 0xFF	; 255
    3e8c:	b9 f4       	brne	.+46     	; 0x3ebc <xQueueReceiveFromISR+0x92>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3e8e:	8a 81       	ldd	r24, Y+2	; 0x02
    3e90:	9b 81       	ldd	r25, Y+3	; 0x03
    3e92:	fc 01       	movw	r30, r24
    3e94:	80 85       	ldd	r24, Z+8	; 0x08
    3e96:	88 23       	and	r24, r24
    3e98:	d9 f0       	breq	.+54     	; 0x3ed0 <xQueueReceiveFromISR+0xa6>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3e9a:	8a 81       	ldd	r24, Y+2	; 0x02
    3e9c:	9b 81       	ldd	r25, Y+3	; 0x03
    3e9e:	08 96       	adiw	r24, 0x08	; 8
    3ea0:	0e 94 31 26 	call	0x4c62	; 0x4c62 <xTaskRemoveFromEventList>
    3ea4:	88 23       	and	r24, r24
    3ea6:	a1 f0       	breq	.+40     	; 0x3ed0 <xQueueReceiveFromISR+0xa6>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    3ea8:	89 85       	ldd	r24, Y+9	; 0x09
    3eaa:	9a 85       	ldd	r25, Y+10	; 0x0a
    3eac:	00 97       	sbiw	r24, 0x00	; 0
    3eae:	81 f0       	breq	.+32     	; 0x3ed0 <xQueueReceiveFromISR+0xa6>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    3eb0:	89 85       	ldd	r24, Y+9	; 0x09
    3eb2:	9a 85       	ldd	r25, Y+10	; 0x0a
    3eb4:	21 e0       	ldi	r18, 0x01	; 1
    3eb6:	fc 01       	movw	r30, r24
    3eb8:	20 83       	st	Z, r18
    3eba:	0a c0       	rjmp	.+20     	; 0x3ed0 <xQueueReceiveFromISR+0xa6>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    3ebc:	8a 81       	ldd	r24, Y+2	; 0x02
    3ebe:	9b 81       	ldd	r25, Y+3	; 0x03
    3ec0:	fc 01       	movw	r30, r24
    3ec2:	85 8d       	ldd	r24, Z+29	; 0x1d
    3ec4:	28 2f       	mov	r18, r24
    3ec6:	2f 5f       	subi	r18, 0xFF	; 255
    3ec8:	8a 81       	ldd	r24, Y+2	; 0x02
    3eca:	9b 81       	ldd	r25, Y+3	; 0x03
    3ecc:	fc 01       	movw	r30, r24
    3ece:	25 8f       	std	Z+29, r18	; 0x1d
			}

			xReturn = pdPASS;
    3ed0:	81 e0       	ldi	r24, 0x01	; 1
    3ed2:	89 83       	std	Y+1, r24	; 0x01
    3ed4:	01 c0       	rjmp	.+2      	; 0x3ed8 <xQueueReceiveFromISR+0xae>
		}
		else
		{
			xReturn = pdFAIL;
    3ed6:	19 82       	std	Y+1, r1	; 0x01
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3ed8:	89 81       	ldd	r24, Y+1	; 0x01
}
    3eda:	2a 96       	adiw	r28, 0x0a	; 10
    3edc:	0f b6       	in	r0, 0x3f	; 63
    3ede:	f8 94       	cli
    3ee0:	de bf       	out	0x3e, r29	; 62
    3ee2:	0f be       	out	0x3f, r0	; 63
    3ee4:	cd bf       	out	0x3d, r28	; 61
    3ee6:	df 91       	pop	r29
    3ee8:	cf 91       	pop	r28
    3eea:	08 95       	ret

00003eec <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle xQueue )
{
    3eec:	cf 93       	push	r28
    3eee:	df 93       	push	r29
    3ef0:	00 d0       	rcall	.+0      	; 0x3ef2 <uxQueueMessagesWaiting+0x6>
    3ef2:	0f 92       	push	r0
    3ef4:	cd b7       	in	r28, 0x3d	; 61
    3ef6:	de b7       	in	r29, 0x3e	; 62
    3ef8:	9b 83       	std	Y+3, r25	; 0x03
    3efa:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    3efc:	0f b6       	in	r0, 0x3f	; 63
    3efe:	f8 94       	cli
    3f00:	0f 92       	push	r0
		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
    3f02:	8a 81       	ldd	r24, Y+2	; 0x02
    3f04:	9b 81       	ldd	r25, Y+3	; 0x03
    3f06:	fc 01       	movw	r30, r24
    3f08:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f0a:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    3f0c:	0f 90       	pop	r0
    3f0e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    3f10:	89 81       	ldd	r24, Y+1	; 0x01
}
    3f12:	0f 90       	pop	r0
    3f14:	0f 90       	pop	r0
    3f16:	0f 90       	pop	r0
    3f18:	df 91       	pop	r29
    3f1a:	cf 91       	pop	r28
    3f1c:	08 95       	ret

00003f1e <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle xQueue )
{
    3f1e:	cf 93       	push	r28
    3f20:	df 93       	push	r29
    3f22:	00 d0       	rcall	.+0      	; 0x3f24 <uxQueueMessagesWaitingFromISR+0x6>
    3f24:	0f 92       	push	r0
    3f26:	cd b7       	in	r28, 0x3d	; 61
    3f28:	de b7       	in	r29, 0x3e	; 62
    3f2a:	9b 83       	std	Y+3, r25	; 0x03
    3f2c:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
    3f2e:	8a 81       	ldd	r24, Y+2	; 0x02
    3f30:	9b 81       	ldd	r25, Y+3	; 0x03
    3f32:	fc 01       	movw	r30, r24
    3f34:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f36:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    3f38:	89 81       	ldd	r24, Y+1	; 0x01
}
    3f3a:	0f 90       	pop	r0
    3f3c:	0f 90       	pop	r0
    3f3e:	0f 90       	pop	r0
    3f40:	df 91       	pop	r29
    3f42:	cf 91       	pop	r28
    3f44:	08 95       	ret

00003f46 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle xQueue )
{
    3f46:	cf 93       	push	r28
    3f48:	df 93       	push	r29
    3f4a:	00 d0       	rcall	.+0      	; 0x3f4c <vQueueDelete+0x6>
    3f4c:	00 d0       	rcall	.+0      	; 0x3f4e <vQueueDelete+0x8>
    3f4e:	cd b7       	in	r28, 0x3d	; 61
    3f50:	de b7       	in	r29, 0x3e	; 62
    3f52:	9c 83       	std	Y+4, r25	; 0x04
    3f54:	8b 83       	std	Y+3, r24	; 0x03
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
    3f56:	8b 81       	ldd	r24, Y+3	; 0x03
    3f58:	9c 81       	ldd	r25, Y+4	; 0x04
    3f5a:	9a 83       	std	Y+2, r25	; 0x02
    3f5c:	89 83       	std	Y+1, r24	; 0x01
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		prvQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue->pcHead );
    3f5e:	89 81       	ldd	r24, Y+1	; 0x01
    3f60:	9a 81       	ldd	r25, Y+2	; 0x02
    3f62:	fc 01       	movw	r30, r24
    3f64:	80 81       	ld	r24, Z
    3f66:	91 81       	ldd	r25, Z+1	; 0x01
    3f68:	0e 94 ba 17 	call	0x2f74	; 0x2f74 <vPortFree>
	vPortFree( pxQueue );
    3f6c:	89 81       	ldd	r24, Y+1	; 0x01
    3f6e:	9a 81       	ldd	r25, Y+2	; 0x02
    3f70:	0e 94 ba 17 	call	0x2f74	; 0x2f74 <vPortFree>
}
    3f74:	0f 90       	pop	r0
    3f76:	0f 90       	pop	r0
    3f78:	0f 90       	pop	r0
    3f7a:	0f 90       	pop	r0
    3f7c:	df 91       	pop	r29
    3f7e:	cf 91       	pop	r28
    3f80:	08 95       	ret

00003f82 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    3f82:	cf 93       	push	r28
    3f84:	df 93       	push	r29
    3f86:	00 d0       	rcall	.+0      	; 0x3f88 <prvCopyDataToQueue+0x6>
    3f88:	00 d0       	rcall	.+0      	; 0x3f8a <prvCopyDataToQueue+0x8>
    3f8a:	0f 92       	push	r0
    3f8c:	cd b7       	in	r28, 0x3d	; 61
    3f8e:	de b7       	in	r29, 0x3e	; 62
    3f90:	9a 83       	std	Y+2, r25	; 0x02
    3f92:	89 83       	std	Y+1, r24	; 0x01
    3f94:	7c 83       	std	Y+4, r23	; 0x04
    3f96:	6b 83       	std	Y+3, r22	; 0x03
    3f98:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    3f9a:	89 81       	ldd	r24, Y+1	; 0x01
    3f9c:	9a 81       	ldd	r25, Y+2	; 0x02
    3f9e:	fc 01       	movw	r30, r24
    3fa0:	84 8d       	ldd	r24, Z+28	; 0x1c
    3fa2:	88 23       	and	r24, r24
    3fa4:	09 f4       	brne	.+2      	; 0x3fa8 <prvCopyDataToQueue+0x26>
    3fa6:	87 c0       	rjmp	.+270    	; 0x40b6 <prvCopyDataToQueue+0x134>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    3fa8:	8d 81       	ldd	r24, Y+5	; 0x05
    3faa:	88 23       	and	r24, r24
    3fac:	e1 f5       	brne	.+120    	; 0x4026 <prvCopyDataToQueue+0xa4>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    3fae:	89 81       	ldd	r24, Y+1	; 0x01
    3fb0:	9a 81       	ldd	r25, Y+2	; 0x02
    3fb2:	fc 01       	movw	r30, r24
    3fb4:	84 81       	ldd	r24, Z+4	; 0x04
    3fb6:	95 81       	ldd	r25, Z+5	; 0x05
    3fb8:	29 81       	ldd	r18, Y+1	; 0x01
    3fba:	3a 81       	ldd	r19, Y+2	; 0x02
    3fbc:	f9 01       	movw	r30, r18
    3fbe:	24 8d       	ldd	r18, Z+28	; 0x1c
    3fc0:	22 2f       	mov	r18, r18
    3fc2:	30 e0       	ldi	r19, 0x00	; 0
    3fc4:	4b 81       	ldd	r20, Y+3	; 0x03
    3fc6:	5c 81       	ldd	r21, Y+4	; 0x04
    3fc8:	ba 01       	movw	r22, r20
    3fca:	a9 01       	movw	r20, r18
    3fcc:	0e 94 a5 36 	call	0x6d4a	; 0x6d4a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    3fd0:	89 81       	ldd	r24, Y+1	; 0x01
    3fd2:	9a 81       	ldd	r25, Y+2	; 0x02
    3fd4:	fc 01       	movw	r30, r24
    3fd6:	24 81       	ldd	r18, Z+4	; 0x04
    3fd8:	35 81       	ldd	r19, Z+5	; 0x05
    3fda:	89 81       	ldd	r24, Y+1	; 0x01
    3fdc:	9a 81       	ldd	r25, Y+2	; 0x02
    3fde:	fc 01       	movw	r30, r24
    3fe0:	84 8d       	ldd	r24, Z+28	; 0x1c
    3fe2:	88 2f       	mov	r24, r24
    3fe4:	90 e0       	ldi	r25, 0x00	; 0
    3fe6:	28 0f       	add	r18, r24
    3fe8:	39 1f       	adc	r19, r25
    3fea:	89 81       	ldd	r24, Y+1	; 0x01
    3fec:	9a 81       	ldd	r25, Y+2	; 0x02
    3fee:	fc 01       	movw	r30, r24
    3ff0:	35 83       	std	Z+5, r19	; 0x05
    3ff2:	24 83       	std	Z+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    3ff4:	89 81       	ldd	r24, Y+1	; 0x01
    3ff6:	9a 81       	ldd	r25, Y+2	; 0x02
    3ff8:	fc 01       	movw	r30, r24
    3ffa:	24 81       	ldd	r18, Z+4	; 0x04
    3ffc:	35 81       	ldd	r19, Z+5	; 0x05
    3ffe:	89 81       	ldd	r24, Y+1	; 0x01
    4000:	9a 81       	ldd	r25, Y+2	; 0x02
    4002:	fc 01       	movw	r30, r24
    4004:	82 81       	ldd	r24, Z+2	; 0x02
    4006:	93 81       	ldd	r25, Z+3	; 0x03
    4008:	28 17       	cp	r18, r24
    400a:	39 07       	cpc	r19, r25
    400c:	08 f4       	brcc	.+2      	; 0x4010 <prvCopyDataToQueue+0x8e>
    400e:	53 c0       	rjmp	.+166    	; 0x40b6 <prvCopyDataToQueue+0x134>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    4010:	89 81       	ldd	r24, Y+1	; 0x01
    4012:	9a 81       	ldd	r25, Y+2	; 0x02
    4014:	fc 01       	movw	r30, r24
    4016:	20 81       	ld	r18, Z
    4018:	31 81       	ldd	r19, Z+1	; 0x01
    401a:	89 81       	ldd	r24, Y+1	; 0x01
    401c:	9a 81       	ldd	r25, Y+2	; 0x02
    401e:	fc 01       	movw	r30, r24
    4020:	35 83       	std	Z+5, r19	; 0x05
    4022:	24 83       	std	Z+4, r18	; 0x04
    4024:	48 c0       	rjmp	.+144    	; 0x40b6 <prvCopyDataToQueue+0x134>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    4026:	89 81       	ldd	r24, Y+1	; 0x01
    4028:	9a 81       	ldd	r25, Y+2	; 0x02
    402a:	fc 01       	movw	r30, r24
    402c:	86 81       	ldd	r24, Z+6	; 0x06
    402e:	97 81       	ldd	r25, Z+7	; 0x07
    4030:	29 81       	ldd	r18, Y+1	; 0x01
    4032:	3a 81       	ldd	r19, Y+2	; 0x02
    4034:	f9 01       	movw	r30, r18
    4036:	24 8d       	ldd	r18, Z+28	; 0x1c
    4038:	22 2f       	mov	r18, r18
    403a:	30 e0       	ldi	r19, 0x00	; 0
    403c:	4b 81       	ldd	r20, Y+3	; 0x03
    403e:	5c 81       	ldd	r21, Y+4	; 0x04
    4040:	ba 01       	movw	r22, r20
    4042:	a9 01       	movw	r20, r18
    4044:	0e 94 a5 36 	call	0x6d4a	; 0x6d4a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    4048:	89 81       	ldd	r24, Y+1	; 0x01
    404a:	9a 81       	ldd	r25, Y+2	; 0x02
    404c:	fc 01       	movw	r30, r24
    404e:	26 81       	ldd	r18, Z+6	; 0x06
    4050:	37 81       	ldd	r19, Z+7	; 0x07
    4052:	89 81       	ldd	r24, Y+1	; 0x01
    4054:	9a 81       	ldd	r25, Y+2	; 0x02
    4056:	fc 01       	movw	r30, r24
    4058:	84 8d       	ldd	r24, Z+28	; 0x1c
    405a:	88 2f       	mov	r24, r24
    405c:	90 e0       	ldi	r25, 0x00	; 0
    405e:	90 95       	com	r25
    4060:	81 95       	neg	r24
    4062:	9f 4f       	sbci	r25, 0xFF	; 255
    4064:	28 0f       	add	r18, r24
    4066:	39 1f       	adc	r19, r25
    4068:	89 81       	ldd	r24, Y+1	; 0x01
    406a:	9a 81       	ldd	r25, Y+2	; 0x02
    406c:	fc 01       	movw	r30, r24
    406e:	37 83       	std	Z+7, r19	; 0x07
    4070:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    4072:	89 81       	ldd	r24, Y+1	; 0x01
    4074:	9a 81       	ldd	r25, Y+2	; 0x02
    4076:	fc 01       	movw	r30, r24
    4078:	26 81       	ldd	r18, Z+6	; 0x06
    407a:	37 81       	ldd	r19, Z+7	; 0x07
    407c:	89 81       	ldd	r24, Y+1	; 0x01
    407e:	9a 81       	ldd	r25, Y+2	; 0x02
    4080:	fc 01       	movw	r30, r24
    4082:	80 81       	ld	r24, Z
    4084:	91 81       	ldd	r25, Z+1	; 0x01
    4086:	28 17       	cp	r18, r24
    4088:	39 07       	cpc	r19, r25
    408a:	a8 f4       	brcc	.+42     	; 0x40b6 <prvCopyDataToQueue+0x134>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    408c:	89 81       	ldd	r24, Y+1	; 0x01
    408e:	9a 81       	ldd	r25, Y+2	; 0x02
    4090:	fc 01       	movw	r30, r24
    4092:	22 81       	ldd	r18, Z+2	; 0x02
    4094:	33 81       	ldd	r19, Z+3	; 0x03
    4096:	89 81       	ldd	r24, Y+1	; 0x01
    4098:	9a 81       	ldd	r25, Y+2	; 0x02
    409a:	fc 01       	movw	r30, r24
    409c:	84 8d       	ldd	r24, Z+28	; 0x1c
    409e:	88 2f       	mov	r24, r24
    40a0:	90 e0       	ldi	r25, 0x00	; 0
    40a2:	90 95       	com	r25
    40a4:	81 95       	neg	r24
    40a6:	9f 4f       	sbci	r25, 0xFF	; 255
    40a8:	28 0f       	add	r18, r24
    40aa:	39 1f       	adc	r19, r25
    40ac:	89 81       	ldd	r24, Y+1	; 0x01
    40ae:	9a 81       	ldd	r25, Y+2	; 0x02
    40b0:	fc 01       	movw	r30, r24
    40b2:	37 83       	std	Z+7, r19	; 0x07
    40b4:	26 83       	std	Z+6, r18	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    40b6:	89 81       	ldd	r24, Y+1	; 0x01
    40b8:	9a 81       	ldd	r25, Y+2	; 0x02
    40ba:	fc 01       	movw	r30, r24
    40bc:	82 8d       	ldd	r24, Z+26	; 0x1a
    40be:	28 2f       	mov	r18, r24
    40c0:	2f 5f       	subi	r18, 0xFF	; 255
    40c2:	89 81       	ldd	r24, Y+1	; 0x01
    40c4:	9a 81       	ldd	r25, Y+2	; 0x02
    40c6:	fc 01       	movw	r30, r24
    40c8:	22 8f       	std	Z+26, r18	; 0x1a
}
    40ca:	0f 90       	pop	r0
    40cc:	0f 90       	pop	r0
    40ce:	0f 90       	pop	r0
    40d0:	0f 90       	pop	r0
    40d2:	0f 90       	pop	r0
    40d4:	df 91       	pop	r29
    40d6:	cf 91       	pop	r28
    40d8:	08 95       	ret

000040da <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    40da:	cf 93       	push	r28
    40dc:	df 93       	push	r29
    40de:	00 d0       	rcall	.+0      	; 0x40e0 <prvCopyDataFromQueue+0x6>
    40e0:	00 d0       	rcall	.+0      	; 0x40e2 <prvCopyDataFromQueue+0x8>
    40e2:	cd b7       	in	r28, 0x3d	; 61
    40e4:	de b7       	in	r29, 0x3e	; 62
    40e6:	9a 83       	std	Y+2, r25	; 0x02
    40e8:	89 83       	std	Y+1, r24	; 0x01
    40ea:	7c 83       	std	Y+4, r23	; 0x04
    40ec:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    40ee:	89 81       	ldd	r24, Y+1	; 0x01
    40f0:	9a 81       	ldd	r25, Y+2	; 0x02
    40f2:	fc 01       	movw	r30, r24
    40f4:	80 81       	ld	r24, Z
    40f6:	91 81       	ldd	r25, Z+1	; 0x01
    40f8:	00 97       	sbiw	r24, 0x00	; 0
    40fa:	d1 f1       	breq	.+116    	; 0x4170 <__stack+0x71>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    40fc:	89 81       	ldd	r24, Y+1	; 0x01
    40fe:	9a 81       	ldd	r25, Y+2	; 0x02
    4100:	fc 01       	movw	r30, r24
    4102:	26 81       	ldd	r18, Z+6	; 0x06
    4104:	37 81       	ldd	r19, Z+7	; 0x07
    4106:	89 81       	ldd	r24, Y+1	; 0x01
    4108:	9a 81       	ldd	r25, Y+2	; 0x02
    410a:	fc 01       	movw	r30, r24
    410c:	84 8d       	ldd	r24, Z+28	; 0x1c
    410e:	88 2f       	mov	r24, r24
    4110:	90 e0       	ldi	r25, 0x00	; 0
    4112:	28 0f       	add	r18, r24
    4114:	39 1f       	adc	r19, r25
    4116:	89 81       	ldd	r24, Y+1	; 0x01
    4118:	9a 81       	ldd	r25, Y+2	; 0x02
    411a:	fc 01       	movw	r30, r24
    411c:	37 83       	std	Z+7, r19	; 0x07
    411e:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    4120:	89 81       	ldd	r24, Y+1	; 0x01
    4122:	9a 81       	ldd	r25, Y+2	; 0x02
    4124:	fc 01       	movw	r30, r24
    4126:	26 81       	ldd	r18, Z+6	; 0x06
    4128:	37 81       	ldd	r19, Z+7	; 0x07
    412a:	89 81       	ldd	r24, Y+1	; 0x01
    412c:	9a 81       	ldd	r25, Y+2	; 0x02
    412e:	fc 01       	movw	r30, r24
    4130:	82 81       	ldd	r24, Z+2	; 0x02
    4132:	93 81       	ldd	r25, Z+3	; 0x03
    4134:	28 17       	cp	r18, r24
    4136:	39 07       	cpc	r19, r25
    4138:	50 f0       	brcs	.+20     	; 0x414e <__stack+0x4f>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    413a:	89 81       	ldd	r24, Y+1	; 0x01
    413c:	9a 81       	ldd	r25, Y+2	; 0x02
    413e:	fc 01       	movw	r30, r24
    4140:	20 81       	ld	r18, Z
    4142:	31 81       	ldd	r19, Z+1	; 0x01
    4144:	89 81       	ldd	r24, Y+1	; 0x01
    4146:	9a 81       	ldd	r25, Y+2	; 0x02
    4148:	fc 01       	movw	r30, r24
    414a:	37 83       	std	Z+7, r19	; 0x07
    414c:	26 83       	std	Z+6, r18	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    414e:	89 81       	ldd	r24, Y+1	; 0x01
    4150:	9a 81       	ldd	r25, Y+2	; 0x02
    4152:	fc 01       	movw	r30, r24
    4154:	46 81       	ldd	r20, Z+6	; 0x06
    4156:	57 81       	ldd	r21, Z+7	; 0x07
    4158:	89 81       	ldd	r24, Y+1	; 0x01
    415a:	9a 81       	ldd	r25, Y+2	; 0x02
    415c:	fc 01       	movw	r30, r24
    415e:	84 8d       	ldd	r24, Z+28	; 0x1c
    4160:	28 2f       	mov	r18, r24
    4162:	30 e0       	ldi	r19, 0x00	; 0
    4164:	8b 81       	ldd	r24, Y+3	; 0x03
    4166:	9c 81       	ldd	r25, Y+4	; 0x04
    4168:	ba 01       	movw	r22, r20
    416a:	a9 01       	movw	r20, r18
    416c:	0e 94 a5 36 	call	0x6d4a	; 0x6d4a <memcpy>
	}
}
    4170:	0f 90       	pop	r0
    4172:	0f 90       	pop	r0
    4174:	0f 90       	pop	r0
    4176:	0f 90       	pop	r0
    4178:	df 91       	pop	r29
    417a:	cf 91       	pop	r28
    417c:	08 95       	ret

0000417e <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQUEUE *pxQueue )
{
    417e:	cf 93       	push	r28
    4180:	df 93       	push	r29
    4182:	00 d0       	rcall	.+0      	; 0x4184 <prvUnlockQueue+0x6>
    4184:	cd b7       	in	r28, 0x3d	; 61
    4186:	de b7       	in	r29, 0x3e	; 62
    4188:	9a 83       	std	Y+2, r25	; 0x02
    418a:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    418c:	0f b6       	in	r0, 0x3f	; 63
    418e:	f8 94       	cli
    4190:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    4192:	19 c0       	rjmp	.+50     	; 0x41c6 <prvUnlockQueue+0x48>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4194:	89 81       	ldd	r24, Y+1	; 0x01
    4196:	9a 81       	ldd	r25, Y+2	; 0x02
    4198:	fc 01       	movw	r30, r24
    419a:	81 89       	ldd	r24, Z+17	; 0x11
    419c:	88 23       	and	r24, r24
    419e:	d1 f0       	breq	.+52     	; 0x41d4 <prvUnlockQueue+0x56>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    41a0:	89 81       	ldd	r24, Y+1	; 0x01
    41a2:	9a 81       	ldd	r25, Y+2	; 0x02
    41a4:	41 96       	adiw	r24, 0x11	; 17
    41a6:	0e 94 31 26 	call	0x4c62	; 0x4c62 <xTaskRemoveFromEventList>
    41aa:	88 23       	and	r24, r24
    41ac:	11 f0       	breq	.+4      	; 0x41b2 <prvUnlockQueue+0x34>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    41ae:	0e 94 28 27 	call	0x4e50	; 0x4e50 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    41b2:	89 81       	ldd	r24, Y+1	; 0x01
    41b4:	9a 81       	ldd	r25, Y+2	; 0x02
    41b6:	fc 01       	movw	r30, r24
    41b8:	86 8d       	ldd	r24, Z+30	; 0x1e
    41ba:	28 2f       	mov	r18, r24
    41bc:	21 50       	subi	r18, 0x01	; 1
    41be:	89 81       	ldd	r24, Y+1	; 0x01
    41c0:	9a 81       	ldd	r25, Y+2	; 0x02
    41c2:	fc 01       	movw	r30, r24
    41c4:	26 8f       	std	Z+30, r18	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    41c6:	89 81       	ldd	r24, Y+1	; 0x01
    41c8:	9a 81       	ldd	r25, Y+2	; 0x02
    41ca:	fc 01       	movw	r30, r24
    41cc:	86 8d       	ldd	r24, Z+30	; 0x1e
    41ce:	18 16       	cp	r1, r24
    41d0:	0c f3       	brlt	.-62     	; 0x4194 <prvUnlockQueue+0x16>
    41d2:	01 c0       	rjmp	.+2      	; 0x41d6 <prvUnlockQueue+0x58>
						vTaskMissedYield();
					}
				}
				else
				{
					break;
    41d4:	00 00       	nop
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    41d6:	89 81       	ldd	r24, Y+1	; 0x01
    41d8:	9a 81       	ldd	r25, Y+2	; 0x02
    41da:	2f ef       	ldi	r18, 0xFF	; 255
    41dc:	fc 01       	movw	r30, r24
    41de:	26 8f       	std	Z+30, r18	; 0x1e
	}
	taskEXIT_CRITICAL();
    41e0:	0f 90       	pop	r0
    41e2:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    41e4:	0f b6       	in	r0, 0x3f	; 63
    41e6:	f8 94       	cli
    41e8:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    41ea:	19 c0       	rjmp	.+50     	; 0x421e <prvUnlockQueue+0xa0>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    41ec:	89 81       	ldd	r24, Y+1	; 0x01
    41ee:	9a 81       	ldd	r25, Y+2	; 0x02
    41f0:	fc 01       	movw	r30, r24
    41f2:	80 85       	ldd	r24, Z+8	; 0x08
    41f4:	88 23       	and	r24, r24
    41f6:	d1 f0       	breq	.+52     	; 0x422c <prvUnlockQueue+0xae>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    41f8:	89 81       	ldd	r24, Y+1	; 0x01
    41fa:	9a 81       	ldd	r25, Y+2	; 0x02
    41fc:	08 96       	adiw	r24, 0x08	; 8
    41fe:	0e 94 31 26 	call	0x4c62	; 0x4c62 <xTaskRemoveFromEventList>
    4202:	88 23       	and	r24, r24
    4204:	11 f0       	breq	.+4      	; 0x420a <prvUnlockQueue+0x8c>
				{
					vTaskMissedYield();
    4206:	0e 94 28 27 	call	0x4e50	; 0x4e50 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    420a:	89 81       	ldd	r24, Y+1	; 0x01
    420c:	9a 81       	ldd	r25, Y+2	; 0x02
    420e:	fc 01       	movw	r30, r24
    4210:	85 8d       	ldd	r24, Z+29	; 0x1d
    4212:	28 2f       	mov	r18, r24
    4214:	21 50       	subi	r18, 0x01	; 1
    4216:	89 81       	ldd	r24, Y+1	; 0x01
    4218:	9a 81       	ldd	r25, Y+2	; 0x02
    421a:	fc 01       	movw	r30, r24
    421c:	25 8f       	std	Z+29, r18	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    421e:	89 81       	ldd	r24, Y+1	; 0x01
    4220:	9a 81       	ldd	r25, Y+2	; 0x02
    4222:	fc 01       	movw	r30, r24
    4224:	85 8d       	ldd	r24, Z+29	; 0x1d
    4226:	18 16       	cp	r1, r24
    4228:	0c f3       	brlt	.-62     	; 0x41ec <prvUnlockQueue+0x6e>
    422a:	01 c0       	rjmp	.+2      	; 0x422e <prvUnlockQueue+0xb0>

				--( pxQueue->xRxLock );
			}
			else
			{
				break;
    422c:	00 00       	nop
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    422e:	89 81       	ldd	r24, Y+1	; 0x01
    4230:	9a 81       	ldd	r25, Y+2	; 0x02
    4232:	2f ef       	ldi	r18, 0xFF	; 255
    4234:	fc 01       	movw	r30, r24
    4236:	25 8f       	std	Z+29, r18	; 0x1d
	}
	taskEXIT_CRITICAL();
    4238:	0f 90       	pop	r0
    423a:	0f be       	out	0x3f, r0	; 63
}
    423c:	0f 90       	pop	r0
    423e:	0f 90       	pop	r0
    4240:	df 91       	pop	r29
    4242:	cf 91       	pop	r28
    4244:	08 95       	ret

00004246 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
{
    4246:	cf 93       	push	r28
    4248:	df 93       	push	r29
    424a:	00 d0       	rcall	.+0      	; 0x424c <prvIsQueueEmpty+0x6>
    424c:	0f 92       	push	r0
    424e:	cd b7       	in	r28, 0x3d	; 61
    4250:	de b7       	in	r29, 0x3e	; 62
    4252:	9b 83       	std	Y+3, r25	; 0x03
    4254:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    4256:	0f b6       	in	r0, 0x3f	; 63
    4258:	f8 94       	cli
    425a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == 0 )
    425c:	8a 81       	ldd	r24, Y+2	; 0x02
    425e:	9b 81       	ldd	r25, Y+3	; 0x03
    4260:	fc 01       	movw	r30, r24
    4262:	82 8d       	ldd	r24, Z+26	; 0x1a
    4264:	88 23       	and	r24, r24
    4266:	19 f4       	brne	.+6      	; 0x426e <prvIsQueueEmpty+0x28>
		{
			xReturn = pdTRUE;
    4268:	81 e0       	ldi	r24, 0x01	; 1
    426a:	89 83       	std	Y+1, r24	; 0x01
    426c:	01 c0       	rjmp	.+2      	; 0x4270 <prvIsQueueEmpty+0x2a>
		}
		else
		{
			xReturn = pdFALSE;
    426e:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4270:	0f 90       	pop	r0
    4272:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4274:	89 81       	ldd	r24, Y+1	; 0x01
}
    4276:	0f 90       	pop	r0
    4278:	0f 90       	pop	r0
    427a:	0f 90       	pop	r0
    427c:	df 91       	pop	r29
    427e:	cf 91       	pop	r28
    4280:	08 95       	ret

00004282 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
{
    4282:	cf 93       	push	r28
    4284:	df 93       	push	r29
    4286:	00 d0       	rcall	.+0      	; 0x4288 <xQueueIsQueueEmptyFromISR+0x6>
    4288:	0f 92       	push	r0
    428a:	cd b7       	in	r28, 0x3d	; 61
    428c:	de b7       	in	r29, 0x3e	; 62
    428e:	9b 83       	std	Y+3, r25	; 0x03
    4290:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == 0 )
    4292:	8a 81       	ldd	r24, Y+2	; 0x02
    4294:	9b 81       	ldd	r25, Y+3	; 0x03
    4296:	fc 01       	movw	r30, r24
    4298:	82 8d       	ldd	r24, Z+26	; 0x1a
    429a:	88 23       	and	r24, r24
    429c:	19 f4       	brne	.+6      	; 0x42a4 <xQueueIsQueueEmptyFromISR+0x22>
	{
		xReturn = pdTRUE;
    429e:	81 e0       	ldi	r24, 0x01	; 1
    42a0:	89 83       	std	Y+1, r24	; 0x01
    42a2:	01 c0       	rjmp	.+2      	; 0x42a6 <xQueueIsQueueEmptyFromISR+0x24>
	}
	else
	{
		xReturn = pdFALSE;
    42a4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    42a6:	89 81       	ldd	r24, Y+1	; 0x01
}
    42a8:	0f 90       	pop	r0
    42aa:	0f 90       	pop	r0
    42ac:	0f 90       	pop	r0
    42ae:	df 91       	pop	r29
    42b0:	cf 91       	pop	r28
    42b2:	08 95       	ret

000042b4 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
    42b4:	cf 93       	push	r28
    42b6:	df 93       	push	r29
    42b8:	00 d0       	rcall	.+0      	; 0x42ba <prvIsQueueFull+0x6>
    42ba:	0f 92       	push	r0
    42bc:	cd b7       	in	r28, 0x3d	; 61
    42be:	de b7       	in	r29, 0x3e	; 62
    42c0:	9b 83       	std	Y+3, r25	; 0x03
    42c2:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    42c4:	0f b6       	in	r0, 0x3f	; 63
    42c6:	f8 94       	cli
    42c8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    42ca:	8a 81       	ldd	r24, Y+2	; 0x02
    42cc:	9b 81       	ldd	r25, Y+3	; 0x03
    42ce:	fc 01       	movw	r30, r24
    42d0:	22 8d       	ldd	r18, Z+26	; 0x1a
    42d2:	8a 81       	ldd	r24, Y+2	; 0x02
    42d4:	9b 81       	ldd	r25, Y+3	; 0x03
    42d6:	fc 01       	movw	r30, r24
    42d8:	83 8d       	ldd	r24, Z+27	; 0x1b
    42da:	28 17       	cp	r18, r24
    42dc:	19 f4       	brne	.+6      	; 0x42e4 <prvIsQueueFull+0x30>
		{
			xReturn = pdTRUE;
    42de:	81 e0       	ldi	r24, 0x01	; 1
    42e0:	89 83       	std	Y+1, r24	; 0x01
    42e2:	01 c0       	rjmp	.+2      	; 0x42e6 <prvIsQueueFull+0x32>
		}
		else
		{
			xReturn = pdFALSE;
    42e4:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    42e6:	0f 90       	pop	r0
    42e8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    42ea:	89 81       	ldd	r24, Y+1	; 0x01
}
    42ec:	0f 90       	pop	r0
    42ee:	0f 90       	pop	r0
    42f0:	0f 90       	pop	r0
    42f2:	df 91       	pop	r29
    42f4:	cf 91       	pop	r28
    42f6:	08 95       	ret

000042f8 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
{
    42f8:	cf 93       	push	r28
    42fa:	df 93       	push	r29
    42fc:	00 d0       	rcall	.+0      	; 0x42fe <xQueueIsQueueFullFromISR+0x6>
    42fe:	0f 92       	push	r0
    4300:	cd b7       	in	r28, 0x3d	; 61
    4302:	de b7       	in	r29, 0x3e	; 62
    4304:	9b 83       	std	Y+3, r25	; 0x03
    4306:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
    4308:	8a 81       	ldd	r24, Y+2	; 0x02
    430a:	9b 81       	ldd	r25, Y+3	; 0x03
    430c:	fc 01       	movw	r30, r24
    430e:	22 8d       	ldd	r18, Z+26	; 0x1a
    4310:	8a 81       	ldd	r24, Y+2	; 0x02
    4312:	9b 81       	ldd	r25, Y+3	; 0x03
    4314:	fc 01       	movw	r30, r24
    4316:	83 8d       	ldd	r24, Z+27	; 0x1b
    4318:	28 17       	cp	r18, r24
    431a:	19 f4       	brne	.+6      	; 0x4322 <xQueueIsQueueFullFromISR+0x2a>
	{
		xReturn = pdTRUE;
    431c:	81 e0       	ldi	r24, 0x01	; 1
    431e:	89 83       	std	Y+1, r24	; 0x01
    4320:	01 c0       	rjmp	.+2      	; 0x4324 <xQueueIsQueueFullFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    4322:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4324:	89 81       	ldd	r24, Y+1	; 0x01
}
    4326:	0f 90       	pop	r0
    4328:	0f 90       	pop	r0
    432a:	0f 90       	pop	r0
    432c:	df 91       	pop	r29
    432e:	cf 91       	pop	r28
    4330:	08 95       	ret

00004332 <xTaskGenericCreate>:
#endif

/*lint +e956 */

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    4332:	af 92       	push	r10
    4334:	bf 92       	push	r11
    4336:	cf 92       	push	r12
    4338:	df 92       	push	r13
    433a:	ef 92       	push	r14
    433c:	ff 92       	push	r15
    433e:	0f 93       	push	r16
    4340:	1f 93       	push	r17
    4342:	cf 93       	push	r28
    4344:	df 93       	push	r29
    4346:	cd b7       	in	r28, 0x3d	; 61
    4348:	de b7       	in	r29, 0x3e	; 62
    434a:	64 97       	sbiw	r28, 0x14	; 20
    434c:	0f b6       	in	r0, 0x3f	; 63
    434e:	f8 94       	cli
    4350:	de bf       	out	0x3e, r29	; 62
    4352:	0f be       	out	0x3f, r0	; 63
    4354:	cd bf       	out	0x3d, r28	; 61
    4356:	9f 83       	std	Y+7, r25	; 0x07
    4358:	8e 83       	std	Y+6, r24	; 0x06
    435a:	79 87       	std	Y+9, r23	; 0x09
    435c:	68 87       	std	Y+8, r22	; 0x08
    435e:	5b 87       	std	Y+11, r21	; 0x0b
    4360:	4a 87       	std	Y+10, r20	; 0x0a
    4362:	3d 87       	std	Y+13, r19	; 0x0d
    4364:	2c 87       	std	Y+12, r18	; 0x0c
    4366:	0e 87       	std	Y+14, r16	; 0x0e
    4368:	f8 8a       	std	Y+16, r15	; 0x10
    436a:	ef 86       	std	Y+15, r14	; 0x0f
    436c:	da 8a       	std	Y+18, r13	; 0x12
    436e:	c9 8a       	std	Y+17, r12	; 0x11
    4370:	bc 8a       	std	Y+20, r11	; 0x14
    4372:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    4374:	8a 85       	ldd	r24, Y+10	; 0x0a
    4376:	9b 85       	ldd	r25, Y+11	; 0x0b
    4378:	29 89       	ldd	r18, Y+17	; 0x11
    437a:	3a 89       	ldd	r19, Y+18	; 0x12
    437c:	b9 01       	movw	r22, r18
    437e:	0e 94 65 28 	call	0x50ca	; 0x50ca <prvAllocateTCBAndStack>
    4382:	9b 83       	std	Y+3, r25	; 0x03
    4384:	8a 83       	std	Y+2, r24	; 0x02

	if( pxNewTCB != NULL )
    4386:	8a 81       	ldd	r24, Y+2	; 0x02
    4388:	9b 81       	ldd	r25, Y+3	; 0x03
    438a:	00 97       	sbiw	r24, 0x00	; 0
    438c:	09 f4       	brne	.+2      	; 0x4390 <xTaskGenericCreate+0x5e>
    438e:	a0 c0       	rjmp	.+320    	; 0x44d0 <xTaskGenericCreate+0x19e>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    4390:	8a 81       	ldd	r24, Y+2	; 0x02
    4392:	9b 81       	ldd	r25, Y+3	; 0x03
    4394:	fc 01       	movw	r30, r24
    4396:	27 89       	ldd	r18, Z+23	; 0x17
    4398:	30 8d       	ldd	r19, Z+24	; 0x18
    439a:	8a 85       	ldd	r24, Y+10	; 0x0a
    439c:	9b 85       	ldd	r25, Y+11	; 0x0b
    439e:	01 97       	sbiw	r24, 0x01	; 1
    43a0:	82 0f       	add	r24, r18
    43a2:	93 1f       	adc	r25, r19
    43a4:	9d 83       	std	Y+5, r25	; 0x05
    43a6:	8c 83       	std	Y+4, r24	; 0x04
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    43a8:	8a 81       	ldd	r24, Y+2	; 0x02
    43aa:	9b 81       	ldd	r25, Y+3	; 0x03
    43ac:	48 85       	ldd	r20, Y+8	; 0x08
    43ae:	59 85       	ldd	r21, Y+9	; 0x09
    43b0:	2b 89       	ldd	r18, Y+19	; 0x13
    43b2:	3c 89       	ldd	r19, Y+20	; 0x14
    43b4:	ea 85       	ldd	r30, Y+10	; 0x0a
    43b6:	fb 85       	ldd	r31, Y+11	; 0x0b
    43b8:	ba 01       	movw	r22, r20
    43ba:	4e 85       	ldd	r20, Y+14	; 0x0e
    43bc:	8f 01       	movw	r16, r30
    43be:	0e 94 44 27 	call	0x4e88	; 0x4e88 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    43c2:	8c 81       	ldd	r24, Y+4	; 0x04
    43c4:	9d 81       	ldd	r25, Y+5	; 0x05
    43c6:	4e 81       	ldd	r20, Y+6	; 0x06
    43c8:	5f 81       	ldd	r21, Y+7	; 0x07
    43ca:	2c 85       	ldd	r18, Y+12	; 0x0c
    43cc:	3d 85       	ldd	r19, Y+13	; 0x0d
    43ce:	ba 01       	movw	r22, r20
    43d0:	a9 01       	movw	r20, r18
    43d2:	0e 94 62 19 	call	0x32c4	; 0x32c4 <pxPortInitialiseStack>
    43d6:	9c 01       	movw	r18, r24
    43d8:	8a 81       	ldd	r24, Y+2	; 0x02
    43da:	9b 81       	ldd	r25, Y+3	; 0x03
    43dc:	fc 01       	movw	r30, r24
    43de:	31 83       	std	Z+1, r19	; 0x01
    43e0:	20 83       	st	Z, r18
		#endif /* portUSING_MPU_WRAPPERS */

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    43e2:	8f 85       	ldd	r24, Y+15	; 0x0f
    43e4:	98 89       	ldd	r25, Y+16	; 0x10
    43e6:	00 97       	sbiw	r24, 0x00	; 0
    43e8:	39 f0       	breq	.+14     	; 0x43f8 <xTaskGenericCreate+0xc6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    43ea:	8f 85       	ldd	r24, Y+15	; 0x0f
    43ec:	98 89       	ldd	r25, Y+16	; 0x10
    43ee:	2a 81       	ldd	r18, Y+2	; 0x02
    43f0:	3b 81       	ldd	r19, Y+3	; 0x03
    43f2:	fc 01       	movw	r30, r24
    43f4:	31 83       	std	Z+1, r19	; 0x01
    43f6:	20 83       	st	Z, r18
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    43f8:	0f b6       	in	r0, 0x3f	; 63
    43fa:	f8 94       	cli
    43fc:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    43fe:	80 91 a5 0d 	lds	r24, 0x0DA5
    4402:	8f 5f       	subi	r24, 0xFF	; 255
    4404:	80 93 a5 0d 	sts	0x0DA5, r24
			if( pxCurrentTCB == NULL )
    4408:	80 91 56 0d 	lds	r24, 0x0D56
    440c:	90 91 57 0d 	lds	r25, 0x0D57
    4410:	00 97       	sbiw	r24, 0x00	; 0
    4412:	69 f4       	brne	.+26     	; 0x442e <xTaskGenericCreate+0xfc>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    4414:	8a 81       	ldd	r24, Y+2	; 0x02
    4416:	9b 81       	ldd	r25, Y+3	; 0x03
    4418:	90 93 57 0d 	sts	0x0D57, r25
    441c:	80 93 56 0d 	sts	0x0D56, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    4420:	80 91 a5 0d 	lds	r24, 0x0DA5
    4424:	81 30       	cpi	r24, 0x01	; 1
    4426:	b1 f4       	brne	.+44     	; 0x4454 <xTaskGenericCreate+0x122>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    4428:	0e 94 a0 27 	call	0x4f40	; 0x4f40 <prvInitialiseTaskLists>
    442c:	13 c0       	rjmp	.+38     	; 0x4454 <xTaskGenericCreate+0x122>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    442e:	80 91 aa 0d 	lds	r24, 0x0DAA
    4432:	88 23       	and	r24, r24
    4434:	79 f4       	brne	.+30     	; 0x4454 <xTaskGenericCreate+0x122>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    4436:	80 91 56 0d 	lds	r24, 0x0D56
    443a:	90 91 57 0d 	lds	r25, 0x0D57
    443e:	fc 01       	movw	r30, r24
    4440:	96 89       	ldd	r25, Z+22	; 0x16
    4442:	8e 85       	ldd	r24, Y+14	; 0x0e
    4444:	89 17       	cp	r24, r25
    4446:	30 f0       	brcs	.+12     	; 0x4454 <xTaskGenericCreate+0x122>
					{
						pxCurrentTCB = pxNewTCB;
    4448:	8a 81       	ldd	r24, Y+2	; 0x02
    444a:	9b 81       	ldd	r25, Y+3	; 0x03
    444c:	90 93 57 0d 	sts	0x0D57, r25
    4450:	80 93 56 0d 	sts	0x0D56, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    4454:	8a 81       	ldd	r24, Y+2	; 0x02
    4456:	9b 81       	ldd	r25, Y+3	; 0x03
    4458:	fc 01       	movw	r30, r24
    445a:	96 89       	ldd	r25, Z+22	; 0x16
    445c:	80 91 a8 0d 	lds	r24, 0x0DA8
    4460:	89 17       	cp	r24, r25
    4462:	30 f4       	brcc	.+12     	; 0x4470 <xTaskGenericCreate+0x13e>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    4464:	8a 81       	ldd	r24, Y+2	; 0x02
    4466:	9b 81       	ldd	r25, Y+3	; 0x03
    4468:	fc 01       	movw	r30, r24
    446a:	86 89       	ldd	r24, Z+22	; 0x16
    446c:	80 93 a8 0d 	sts	0x0DA8, r24
			}

			uxTaskNumber++;
    4470:	80 91 af 0d 	lds	r24, 0x0DAF
    4474:	8f 5f       	subi	r24, 0xFF	; 255
    4476:	80 93 af 0d 	sts	0x0DAF, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyQueue( pxNewTCB );
    447a:	8a 81       	ldd	r24, Y+2	; 0x02
    447c:	9b 81       	ldd	r25, Y+3	; 0x03
    447e:	fc 01       	movw	r30, r24
    4480:	96 89       	ldd	r25, Z+22	; 0x16
    4482:	80 91 a9 0d 	lds	r24, 0x0DA9
    4486:	89 17       	cp	r24, r25
    4488:	30 f4       	brcc	.+12     	; 0x4496 <xTaskGenericCreate+0x164>
    448a:	8a 81       	ldd	r24, Y+2	; 0x02
    448c:	9b 81       	ldd	r25, Y+3	; 0x03
    448e:	fc 01       	movw	r30, r24
    4490:	86 89       	ldd	r24, Z+22	; 0x16
    4492:	80 93 a9 0d 	sts	0x0DA9, r24
    4496:	8a 81       	ldd	r24, Y+2	; 0x02
    4498:	9b 81       	ldd	r25, Y+3	; 0x03
    449a:	fc 01       	movw	r30, r24
    449c:	86 89       	ldd	r24, Z+22	; 0x16
    449e:	28 2f       	mov	r18, r24
    44a0:	30 e0       	ldi	r19, 0x00	; 0
    44a2:	c9 01       	movw	r24, r18
    44a4:	88 0f       	add	r24, r24
    44a6:	99 1f       	adc	r25, r25
    44a8:	88 0f       	add	r24, r24
    44aa:	99 1f       	adc	r25, r25
    44ac:	88 0f       	add	r24, r24
    44ae:	99 1f       	adc	r25, r25
    44b0:	82 0f       	add	r24, r18
    44b2:	93 1f       	adc	r25, r19
    44b4:	88 5a       	subi	r24, 0xA8	; 168
    44b6:	92 4f       	sbci	r25, 0xF2	; 242
    44b8:	2a 81       	ldd	r18, Y+2	; 0x02
    44ba:	3b 81       	ldd	r19, Y+3	; 0x03
    44bc:	2e 5f       	subi	r18, 0xFE	; 254
    44be:	3f 4f       	sbci	r19, 0xFF	; 255
    44c0:	b9 01       	movw	r22, r18
    44c2:	0e 94 28 18 	call	0x3050	; 0x3050 <vListInsertEnd>

			xReturn = pdPASS;
    44c6:	81 e0       	ldi	r24, 0x01	; 1
    44c8:	89 83       	std	Y+1, r24	; 0x01
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    44ca:	0f 90       	pop	r0
    44cc:	0f be       	out	0x3f, r0	; 63
    44ce:	02 c0       	rjmp	.+4      	; 0x44d4 <xTaskGenericCreate+0x1a2>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    44d0:	8f ef       	ldi	r24, 0xFF	; 255
    44d2:	89 83       	std	Y+1, r24	; 0x01
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    44d4:	89 81       	ldd	r24, Y+1	; 0x01
    44d6:	81 30       	cpi	r24, 0x01	; 1
    44d8:	79 f4       	brne	.+30     	; 0x44f8 <xTaskGenericCreate+0x1c6>
	{
		if( xSchedulerRunning != pdFALSE )
    44da:	80 91 aa 0d 	lds	r24, 0x0DAA
    44de:	88 23       	and	r24, r24
    44e0:	59 f0       	breq	.+22     	; 0x44f8 <xTaskGenericCreate+0x1c6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    44e2:	80 91 56 0d 	lds	r24, 0x0D56
    44e6:	90 91 57 0d 	lds	r25, 0x0D57
    44ea:	fc 01       	movw	r30, r24
    44ec:	96 89       	ldd	r25, Z+22	; 0x16
    44ee:	8e 85       	ldd	r24, Y+14	; 0x0e
    44f0:	98 17       	cp	r25, r24
    44f2:	10 f4       	brcc	.+4      	; 0x44f8 <xTaskGenericCreate+0x1c6>
			{
				portYIELD_WITHIN_API();
    44f4:	0e 94 47 1b 	call	0x368e	; 0x368e <vPortYield>
			}
		}
	}

	return xReturn;
    44f8:	89 81       	ldd	r24, Y+1	; 0x01
}
    44fa:	64 96       	adiw	r28, 0x14	; 20
    44fc:	0f b6       	in	r0, 0x3f	; 63
    44fe:	f8 94       	cli
    4500:	de bf       	out	0x3e, r29	; 62
    4502:	0f be       	out	0x3f, r0	; 63
    4504:	cd bf       	out	0x3d, r28	; 61
    4506:	df 91       	pop	r29
    4508:	cf 91       	pop	r28
    450a:	1f 91       	pop	r17
    450c:	0f 91       	pop	r16
    450e:	ff 90       	pop	r15
    4510:	ef 90       	pop	r14
    4512:	df 90       	pop	r13
    4514:	cf 90       	pop	r12
    4516:	bf 90       	pop	r11
    4518:	af 90       	pop	r10
    451a:	08 95       	ret

0000451c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle xTaskToDelete )
	{
    451c:	cf 93       	push	r28
    451e:	df 93       	push	r29
    4520:	00 d0       	rcall	.+0      	; 0x4522 <vTaskDelete+0x6>
    4522:	00 d0       	rcall	.+0      	; 0x4524 <vTaskDelete+0x8>
    4524:	cd b7       	in	r28, 0x3d	; 61
    4526:	de b7       	in	r29, 0x3e	; 62
    4528:	9c 83       	std	Y+4, r25	; 0x04
    452a:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    452c:	0f b6       	in	r0, 0x3f	; 63
    452e:	f8 94       	cli
    4530:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( xTaskToDelete == pxCurrentTCB )
    4532:	80 91 56 0d 	lds	r24, 0x0D56
    4536:	90 91 57 0d 	lds	r25, 0x0D57
    453a:	2b 81       	ldd	r18, Y+3	; 0x03
    453c:	3c 81       	ldd	r19, Y+4	; 0x04
    453e:	28 17       	cp	r18, r24
    4540:	39 07       	cpc	r19, r25
    4542:	11 f4       	brne	.+4      	; 0x4548 <vTaskDelete+0x2c>
			{
				xTaskToDelete = NULL;
    4544:	1c 82       	std	Y+4, r1	; 0x04
    4546:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    4548:	8b 81       	ldd	r24, Y+3	; 0x03
    454a:	9c 81       	ldd	r25, Y+4	; 0x04
    454c:	00 97       	sbiw	r24, 0x00	; 0
    454e:	29 f4       	brne	.+10     	; 0x455a <vTaskDelete+0x3e>
    4550:	80 91 56 0d 	lds	r24, 0x0D56
    4554:	90 91 57 0d 	lds	r25, 0x0D57
    4558:	02 c0       	rjmp	.+4      	; 0x455e <vTaskDelete+0x42>
    455a:	8b 81       	ldd	r24, Y+3	; 0x03
    455c:	9c 81       	ldd	r25, Y+4	; 0x04
    455e:	9a 83       	std	Y+2, r25	; 0x02
    4560:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    4562:	89 81       	ldd	r24, Y+1	; 0x01
    4564:	9a 81       	ldd	r25, Y+2	; 0x02
    4566:	02 96       	adiw	r24, 0x02	; 2
    4568:	0e 94 0b 19 	call	0x3216	; 0x3216 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    456c:	89 81       	ldd	r24, Y+1	; 0x01
    456e:	9a 81       	ldd	r25, Y+2	; 0x02
    4570:	fc 01       	movw	r30, r24
    4572:	84 89       	ldd	r24, Z+20	; 0x14
    4574:	95 89       	ldd	r25, Z+21	; 0x15
    4576:	00 97       	sbiw	r24, 0x00	; 0
    4578:	29 f0       	breq	.+10     	; 0x4584 <vTaskDelete+0x68>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
    457a:	89 81       	ldd	r24, Y+1	; 0x01
    457c:	9a 81       	ldd	r25, Y+2	; 0x02
    457e:	0c 96       	adiw	r24, 0x0c	; 12
    4580:	0e 94 0b 19 	call	0x3216	; 0x3216 <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    4584:	89 81       	ldd	r24, Y+1	; 0x01
    4586:	9a 81       	ldd	r25, Y+2	; 0x02
    4588:	9c 01       	movw	r18, r24
    458a:	2e 5f       	subi	r18, 0xFE	; 254
    458c:	3f 4f       	sbci	r19, 0xFF	; 255
    458e:	8b e9       	ldi	r24, 0x9B	; 155
    4590:	9d e0       	ldi	r25, 0x0D	; 13
    4592:	b9 01       	movw	r22, r18
    4594:	0e 94 28 18 	call	0x3050	; 0x3050 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    4598:	80 91 a4 0d 	lds	r24, 0x0DA4
    459c:	8f 5f       	subi	r24, 0xFF	; 255
    459e:	80 93 a4 0d 	sts	0x0DA4, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    45a2:	80 91 af 0d 	lds	r24, 0x0DAF
    45a6:	8f 5f       	subi	r24, 0xFF	; 255
    45a8:	80 93 af 0d 	sts	0x0DAF, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    45ac:	0f 90       	pop	r0
    45ae:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    45b0:	80 91 aa 0d 	lds	r24, 0x0DAA
    45b4:	88 23       	and	r24, r24
    45b6:	31 f0       	breq	.+12     	; 0x45c4 <vTaskDelete+0xa8>
		{
			if( ( void * ) xTaskToDelete == NULL )
    45b8:	8b 81       	ldd	r24, Y+3	; 0x03
    45ba:	9c 81       	ldd	r25, Y+4	; 0x04
    45bc:	00 97       	sbiw	r24, 0x00	; 0
    45be:	11 f4       	brne	.+4      	; 0x45c4 <vTaskDelete+0xa8>
			{
				portYIELD_WITHIN_API();
    45c0:	0e 94 47 1b 	call	0x368e	; 0x368e <vPortYield>
			}
		}
	}
    45c4:	0f 90       	pop	r0
    45c6:	0f 90       	pop	r0
    45c8:	0f 90       	pop	r0
    45ca:	0f 90       	pop	r0
    45cc:	df 91       	pop	r29
    45ce:	cf 91       	pop	r28
    45d0:	08 95       	ret

000045d2 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( uint16_t * const pxPreviousWakeTime, uint16_t xTimeIncrement )
	{
    45d2:	cf 93       	push	r28
    45d4:	df 93       	push	r29
    45d6:	cd b7       	in	r28, 0x3d	; 61
    45d8:	de b7       	in	r29, 0x3e	; 62
    45da:	28 97       	sbiw	r28, 0x08	; 8
    45dc:	0f b6       	in	r0, 0x3f	; 63
    45de:	f8 94       	cli
    45e0:	de bf       	out	0x3e, r29	; 62
    45e2:	0f be       	out	0x3f, r0	; 63
    45e4:	cd bf       	out	0x3d, r28	; 61
    45e6:	9e 83       	std	Y+6, r25	; 0x06
    45e8:	8d 83       	std	Y+5, r24	; 0x05
    45ea:	78 87       	std	Y+8, r23	; 0x08
    45ec:	6f 83       	std	Y+7, r22	; 0x07
	uint16_t xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    45ee:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

if( *pxPreviousWakeTime!=xTickCount )
    45f0:	8d 81       	ldd	r24, Y+5	; 0x05
    45f2:	9e 81       	ldd	r25, Y+6	; 0x06
    45f4:	fc 01       	movw	r30, r24
    45f6:	20 81       	ld	r18, Z
    45f8:	31 81       	ldd	r19, Z+1	; 0x01
    45fa:	80 91 a6 0d 	lds	r24, 0x0DA6
    45fe:	90 91 a7 0d 	lds	r25, 0x0DA7
    4602:	28 17       	cp	r18, r24
    4604:	39 07       	cpc	r19, r25
    4606:	09 f0       	breq	.+2      	; 0x460a <vTaskDelayUntil+0x38>
{
    asm ("nop");
    4608:	00 00       	nop
    
}

		vTaskSuspendAll();
    460a:	0e 94 e7 23 	call	0x47ce	; 0x47ce <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    460e:	8d 81       	ldd	r24, Y+5	; 0x05
    4610:	9e 81       	ldd	r25, Y+6	; 0x06
    4612:	fc 01       	movw	r30, r24
    4614:	20 81       	ld	r18, Z
    4616:	31 81       	ldd	r19, Z+1	; 0x01
    4618:	8f 81       	ldd	r24, Y+7	; 0x07
    461a:	98 85       	ldd	r25, Y+8	; 0x08
    461c:	82 0f       	add	r24, r18
    461e:	93 1f       	adc	r25, r19
    4620:	9b 83       	std	Y+3, r25	; 0x03
    4622:	8a 83       	std	Y+2, r24	; 0x02

			if( xTickCount < *pxPreviousWakeTime )
    4624:	8d 81       	ldd	r24, Y+5	; 0x05
    4626:	9e 81       	ldd	r25, Y+6	; 0x06
    4628:	fc 01       	movw	r30, r24
    462a:	20 81       	ld	r18, Z
    462c:	31 81       	ldd	r19, Z+1	; 0x01
    462e:	80 91 a6 0d 	lds	r24, 0x0DA6
    4632:	90 91 a7 0d 	lds	r25, 0x0DA7
    4636:	82 17       	cp	r24, r18
    4638:	93 07       	cpc	r25, r19
    463a:	b0 f4       	brcc	.+44     	; 0x4668 <vTaskDelayUntil+0x96>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    463c:	8d 81       	ldd	r24, Y+5	; 0x05
    463e:	9e 81       	ldd	r25, Y+6	; 0x06
    4640:	fc 01       	movw	r30, r24
    4642:	20 81       	ld	r18, Z
    4644:	31 81       	ldd	r19, Z+1	; 0x01
    4646:	8a 81       	ldd	r24, Y+2	; 0x02
    4648:	9b 81       	ldd	r25, Y+3	; 0x03
    464a:	82 17       	cp	r24, r18
    464c:	93 07       	cpc	r25, r19
    464e:	08 f5       	brcc	.+66     	; 0x4692 <vTaskDelayUntil+0xc0>
    4650:	80 91 a6 0d 	lds	r24, 0x0DA6
    4654:	90 91 a7 0d 	lds	r25, 0x0DA7
    4658:	2a 81       	ldd	r18, Y+2	; 0x02
    465a:	3b 81       	ldd	r19, Y+3	; 0x03
    465c:	82 17       	cp	r24, r18
    465e:	93 07       	cpc	r25, r19
    4660:	c0 f4       	brcc	.+48     	; 0x4692 <vTaskDelayUntil+0xc0>
				{
					xShouldDelay = pdTRUE;
    4662:	81 e0       	ldi	r24, 0x01	; 1
    4664:	89 83       	std	Y+1, r24	; 0x01
    4666:	15 c0       	rjmp	.+42     	; 0x4692 <vTaskDelayUntil+0xc0>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    4668:	8d 81       	ldd	r24, Y+5	; 0x05
    466a:	9e 81       	ldd	r25, Y+6	; 0x06
    466c:	fc 01       	movw	r30, r24
    466e:	20 81       	ld	r18, Z
    4670:	31 81       	ldd	r19, Z+1	; 0x01
    4672:	8a 81       	ldd	r24, Y+2	; 0x02
    4674:	9b 81       	ldd	r25, Y+3	; 0x03
    4676:	82 17       	cp	r24, r18
    4678:	93 07       	cpc	r25, r19
    467a:	48 f0       	brcs	.+18     	; 0x468e <vTaskDelayUntil+0xbc>
    467c:	80 91 a6 0d 	lds	r24, 0x0DA6
    4680:	90 91 a7 0d 	lds	r25, 0x0DA7
    4684:	2a 81       	ldd	r18, Y+2	; 0x02
    4686:	3b 81       	ldd	r19, Y+3	; 0x03
    4688:	82 17       	cp	r24, r18
    468a:	93 07       	cpc	r25, r19
    468c:	10 f4       	brcc	.+4      	; 0x4692 <vTaskDelayUntil+0xc0>
				{
					xShouldDelay = pdTRUE;
    468e:	81 e0       	ldi	r24, 0x01	; 1
    4690:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    4692:	8d 81       	ldd	r24, Y+5	; 0x05
    4694:	9e 81       	ldd	r25, Y+6	; 0x06
    4696:	2a 81       	ldd	r18, Y+2	; 0x02
    4698:	3b 81       	ldd	r19, Y+3	; 0x03
    469a:	fc 01       	movw	r30, r24
    469c:	31 83       	std	Z+1, r19	; 0x01
    469e:	20 83       	st	Z, r18

			if( xShouldDelay != pdFALSE )
    46a0:	89 81       	ldd	r24, Y+1	; 0x01
    46a2:	88 23       	and	r24, r24
    46a4:	59 f0       	breq	.+22     	; 0x46bc <vTaskDelayUntil+0xea>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    46a6:	80 91 56 0d 	lds	r24, 0x0D56
    46aa:	90 91 57 0d 	lds	r25, 0x0D57
    46ae:	02 96       	adiw	r24, 0x02	; 2
    46b0:	0e 94 0b 19 	call	0x3216	; 0x3216 <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    46b4:	8a 81       	ldd	r24, Y+2	; 0x02
    46b6:	9b 81       	ldd	r25, Y+3	; 0x03
    46b8:	0e 94 1d 28 	call	0x503a	; 0x503a <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    46bc:	0e 94 f3 23 	call	0x47e6	; 0x47e6 <xTaskResumeAll>
    46c0:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    46c2:	8c 81       	ldd	r24, Y+4	; 0x04
    46c4:	88 23       	and	r24, r24
    46c6:	11 f4       	brne	.+4      	; 0x46cc <vTaskDelayUntil+0xfa>
		{
			portYIELD_WITHIN_API();
    46c8:	0e 94 47 1b 	call	0x368e	; 0x368e <vPortYield>
		}
	}
    46cc:	28 96       	adiw	r28, 0x08	; 8
    46ce:	0f b6       	in	r0, 0x3f	; 63
    46d0:	f8 94       	cli
    46d2:	de bf       	out	0x3e, r29	; 62
    46d4:	0f be       	out	0x3f, r0	; 63
    46d6:	cd bf       	out	0x3d, r28	; 61
    46d8:	df 91       	pop	r29
    46da:	cf 91       	pop	r28
    46dc:	08 95       	ret

000046de <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( uint16_t xTicksToDelay )
	{
    46de:	cf 93       	push	r28
    46e0:	df 93       	push	r29
    46e2:	00 d0       	rcall	.+0      	; 0x46e4 <vTaskDelay+0x6>
    46e4:	00 d0       	rcall	.+0      	; 0x46e6 <vTaskDelay+0x8>
    46e6:	0f 92       	push	r0
    46e8:	cd b7       	in	r28, 0x3d	; 61
    46ea:	de b7       	in	r29, 0x3e	; 62
    46ec:	9d 83       	std	Y+5, r25	; 0x05
    46ee:	8c 83       	std	Y+4, r24	; 0x04
	uint16_t xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    46f0:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( uint16_t ) 0U )
    46f2:	8c 81       	ldd	r24, Y+4	; 0x04
    46f4:	9d 81       	ldd	r25, Y+5	; 0x05
    46f6:	00 97       	sbiw	r24, 0x00	; 0
    46f8:	d1 f0       	breq	.+52     	; 0x472e <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    46fa:	0e 94 e7 23 	call	0x47ce	; 0x47ce <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    46fe:	20 91 a6 0d 	lds	r18, 0x0DA6
    4702:	30 91 a7 0d 	lds	r19, 0x0DA7
    4706:	8c 81       	ldd	r24, Y+4	; 0x04
    4708:	9d 81       	ldd	r25, Y+5	; 0x05
    470a:	82 0f       	add	r24, r18
    470c:	93 1f       	adc	r25, r19
    470e:	9b 83       	std	Y+3, r25	; 0x03
    4710:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    4712:	80 91 56 0d 	lds	r24, 0x0D56
    4716:	90 91 57 0d 	lds	r25, 0x0D57
    471a:	02 96       	adiw	r24, 0x02	; 2
    471c:	0e 94 0b 19 	call	0x3216	; 0x3216 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    4720:	8a 81       	ldd	r24, Y+2	; 0x02
    4722:	9b 81       	ldd	r25, Y+3	; 0x03
    4724:	0e 94 1d 28 	call	0x503a	; 0x503a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    4728:	0e 94 f3 23 	call	0x47e6	; 0x47e6 <xTaskResumeAll>
    472c:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    472e:	89 81       	ldd	r24, Y+1	; 0x01
    4730:	88 23       	and	r24, r24
    4732:	11 f4       	brne	.+4      	; 0x4738 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    4734:	0e 94 47 1b 	call	0x368e	; 0x368e <vPortYield>
		}
	}
    4738:	0f 90       	pop	r0
    473a:	0f 90       	pop	r0
    473c:	0f 90       	pop	r0
    473e:	0f 90       	pop	r0
    4740:	0f 90       	pop	r0
    4742:	df 91       	pop	r29
    4744:	cf 91       	pop	r28
    4746:	08 95       	ret

00004748 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    4748:	af 92       	push	r10
    474a:	bf 92       	push	r11
    474c:	cf 92       	push	r12
    474e:	df 92       	push	r13
    4750:	ef 92       	push	r14
    4752:	ff 92       	push	r15
    4754:	0f 93       	push	r16
    4756:	cf 93       	push	r28
    4758:	df 93       	push	r29
    475a:	0f 92       	push	r0
    475c:	cd b7       	in	r28, 0x3d	; 61
    475e:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    4760:	82 e3       	ldi	r24, 0x32	; 50
    4762:	97 e2       	ldi	r25, 0x27	; 39
    4764:	22 e0       	ldi	r18, 0x02	; 2
    4766:	31 e0       	ldi	r19, 0x01	; 1
    4768:	b9 01       	movw	r22, r18
    476a:	48 ec       	ldi	r20, 0xC8	; 200
    476c:	50 e0       	ldi	r21, 0x00	; 0
    476e:	20 e0       	ldi	r18, 0x00	; 0
    4770:	30 e0       	ldi	r19, 0x00	; 0
    4772:	00 e0       	ldi	r16, 0x00	; 0
    4774:	ee 24       	eor	r14, r14
    4776:	ff 24       	eor	r15, r15
    4778:	cc 24       	eor	r12, r12
    477a:	dd 24       	eor	r13, r13
    477c:	aa 24       	eor	r10, r10
    477e:	bb 24       	eor	r11, r11
    4780:	0e 94 99 21 	call	0x4332	; 0x4332 <xTaskGenericCreate>
    4784:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    4786:	89 81       	ldd	r24, Y+1	; 0x01
    4788:	81 30       	cpi	r24, 0x01	; 1
    478a:	51 f4       	brne	.+20     	; 0x47a0 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    478c:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    478e:	81 e0       	ldi	r24, 0x01	; 1
    4790:	80 93 aa 0d 	sts	0x0DAA, r24
		xTickCount = ( uint16_t ) 0U;
    4794:	10 92 a7 0d 	sts	0x0DA7, r1
    4798:	10 92 a6 0d 	sts	0x0DA6, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    479c:	0e 94 0b 1b 	call	0x3616	; 0x3616 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    47a0:	0f 90       	pop	r0
    47a2:	df 91       	pop	r29
    47a4:	cf 91       	pop	r28
    47a6:	0f 91       	pop	r16
    47a8:	ff 90       	pop	r15
    47aa:	ef 90       	pop	r14
    47ac:	df 90       	pop	r13
    47ae:	cf 90       	pop	r12
    47b0:	bf 90       	pop	r11
    47b2:	af 90       	pop	r10
    47b4:	08 95       	ret

000047b6 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    47b6:	cf 93       	push	r28
    47b8:	df 93       	push	r29
    47ba:	cd b7       	in	r28, 0x3d	; 61
    47bc:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    47be:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    47c0:	10 92 aa 0d 	sts	0x0DAA, r1
	vPortEndScheduler();
    47c4:	0e 94 40 1b 	call	0x3680	; 0x3680 <vPortEndScheduler>
}
    47c8:	df 91       	pop	r29
    47ca:	cf 91       	pop	r28
    47cc:	08 95       	ret

000047ce <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    47ce:	cf 93       	push	r28
    47d0:	df 93       	push	r29
    47d2:	cd b7       	in	r28, 0x3d	; 61
    47d4:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    47d6:	80 91 ab 0d 	lds	r24, 0x0DAB
    47da:	8f 5f       	subi	r24, 0xFF	; 255
    47dc:	80 93 ab 0d 	sts	0x0DAB, r24
}
    47e0:	df 91       	pop	r29
    47e2:	cf 91       	pop	r28
    47e4:	08 95       	ret

000047e6 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    47e6:	0f 93       	push	r16
    47e8:	1f 93       	push	r17
    47ea:	cf 93       	push	r28
    47ec:	df 93       	push	r29
    47ee:	00 d0       	rcall	.+0      	; 0x47f0 <xTaskResumeAll+0xa>
    47f0:	cd b7       	in	r28, 0x3d	; 61
    47f2:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    47f4:	19 82       	std	Y+1, r1	; 0x01
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    47f6:	0f b6       	in	r0, 0x3f	; 63
    47f8:	f8 94       	cli
    47fa:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    47fc:	80 91 ab 0d 	lds	r24, 0x0DAB
    4800:	81 50       	subi	r24, 0x01	; 1
    4802:	80 93 ab 0d 	sts	0x0DAB, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4806:	80 91 ab 0d 	lds	r24, 0x0DAB
    480a:	88 23       	and	r24, r24
    480c:	09 f0       	breq	.+2      	; 0x4810 <xTaskResumeAll+0x2a>
    480e:	64 c0       	rjmp	.+200    	; 0x48d8 <xTaskResumeAll+0xf2>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    4810:	80 91 a5 0d 	lds	r24, 0x0DA5
    4814:	88 23       	and	r24, r24
    4816:	09 f4       	brne	.+2      	; 0x481a <xTaskResumeAll+0x34>
    4818:	5f c0       	rjmp	.+190    	; 0x48d8 <xTaskResumeAll+0xf2>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    481a:	1a 82       	std	Y+2, r1	; 0x02

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    481c:	3a c0       	rjmp	.+116    	; 0x4892 <xTaskResumeAll+0xac>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    481e:	80 91 97 0d 	lds	r24, 0x0D97
    4822:	90 91 98 0d 	lds	r25, 0x0D98
    4826:	fc 01       	movw	r30, r24
    4828:	06 81       	ldd	r16, Z+6	; 0x06
    482a:	17 81       	ldd	r17, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
    482c:	c8 01       	movw	r24, r16
    482e:	0c 96       	adiw	r24, 0x0c	; 12
    4830:	0e 94 0b 19 	call	0x3216	; 0x3216 <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
    4834:	c8 01       	movw	r24, r16
    4836:	02 96       	adiw	r24, 0x02	; 2
    4838:	0e 94 0b 19 	call	0x3216	; 0x3216 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    483c:	f8 01       	movw	r30, r16
    483e:	96 89       	ldd	r25, Z+22	; 0x16
    4840:	80 91 a9 0d 	lds	r24, 0x0DA9
    4844:	89 17       	cp	r24, r25
    4846:	20 f4       	brcc	.+8      	; 0x4850 <xTaskResumeAll+0x6a>
    4848:	f8 01       	movw	r30, r16
    484a:	86 89       	ldd	r24, Z+22	; 0x16
    484c:	80 93 a9 0d 	sts	0x0DA9, r24
    4850:	f8 01       	movw	r30, r16
    4852:	86 89       	ldd	r24, Z+22	; 0x16
    4854:	28 2f       	mov	r18, r24
    4856:	30 e0       	ldi	r19, 0x00	; 0
    4858:	c9 01       	movw	r24, r18
    485a:	88 0f       	add	r24, r24
    485c:	99 1f       	adc	r25, r25
    485e:	88 0f       	add	r24, r24
    4860:	99 1f       	adc	r25, r25
    4862:	88 0f       	add	r24, r24
    4864:	99 1f       	adc	r25, r25
    4866:	82 0f       	add	r24, r18
    4868:	93 1f       	adc	r25, r19
    486a:	88 5a       	subi	r24, 0xA8	; 168
    486c:	92 4f       	sbci	r25, 0xF2	; 242
    486e:	98 01       	movw	r18, r16
    4870:	2e 5f       	subi	r18, 0xFE	; 254
    4872:	3f 4f       	sbci	r19, 0xFF	; 255
    4874:	b9 01       	movw	r22, r18
    4876:	0e 94 28 18 	call	0x3050	; 0x3050 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    487a:	f8 01       	movw	r30, r16
    487c:	26 89       	ldd	r18, Z+22	; 0x16
    487e:	80 91 56 0d 	lds	r24, 0x0D56
    4882:	90 91 57 0d 	lds	r25, 0x0D57
    4886:	fc 01       	movw	r30, r24
    4888:	86 89       	ldd	r24, Z+22	; 0x16
    488a:	28 17       	cp	r18, r24
    488c:	10 f0       	brcs	.+4      	; 0x4892 <xTaskResumeAll+0xac>
					{
						xYieldRequired = pdTRUE;
    488e:	81 e0       	ldi	r24, 0x01	; 1
    4890:	8a 83       	std	Y+2, r24	; 0x02
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    4892:	80 91 92 0d 	lds	r24, 0x0D92
    4896:	88 23       	and	r24, r24
    4898:	11 f6       	brne	.-124    	; 0x481e <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    489a:	80 91 ac 0d 	lds	r24, 0x0DAC
    489e:	88 23       	and	r24, r24
    48a0:	71 f0       	breq	.+28     	; 0x48be <xTaskResumeAll+0xd8>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    48a2:	07 c0       	rjmp	.+14     	; 0x48b2 <xTaskResumeAll+0xcc>
					{
						vTaskIncrementTick();
    48a4:	0e 94 ab 24 	call	0x4956	; 0x4956 <vTaskIncrementTick>
						--uxMissedTicks;
    48a8:	80 91 ac 0d 	lds	r24, 0x0DAC
    48ac:	81 50       	subi	r24, 0x01	; 1
    48ae:	80 93 ac 0d 	sts	0x0DAC, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    48b2:	80 91 ac 0d 	lds	r24, 0x0DAC
    48b6:	88 23       	and	r24, r24
    48b8:	a9 f7       	brne	.-22     	; 0x48a4 <xTaskResumeAll+0xbe>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    48ba:	81 e0       	ldi	r24, 0x01	; 1
    48bc:	8a 83       	std	Y+2, r24	; 0x02
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    48be:	8a 81       	ldd	r24, Y+2	; 0x02
    48c0:	81 30       	cpi	r24, 0x01	; 1
    48c2:	21 f0       	breq	.+8      	; 0x48cc <xTaskResumeAll+0xe6>
    48c4:	80 91 ad 0d 	lds	r24, 0x0DAD
    48c8:	81 30       	cpi	r24, 0x01	; 1
    48ca:	31 f4       	brne	.+12     	; 0x48d8 <xTaskResumeAll+0xf2>
				{
					xAlreadyYielded = pdTRUE;
    48cc:	81 e0       	ldi	r24, 0x01	; 1
    48ce:	89 83       	std	Y+1, r24	; 0x01
					xMissedYield = pdFALSE;
    48d0:	10 92 ad 0d 	sts	0x0DAD, r1
					portYIELD_WITHIN_API();
    48d4:	0e 94 47 1b 	call	0x368e	; 0x368e <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    48d8:	0f 90       	pop	r0
    48da:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    48dc:	89 81       	ldd	r24, Y+1	; 0x01
}
    48de:	0f 90       	pop	r0
    48e0:	0f 90       	pop	r0
    48e2:	df 91       	pop	r29
    48e4:	cf 91       	pop	r28
    48e6:	1f 91       	pop	r17
    48e8:	0f 91       	pop	r16
    48ea:	08 95       	ret

000048ec <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

uint16_t xTaskGetTickCount( void )
{
    48ec:	cf 93       	push	r28
    48ee:	df 93       	push	r29
    48f0:	00 d0       	rcall	.+0      	; 0x48f2 <xTaskGetTickCount+0x6>
    48f2:	cd b7       	in	r28, 0x3d	; 61
    48f4:	de b7       	in	r29, 0x3e	; 62
uint16_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    48f6:	0f b6       	in	r0, 0x3f	; 63
    48f8:	f8 94       	cli
    48fa:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    48fc:	80 91 a6 0d 	lds	r24, 0x0DA6
    4900:	90 91 a7 0d 	lds	r25, 0x0DA7
    4904:	9a 83       	std	Y+2, r25	; 0x02
    4906:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4908:	0f 90       	pop	r0
    490a:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    490c:	89 81       	ldd	r24, Y+1	; 0x01
    490e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4910:	0f 90       	pop	r0
    4912:	0f 90       	pop	r0
    4914:	df 91       	pop	r29
    4916:	cf 91       	pop	r28
    4918:	08 95       	ret

0000491a <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

uint16_t xTaskGetTickCountFromISR( void )
{
    491a:	cf 93       	push	r28
    491c:	df 93       	push	r29
    491e:	00 d0       	rcall	.+0      	; 0x4920 <xTaskGetTickCountFromISR+0x6>
    4920:	0f 92       	push	r0
    4922:	cd b7       	in	r28, 0x3d	; 61
    4924:	de b7       	in	r29, 0x3e	; 62
uint16_t xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4926:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    4928:	80 91 a6 0d 	lds	r24, 0x0DA6
    492c:	90 91 a7 0d 	lds	r25, 0x0DA7
    4930:	9b 83       	std	Y+3, r25	; 0x03
    4932:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4934:	8a 81       	ldd	r24, Y+2	; 0x02
    4936:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4938:	0f 90       	pop	r0
    493a:	0f 90       	pop	r0
    493c:	0f 90       	pop	r0
    493e:	df 91       	pop	r29
    4940:	cf 91       	pop	r28
    4942:	08 95       	ret

00004944 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    4944:	cf 93       	push	r28
    4946:	df 93       	push	r29
    4948:	cd b7       	in	r28, 0x3d	; 61
    494a:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    494c:	80 91 a5 0d 	lds	r24, 0x0DA5
}
    4950:	df 91       	pop	r29
    4952:	cf 91       	pop	r28
    4954:	08 95       	ret

00004956 <vTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    4956:	cf 93       	push	r28
    4958:	df 93       	push	r29
    495a:	00 d0       	rcall	.+0      	; 0x495c <vTaskIncrementTick+0x6>
    495c:	00 d0       	rcall	.+0      	; 0x495e <vTaskIncrementTick+0x8>
    495e:	00 d0       	rcall	.+0      	; 0x4960 <vTaskIncrementTick+0xa>
    4960:	cd b7       	in	r28, 0x3d	; 61
    4962:	de b7       	in	r29, 0x3e	; 62

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4964:	80 91 ab 0d 	lds	r24, 0x0DAB
    4968:	88 23       	and	r24, r24
    496a:	09 f0       	breq	.+2      	; 0x496e <vTaskIncrementTick+0x18>
    496c:	cb c0       	rjmp	.+406    	; 0x4b04 <vTaskIncrementTick+0x1ae>
	{
		++xTickCount;
    496e:	80 91 a6 0d 	lds	r24, 0x0DA6
    4972:	90 91 a7 0d 	lds	r25, 0x0DA7
    4976:	01 96       	adiw	r24, 0x01	; 1
    4978:	90 93 a7 0d 	sts	0x0DA7, r25
    497c:	80 93 a6 0d 	sts	0x0DA6, r24
        
if( xTickCount==65535 )
    4980:	80 91 a6 0d 	lds	r24, 0x0DA6
    4984:	90 91 a7 0d 	lds	r25, 0x0DA7
    4988:	2f ef       	ldi	r18, 0xFF	; 255
    498a:	8f 3f       	cpi	r24, 0xFF	; 255
    498c:	92 07       	cpc	r25, r18
    498e:	09 f4       	brne	.+2      	; 0x4992 <vTaskIncrementTick+0x3c>
{
    asm("nop");
    4990:	00 00       	nop
}
        
		if( xTickCount == ( uint16_t ) 0U )
    4992:	80 91 a6 0d 	lds	r24, 0x0DA6
    4996:	90 91 a7 0d 	lds	r25, 0x0DA7
    499a:	00 97       	sbiw	r24, 0x00	; 0
    499c:	e9 f5       	brne	.+122    	; 0x4a18 <vTaskIncrementTick+0xc2>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
    499e:	80 91 8e 0d 	lds	r24, 0x0D8E
    49a2:	90 91 8f 0d 	lds	r25, 0x0D8F
    49a6:	9a 83       	std	Y+2, r25	; 0x02
    49a8:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    49aa:	80 91 90 0d 	lds	r24, 0x0D90
    49ae:	90 91 91 0d 	lds	r25, 0x0D91
    49b2:	90 93 8f 0d 	sts	0x0D8F, r25
    49b6:	80 93 8e 0d 	sts	0x0D8E, r24
			pxOverflowDelayedTaskList = pxTemp;
    49ba:	89 81       	ldd	r24, Y+1	; 0x01
    49bc:	9a 81       	ldd	r25, Y+2	; 0x02
    49be:	90 93 91 0d 	sts	0x0D91, r25
    49c2:	80 93 90 0d 	sts	0x0D90, r24
			xNumOfOverflows++;
    49c6:	80 91 ae 0d 	lds	r24, 0x0DAE
    49ca:	8f 5f       	subi	r24, 0xFF	; 255
    49cc:	80 93 ae 0d 	sts	0x0DAE, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    49d0:	80 91 8e 0d 	lds	r24, 0x0D8E
    49d4:	90 91 8f 0d 	lds	r25, 0x0D8F
    49d8:	fc 01       	movw	r30, r24
    49da:	80 81       	ld	r24, Z
    49dc:	88 23       	and	r24, r24
    49de:	39 f4       	brne	.+14     	; 0x49ee <vTaskIncrementTick+0x98>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    49e0:	8f ef       	ldi	r24, 0xFF	; 255
    49e2:	9f ef       	ldi	r25, 0xFF	; 255
    49e4:	90 93 01 01 	sts	0x0101, r25
    49e8:	80 93 00 01 	sts	0x0100, r24
    49ec:	15 c0       	rjmp	.+42     	; 0x4a18 <vTaskIncrementTick+0xc2>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    49ee:	80 91 8e 0d 	lds	r24, 0x0D8E
    49f2:	90 91 8f 0d 	lds	r25, 0x0D8F
    49f6:	fc 01       	movw	r30, r24
    49f8:	85 81       	ldd	r24, Z+5	; 0x05
    49fa:	96 81       	ldd	r25, Z+6	; 0x06
    49fc:	fc 01       	movw	r30, r24
    49fe:	86 81       	ldd	r24, Z+6	; 0x06
    4a00:	97 81       	ldd	r25, Z+7	; 0x07
    4a02:	9c 83       	std	Y+4, r25	; 0x04
    4a04:	8b 83       	std	Y+3, r24	; 0x03
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    4a06:	8b 81       	ldd	r24, Y+3	; 0x03
    4a08:	9c 81       	ldd	r25, Y+4	; 0x04
    4a0a:	fc 01       	movw	r30, r24
    4a0c:	82 81       	ldd	r24, Z+2	; 0x02
    4a0e:	93 81       	ldd	r25, Z+3	; 0x03
    4a10:	90 93 01 01 	sts	0x0101, r25
    4a14:	80 93 00 01 	sts	0x0100, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    4a18:	20 91 a6 0d 	lds	r18, 0x0DA6
    4a1c:	30 91 a7 0d 	lds	r19, 0x0DA7
    4a20:	80 91 00 01 	lds	r24, 0x0100
    4a24:	90 91 01 01 	lds	r25, 0x0101
    4a28:	28 17       	cp	r18, r24
    4a2a:	39 07       	cpc	r19, r25
    4a2c:	08 f4       	brcc	.+2      	; 0x4a30 <vTaskIncrementTick+0xda>
    4a2e:	6f c0       	rjmp	.+222    	; 0x4b0e <vTaskIncrementTick+0x1b8>
    4a30:	80 91 8e 0d 	lds	r24, 0x0D8E
    4a34:	90 91 8f 0d 	lds	r25, 0x0D8F
    4a38:	fc 01       	movw	r30, r24
    4a3a:	80 81       	ld	r24, Z
    4a3c:	88 23       	and	r24, r24
    4a3e:	39 f4       	brne	.+14     	; 0x4a4e <vTaskIncrementTick+0xf8>
    4a40:	8f ef       	ldi	r24, 0xFF	; 255
    4a42:	9f ef       	ldi	r25, 0xFF	; 255
    4a44:	90 93 01 01 	sts	0x0101, r25
    4a48:	80 93 00 01 	sts	0x0100, r24
    4a4c:	60 c0       	rjmp	.+192    	; 0x4b0e <vTaskIncrementTick+0x1b8>
    4a4e:	80 91 8e 0d 	lds	r24, 0x0D8E
    4a52:	90 91 8f 0d 	lds	r25, 0x0D8F
    4a56:	fc 01       	movw	r30, r24
    4a58:	85 81       	ldd	r24, Z+5	; 0x05
    4a5a:	96 81       	ldd	r25, Z+6	; 0x06
    4a5c:	fc 01       	movw	r30, r24
    4a5e:	86 81       	ldd	r24, Z+6	; 0x06
    4a60:	97 81       	ldd	r25, Z+7	; 0x07
    4a62:	9c 83       	std	Y+4, r25	; 0x04
    4a64:	8b 83       	std	Y+3, r24	; 0x03
    4a66:	8b 81       	ldd	r24, Y+3	; 0x03
    4a68:	9c 81       	ldd	r25, Y+4	; 0x04
    4a6a:	fc 01       	movw	r30, r24
    4a6c:	82 81       	ldd	r24, Z+2	; 0x02
    4a6e:	93 81       	ldd	r25, Z+3	; 0x03
    4a70:	9e 83       	std	Y+6, r25	; 0x06
    4a72:	8d 83       	std	Y+5, r24	; 0x05
    4a74:	20 91 a6 0d 	lds	r18, 0x0DA6
    4a78:	30 91 a7 0d 	lds	r19, 0x0DA7
    4a7c:	8d 81       	ldd	r24, Y+5	; 0x05
    4a7e:	9e 81       	ldd	r25, Y+6	; 0x06
    4a80:	28 17       	cp	r18, r24
    4a82:	39 07       	cpc	r19, r25
    4a84:	38 f4       	brcc	.+14     	; 0x4a94 <vTaskIncrementTick+0x13e>
    4a86:	8d 81       	ldd	r24, Y+5	; 0x05
    4a88:	9e 81       	ldd	r25, Y+6	; 0x06
    4a8a:	90 93 01 01 	sts	0x0101, r25
    4a8e:	80 93 00 01 	sts	0x0100, r24
    4a92:	3d c0       	rjmp	.+122    	; 0x4b0e <vTaskIncrementTick+0x1b8>
    4a94:	8b 81       	ldd	r24, Y+3	; 0x03
    4a96:	9c 81       	ldd	r25, Y+4	; 0x04
    4a98:	02 96       	adiw	r24, 0x02	; 2
    4a9a:	0e 94 0b 19 	call	0x3216	; 0x3216 <uxListRemove>
    4a9e:	8b 81       	ldd	r24, Y+3	; 0x03
    4aa0:	9c 81       	ldd	r25, Y+4	; 0x04
    4aa2:	fc 01       	movw	r30, r24
    4aa4:	84 89       	ldd	r24, Z+20	; 0x14
    4aa6:	95 89       	ldd	r25, Z+21	; 0x15
    4aa8:	00 97       	sbiw	r24, 0x00	; 0
    4aaa:	29 f0       	breq	.+10     	; 0x4ab6 <vTaskIncrementTick+0x160>
    4aac:	8b 81       	ldd	r24, Y+3	; 0x03
    4aae:	9c 81       	ldd	r25, Y+4	; 0x04
    4ab0:	0c 96       	adiw	r24, 0x0c	; 12
    4ab2:	0e 94 0b 19 	call	0x3216	; 0x3216 <uxListRemove>
    4ab6:	8b 81       	ldd	r24, Y+3	; 0x03
    4ab8:	9c 81       	ldd	r25, Y+4	; 0x04
    4aba:	fc 01       	movw	r30, r24
    4abc:	96 89       	ldd	r25, Z+22	; 0x16
    4abe:	80 91 a9 0d 	lds	r24, 0x0DA9
    4ac2:	89 17       	cp	r24, r25
    4ac4:	30 f4       	brcc	.+12     	; 0x4ad2 <vTaskIncrementTick+0x17c>
    4ac6:	8b 81       	ldd	r24, Y+3	; 0x03
    4ac8:	9c 81       	ldd	r25, Y+4	; 0x04
    4aca:	fc 01       	movw	r30, r24
    4acc:	86 89       	ldd	r24, Z+22	; 0x16
    4ace:	80 93 a9 0d 	sts	0x0DA9, r24
    4ad2:	8b 81       	ldd	r24, Y+3	; 0x03
    4ad4:	9c 81       	ldd	r25, Y+4	; 0x04
    4ad6:	fc 01       	movw	r30, r24
    4ad8:	86 89       	ldd	r24, Z+22	; 0x16
    4ada:	28 2f       	mov	r18, r24
    4adc:	30 e0       	ldi	r19, 0x00	; 0
    4ade:	c9 01       	movw	r24, r18
    4ae0:	88 0f       	add	r24, r24
    4ae2:	99 1f       	adc	r25, r25
    4ae4:	88 0f       	add	r24, r24
    4ae6:	99 1f       	adc	r25, r25
    4ae8:	88 0f       	add	r24, r24
    4aea:	99 1f       	adc	r25, r25
    4aec:	82 0f       	add	r24, r18
    4aee:	93 1f       	adc	r25, r19
    4af0:	88 5a       	subi	r24, 0xA8	; 168
    4af2:	92 4f       	sbci	r25, 0xF2	; 242
    4af4:	2b 81       	ldd	r18, Y+3	; 0x03
    4af6:	3c 81       	ldd	r19, Y+4	; 0x04
    4af8:	2e 5f       	subi	r18, 0xFE	; 254
    4afa:	3f 4f       	sbci	r19, 0xFF	; 255
    4afc:	b9 01       	movw	r22, r18
    4afe:	0e 94 28 18 	call	0x3050	; 0x3050 <vListInsertEnd>
    4b02:	96 cf       	rjmp	.-212    	; 0x4a30 <vTaskIncrementTick+0xda>
	}
	else
	{
		++uxMissedTicks;
    4b04:	80 91 ac 0d 	lds	r24, 0x0DAC
    4b08:	8f 5f       	subi	r24, 0xFF	; 255
    4b0a:	80 93 ac 0d 	sts	0x0DAC, r24
		{
			vApplicationTickHook();
		}
	}
	#endif /* configUSE_TICK_HOOK */
}
    4b0e:	26 96       	adiw	r28, 0x06	; 6
    4b10:	0f b6       	in	r0, 0x3f	; 63
    4b12:	f8 94       	cli
    4b14:	de bf       	out	0x3e, r29	; 62
    4b16:	0f be       	out	0x3f, r0	; 63
    4b18:	cd bf       	out	0x3d, r28	; 61
    4b1a:	df 91       	pop	r29
    4b1c:	cf 91       	pop	r28
    4b1e:	08 95       	ret

00004b20 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    4b20:	cf 93       	push	r28
    4b22:	df 93       	push	r29
    4b24:	00 d0       	rcall	.+0      	; 0x4b26 <vTaskSwitchContext+0x6>
    4b26:	cd b7       	in	r28, 0x3d	; 61
    4b28:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    4b2a:	80 91 ab 0d 	lds	r24, 0x0DAB
    4b2e:	88 23       	and	r24, r24
    4b30:	49 f0       	breq	.+18     	; 0x4b44 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    4b32:	81 e0       	ldi	r24, 0x01	; 1
    4b34:	80 93 ad 0d 	sts	0x0DAD, r24
    4b38:	5a c0       	rjmp	.+180    	; 0x4bee <vTaskSwitchContext+0xce>
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    4b3a:	80 91 a9 0d 	lds	r24, 0x0DA9
    4b3e:	81 50       	subi	r24, 0x01	; 1
    4b40:	80 93 a9 0d 	sts	0x0DA9, r24
    4b44:	80 91 a9 0d 	lds	r24, 0x0DA9
    4b48:	28 2f       	mov	r18, r24
    4b4a:	30 e0       	ldi	r19, 0x00	; 0
    4b4c:	c9 01       	movw	r24, r18
    4b4e:	88 0f       	add	r24, r24
    4b50:	99 1f       	adc	r25, r25
    4b52:	88 0f       	add	r24, r24
    4b54:	99 1f       	adc	r25, r25
    4b56:	88 0f       	add	r24, r24
    4b58:	99 1f       	adc	r25, r25
    4b5a:	82 0f       	add	r24, r18
    4b5c:	93 1f       	adc	r25, r19
    4b5e:	88 5a       	subi	r24, 0xA8	; 168
    4b60:	92 4f       	sbci	r25, 0xF2	; 242
    4b62:	fc 01       	movw	r30, r24
    4b64:	80 81       	ld	r24, Z
    4b66:	88 23       	and	r24, r24
    4b68:	41 f3       	breq	.-48     	; 0x4b3a <vTaskSwitchContext+0x1a>
    4b6a:	80 91 a9 0d 	lds	r24, 0x0DA9
    4b6e:	28 2f       	mov	r18, r24
    4b70:	30 e0       	ldi	r19, 0x00	; 0
    4b72:	c9 01       	movw	r24, r18
    4b74:	88 0f       	add	r24, r24
    4b76:	99 1f       	adc	r25, r25
    4b78:	88 0f       	add	r24, r24
    4b7a:	99 1f       	adc	r25, r25
    4b7c:	88 0f       	add	r24, r24
    4b7e:	99 1f       	adc	r25, r25
    4b80:	82 0f       	add	r24, r18
    4b82:	93 1f       	adc	r25, r19
    4b84:	88 5a       	subi	r24, 0xA8	; 168
    4b86:	92 4f       	sbci	r25, 0xF2	; 242
    4b88:	9a 83       	std	Y+2, r25	; 0x02
    4b8a:	89 83       	std	Y+1, r24	; 0x01
    4b8c:	89 81       	ldd	r24, Y+1	; 0x01
    4b8e:	9a 81       	ldd	r25, Y+2	; 0x02
    4b90:	fc 01       	movw	r30, r24
    4b92:	81 81       	ldd	r24, Z+1	; 0x01
    4b94:	92 81       	ldd	r25, Z+2	; 0x02
    4b96:	fc 01       	movw	r30, r24
    4b98:	22 81       	ldd	r18, Z+2	; 0x02
    4b9a:	33 81       	ldd	r19, Z+3	; 0x03
    4b9c:	89 81       	ldd	r24, Y+1	; 0x01
    4b9e:	9a 81       	ldd	r25, Y+2	; 0x02
    4ba0:	fc 01       	movw	r30, r24
    4ba2:	32 83       	std	Z+2, r19	; 0x02
    4ba4:	21 83       	std	Z+1, r18	; 0x01
    4ba6:	89 81       	ldd	r24, Y+1	; 0x01
    4ba8:	9a 81       	ldd	r25, Y+2	; 0x02
    4baa:	fc 01       	movw	r30, r24
    4bac:	21 81       	ldd	r18, Z+1	; 0x01
    4bae:	32 81       	ldd	r19, Z+2	; 0x02
    4bb0:	89 81       	ldd	r24, Y+1	; 0x01
    4bb2:	9a 81       	ldd	r25, Y+2	; 0x02
    4bb4:	03 96       	adiw	r24, 0x03	; 3
    4bb6:	28 17       	cp	r18, r24
    4bb8:	39 07       	cpc	r19, r25
    4bba:	69 f4       	brne	.+26     	; 0x4bd6 <vTaskSwitchContext+0xb6>
    4bbc:	89 81       	ldd	r24, Y+1	; 0x01
    4bbe:	9a 81       	ldd	r25, Y+2	; 0x02
    4bc0:	fc 01       	movw	r30, r24
    4bc2:	81 81       	ldd	r24, Z+1	; 0x01
    4bc4:	92 81       	ldd	r25, Z+2	; 0x02
    4bc6:	fc 01       	movw	r30, r24
    4bc8:	22 81       	ldd	r18, Z+2	; 0x02
    4bca:	33 81       	ldd	r19, Z+3	; 0x03
    4bcc:	89 81       	ldd	r24, Y+1	; 0x01
    4bce:	9a 81       	ldd	r25, Y+2	; 0x02
    4bd0:	fc 01       	movw	r30, r24
    4bd2:	32 83       	std	Z+2, r19	; 0x02
    4bd4:	21 83       	std	Z+1, r18	; 0x01
    4bd6:	89 81       	ldd	r24, Y+1	; 0x01
    4bd8:	9a 81       	ldd	r25, Y+2	; 0x02
    4bda:	fc 01       	movw	r30, r24
    4bdc:	81 81       	ldd	r24, Z+1	; 0x01
    4bde:	92 81       	ldd	r25, Z+2	; 0x02
    4be0:	fc 01       	movw	r30, r24
    4be2:	86 81       	ldd	r24, Z+6	; 0x06
    4be4:	97 81       	ldd	r25, Z+7	; 0x07
    4be6:	90 93 57 0d 	sts	0x0D57, r25
    4bea:	80 93 56 0d 	sts	0x0D56, r24

		traceTASK_SWITCHED_IN();
	}
}
    4bee:	0f 90       	pop	r0
    4bf0:	0f 90       	pop	r0
    4bf2:	df 91       	pop	r29
    4bf4:	cf 91       	pop	r28
    4bf6:	08 95       	ret

00004bf8 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, uint16_t xTicksToWait )
{
    4bf8:	cf 93       	push	r28
    4bfa:	df 93       	push	r29
    4bfc:	00 d0       	rcall	.+0      	; 0x4bfe <vTaskPlaceOnEventList+0x6>
    4bfe:	00 d0       	rcall	.+0      	; 0x4c00 <vTaskPlaceOnEventList+0x8>
    4c00:	00 d0       	rcall	.+0      	; 0x4c02 <vTaskPlaceOnEventList+0xa>
    4c02:	cd b7       	in	r28, 0x3d	; 61
    4c04:	de b7       	in	r29, 0x3e	; 62
    4c06:	9c 83       	std	Y+4, r25	; 0x04
    4c08:	8b 83       	std	Y+3, r24	; 0x03
    4c0a:	7e 83       	std	Y+6, r23	; 0x06
    4c0c:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    4c0e:	80 91 56 0d 	lds	r24, 0x0D56
    4c12:	90 91 57 0d 	lds	r25, 0x0D57
    4c16:	9c 01       	movw	r18, r24
    4c18:	24 5f       	subi	r18, 0xF4	; 244
    4c1a:	3f 4f       	sbci	r19, 0xFF	; 255
    4c1c:	8b 81       	ldd	r24, Y+3	; 0x03
    4c1e:	9c 81       	ldd	r25, Y+4	; 0x04
    4c20:	b9 01       	movw	r22, r18
    4c22:	0e 94 80 18 	call	0x3100	; 0x3100 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    4c26:	80 91 56 0d 	lds	r24, 0x0D56
    4c2a:	90 91 57 0d 	lds	r25, 0x0D57
    4c2e:	02 96       	adiw	r24, 0x02	; 2
    4c30:	0e 94 0b 19 	call	0x3216	; 0x3216 <uxListRemove>
	}
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    4c34:	20 91 a6 0d 	lds	r18, 0x0DA6
    4c38:	30 91 a7 0d 	lds	r19, 0x0DA7
    4c3c:	8d 81       	ldd	r24, Y+5	; 0x05
    4c3e:	9e 81       	ldd	r25, Y+6	; 0x06
    4c40:	82 0f       	add	r24, r18
    4c42:	93 1f       	adc	r25, r19
    4c44:	9a 83       	std	Y+2, r25	; 0x02
    4c46:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    4c48:	89 81       	ldd	r24, Y+1	; 0x01
    4c4a:	9a 81       	ldd	r25, Y+2	; 0x02
    4c4c:	0e 94 1d 28 	call	0x503a	; 0x503a <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    4c50:	26 96       	adiw	r28, 0x06	; 6
    4c52:	0f b6       	in	r0, 0x3f	; 63
    4c54:	f8 94       	cli
    4c56:	de bf       	out	0x3e, r29	; 62
    4c58:	0f be       	out	0x3f, r0	; 63
    4c5a:	cd bf       	out	0x3d, r28	; 61
    4c5c:	df 91       	pop	r29
    4c5e:	cf 91       	pop	r28
    4c60:	08 95       	ret

00004c62 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    4c62:	cf 93       	push	r28
    4c64:	df 93       	push	r29
    4c66:	00 d0       	rcall	.+0      	; 0x4c68 <xTaskRemoveFromEventList+0x6>
    4c68:	00 d0       	rcall	.+0      	; 0x4c6a <xTaskRemoveFromEventList+0x8>
    4c6a:	0f 92       	push	r0
    4c6c:	cd b7       	in	r28, 0x3d	; 61
    4c6e:	de b7       	in	r29, 0x3e	; 62
    4c70:	9d 83       	std	Y+5, r25	; 0x05
    4c72:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    4c74:	8c 81       	ldd	r24, Y+4	; 0x04
    4c76:	9d 81       	ldd	r25, Y+5	; 0x05
    4c78:	fc 01       	movw	r30, r24
    4c7a:	85 81       	ldd	r24, Z+5	; 0x05
    4c7c:	96 81       	ldd	r25, Z+6	; 0x06
    4c7e:	fc 01       	movw	r30, r24
    4c80:	86 81       	ldd	r24, Z+6	; 0x06
    4c82:	97 81       	ldd	r25, Z+7	; 0x07
    4c84:	9b 83       	std	Y+3, r25	; 0x03
    4c86:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4c88:	8a 81       	ldd	r24, Y+2	; 0x02
    4c8a:	9b 81       	ldd	r25, Y+3	; 0x03
    4c8c:	0c 96       	adiw	r24, 0x0c	; 12
    4c8e:	0e 94 0b 19 	call	0x3216	; 0x3216 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4c92:	80 91 ab 0d 	lds	r24, 0x0DAB
    4c96:	88 23       	and	r24, r24
    4c98:	61 f5       	brne	.+88     	; 0x4cf2 <xTaskRemoveFromEventList+0x90>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    4c9a:	8a 81       	ldd	r24, Y+2	; 0x02
    4c9c:	9b 81       	ldd	r25, Y+3	; 0x03
    4c9e:	02 96       	adiw	r24, 0x02	; 2
    4ca0:	0e 94 0b 19 	call	0x3216	; 0x3216 <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    4ca4:	8a 81       	ldd	r24, Y+2	; 0x02
    4ca6:	9b 81       	ldd	r25, Y+3	; 0x03
    4ca8:	fc 01       	movw	r30, r24
    4caa:	96 89       	ldd	r25, Z+22	; 0x16
    4cac:	80 91 a9 0d 	lds	r24, 0x0DA9
    4cb0:	89 17       	cp	r24, r25
    4cb2:	30 f4       	brcc	.+12     	; 0x4cc0 <xTaskRemoveFromEventList+0x5e>
    4cb4:	8a 81       	ldd	r24, Y+2	; 0x02
    4cb6:	9b 81       	ldd	r25, Y+3	; 0x03
    4cb8:	fc 01       	movw	r30, r24
    4cba:	86 89       	ldd	r24, Z+22	; 0x16
    4cbc:	80 93 a9 0d 	sts	0x0DA9, r24
    4cc0:	8a 81       	ldd	r24, Y+2	; 0x02
    4cc2:	9b 81       	ldd	r25, Y+3	; 0x03
    4cc4:	fc 01       	movw	r30, r24
    4cc6:	86 89       	ldd	r24, Z+22	; 0x16
    4cc8:	28 2f       	mov	r18, r24
    4cca:	30 e0       	ldi	r19, 0x00	; 0
    4ccc:	c9 01       	movw	r24, r18
    4cce:	88 0f       	add	r24, r24
    4cd0:	99 1f       	adc	r25, r25
    4cd2:	88 0f       	add	r24, r24
    4cd4:	99 1f       	adc	r25, r25
    4cd6:	88 0f       	add	r24, r24
    4cd8:	99 1f       	adc	r25, r25
    4cda:	82 0f       	add	r24, r18
    4cdc:	93 1f       	adc	r25, r19
    4cde:	88 5a       	subi	r24, 0xA8	; 168
    4ce0:	92 4f       	sbci	r25, 0xF2	; 242
    4ce2:	2a 81       	ldd	r18, Y+2	; 0x02
    4ce4:	3b 81       	ldd	r19, Y+3	; 0x03
    4ce6:	2e 5f       	subi	r18, 0xFE	; 254
    4ce8:	3f 4f       	sbci	r19, 0xFF	; 255
    4cea:	b9 01       	movw	r22, r18
    4cec:	0e 94 28 18 	call	0x3050	; 0x3050 <vListInsertEnd>
    4cf0:	0a c0       	rjmp	.+20     	; 0x4d06 <xTaskRemoveFromEventList+0xa4>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4cf2:	8a 81       	ldd	r24, Y+2	; 0x02
    4cf4:	9b 81       	ldd	r25, Y+3	; 0x03
    4cf6:	9c 01       	movw	r18, r24
    4cf8:	24 5f       	subi	r18, 0xF4	; 244
    4cfa:	3f 4f       	sbci	r19, 0xFF	; 255
    4cfc:	82 e9       	ldi	r24, 0x92	; 146
    4cfe:	9d e0       	ldi	r25, 0x0D	; 13
    4d00:	b9 01       	movw	r22, r18
    4d02:	0e 94 28 18 	call	0x3050	; 0x3050 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4d06:	8a 81       	ldd	r24, Y+2	; 0x02
    4d08:	9b 81       	ldd	r25, Y+3	; 0x03
    4d0a:	fc 01       	movw	r30, r24
    4d0c:	26 89       	ldd	r18, Z+22	; 0x16
    4d0e:	80 91 56 0d 	lds	r24, 0x0D56
    4d12:	90 91 57 0d 	lds	r25, 0x0D57
    4d16:	fc 01       	movw	r30, r24
    4d18:	86 89       	ldd	r24, Z+22	; 0x16
    4d1a:	28 17       	cp	r18, r24
    4d1c:	18 f0       	brcs	.+6      	; 0x4d24 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    4d1e:	81 e0       	ldi	r24, 0x01	; 1
    4d20:	89 83       	std	Y+1, r24	; 0x01
    4d22:	01 c0       	rjmp	.+2      	; 0x4d26 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    4d24:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4d26:	89 81       	ldd	r24, Y+1	; 0x01
}
    4d28:	0f 90       	pop	r0
    4d2a:	0f 90       	pop	r0
    4d2c:	0f 90       	pop	r0
    4d2e:	0f 90       	pop	r0
    4d30:	0f 90       	pop	r0
    4d32:	df 91       	pop	r29
    4d34:	cf 91       	pop	r28
    4d36:	08 95       	ret

00004d38 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    4d38:	cf 93       	push	r28
    4d3a:	df 93       	push	r29
    4d3c:	00 d0       	rcall	.+0      	; 0x4d3e <vTaskSetTimeOutState+0x6>
    4d3e:	cd b7       	in	r28, 0x3d	; 61
    4d40:	de b7       	in	r29, 0x3e	; 62
    4d42:	9a 83       	std	Y+2, r25	; 0x02
    4d44:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    4d46:	20 91 ae 0d 	lds	r18, 0x0DAE
    4d4a:	89 81       	ldd	r24, Y+1	; 0x01
    4d4c:	9a 81       	ldd	r25, Y+2	; 0x02
    4d4e:	fc 01       	movw	r30, r24
    4d50:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    4d52:	80 91 a6 0d 	lds	r24, 0x0DA6
    4d56:	90 91 a7 0d 	lds	r25, 0x0DA7
    4d5a:	cc 01       	movw	r24, r24
    4d5c:	a0 e0       	ldi	r26, 0x00	; 0
    4d5e:	b0 e0       	ldi	r27, 0x00	; 0
    4d60:	29 81       	ldd	r18, Y+1	; 0x01
    4d62:	3a 81       	ldd	r19, Y+2	; 0x02
    4d64:	f9 01       	movw	r30, r18
    4d66:	81 83       	std	Z+1, r24	; 0x01
    4d68:	92 83       	std	Z+2, r25	; 0x02
    4d6a:	a3 83       	std	Z+3, r26	; 0x03
    4d6c:	b4 83       	std	Z+4, r27	; 0x04
}
    4d6e:	0f 90       	pop	r0
    4d70:	0f 90       	pop	r0
    4d72:	df 91       	pop	r29
    4d74:	cf 91       	pop	r28
    4d76:	08 95       	ret

00004d78 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, uint16_t * const pxTicksToWait )
{
    4d78:	cf 93       	push	r28
    4d7a:	df 93       	push	r29
    4d7c:	00 d0       	rcall	.+0      	; 0x4d7e <xTaskCheckForTimeOut+0x6>
    4d7e:	00 d0       	rcall	.+0      	; 0x4d80 <xTaskCheckForTimeOut+0x8>
    4d80:	0f 92       	push	r0
    4d82:	cd b7       	in	r28, 0x3d	; 61
    4d84:	de b7       	in	r29, 0x3e	; 62
    4d86:	9b 83       	std	Y+3, r25	; 0x03
    4d88:	8a 83       	std	Y+2, r24	; 0x02
    4d8a:	7d 83       	std	Y+5, r23	; 0x05
    4d8c:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4d8e:	0f b6       	in	r0, 0x3f	; 63
    4d90:	f8 94       	cli
    4d92:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( uint16_t ) xTickCount >= ( uint16_t ) pxTimeOut->xTimeOnEntering ) )
    4d94:	8a 81       	ldd	r24, Y+2	; 0x02
    4d96:	9b 81       	ldd	r25, Y+3	; 0x03
    4d98:	fc 01       	movw	r30, r24
    4d9a:	90 81       	ld	r25, Z
    4d9c:	80 91 ae 0d 	lds	r24, 0x0DAE
    4da0:	98 17       	cp	r25, r24
    4da2:	91 f0       	breq	.+36     	; 0x4dc8 <xTaskCheckForTimeOut+0x50>
    4da4:	8a 81       	ldd	r24, Y+2	; 0x02
    4da6:	9b 81       	ldd	r25, Y+3	; 0x03
    4da8:	fc 01       	movw	r30, r24
    4daa:	81 81       	ldd	r24, Z+1	; 0x01
    4dac:	92 81       	ldd	r25, Z+2	; 0x02
    4dae:	a3 81       	ldd	r26, Z+3	; 0x03
    4db0:	b4 81       	ldd	r27, Z+4	; 0x04
    4db2:	9c 01       	movw	r18, r24
    4db4:	80 91 a6 0d 	lds	r24, 0x0DA6
    4db8:	90 91 a7 0d 	lds	r25, 0x0DA7
    4dbc:	82 17       	cp	r24, r18
    4dbe:	93 07       	cpc	r25, r19
    4dc0:	18 f0       	brcs	.+6      	; 0x4dc8 <xTaskCheckForTimeOut+0x50>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    4dc2:	81 e0       	ldi	r24, 0x01	; 1
    4dc4:	89 83       	std	Y+1, r24	; 0x01
    4dc6:	39 c0       	rjmp	.+114    	; 0x4e3a <xTaskCheckForTimeOut+0xc2>
		}
		else if( ( ( uint16_t ) ( ( uint16_t ) xTickCount - ( uint16_t ) pxTimeOut->xTimeOnEntering ) ) < ( uint16_t ) *pxTicksToWait )
    4dc8:	20 91 a6 0d 	lds	r18, 0x0DA6
    4dcc:	30 91 a7 0d 	lds	r19, 0x0DA7
    4dd0:	8a 81       	ldd	r24, Y+2	; 0x02
    4dd2:	9b 81       	ldd	r25, Y+3	; 0x03
    4dd4:	fc 01       	movw	r30, r24
    4dd6:	81 81       	ldd	r24, Z+1	; 0x01
    4dd8:	92 81       	ldd	r25, Z+2	; 0x02
    4dda:	a3 81       	ldd	r26, Z+3	; 0x03
    4ddc:	b4 81       	ldd	r27, Z+4	; 0x04
    4dde:	28 1b       	sub	r18, r24
    4de0:	39 0b       	sbc	r19, r25
    4de2:	8c 81       	ldd	r24, Y+4	; 0x04
    4de4:	9d 81       	ldd	r25, Y+5	; 0x05
    4de6:	fc 01       	movw	r30, r24
    4de8:	80 81       	ld	r24, Z
    4dea:	91 81       	ldd	r25, Z+1	; 0x01
    4dec:	28 17       	cp	r18, r24
    4dee:	39 07       	cpc	r19, r25
    4df0:	10 f5       	brcc	.+68     	; 0x4e36 <xTaskCheckForTimeOut+0xbe>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( uint16_t ) xTickCount - ( uint16_t ) pxTimeOut->xTimeOnEntering );
    4df2:	8c 81       	ldd	r24, Y+4	; 0x04
    4df4:	9d 81       	ldd	r25, Y+5	; 0x05
    4df6:	fc 01       	movw	r30, r24
    4df8:	20 81       	ld	r18, Z
    4dfa:	31 81       	ldd	r19, Z+1	; 0x01
    4dfc:	8a 81       	ldd	r24, Y+2	; 0x02
    4dfe:	9b 81       	ldd	r25, Y+3	; 0x03
    4e00:	fc 01       	movw	r30, r24
    4e02:	81 81       	ldd	r24, Z+1	; 0x01
    4e04:	92 81       	ldd	r25, Z+2	; 0x02
    4e06:	a3 81       	ldd	r26, Z+3	; 0x03
    4e08:	b4 81       	ldd	r27, Z+4	; 0x04
    4e0a:	ac 01       	movw	r20, r24
    4e0c:	80 91 a6 0d 	lds	r24, 0x0DA6
    4e10:	90 91 a7 0d 	lds	r25, 0x0DA7
    4e14:	ba 01       	movw	r22, r20
    4e16:	68 1b       	sub	r22, r24
    4e18:	79 0b       	sbc	r23, r25
    4e1a:	cb 01       	movw	r24, r22
    4e1c:	28 0f       	add	r18, r24
    4e1e:	39 1f       	adc	r19, r25
    4e20:	8c 81       	ldd	r24, Y+4	; 0x04
    4e22:	9d 81       	ldd	r25, Y+5	; 0x05
    4e24:	fc 01       	movw	r30, r24
    4e26:	31 83       	std	Z+1, r19	; 0x01
    4e28:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    4e2a:	8a 81       	ldd	r24, Y+2	; 0x02
    4e2c:	9b 81       	ldd	r25, Y+3	; 0x03
    4e2e:	0e 94 9c 26 	call	0x4d38	; 0x4d38 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    4e32:	19 82       	std	Y+1, r1	; 0x01
    4e34:	02 c0       	rjmp	.+4      	; 0x4e3a <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			xReturn = pdTRUE;
    4e36:	81 e0       	ldi	r24, 0x01	; 1
    4e38:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    4e3a:	0f 90       	pop	r0
    4e3c:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4e3e:	89 81       	ldd	r24, Y+1	; 0x01
}
    4e40:	0f 90       	pop	r0
    4e42:	0f 90       	pop	r0
    4e44:	0f 90       	pop	r0
    4e46:	0f 90       	pop	r0
    4e48:	0f 90       	pop	r0
    4e4a:	df 91       	pop	r29
    4e4c:	cf 91       	pop	r28
    4e4e:	08 95       	ret

00004e50 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    4e50:	cf 93       	push	r28
    4e52:	df 93       	push	r29
    4e54:	cd b7       	in	r28, 0x3d	; 61
    4e56:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    4e58:	81 e0       	ldi	r24, 0x01	; 1
    4e5a:	80 93 ad 0d 	sts	0x0DAD, r24
}
    4e5e:	df 91       	pop	r29
    4e60:	cf 91       	pop	r28
    4e62:	08 95       	ret

00004e64 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    4e64:	cf 93       	push	r28
    4e66:	df 93       	push	r29
    4e68:	00 d0       	rcall	.+0      	; 0x4e6a <prvIdleTask+0x6>
    4e6a:	cd b7       	in	r28, 0x3d	; 61
    4e6c:	de b7       	in	r29, 0x3e	; 62
    4e6e:	9a 83       	std	Y+2, r25	; 0x02
    4e70:	89 83       	std	Y+1, r24	; 0x01
    4e72:	01 c0       	rjmp	.+2      	; 0x4e76 <prvIdleTask+0x12>
				}
				xTaskResumeAll();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    4e74:	00 00       	nop
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    4e76:	0e 94 dd 27 	call	0x4fba	; 0x4fba <prvCheckTasksWaitingTermination>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    4e7a:	80 91 58 0d 	lds	r24, 0x0D58
    4e7e:	82 30       	cpi	r24, 0x02	; 2
    4e80:	c8 f3       	brcs	.-14     	; 0x4e74 <prvIdleTask+0x10>
			{
				taskYIELD();
    4e82:	0e 94 47 1b 	call	0x368e	; 0x368e <vPortYield>
				}
				xTaskResumeAll();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
    4e86:	f6 cf       	rjmp	.-20     	; 0x4e74 <prvIdleTask+0x10>

00004e88 <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    4e88:	0f 93       	push	r16
    4e8a:	1f 93       	push	r17
    4e8c:	cf 93       	push	r28
    4e8e:	df 93       	push	r29
    4e90:	cd b7       	in	r28, 0x3d	; 61
    4e92:	de b7       	in	r29, 0x3e	; 62
    4e94:	29 97       	sbiw	r28, 0x09	; 9
    4e96:	0f b6       	in	r0, 0x3f	; 63
    4e98:	f8 94       	cli
    4e9a:	de bf       	out	0x3e, r29	; 62
    4e9c:	0f be       	out	0x3f, r0	; 63
    4e9e:	cd bf       	out	0x3d, r28	; 61
    4ea0:	9a 83       	std	Y+2, r25	; 0x02
    4ea2:	89 83       	std	Y+1, r24	; 0x01
    4ea4:	7c 83       	std	Y+4, r23	; 0x04
    4ea6:	6b 83       	std	Y+3, r22	; 0x03
    4ea8:	4d 83       	std	Y+5, r20	; 0x05
    4eaa:	3f 83       	std	Y+7, r19	; 0x07
    4eac:	2e 83       	std	Y+6, r18	; 0x06
    4eae:	19 87       	std	Y+9, r17	; 0x09
    4eb0:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    4eb2:	89 81       	ldd	r24, Y+1	; 0x01
    4eb4:	9a 81       	ldd	r25, Y+2	; 0x02
    4eb6:	49 96       	adiw	r24, 0x19	; 25
    4eb8:	2b 81       	ldd	r18, Y+3	; 0x03
    4eba:	3c 81       	ldd	r19, Y+4	; 0x04
    4ebc:	b9 01       	movw	r22, r18
    4ebe:	4f e0       	ldi	r20, 0x0F	; 15
    4ec0:	50 e0       	ldi	r21, 0x00	; 0
    4ec2:	0e 94 b5 36 	call	0x6d6a	; 0x6d6a <strncpy>
	}
	#endif /* configMAX_TASK_NAME_LEN */
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    4ec6:	89 81       	ldd	r24, Y+1	; 0x01
    4ec8:	9a 81       	ldd	r25, Y+2	; 0x02
    4eca:	fc 01       	movw	r30, r24
    4ecc:	17 a2       	lds	r17, 0x97

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    4ece:	8d 81       	ldd	r24, Y+5	; 0x05
    4ed0:	84 30       	cpi	r24, 0x04	; 4
    4ed2:	10 f0       	brcs	.+4      	; 0x4ed8 <prvInitialiseTCBVariables+0x50>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    4ed4:	83 e0       	ldi	r24, 0x03	; 3
    4ed6:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    4ed8:	89 81       	ldd	r24, Y+1	; 0x01
    4eda:	9a 81       	ldd	r25, Y+2	; 0x02
    4edc:	2d 81       	ldd	r18, Y+5	; 0x05
    4ede:	fc 01       	movw	r30, r24
    4ee0:	26 8b       	std	Z+22, r18	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    4ee2:	89 81       	ldd	r24, Y+1	; 0x01
    4ee4:	9a 81       	ldd	r25, Y+2	; 0x02
    4ee6:	02 96       	adiw	r24, 0x02	; 2
    4ee8:	0e 94 17 18 	call	0x302e	; 0x302e <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    4eec:	89 81       	ldd	r24, Y+1	; 0x01
    4eee:	9a 81       	ldd	r25, Y+2	; 0x02
    4ef0:	0c 96       	adiw	r24, 0x0c	; 12
    4ef2:	0e 94 17 18 	call	0x302e	; 0x302e <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    4ef6:	89 81       	ldd	r24, Y+1	; 0x01
    4ef8:	9a 81       	ldd	r25, Y+2	; 0x02
    4efa:	29 81       	ldd	r18, Y+1	; 0x01
    4efc:	3a 81       	ldd	r19, Y+2	; 0x02
    4efe:	fc 01       	movw	r30, r24
    4f00:	31 87       	std	Z+9, r19	; 0x09
    4f02:	20 87       	std	Z+8, r18	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( uint16_t ) uxPriority );
    4f04:	8d 81       	ldd	r24, Y+5	; 0x05
    4f06:	88 2f       	mov	r24, r24
    4f08:	90 e0       	ldi	r25, 0x00	; 0
    4f0a:	24 e0       	ldi	r18, 0x04	; 4
    4f0c:	30 e0       	ldi	r19, 0x00	; 0
    4f0e:	28 1b       	sub	r18, r24
    4f10:	39 0b       	sbc	r19, r25
    4f12:	89 81       	ldd	r24, Y+1	; 0x01
    4f14:	9a 81       	ldd	r25, Y+2	; 0x02
    4f16:	fc 01       	movw	r30, r24
    4f18:	35 87       	std	Z+13, r19	; 0x0d
    4f1a:	24 87       	std	Z+12, r18	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    4f1c:	89 81       	ldd	r24, Y+1	; 0x01
    4f1e:	9a 81       	ldd	r25, Y+2	; 0x02
    4f20:	29 81       	ldd	r18, Y+1	; 0x01
    4f22:	3a 81       	ldd	r19, Y+2	; 0x02
    4f24:	fc 01       	movw	r30, r24
    4f26:	33 8b       	std	Z+19, r19	; 0x13
    4f28:	22 8b       	std	Z+18, r18	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif /* portUSING_MPU_WRAPPERS */
}
    4f2a:	29 96       	adiw	r28, 0x09	; 9
    4f2c:	0f b6       	in	r0, 0x3f	; 63
    4f2e:	f8 94       	cli
    4f30:	de bf       	out	0x3e, r29	; 62
    4f32:	0f be       	out	0x3f, r0	; 63
    4f34:	cd bf       	out	0x3d, r28	; 61
    4f36:	df 91       	pop	r29
    4f38:	cf 91       	pop	r28
    4f3a:	1f 91       	pop	r17
    4f3c:	0f 91       	pop	r16
    4f3e:	08 95       	ret

00004f40 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    4f40:	cf 93       	push	r28
    4f42:	df 93       	push	r29
    4f44:	0f 92       	push	r0
    4f46:	cd b7       	in	r28, 0x3d	; 61
    4f48:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4f4a:	19 82       	std	Y+1, r1	; 0x01
    4f4c:	13 c0       	rjmp	.+38     	; 0x4f74 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    4f4e:	89 81       	ldd	r24, Y+1	; 0x01
    4f50:	28 2f       	mov	r18, r24
    4f52:	30 e0       	ldi	r19, 0x00	; 0
    4f54:	c9 01       	movw	r24, r18
    4f56:	88 0f       	add	r24, r24
    4f58:	99 1f       	adc	r25, r25
    4f5a:	88 0f       	add	r24, r24
    4f5c:	99 1f       	adc	r25, r25
    4f5e:	88 0f       	add	r24, r24
    4f60:	99 1f       	adc	r25, r25
    4f62:	82 0f       	add	r24, r18
    4f64:	93 1f       	adc	r25, r19
    4f66:	88 5a       	subi	r24, 0xA8	; 168
    4f68:	92 4f       	sbci	r25, 0xF2	; 242
    4f6a:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    4f6e:	89 81       	ldd	r24, Y+1	; 0x01
    4f70:	8f 5f       	subi	r24, 0xFF	; 255
    4f72:	89 83       	std	Y+1, r24	; 0x01
    4f74:	89 81       	ldd	r24, Y+1	; 0x01
    4f76:	84 30       	cpi	r24, 0x04	; 4
    4f78:	50 f3       	brcs	.-44     	; 0x4f4e <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    4f7a:	8c e7       	ldi	r24, 0x7C	; 124
    4f7c:	9d e0       	ldi	r25, 0x0D	; 13
    4f7e:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    4f82:	85 e8       	ldi	r24, 0x85	; 133
    4f84:	9d e0       	ldi	r25, 0x0D	; 13
    4f86:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    4f8a:	82 e9       	ldi	r24, 0x92	; 146
    4f8c:	9d e0       	ldi	r25, 0x0D	; 13
    4f8e:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    4f92:	8b e9       	ldi	r24, 0x9B	; 155
    4f94:	9d e0       	ldi	r25, 0x0D	; 13
    4f96:	0e 94 e2 17 	call	0x2fc4	; 0x2fc4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    4f9a:	8c e7       	ldi	r24, 0x7C	; 124
    4f9c:	9d e0       	ldi	r25, 0x0D	; 13
    4f9e:	90 93 8f 0d 	sts	0x0D8F, r25
    4fa2:	80 93 8e 0d 	sts	0x0D8E, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    4fa6:	85 e8       	ldi	r24, 0x85	; 133
    4fa8:	9d e0       	ldi	r25, 0x0D	; 13
    4faa:	90 93 91 0d 	sts	0x0D91, r25
    4fae:	80 93 90 0d 	sts	0x0D90, r24
}
    4fb2:	0f 90       	pop	r0
    4fb4:	df 91       	pop	r29
    4fb6:	cf 91       	pop	r28
    4fb8:	08 95       	ret

00004fba <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    4fba:	cf 93       	push	r28
    4fbc:	df 93       	push	r29
    4fbe:	00 d0       	rcall	.+0      	; 0x4fc0 <prvCheckTasksWaitingTermination+0x6>
    4fc0:	0f 92       	push	r0
    4fc2:	cd b7       	in	r28, 0x3d	; 61
    4fc4:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    4fc6:	2f c0       	rjmp	.+94     	; 0x5026 <prvCheckTasksWaitingTermination+0x6c>
		{
			vTaskSuspendAll();
    4fc8:	0e 94 e7 23 	call	0x47ce	; 0x47ce <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    4fcc:	90 91 9b 0d 	lds	r25, 0x0D9B
    4fd0:	81 e0       	ldi	r24, 0x01	; 1
    4fd2:	99 23       	and	r25, r25
    4fd4:	09 f0       	breq	.+2      	; 0x4fd8 <prvCheckTasksWaitingTermination+0x1e>
    4fd6:	80 e0       	ldi	r24, 0x00	; 0
    4fd8:	89 83       	std	Y+1, r24	; 0x01
			xTaskResumeAll();
    4fda:	0e 94 f3 23 	call	0x47e6	; 0x47e6 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    4fde:	89 81       	ldd	r24, Y+1	; 0x01
    4fe0:	88 23       	and	r24, r24
    4fe2:	09 f5       	brne	.+66     	; 0x5026 <prvCheckTasksWaitingTermination+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    4fe4:	0f b6       	in	r0, 0x3f	; 63
    4fe6:	f8 94       	cli
    4fe8:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    4fea:	80 91 a0 0d 	lds	r24, 0x0DA0
    4fee:	90 91 a1 0d 	lds	r25, 0x0DA1
    4ff2:	fc 01       	movw	r30, r24
    4ff4:	86 81       	ldd	r24, Z+6	; 0x06
    4ff6:	97 81       	ldd	r25, Z+7	; 0x07
    4ff8:	9b 83       	std	Y+3, r25	; 0x03
    4ffa:	8a 83       	std	Y+2, r24	; 0x02
					uxListRemove( &( pxTCB->xGenericListItem ) );
    4ffc:	8a 81       	ldd	r24, Y+2	; 0x02
    4ffe:	9b 81       	ldd	r25, Y+3	; 0x03
    5000:	02 96       	adiw	r24, 0x02	; 2
    5002:	0e 94 0b 19 	call	0x3216	; 0x3216 <uxListRemove>
					--uxCurrentNumberOfTasks;
    5006:	80 91 a5 0d 	lds	r24, 0x0DA5
    500a:	81 50       	subi	r24, 0x01	; 1
    500c:	80 93 a5 0d 	sts	0x0DA5, r24
					--uxTasksDeleted;
    5010:	80 91 a4 0d 	lds	r24, 0x0DA4
    5014:	81 50       	subi	r24, 0x01	; 1
    5016:	80 93 a4 0d 	sts	0x0DA4, r24
				}
				taskEXIT_CRITICAL();
    501a:	0f 90       	pop	r0
    501c:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    501e:	8a 81       	ldd	r24, Y+2	; 0x02
    5020:	9b 81       	ldd	r25, Y+3	; 0x03
    5022:	0e 94 af 28 	call	0x515e	; 0x515e <prvDeleteTCB>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    5026:	80 91 a4 0d 	lds	r24, 0x0DA4
    502a:	88 23       	and	r24, r24
    502c:	69 f6       	brne	.-102    	; 0x4fc8 <prvCheckTasksWaitingTermination+0xe>
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif /* vTaskDelete */
}
    502e:	0f 90       	pop	r0
    5030:	0f 90       	pop	r0
    5032:	0f 90       	pop	r0
    5034:	df 91       	pop	r29
    5036:	cf 91       	pop	r28
    5038:	08 95       	ret

0000503a <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( uint16_t xTimeToWake )
{
    503a:	cf 93       	push	r28
    503c:	df 93       	push	r29
    503e:	00 d0       	rcall	.+0      	; 0x5040 <prvAddCurrentTaskToDelayedList+0x6>
    5040:	cd b7       	in	r28, 0x3d	; 61
    5042:	de b7       	in	r29, 0x3e	; 62
    5044:	9a 83       	std	Y+2, r25	; 0x02
    5046:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    5048:	80 91 56 0d 	lds	r24, 0x0D56
    504c:	90 91 57 0d 	lds	r25, 0x0D57
    5050:	29 81       	ldd	r18, Y+1	; 0x01
    5052:	3a 81       	ldd	r19, Y+2	; 0x02
    5054:	fc 01       	movw	r30, r24
    5056:	33 83       	std	Z+3, r19	; 0x03
    5058:	22 83       	std	Z+2, r18	; 0x02

	if( xTimeToWake < xTickCount )
    505a:	80 91 a6 0d 	lds	r24, 0x0DA6
    505e:	90 91 a7 0d 	lds	r25, 0x0DA7
    5062:	29 81       	ldd	r18, Y+1	; 0x01
    5064:	3a 81       	ldd	r19, Y+2	; 0x02
    5066:	28 17       	cp	r18, r24
    5068:	39 07       	cpc	r19, r25
    506a:	70 f4       	brcc	.+28     	; 0x5088 <prvAddCurrentTaskToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    506c:	80 91 90 0d 	lds	r24, 0x0D90
    5070:	90 91 91 0d 	lds	r25, 0x0D91
    5074:	20 91 56 0d 	lds	r18, 0x0D56
    5078:	30 91 57 0d 	lds	r19, 0x0D57
    507c:	2e 5f       	subi	r18, 0xFE	; 254
    507e:	3f 4f       	sbci	r19, 0xFF	; 255
    5080:	b9 01       	movw	r22, r18
    5082:	0e 94 80 18 	call	0x3100	; 0x3100 <vListInsert>
    5086:	1c c0       	rjmp	.+56     	; 0x50c0 <prvAddCurrentTaskToDelayedList+0x86>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5088:	80 91 8e 0d 	lds	r24, 0x0D8E
    508c:	90 91 8f 0d 	lds	r25, 0x0D8F
    5090:	20 91 56 0d 	lds	r18, 0x0D56
    5094:	30 91 57 0d 	lds	r19, 0x0D57
    5098:	2e 5f       	subi	r18, 0xFE	; 254
    509a:	3f 4f       	sbci	r19, 0xFF	; 255
    509c:	b9 01       	movw	r22, r18
    509e:	0e 94 80 18 	call	0x3100	; 0x3100 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    50a2:	80 91 00 01 	lds	r24, 0x0100
    50a6:	90 91 01 01 	lds	r25, 0x0101
    50aa:	29 81       	ldd	r18, Y+1	; 0x01
    50ac:	3a 81       	ldd	r19, Y+2	; 0x02
    50ae:	28 17       	cp	r18, r24
    50b0:	39 07       	cpc	r19, r25
    50b2:	30 f4       	brcc	.+12     	; 0x50c0 <prvAddCurrentTaskToDelayedList+0x86>
		{
			xNextTaskUnblockTime = xTimeToWake;
    50b4:	89 81       	ldd	r24, Y+1	; 0x01
    50b6:	9a 81       	ldd	r25, Y+2	; 0x02
    50b8:	90 93 01 01 	sts	0x0101, r25
    50bc:	80 93 00 01 	sts	0x0100, r24
		}
	}
}
    50c0:	0f 90       	pop	r0
    50c2:	0f 90       	pop	r0
    50c4:	df 91       	pop	r29
    50c6:	cf 91       	pop	r28
    50c8:	08 95       	ret

000050ca <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    50ca:	cf 93       	push	r28
    50cc:	df 93       	push	r29
    50ce:	00 d0       	rcall	.+0      	; 0x50d0 <prvAllocateTCBAndStack+0x6>
    50d0:	00 d0       	rcall	.+0      	; 0x50d2 <prvAllocateTCBAndStack+0x8>
    50d2:	00 d0       	rcall	.+0      	; 0x50d4 <prvAllocateTCBAndStack+0xa>
    50d4:	cd b7       	in	r28, 0x3d	; 61
    50d6:	de b7       	in	r29, 0x3e	; 62
    50d8:	9c 83       	std	Y+4, r25	; 0x04
    50da:	8b 83       	std	Y+3, r24	; 0x03
    50dc:	7e 83       	std	Y+6, r23	; 0x06
    50de:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    50e0:	88 e2       	ldi	r24, 0x28	; 40
    50e2:	90 e0       	ldi	r25, 0x00	; 0
    50e4:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <pvPortMalloc>
    50e8:	9a 83       	std	Y+2, r25	; 0x02
    50ea:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    50ec:	89 81       	ldd	r24, Y+1	; 0x01
    50ee:	9a 81       	ldd	r25, Y+2	; 0x02
    50f0:	00 97       	sbiw	r24, 0x00	; 0
    50f2:	51 f1       	breq	.+84     	; 0x5148 <prvAllocateTCBAndStack+0x7e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    50f4:	8d 81       	ldd	r24, Y+5	; 0x05
    50f6:	9e 81       	ldd	r25, Y+6	; 0x06
    50f8:	00 97       	sbiw	r24, 0x00	; 0
    50fa:	29 f4       	brne	.+10     	; 0x5106 <prvAllocateTCBAndStack+0x3c>
    50fc:	8b 81       	ldd	r24, Y+3	; 0x03
    50fe:	9c 81       	ldd	r25, Y+4	; 0x04
    5100:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <pvPortMalloc>
    5104:	02 c0       	rjmp	.+4      	; 0x510a <prvAllocateTCBAndStack+0x40>
    5106:	8d 81       	ldd	r24, Y+5	; 0x05
    5108:	9e 81       	ldd	r25, Y+6	; 0x06
    510a:	29 81       	ldd	r18, Y+1	; 0x01
    510c:	3a 81       	ldd	r19, Y+2	; 0x02
    510e:	f9 01       	movw	r30, r18
    5110:	90 8f       	std	Z+24, r25	; 0x18
    5112:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    5114:	89 81       	ldd	r24, Y+1	; 0x01
    5116:	9a 81       	ldd	r25, Y+2	; 0x02
    5118:	fc 01       	movw	r30, r24
    511a:	87 89       	ldd	r24, Z+23	; 0x17
    511c:	90 8d       	ldd	r25, Z+24	; 0x18
    511e:	00 97       	sbiw	r24, 0x00	; 0
    5120:	39 f4       	brne	.+14     	; 0x5130 <prvAllocateTCBAndStack+0x66>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    5122:	89 81       	ldd	r24, Y+1	; 0x01
    5124:	9a 81       	ldd	r25, Y+2	; 0x02
    5126:	0e 94 ba 17 	call	0x2f74	; 0x2f74 <vPortFree>
			pxNewTCB = NULL;
    512a:	1a 82       	std	Y+2, r1	; 0x02
    512c:	19 82       	std	Y+1, r1	; 0x01
    512e:	0c c0       	rjmp	.+24     	; 0x5148 <prvAllocateTCBAndStack+0x7e>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    5130:	89 81       	ldd	r24, Y+1	; 0x01
    5132:	9a 81       	ldd	r25, Y+2	; 0x02
    5134:	fc 01       	movw	r30, r24
    5136:	87 89       	ldd	r24, Z+23	; 0x17
    5138:	90 8d       	ldd	r25, Z+24	; 0x18
    513a:	2b 81       	ldd	r18, Y+3	; 0x03
    513c:	3c 81       	ldd	r19, Y+4	; 0x04
    513e:	65 ea       	ldi	r22, 0xA5	; 165
    5140:	70 e0       	ldi	r23, 0x00	; 0
    5142:	a9 01       	movw	r20, r18
    5144:	0e 94 ae 36 	call	0x6d5c	; 0x6d5c <memset>
		}
	}

	return pxNewTCB;
    5148:	89 81       	ldd	r24, Y+1	; 0x01
    514a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    514c:	26 96       	adiw	r28, 0x06	; 6
    514e:	0f b6       	in	r0, 0x3f	; 63
    5150:	f8 94       	cli
    5152:	de bf       	out	0x3e, r29	; 62
    5154:	0f be       	out	0x3f, r0	; 63
    5156:	cd bf       	out	0x3d, r28	; 61
    5158:	df 91       	pop	r29
    515a:	cf 91       	pop	r28
    515c:	08 95       	ret

0000515e <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    515e:	cf 93       	push	r28
    5160:	df 93       	push	r29
    5162:	00 d0       	rcall	.+0      	; 0x5164 <prvDeleteTCB+0x6>
    5164:	cd b7       	in	r28, 0x3d	; 61
    5166:	de b7       	in	r29, 0x3e	; 62
    5168:	9a 83       	std	Y+2, r25	; 0x02
    516a:	89 83       	std	Y+1, r24	; 0x01
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    516c:	89 81       	ldd	r24, Y+1	; 0x01
    516e:	9a 81       	ldd	r25, Y+2	; 0x02
    5170:	fc 01       	movw	r30, r24
    5172:	87 89       	ldd	r24, Z+23	; 0x17
    5174:	90 8d       	ldd	r25, Z+24	; 0x18
    5176:	0e 94 ba 17 	call	0x2f74	; 0x2f74 <vPortFree>
		vPortFree( pxTCB );
    517a:	89 81       	ldd	r24, Y+1	; 0x01
    517c:	9a 81       	ldd	r25, Y+2	; 0x02
    517e:	0e 94 ba 17 	call	0x2f74	; 0x2f74 <vPortFree>
	}
    5182:	0f 90       	pop	r0
    5184:	0f 90       	pop	r0
    5186:	df 91       	pop	r29
    5188:	cf 91       	pop	r28
    518a:	08 95       	ret

0000518c <vAltStartComTestTasks>:
static volatile unsigned portBASE_TYPE uxRxLoops = comINITIAL_RX_COUNT_VALUE;

/*-----------------------------------------------------------*/

void vAltStartComTestTasks( unsigned portBASE_TYPE uxPriority, unsigned long ulBaudRate, unsigned portBASE_TYPE uxLED )
{
    518c:	af 92       	push	r10
    518e:	bf 92       	push	r11
    5190:	cf 92       	push	r12
    5192:	df 92       	push	r13
    5194:	ef 92       	push	r14
    5196:	ff 92       	push	r15
    5198:	0f 93       	push	r16
    519a:	cf 93       	push	r28
    519c:	df 93       	push	r29
    519e:	00 d0       	rcall	.+0      	; 0x51a0 <vAltStartComTestTasks+0x14>
    51a0:	00 d0       	rcall	.+0      	; 0x51a2 <vAltStartComTestTasks+0x16>
    51a2:	00 d0       	rcall	.+0      	; 0x51a4 <vAltStartComTestTasks+0x18>
    51a4:	cd b7       	in	r28, 0x3d	; 61
    51a6:	de b7       	in	r29, 0x3e	; 62
    51a8:	89 83       	std	Y+1, r24	; 0x01
    51aa:	4a 83       	std	Y+2, r20	; 0x02
    51ac:	5b 83       	std	Y+3, r21	; 0x03
    51ae:	6c 83       	std	Y+4, r22	; 0x04
    51b0:	7d 83       	std	Y+5, r23	; 0x05
    51b2:	2e 83       	std	Y+6, r18	; 0x06
	/* Initialise the com port then spawn the Rx and Tx tasks. */
	uxBaseLED = uxLED;
    51b4:	8e 81       	ldd	r24, Y+6	; 0x06
    51b6:	80 93 b2 0d 	sts	0x0DB2, r24
	xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
    51ba:	8a 81       	ldd	r24, Y+2	; 0x02
    51bc:	9b 81       	ldd	r25, Y+3	; 0x03
    51be:	ac 81       	ldd	r26, Y+4	; 0x04
    51c0:	bd 81       	ldd	r27, Y+5	; 0x05
    51c2:	bc 01       	movw	r22, r24
    51c4:	cd 01       	movw	r24, r26
    51c6:	48 e1       	ldi	r20, 0x18	; 24
    51c8:	0e 94 2d 2e 	call	0x5c5a	; 0x5c5a <xSerialPortInitMinimal>

	/* The Tx task is spawned with a lower priority than the Rx task. */
	xTaskCreate( vComTxTask, ( signed char * ) "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( xTaskHandle * ) NULL );
    51cc:	89 81       	ldd	r24, Y+1	; 0x01
    51ce:	e8 2f       	mov	r30, r24
    51d0:	e1 50       	subi	r30, 0x01	; 1
    51d2:	8d e1       	ldi	r24, 0x1D	; 29
    51d4:	99 e2       	ldi	r25, 0x29	; 41
    51d6:	27 e0       	ldi	r18, 0x07	; 7
    51d8:	31 e0       	ldi	r19, 0x01	; 1
    51da:	b9 01       	movw	r22, r18
    51dc:	48 ec       	ldi	r20, 0xC8	; 200
    51de:	50 e0       	ldi	r21, 0x00	; 0
    51e0:	20 e0       	ldi	r18, 0x00	; 0
    51e2:	30 e0       	ldi	r19, 0x00	; 0
    51e4:	0e 2f       	mov	r16, r30
    51e6:	ee 24       	eor	r14, r14
    51e8:	ff 24       	eor	r15, r15
    51ea:	cc 24       	eor	r12, r12
    51ec:	dd 24       	eor	r13, r13
    51ee:	aa 24       	eor	r10, r10
    51f0:	bb 24       	eor	r11, r11
    51f2:	0e 94 99 21 	call	0x4332	; 0x4332 <xTaskGenericCreate>
	xTaskCreate( vComRxTask, ( signed char * ) "COMRx", comSTACK_SIZE, NULL, uxPriority, ( xTaskHandle * ) NULL );
    51f6:	8b e7       	ldi	r24, 0x7B	; 123
    51f8:	99 e2       	ldi	r25, 0x29	; 41
    51fa:	2d e0       	ldi	r18, 0x0D	; 13
    51fc:	31 e0       	ldi	r19, 0x01	; 1
    51fe:	b9 01       	movw	r22, r18
    5200:	48 ec       	ldi	r20, 0xC8	; 200
    5202:	50 e0       	ldi	r21, 0x00	; 0
    5204:	20 e0       	ldi	r18, 0x00	; 0
    5206:	30 e0       	ldi	r19, 0x00	; 0
    5208:	09 81       	ldd	r16, Y+1	; 0x01
    520a:	ee 24       	eor	r14, r14
    520c:	ff 24       	eor	r15, r15
    520e:	cc 24       	eor	r12, r12
    5210:	dd 24       	eor	r13, r13
    5212:	aa 24       	eor	r10, r10
    5214:	bb 24       	eor	r11, r11
    5216:	0e 94 99 21 	call	0x4332	; 0x4332 <xTaskGenericCreate>
}
    521a:	26 96       	adiw	r28, 0x06	; 6
    521c:	0f b6       	in	r0, 0x3f	; 63
    521e:	f8 94       	cli
    5220:	de bf       	out	0x3e, r29	; 62
    5222:	0f be       	out	0x3f, r0	; 63
    5224:	cd bf       	out	0x3d, r28	; 61
    5226:	df 91       	pop	r29
    5228:	cf 91       	pop	r28
    522a:	0f 91       	pop	r16
    522c:	ff 90       	pop	r15
    522e:	ef 90       	pop	r14
    5230:	df 90       	pop	r13
    5232:	cf 90       	pop	r12
    5234:	bf 90       	pop	r11
    5236:	af 90       	pop	r10
    5238:	08 95       	ret

0000523a <vComTxTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComTxTask, pvParameters )
{
    523a:	cf 93       	push	r28
    523c:	df 93       	push	r29
    523e:	cd b7       	in	r28, 0x3d	; 61
    5240:	de b7       	in	r29, 0x3e	; 62
    5242:	27 97       	sbiw	r28, 0x07	; 7
    5244:	0f b6       	in	r0, 0x3f	; 63
    5246:	f8 94       	cli
    5248:	de bf       	out	0x3e, r29	; 62
    524a:	0f be       	out	0x3f, r0	; 63
    524c:	cd bf       	out	0x3d, r28	; 61
    524e:	9f 83       	std	Y+7, r25	; 0x07
    5250:	8e 83       	std	Y+6, r24	; 0x06

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
    5252:	81 e4       	ldi	r24, 0x41	; 65
    5254:	89 83       	std	Y+1, r24	; 0x01
    5256:	13 c0       	rjmp	.+38     	; 0x527e <vComTxTask+0x44>
		{
			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
    5258:	80 91 b0 0d 	lds	r24, 0x0DB0
    525c:	90 91 b1 0d 	lds	r25, 0x0DB1
    5260:	69 81       	ldd	r22, Y+1	; 0x01
    5262:	20 e0       	ldi	r18, 0x00	; 0
    5264:	30 e0       	ldi	r19, 0x00	; 0
    5266:	a9 01       	movw	r20, r18
    5268:	0e 94 d8 2e 	call	0x5db0	; 0x5db0 <xSerialPutChar>
    526c:	81 30       	cpi	r24, 0x01	; 1
    526e:	21 f4       	brne	.+8      	; 0x5278 <vComTxTask+0x3e>
			{
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
    5270:	80 91 b2 0d 	lds	r24, 0x0DB2
    5274:	0e 94 1d 2b 	call	0x563a	; 0x563a <vParTestToggleLED>

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
    5278:	89 81       	ldd	r24, Y+1	; 0x01
    527a:	8f 5f       	subi	r24, 0xFF	; 255
    527c:	89 83       	std	Y+1, r24	; 0x01
    527e:	89 81       	ldd	r24, Y+1	; 0x01
    5280:	89 35       	cpi	r24, 0x59	; 89
    5282:	54 f3       	brlt	.-44     	; 0x5258 <vComTxTask+0x1e>
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );
    5284:	80 91 b2 0d 	lds	r24, 0x0DB2
    5288:	60 e0       	ldi	r22, 0x00	; 0
    528a:	0e 94 e1 2a 	call	0x55c2	; 0x55c2 <vParTestSetLED>

		/* We have posted all the characters in the string - wait before
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
    528e:	0e 94 76 24 	call	0x48ec	; 0x48ec <xTaskGetTickCount>
    5292:	cc 01       	movw	r24, r24
    5294:	a0 e0       	ldi	r26, 0x00	; 0
    5296:	b0 e0       	ldi	r27, 0x00	; 0
    5298:	03 96       	adiw	r24, 0x03	; 3
    529a:	a1 1d       	adc	r26, r1
    529c:	b1 1d       	adc	r27, r1
    529e:	8a 83       	std	Y+2, r24	; 0x02
    52a0:	9b 83       	std	Y+3, r25	; 0x03
    52a2:	ac 83       	std	Y+4, r26	; 0x04
    52a4:	bd 83       	std	Y+5, r27	; 0x05

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
    52a6:	8a 81       	ldd	r24, Y+2	; 0x02
    52a8:	9b 81       	ldd	r25, Y+3	; 0x03
    52aa:	ac 81       	ldd	r26, Y+4	; 0x04
    52ac:	bd 81       	ldd	r27, Y+5	; 0x05
    52ae:	26 e9       	ldi	r18, 0x96	; 150
    52b0:	30 e0       	ldi	r19, 0x00	; 0
    52b2:	40 e0       	ldi	r20, 0x00	; 0
    52b4:	50 e0       	ldi	r21, 0x00	; 0
    52b6:	bc 01       	movw	r22, r24
    52b8:	cd 01       	movw	r24, r26
    52ba:	0e 94 68 36 	call	0x6cd0	; 0x6cd0 <__udivmodsi4>
    52be:	dc 01       	movw	r26, r24
    52c0:	cb 01       	movw	r24, r22
    52c2:	8a 83       	std	Y+2, r24	; 0x02
    52c4:	9b 83       	std	Y+3, r25	; 0x03
    52c6:	ac 83       	std	Y+4, r26	; 0x04
    52c8:	bd 83       	std	Y+5, r27	; 0x05

		/* ...but we do want to wait. */
		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
    52ca:	8a 81       	ldd	r24, Y+2	; 0x02
    52cc:	9b 81       	ldd	r25, Y+3	; 0x03
    52ce:	ac 81       	ldd	r26, Y+4	; 0x04
    52d0:	bd 81       	ldd	r27, Y+5	; 0x05
    52d2:	82 33       	cpi	r24, 0x32	; 50
    52d4:	91 05       	cpc	r25, r1
    52d6:	a1 05       	cpc	r26, r1
    52d8:	b1 05       	cpc	r27, r1
    52da:	40 f4       	brcc	.+16     	; 0x52ec <vComTxTask+0xb2>
		{
			xTimeToWait = comTX_MIN_BLOCK_TIME;
    52dc:	82 e3       	ldi	r24, 0x32	; 50
    52de:	90 e0       	ldi	r25, 0x00	; 0
    52e0:	a0 e0       	ldi	r26, 0x00	; 0
    52e2:	b0 e0       	ldi	r27, 0x00	; 0
    52e4:	8a 83       	std	Y+2, r24	; 0x02
    52e6:	9b 83       	std	Y+3, r25	; 0x03
    52e8:	ac 83       	std	Y+4, r26	; 0x04
    52ea:	bd 83       	std	Y+5, r27	; 0x05
		}

		vTaskDelay( xTimeToWait );
    52ec:	8a 81       	ldd	r24, Y+2	; 0x02
    52ee:	9b 81       	ldd	r25, Y+3	; 0x03
    52f0:	0e 94 6f 23 	call	0x46de	; 0x46de <vTaskDelay>
	}
    52f4:	ae cf       	rjmp	.-164    	; 0x5252 <vComTxTask+0x18>

000052f6 <vComRxTask>:
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
    52f6:	cf 93       	push	r28
    52f8:	df 93       	push	r29
    52fa:	00 d0       	rcall	.+0      	; 0x52fc <vComRxTask+0x6>
    52fc:	00 d0       	rcall	.+0      	; 0x52fe <vComRxTask+0x8>
    52fe:	00 d0       	rcall	.+0      	; 0x5300 <vComRxTask+0xa>
    5300:	cd b7       	in	r28, 0x3d	; 61
    5302:	de b7       	in	r29, 0x3e	; 62
    5304:	9e 83       	std	Y+6, r25	; 0x06
    5306:	8d 83       	std	Y+5, r24	; 0x05
signed char cExpectedByte, cByteRxed;
portBASE_TYPE xResyncRequired = pdFALSE, xErrorOccurred = pdFALSE;
    5308:	1a 82       	std	Y+2, r1	; 0x02
    530a:	1b 82       	std	Y+3, r1	; 0x03
    530c:	01 c0       	rjmp	.+2      	; 0x5310 <vComRxTask+0x1a>
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
			}
		}
	}
    530e:	00 00       	nop

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
    5310:	81 e4       	ldi	r24, 0x41	; 65
    5312:	89 83       	std	Y+1, r24	; 0x01
    5314:	20 c0       	rjmp	.+64     	; 0x5356 <vComRxTask+0x60>
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
    5316:	80 91 b0 0d 	lds	r24, 0x0DB0
    531a:	90 91 b1 0d 	lds	r25, 0x0DB1
    531e:	9e 01       	movw	r18, r28
    5320:	2c 5f       	subi	r18, 0xFC	; 252
    5322:	3f 4f       	sbci	r19, 0xFF	; 255
    5324:	b9 01       	movw	r22, r18
    5326:	2f ef       	ldi	r18, 0xFF	; 255
    5328:	3f ef       	ldi	r19, 0xFF	; 255
    532a:	40 e0       	ldi	r20, 0x00	; 0
    532c:	50 e0       	ldi	r21, 0x00	; 0
    532e:	0e 94 a9 2e 	call	0x5d52	; 0x5d52 <xSerialGetChar>
    5332:	88 23       	and	r24, r24
    5334:	69 f0       	breq	.+26     	; 0x5350 <vComRxTask+0x5a>
			{
				/* Was this the byte we were expecting?  If so, toggle the LED,
				otherwise we are out on sync and should break out of the loop
				until the expected character sequence is about to restart. */
				if( cByteRxed == cExpectedByte )
    5336:	9c 81       	ldd	r25, Y+4	; 0x04
    5338:	89 81       	ldd	r24, Y+1	; 0x01
    533a:	98 17       	cp	r25, r24
    533c:	31 f4       	brne	.+12     	; 0x534a <vComRxTask+0x54>
				{
					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
    533e:	80 91 b2 0d 	lds	r24, 0x0DB2
    5342:	8f 5f       	subi	r24, 0xFF	; 255
    5344:	0e 94 1d 2b 	call	0x563a	; 0x563a <vParTestToggleLED>
    5348:	03 c0       	rjmp	.+6      	; 0x5350 <vComRxTask+0x5a>
				}
				else
				{
					xResyncRequired = pdTRUE;
    534a:	81 e0       	ldi	r24, 0x01	; 1
    534c:	8a 83       	std	Y+2, r24	; 0x02
					break; /*lint !e960 Non-switch break allowed. */
    534e:	06 c0       	rjmp	.+12     	; 0x535c <vComRxTask+0x66>

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
    5350:	89 81       	ldd	r24, Y+1	; 0x01
    5352:	8f 5f       	subi	r24, 0xFF	; 255
    5354:	89 83       	std	Y+1, r24	; 0x01
    5356:	89 81       	ldd	r24, Y+1	; 0x01
    5358:	89 35       	cpi	r24, 0x59	; 89
    535a:	ec f2       	brlt	.-70     	; 0x5316 <vComRxTask+0x20>
				}
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
    535c:	80 91 b2 0d 	lds	r24, 0x0DB2
    5360:	8f 5f       	subi	r24, 0xFF	; 255
    5362:	60 e0       	ldi	r22, 0x00	; 0
    5364:	0e 94 e1 2a 	call	0x55c2	; 0x55c2 <vParTestSetLED>

		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
    5368:	8a 81       	ldd	r24, Y+2	; 0x02
    536a:	81 30       	cpi	r24, 0x01	; 1
    536c:	b9 f4       	brne	.+46     	; 0x539c <vComRxTask+0xa6>
		{
			while( cByteRxed != comLAST_BYTE )
    536e:	0e c0       	rjmp	.+28     	; 0x538c <vComRxTask+0x96>
			{
				/* Block until the next char is available. */
				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
    5370:	80 91 b0 0d 	lds	r24, 0x0DB0
    5374:	90 91 b1 0d 	lds	r25, 0x0DB1
    5378:	9e 01       	movw	r18, r28
    537a:	2c 5f       	subi	r18, 0xFC	; 252
    537c:	3f 4f       	sbci	r19, 0xFF	; 255
    537e:	b9 01       	movw	r22, r18
    5380:	2f ef       	ldi	r18, 0xFF	; 255
    5382:	3f ef       	ldi	r19, 0xFF	; 255
    5384:	40 e0       	ldi	r20, 0x00	; 0
    5386:	50 e0       	ldi	r21, 0x00	; 0
    5388:	0e 94 a9 2e 	call	0x5d52	; 0x5d52 <xSerialGetChar>
		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
		{
			while( cByteRxed != comLAST_BYTE )
    538c:	8c 81       	ldd	r24, Y+4	; 0x04
    538e:	88 35       	cpi	r24, 0x58	; 88
    5390:	79 f7       	brne	.-34     	; 0x5370 <vComRxTask+0x7a>

			/* Note that an error occurred which caused us to have to resync.
			We use this to stop incrementing the loop counter so
			sAreComTestTasksStillRunning() will return false - indicating an
			error. */
			xErrorOccurred++;
    5392:	8b 81       	ldd	r24, Y+3	; 0x03
    5394:	8f 5f       	subi	r24, 0xFF	; 255
    5396:	8b 83       	std	Y+3, r24	; 0x03

			/* We have now resynced with the Tx task and can continue. */
			xResyncRequired = pdFALSE;
    5398:	1a 82       	std	Y+2, r1	; 0x02
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
			}
		}
	}
    539a:	b9 cf       	rjmp	.-142    	; 0x530e <vComRxTask+0x18>
			/* We have now resynced with the Tx task and can continue. */
			xResyncRequired = pdFALSE;
		}
		else
		{
			if( xErrorOccurred < comTOTAL_PERMISSIBLE_ERRORS )
    539c:	8b 81       	ldd	r24, Y+3	; 0x03
    539e:	82 30       	cpi	r24, 0x02	; 2
    53a0:	08 f0       	brcs	.+2      	; 0x53a4 <vComRxTask+0xae>
    53a2:	b5 cf       	rjmp	.-150    	; 0x530e <vComRxTask+0x18>
				occurring (i.e. an unexpected character being received) will
				prevent this counter being incremented for the rest of the
				execution.   Don't worry about mutual exclusion on this
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
    53a4:	80 91 b3 0d 	lds	r24, 0x0DB3
    53a8:	8f 5f       	subi	r24, 0xFF	; 255
    53aa:	80 93 b3 0d 	sts	0x0DB3, r24
			}
		}
	}
    53ae:	af cf       	rjmp	.-162    	; 0x530e <vComRxTask+0x18>

000053b0 <xAreComTestTasksStillRunning>:
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

portBASE_TYPE xAreComTestTasksStillRunning( void )
{
    53b0:	cf 93       	push	r28
    53b2:	df 93       	push	r29
    53b4:	0f 92       	push	r0
    53b6:	cd b7       	in	r28, 0x3d	; 61
    53b8:	de b7       	in	r29, 0x3e	; 62
portBASE_TYPE xReturn;

	/* If the count of successful reception loops has not changed than at
	some time an error occurred (i.e. a character was received out of sequence)
	and we will return false. */
	if( uxRxLoops == comINITIAL_RX_COUNT_VALUE )
    53ba:	80 91 b3 0d 	lds	r24, 0x0DB3
    53be:	88 23       	and	r24, r24
    53c0:	11 f4       	brne	.+4      	; 0x53c6 <xAreComTestTasksStillRunning+0x16>
	{
		xReturn = pdFALSE;
    53c2:	19 82       	std	Y+1, r1	; 0x01
    53c4:	02 c0       	rjmp	.+4      	; 0x53ca <xAreComTestTasksStillRunning+0x1a>
	}
	else
	{
		xReturn = pdTRUE;
    53c6:	81 e0       	ldi	r24, 0x01	; 1
    53c8:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Reset the count of successful Rx loops.  When this function is called
	again we expect this to have been incremented. */
	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
    53ca:	10 92 b3 0d 	sts	0x0DB3, r1

	return xReturn;
    53ce:	89 81       	ldd	r24, Y+1	; 0x01
}
    53d0:	0f 90       	pop	r0
    53d2:	df 91       	pop	r29
    53d4:	cf 91       	pop	r28
    53d6:	08 95       	ret

000053d8 <vStartIntegerMathTasks>:
static volatile signed portBASE_TYPE xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( signed portBASE_TYPE ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( unsigned portBASE_TYPE uxPriority )
{
    53d8:	af 92       	push	r10
    53da:	bf 92       	push	r11
    53dc:	cf 92       	push	r12
    53de:	df 92       	push	r13
    53e0:	ef 92       	push	r14
    53e2:	ff 92       	push	r15
    53e4:	0f 93       	push	r16
    53e6:	cf 93       	push	r28
    53e8:	df 93       	push	r29
    53ea:	00 d0       	rcall	.+0      	; 0x53ec <vStartIntegerMathTasks+0x14>
    53ec:	0f 92       	push	r0
    53ee:	cd b7       	in	r28, 0x3d	; 61
    53f0:	de b7       	in	r29, 0x3e	; 62
    53f2:	8b 83       	std	Y+3, r24	; 0x03
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    53f4:	1a 82       	std	Y+2, r1	; 0x02
    53f6:	19 82       	std	Y+1, r1	; 0x01
    53f8:	1a c0       	rjmp	.+52     	; 0x542e <vStartIntegerMathTasks+0x56>
	{
		xTaskCreate( vCompeteingIntMathTask, ( signed char * ) "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( xTaskHandle * ) NULL );
    53fa:	89 81       	ldd	r24, Y+1	; 0x01
    53fc:	9a 81       	ldd	r25, Y+2	; 0x02
    53fe:	9c 01       	movw	r18, r24
    5400:	2c 54       	subi	r18, 0x4C	; 76
    5402:	32 4f       	sbci	r19, 0xF2	; 242
    5404:	89 e2       	ldi	r24, 0x29	; 41
    5406:	9a e2       	ldi	r25, 0x2A	; 42
    5408:	43 e1       	ldi	r20, 0x13	; 19
    540a:	51 e0       	ldi	r21, 0x01	; 1
    540c:	ba 01       	movw	r22, r20
    540e:	48 ec       	ldi	r20, 0xC8	; 200
    5410:	50 e0       	ldi	r21, 0x00	; 0
    5412:	0b 81       	ldd	r16, Y+3	; 0x03
    5414:	ee 24       	eor	r14, r14
    5416:	ff 24       	eor	r15, r15
    5418:	cc 24       	eor	r12, r12
    541a:	dd 24       	eor	r13, r13
    541c:	aa 24       	eor	r10, r10
    541e:	bb 24       	eor	r11, r11
    5420:	0e 94 99 21 	call	0x4332	; 0x4332 <xTaskGenericCreate>

void vStartIntegerMathTasks( unsigned portBASE_TYPE uxPriority )
{
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    5424:	89 81       	ldd	r24, Y+1	; 0x01
    5426:	9a 81       	ldd	r25, Y+2	; 0x02
    5428:	01 96       	adiw	r24, 0x01	; 1
    542a:	9a 83       	std	Y+2, r25	; 0x02
    542c:	89 83       	std	Y+1, r24	; 0x01
    542e:	89 81       	ldd	r24, Y+1	; 0x01
    5430:	9a 81       	ldd	r25, Y+2	; 0x02
    5432:	18 16       	cp	r1, r24
    5434:	19 06       	cpc	r1, r25
    5436:	0c f7       	brge	.-62     	; 0x53fa <vStartIntegerMathTasks+0x22>
	{
		xTaskCreate( vCompeteingIntMathTask, ( signed char * ) "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( xTaskHandle * ) NULL );
	}
}
    5438:	0f 90       	pop	r0
    543a:	0f 90       	pop	r0
    543c:	0f 90       	pop	r0
    543e:	df 91       	pop	r29
    5440:	cf 91       	pop	r28
    5442:	0f 91       	pop	r16
    5444:	ff 90       	pop	r15
    5446:	ef 90       	pop	r14
    5448:	df 90       	pop	r13
    544a:	cf 90       	pop	r12
    544c:	bf 90       	pop	r11
    544e:	af 90       	pop	r10
    5450:	08 95       	ret

00005452 <vCompeteingIntMathTask>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    5452:	ef 92       	push	r14
    5454:	ff 92       	push	r15
    5456:	0f 93       	push	r16
    5458:	1f 93       	push	r17
    545a:	cf 93       	push	r28
    545c:	df 93       	push	r29
    545e:	cd b7       	in	r28, 0x3d	; 61
    5460:	de b7       	in	r29, 0x3e	; 62
    5462:	2a 97       	sbiw	r28, 0x0a	; 10
    5464:	0f b6       	in	r0, 0x3f	; 63
    5466:	f8 94       	cli
    5468:	de bf       	out	0x3e, r29	; 62
    546a:	0f be       	out	0x3f, r0	; 63
    546c:	cd bf       	out	0x3d, r28	; 61
    546e:	9a 87       	std	Y+10, r25	; 0x0a
    5470:	89 87       	std	Y+9, r24	; 0x09
/* These variables are all effectively set to constants so they are volatile to
ensure the compiler does not just get rid of them. */
volatile long lValue;
short sError = pdFALSE;
    5472:	1a 82       	std	Y+2, r1	; 0x02
    5474:	19 82       	std	Y+1, r1	; 0x01
volatile signed portBASE_TYPE *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile signed portBASE_TYPE * ) pvParameters;
    5476:	89 85       	ldd	r24, Y+9	; 0x09
    5478:	9a 85       	ldd	r25, Y+10	; 0x0a
    547a:	9c 83       	std	Y+4, r25	; 0x04
    547c:	8b 83       	std	Y+3, r24	; 0x03
    547e:	01 c0       	rjmp	.+2      	; 0x5482 <vCompeteingIntMathTask+0x30>
		#if configUSE_PREEMPTION == 0
		{
			taskYIELD();
		}
		#endif
	}
    5480:	00 00       	nop
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    5482:	8b e7       	ldi	r24, 0x7B	; 123
    5484:	90 e0       	ldi	r25, 0x00	; 0
    5486:	a0 e0       	ldi	r26, 0x00	; 0
    5488:	b0 e0       	ldi	r27, 0x00	; 0
    548a:	8d 83       	std	Y+5, r24	; 0x05
    548c:	9e 83       	std	Y+6, r25	; 0x06
    548e:	af 83       	std	Y+7, r26	; 0x07
    5490:	b8 87       	std	Y+8, r27	; 0x08
		lValue += intgCONST2;
    5492:	8d 81       	ldd	r24, Y+5	; 0x05
    5494:	9e 81       	ldd	r25, Y+6	; 0x06
    5496:	af 81       	ldd	r26, Y+7	; 0x07
    5498:	b8 85       	ldd	r27, Y+8	; 0x08
    549a:	89 5b       	subi	r24, 0xB9	; 185
    549c:	9b 46       	sbci	r25, 0x6B	; 107
    549e:	ac 4f       	sbci	r26, 0xFC	; 252
    54a0:	bf 4f       	sbci	r27, 0xFF	; 255
    54a2:	8d 83       	std	Y+5, r24	; 0x05
    54a4:	9e 83       	std	Y+6, r25	; 0x06
    54a6:	af 83       	std	Y+7, r26	; 0x07
    54a8:	b8 87       	std	Y+8, r27	; 0x08
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    54aa:	8d 81       	ldd	r24, Y+5	; 0x05
    54ac:	9e 81       	ldd	r25, Y+6	; 0x06
    54ae:	af 81       	ldd	r26, Y+7	; 0x07
    54b0:	b8 85       	ldd	r27, Y+8	; 0x08
    54b2:	9c 01       	movw	r18, r24
    54b4:	ad 01       	movw	r20, r26
    54b6:	88 0f       	add	r24, r24
    54b8:	99 1f       	adc	r25, r25
    54ba:	aa 1f       	adc	r26, r26
    54bc:	bb 1f       	adc	r27, r27
    54be:	88 0f       	add	r24, r24
    54c0:	99 1f       	adc	r25, r25
    54c2:	aa 1f       	adc	r26, r26
    54c4:	bb 1f       	adc	r27, r27
    54c6:	79 01       	movw	r14, r18
    54c8:	8a 01       	movw	r16, r20
    54ca:	e8 1a       	sub	r14, r24
    54cc:	f9 0a       	sbc	r15, r25
    54ce:	0a 0b       	sbc	r16, r26
    54d0:	1b 0b       	sbc	r17, r27
    54d2:	d8 01       	movw	r26, r16
    54d4:	c7 01       	movw	r24, r14
    54d6:	8d 83       	std	Y+5, r24	; 0x05
    54d8:	9e 83       	std	Y+6, r25	; 0x06
    54da:	af 83       	std	Y+7, r26	; 0x07
    54dc:	b8 87       	std	Y+8, r27	; 0x08
		lValue /= intgCONST4;
    54de:	8d 81       	ldd	r24, Y+5	; 0x05
    54e0:	9e 81       	ldd	r25, Y+6	; 0x06
    54e2:	af 81       	ldd	r26, Y+7	; 0x07
    54e4:	b8 85       	ldd	r27, Y+8	; 0x08
    54e6:	27 e0       	ldi	r18, 0x07	; 7
    54e8:	30 e0       	ldi	r19, 0x00	; 0
    54ea:	40 e0       	ldi	r20, 0x00	; 0
    54ec:	50 e0       	ldi	r21, 0x00	; 0
    54ee:	bc 01       	movw	r22, r24
    54f0:	cd 01       	movw	r24, r26
    54f2:	0e 94 8a 36 	call	0x6d14	; 0x6d14 <__divmodsi4>
    54f6:	da 01       	movw	r26, r20
    54f8:	c9 01       	movw	r24, r18
    54fa:	8d 83       	std	Y+5, r24	; 0x05
    54fc:	9e 83       	std	Y+6, r25	; 0x06
    54fe:	af 83       	std	Y+7, r26	; 0x07
    5500:	b8 87       	std	Y+8, r27	; 0x08

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    5502:	8d 81       	ldd	r24, Y+5	; 0x05
    5504:	9e 81       	ldd	r25, Y+6	; 0x06
    5506:	af 81       	ldd	r26, Y+7	; 0x07
    5508:	b8 85       	ldd	r27, Y+8	; 0x08
    550a:	8b 31       	cpi	r24, 0x1B	; 27
    550c:	07 e7       	ldi	r16, 0x77	; 119
    550e:	90 07       	cpc	r25, r16
    5510:	0e ef       	ldi	r16, 0xFE	; 254
    5512:	a0 07       	cpc	r26, r16
    5514:	0f ef       	ldi	r16, 0xFF	; 255
    5516:	b0 07       	cpc	r27, r16
    5518:	21 f0       	breq	.+8      	; 0x5522 <vCompeteingIntMathTask+0xd0>
		{
			sError = pdTRUE;
    551a:	81 e0       	ldi	r24, 0x01	; 1
    551c:	90 e0       	ldi	r25, 0x00	; 0
    551e:	9a 83       	std	Y+2, r25	; 0x02
    5520:	89 83       	std	Y+1, r24	; 0x01
		}

		if( sError == pdFALSE )
    5522:	89 81       	ldd	r24, Y+1	; 0x01
    5524:	9a 81       	ldd	r25, Y+2	; 0x02
    5526:	00 97       	sbiw	r24, 0x00	; 0
    5528:	09 f0       	breq	.+2      	; 0x552c <vCompeteingIntMathTask+0xda>
    552a:	aa cf       	rjmp	.-172    	; 0x5480 <vCompeteingIntMathTask+0x2e>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    552c:	0f b6       	in	r0, 0x3f	; 63
    552e:	f8 94       	cli
    5530:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    5532:	8b 81       	ldd	r24, Y+3	; 0x03
    5534:	9c 81       	ldd	r25, Y+4	; 0x04
    5536:	21 e0       	ldi	r18, 0x01	; 1
    5538:	fc 01       	movw	r30, r24
    553a:	20 83       	st	Z, r18
			portEXIT_CRITICAL();
    553c:	0f 90       	pop	r0
    553e:	0f be       	out	0x3f, r0	; 63
		#if configUSE_PREEMPTION == 0
		{
			taskYIELD();
		}
		#endif
	}
    5540:	9f cf       	rjmp	.-194    	; 0x5480 <vCompeteingIntMathTask+0x2e>

00005542 <xAreIntegerMathsTaskStillRunning>:
}
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running. */
portBASE_TYPE xAreIntegerMathsTaskStillRunning( void )
{
    5542:	cf 93       	push	r28
    5544:	df 93       	push	r29
    5546:	00 d0       	rcall	.+0      	; 0x5548 <xAreIntegerMathsTaskStillRunning+0x6>
    5548:	0f 92       	push	r0
    554a:	cd b7       	in	r28, 0x3d	; 61
    554c:	de b7       	in	r29, 0x3e	; 62
portBASE_TYPE xReturn = pdTRUE;
    554e:	81 e0       	ldi	r24, 0x01	; 1
    5550:	89 83       	std	Y+1, r24	; 0x01
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    5552:	1b 82       	std	Y+3, r1	; 0x03
    5554:	1a 82       	std	Y+2, r1	; 0x02
    5556:	14 c0       	rjmp	.+40     	; 0x5580 <xAreIntegerMathsTaskStillRunning+0x3e>
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    5558:	8a 81       	ldd	r24, Y+2	; 0x02
    555a:	9b 81       	ldd	r25, Y+3	; 0x03
    555c:	8c 54       	subi	r24, 0x4C	; 76
    555e:	92 4f       	sbci	r25, 0xF2	; 242
    5560:	fc 01       	movw	r30, r24
    5562:	80 81       	ld	r24, Z
    5564:	88 23       	and	r24, r24
    5566:	09 f4       	brne	.+2      	; 0x556a <xAreIntegerMathsTaskStillRunning+0x28>
		{
			/* The check has not incremented so an error exists. */
			xReturn = pdFALSE;
    5568:	19 82       	std	Y+1, r1	; 0x01
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    556a:	8a 81       	ldd	r24, Y+2	; 0x02
    556c:	9b 81       	ldd	r25, Y+3	; 0x03
    556e:	8c 54       	subi	r24, 0x4C	; 76
    5570:	92 4f       	sbci	r25, 0xF2	; 242
    5572:	fc 01       	movw	r30, r24
    5574:	10 82       	st	Z, r1
portBASE_TYPE xReturn = pdTRUE;
short sTask;

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
    5576:	8a 81       	ldd	r24, Y+2	; 0x02
    5578:	9b 81       	ldd	r25, Y+3	; 0x03
    557a:	01 96       	adiw	r24, 0x01	; 1
    557c:	9b 83       	std	Y+3, r25	; 0x03
    557e:	8a 83       	std	Y+2, r24	; 0x02
    5580:	8a 81       	ldd	r24, Y+2	; 0x02
    5582:	9b 81       	ldd	r25, Y+3	; 0x03
    5584:	18 16       	cp	r1, r24
    5586:	19 06       	cpc	r1, r25
    5588:	3c f7       	brge	.-50     	; 0x5558 <xAreIntegerMathsTaskStillRunning+0x16>
		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
	}

	return xReturn;
    558a:	89 81       	ldd	r24, Y+1	; 0x01
}
    558c:	0f 90       	pop	r0
    558e:	0f 90       	pop	r0
    5590:	0f 90       	pop	r0
    5592:	df 91       	pop	r29
    5594:	cf 91       	pop	r28
    5596:	08 95       	ret

00005598 <vParTestInitialise>:
static volatile unsigned char ucCurrentOutputValue = partstALL_OUTPUTS_OFF; /*lint !e956 File scope parameters okay here. */

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
    5598:	cf 93       	push	r28
    559a:	df 93       	push	r29
    559c:	cd b7       	in	r28, 0x3d	; 61
    559e:	de b7       	in	r29, 0x3e	; 62
	ucCurrentOutputValue = partstALL_OUTPUTS_OFF;
    55a0:	8f ef       	ldi	r24, 0xFF	; 255
    55a2:	80 93 1b 01 	sts	0x011B, r24

	/* Set port B direction to outputs.  Start with all output off. */
	DDRB = partstALL_BITS_OUTPUT;
    55a6:	84 e2       	ldi	r24, 0x24	; 36
    55a8:	90 e0       	ldi	r25, 0x00	; 0
    55aa:	2f ef       	ldi	r18, 0xFF	; 255
    55ac:	fc 01       	movw	r30, r24
    55ae:	20 83       	st	Z, r18
	PORTB = ucCurrentOutputValue;
    55b0:	85 e2       	ldi	r24, 0x25	; 37
    55b2:	90 e0       	ldi	r25, 0x00	; 0
    55b4:	20 91 1b 01 	lds	r18, 0x011B
    55b8:	fc 01       	movw	r30, r24
    55ba:	20 83       	st	Z, r18
}
    55bc:	df 91       	pop	r29
    55be:	cf 91       	pop	r28
    55c0:	08 95       	ret

000055c2 <vParTestSetLED>:
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
    55c2:	cf 93       	push	r28
    55c4:	df 93       	push	r29
    55c6:	00 d0       	rcall	.+0      	; 0x55c8 <vParTestSetLED+0x6>
    55c8:	0f 92       	push	r0
    55ca:	cd b7       	in	r28, 0x3d	; 61
    55cc:	de b7       	in	r29, 0x3e	; 62
    55ce:	8a 83       	std	Y+2, r24	; 0x02
    55d0:	6b 83       	std	Y+3, r22	; 0x03
unsigned char ucBit = ( unsigned char ) 1;
    55d2:	81 e0       	ldi	r24, 0x01	; 1
    55d4:	89 83       	std	Y+1, r24	; 0x01

	if( uxLED <= partstMAX_OUTPUT_LED )
    55d6:	8a 81       	ldd	r24, Y+2	; 0x02
    55d8:	88 30       	cpi	r24, 0x08	; 8
    55da:	48 f5       	brcc	.+82     	; 0x562e <vParTestSetLED+0x6c>
	{
		ucBit <<= uxLED;	
    55dc:	89 81       	ldd	r24, Y+1	; 0x01
    55de:	88 2f       	mov	r24, r24
    55e0:	90 e0       	ldi	r25, 0x00	; 0
    55e2:	2a 81       	ldd	r18, Y+2	; 0x02
    55e4:	22 2f       	mov	r18, r18
    55e6:	30 e0       	ldi	r19, 0x00	; 0
    55e8:	02 c0       	rjmp	.+4      	; 0x55ee <vParTestSetLED+0x2c>
    55ea:	88 0f       	add	r24, r24
    55ec:	99 1f       	adc	r25, r25
    55ee:	2a 95       	dec	r18
    55f0:	e2 f7       	brpl	.-8      	; 0x55ea <vParTestSetLED+0x28>
    55f2:	89 83       	std	Y+1, r24	; 0x01

		vTaskSuspendAll();
    55f4:	0e 94 e7 23 	call	0x47ce	; 0x47ce <vTaskSuspendAll>
		{
			if( xValue == pdTRUE )
    55f8:	8b 81       	ldd	r24, Y+3	; 0x03
    55fa:	81 30       	cpi	r24, 0x01	; 1
    55fc:	51 f4       	brne	.+20     	; 0x5612 <vParTestSetLED+0x50>
			{
				ucBit ^= ( unsigned char ) 0xff;
    55fe:	89 81       	ldd	r24, Y+1	; 0x01
    5600:	80 95       	com	r24
    5602:	89 83       	std	Y+1, r24	; 0x01
				ucCurrentOutputValue &= ucBit;
    5604:	90 91 1b 01 	lds	r25, 0x011B
    5608:	89 81       	ldd	r24, Y+1	; 0x01
    560a:	89 23       	and	r24, r25
    560c:	80 93 1b 01 	sts	0x011B, r24
    5610:	06 c0       	rjmp	.+12     	; 0x561e <vParTestSetLED+0x5c>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
    5612:	90 91 1b 01 	lds	r25, 0x011B
    5616:	89 81       	ldd	r24, Y+1	; 0x01
    5618:	89 2b       	or	r24, r25
    561a:	80 93 1b 01 	sts	0x011B, r24
			}

			PORTB = ucCurrentOutputValue;
    561e:	85 e2       	ldi	r24, 0x25	; 37
    5620:	90 e0       	ldi	r25, 0x00	; 0
    5622:	20 91 1b 01 	lds	r18, 0x011B
    5626:	fc 01       	movw	r30, r24
    5628:	20 83       	st	Z, r18
		}
		xTaskResumeAll();
    562a:	0e 94 f3 23 	call	0x47e6	; 0x47e6 <xTaskResumeAll>
	}
}
    562e:	0f 90       	pop	r0
    5630:	0f 90       	pop	r0
    5632:	0f 90       	pop	r0
    5634:	df 91       	pop	r29
    5636:	cf 91       	pop	r28
    5638:	08 95       	ret

0000563a <vParTestToggleLED>:
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
    563a:	cf 93       	push	r28
    563c:	df 93       	push	r29
    563e:	00 d0       	rcall	.+0      	; 0x5640 <vParTestToggleLED+0x6>
    5640:	cd b7       	in	r28, 0x3d	; 61
    5642:	de b7       	in	r29, 0x3e	; 62
    5644:	8a 83       	std	Y+2, r24	; 0x02
unsigned char ucBit;

	if( uxLED <= partstMAX_OUTPUT_LED )
    5646:	8a 81       	ldd	r24, Y+2	; 0x02
    5648:	88 30       	cpi	r24, 0x08	; 8
    564a:	50 f5       	brcc	.+84     	; 0x56a0 <vParTestToggleLED+0x66>
	{
		ucBit = ( ( unsigned char ) 1 ) << uxLED;
    564c:	8a 81       	ldd	r24, Y+2	; 0x02
    564e:	28 2f       	mov	r18, r24
    5650:	30 e0       	ldi	r19, 0x00	; 0
    5652:	81 e0       	ldi	r24, 0x01	; 1
    5654:	90 e0       	ldi	r25, 0x00	; 0
    5656:	02 c0       	rjmp	.+4      	; 0x565c <vParTestToggleLED+0x22>
    5658:	88 0f       	add	r24, r24
    565a:	99 1f       	adc	r25, r25
    565c:	2a 95       	dec	r18
    565e:	e2 f7       	brpl	.-8      	; 0x5658 <vParTestToggleLED+0x1e>
    5660:	89 83       	std	Y+1, r24	; 0x01

		vTaskSuspendAll();
    5662:	0e 94 e7 23 	call	0x47ce	; 0x47ce <vTaskSuspendAll>
		{
			if( ucCurrentOutputValue & ucBit )
    5666:	90 91 1b 01 	lds	r25, 0x011B
    566a:	89 81       	ldd	r24, Y+1	; 0x01
    566c:	89 23       	and	r24, r25
    566e:	88 23       	and	r24, r24
    5670:	49 f0       	breq	.+18     	; 0x5684 <vParTestToggleLED+0x4a>
			{
				ucCurrentOutputValue &= ~ucBit;
    5672:	89 81       	ldd	r24, Y+1	; 0x01
    5674:	80 95       	com	r24
    5676:	98 2f       	mov	r25, r24
    5678:	80 91 1b 01 	lds	r24, 0x011B
    567c:	89 23       	and	r24, r25
    567e:	80 93 1b 01 	sts	0x011B, r24
    5682:	06 c0       	rjmp	.+12     	; 0x5690 <vParTestToggleLED+0x56>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
    5684:	90 91 1b 01 	lds	r25, 0x011B
    5688:	89 81       	ldd	r24, Y+1	; 0x01
    568a:	89 2b       	or	r24, r25
    568c:	80 93 1b 01 	sts	0x011B, r24
			}

			PORTB = ucCurrentOutputValue;
    5690:	85 e2       	ldi	r24, 0x25	; 37
    5692:	90 e0       	ldi	r25, 0x00	; 0
    5694:	20 91 1b 01 	lds	r18, 0x011B
    5698:	fc 01       	movw	r30, r24
    569a:	20 83       	st	Z, r18
		}
		xTaskResumeAll();			
    569c:	0e 94 f3 23 	call	0x47e6	; 0x47e6 <xTaskResumeAll>
	}
}
    56a0:	0f 90       	pop	r0
    56a2:	0f 90       	pop	r0
    56a4:	df 91       	pop	r29
    56a6:	cf 91       	pop	r28
    56a8:	08 95       	ret

000056aa <vStartPolledQueueTasks>:
static volatile signed portBASE_TYPE xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( unsigned portBASE_TYPE uxPriority )
{
    56aa:	af 92       	push	r10
    56ac:	bf 92       	push	r11
    56ae:	cf 92       	push	r12
    56b0:	df 92       	push	r13
    56b2:	ef 92       	push	r14
    56b4:	ff 92       	push	r15
    56b6:	0f 93       	push	r16
    56b8:	cf 93       	push	r28
    56ba:	df 93       	push	r29
    56bc:	0f 92       	push	r0
    56be:	cd b7       	in	r28, 0x3d	; 61
    56c0:	de b7       	in	r29, 0x3e	; 62
    56c2:	89 83       	std	Y+1, r24	; 0x01
static xQueueHandle xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
    56c4:	8a e0       	ldi	r24, 0x0A	; 10
    56c6:	62 e0       	ldi	r22, 0x02	; 2
    56c8:	40 e0       	ldi	r20, 0x00	; 0
    56ca:	0e 94 c2 1c 	call	0x3984	; 0x3984 <xQueueGenericCreate>
    56ce:	90 93 b8 0d 	sts	0x0DB8, r25
    56d2:	80 93 b7 0d 	sts	0x0DB7, r24
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, ( signed char * ) "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, ( signed char * ) "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( xTaskHandle * ) NULL );
    56d6:	8a ed       	ldi	r24, 0xDA	; 218
    56d8:	9b e2       	ldi	r25, 0x2B	; 43
    56da:	4c e1       	ldi	r20, 0x1C	; 28
    56dc:	51 e0       	ldi	r21, 0x01	; 1
    56de:	27 eb       	ldi	r18, 0xB7	; 183
    56e0:	3d e0       	ldi	r19, 0x0D	; 13
    56e2:	ba 01       	movw	r22, r20
    56e4:	48 ec       	ldi	r20, 0xC8	; 200
    56e6:	50 e0       	ldi	r21, 0x00	; 0
    56e8:	09 81       	ldd	r16, Y+1	; 0x01
    56ea:	ee 24       	eor	r14, r14
    56ec:	ff 24       	eor	r15, r15
    56ee:	cc 24       	eor	r12, r12
    56f0:	dd 24       	eor	r13, r13
    56f2:	aa 24       	eor	r10, r10
    56f4:	bb 24       	eor	r11, r11
    56f6:	0e 94 99 21 	call	0x4332	; 0x4332 <xTaskGenericCreate>
	xTaskCreate( vPolledQueueProducer, ( signed char * ) "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( xTaskHandle * ) NULL );
    56fa:	8a e9       	ldi	r24, 0x9A	; 154
    56fc:	9b e2       	ldi	r25, 0x2B	; 43
    56fe:	44 e2       	ldi	r20, 0x24	; 36
    5700:	51 e0       	ldi	r21, 0x01	; 1
    5702:	27 eb       	ldi	r18, 0xB7	; 183
    5704:	3d e0       	ldi	r19, 0x0D	; 13
    5706:	ba 01       	movw	r22, r20
    5708:	48 ec       	ldi	r20, 0xC8	; 200
    570a:	50 e0       	ldi	r21, 0x00	; 0
    570c:	09 81       	ldd	r16, Y+1	; 0x01
    570e:	ee 24       	eor	r14, r14
    5710:	ff 24       	eor	r15, r15
    5712:	cc 24       	eor	r12, r12
    5714:	dd 24       	eor	r13, r13
    5716:	aa 24       	eor	r10, r10
    5718:	bb 24       	eor	r11, r11
    571a:	0e 94 99 21 	call	0x4332	; 0x4332 <xTaskGenericCreate>
}
    571e:	0f 90       	pop	r0
    5720:	df 91       	pop	r29
    5722:	cf 91       	pop	r28
    5724:	0f 91       	pop	r16
    5726:	ff 90       	pop	r15
    5728:	ef 90       	pop	r14
    572a:	df 90       	pop	r13
    572c:	cf 90       	pop	r12
    572e:	bf 90       	pop	r11
    5730:	af 90       	pop	r10
    5732:	08 95       	ret

00005734 <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
    5734:	0f 93       	push	r16
    5736:	cf 93       	push	r28
    5738:	df 93       	push	r29
    573a:	00 d0       	rcall	.+0      	; 0x573c <vPolledQueueProducer+0x8>
    573c:	00 d0       	rcall	.+0      	; 0x573e <vPolledQueueProducer+0xa>
    573e:	00 d0       	rcall	.+0      	; 0x5740 <vPolledQueueProducer+0xc>
    5740:	cd b7       	in	r28, 0x3d	; 61
    5742:	de b7       	in	r29, 0x3e	; 62
    5744:	9e 83       	std	Y+6, r25	; 0x06
    5746:	8d 83       	std	Y+5, r24	; 0x05
unsigned short usValue = ( unsigned short ) 0;
    5748:	1c 82       	std	Y+4, r1	; 0x04
    574a:	1b 82       	std	Y+3, r1	; 0x03
signed portBASE_TYPE xError = pdFALSE, xLoop;
    574c:	19 82       	std	Y+1, r1	; 0x01

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    574e:	1a 82       	std	Y+2, r1	; 0x02
    5750:	29 c0       	rjmp	.+82     	; 0x57a4 <vPolledQueueProducer+0x70>
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( xQueueHandle * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
    5752:	8d 81       	ldd	r24, Y+5	; 0x05
    5754:	9e 81       	ldd	r25, Y+6	; 0x06
    5756:	fc 01       	movw	r30, r24
    5758:	80 81       	ld	r24, Z
    575a:	91 81       	ldd	r25, Z+1	; 0x01
    575c:	9e 01       	movw	r18, r28
    575e:	2d 5f       	subi	r18, 0xFD	; 253
    5760:	3f 4f       	sbci	r19, 0xFF	; 255
    5762:	b9 01       	movw	r22, r18
    5764:	20 e0       	ldi	r18, 0x00	; 0
    5766:	30 e0       	ldi	r19, 0x00	; 0
    5768:	a9 01       	movw	r20, r18
    576a:	00 e0       	ldi	r16, 0x00	; 0
    576c:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <xQueueGenericSend>
    5770:	81 30       	cpi	r24, 0x01	; 1
    5772:	19 f0       	breq	.+6      	; 0x577a <vPolledQueueProducer+0x46>
			{
				/* We should never find the queue full so if we get here there
				has been an error. */
				xError = pdTRUE;
    5774:	81 e0       	ldi	r24, 0x01	; 1
    5776:	89 83       	std	Y+1, r24	; 0x01
    5778:	12 c0       	rjmp	.+36     	; 0x579e <vPolledQueueProducer+0x6a>
			}
			else
			{
				if( xError == pdFALSE )
    577a:	89 81       	ldd	r24, Y+1	; 0x01
    577c:	88 23       	and	r24, r24
    577e:	51 f4       	brne	.+20     	; 0x5794 <vPolledQueueProducer+0x60>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
    5780:	0f b6       	in	r0, 0x3f	; 63
    5782:	f8 94       	cli
    5784:	0f 92       	push	r0
						xPollingProducerCount++;
    5786:	80 91 b6 0d 	lds	r24, 0x0DB6
    578a:	8f 5f       	subi	r24, 0xFF	; 255
    578c:	80 93 b6 0d 	sts	0x0DB6, r24
					portEXIT_CRITICAL();
    5790:	0f 90       	pop	r0
    5792:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
    5794:	8b 81       	ldd	r24, Y+3	; 0x03
    5796:	9c 81       	ldd	r25, Y+4	; 0x04
    5798:	01 96       	adiw	r24, 0x01	; 1
    579a:	9c 83       	std	Y+4, r25	; 0x04
    579c:	8b 83       	std	Y+3, r24	; 0x03
unsigned short usValue = ( unsigned short ) 0;
signed portBASE_TYPE xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    579e:	8a 81       	ldd	r24, Y+2	; 0x02
    57a0:	8f 5f       	subi	r24, 0xFF	; 255
    57a2:	8a 83       	std	Y+2, r24	; 0x02
    57a4:	8a 81       	ldd	r24, Y+2	; 0x02
    57a6:	83 30       	cpi	r24, 0x03	; 3
    57a8:	a4 f2       	brlt	.-88     	; 0x5752 <vPolledQueueProducer+0x1e>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
    57aa:	88 ec       	ldi	r24, 0xC8	; 200
    57ac:	90 e0       	ldi	r25, 0x00	; 0
    57ae:	0e 94 6f 23 	call	0x46de	; 0x46de <vTaskDelay>
	}
    57b2:	cd cf       	rjmp	.-102    	; 0x574e <vPolledQueueProducer+0x1a>

000057b4 <vPolledQueueConsumer>:
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
    57b4:	0f 93       	push	r16
    57b6:	cf 93       	push	r28
    57b8:	df 93       	push	r29
    57ba:	cd b7       	in	r28, 0x3d	; 61
    57bc:	de b7       	in	r29, 0x3e	; 62
    57be:	27 97       	sbiw	r28, 0x07	; 7
    57c0:	0f b6       	in	r0, 0x3f	; 63
    57c2:	f8 94       	cli
    57c4:	de bf       	out	0x3e, r29	; 62
    57c6:	0f be       	out	0x3f, r0	; 63
    57c8:	cd bf       	out	0x3d, r28	; 61
    57ca:	9f 83       	std	Y+7, r25	; 0x07
    57cc:	8e 83       	std	Y+6, r24	; 0x06
unsigned short usData, usExpectedValue = ( unsigned short ) 0;
    57ce:	1a 82       	std	Y+2, r1	; 0x02
    57d0:	19 82       	std	Y+1, r1	; 0x01
signed portBASE_TYPE xError = pdFALSE;
    57d2:	1b 82       	std	Y+3, r1	; 0x03

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
    57d4:	31 c0       	rjmp	.+98     	; 0x5838 <vPolledQueueConsumer+0x84>
		{
			if( xQueueReceive( *( ( xQueueHandle * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
    57d6:	8e 81       	ldd	r24, Y+6	; 0x06
    57d8:	9f 81       	ldd	r25, Y+7	; 0x07
    57da:	fc 01       	movw	r30, r24
    57dc:	80 81       	ld	r24, Z
    57de:	91 81       	ldd	r25, Z+1	; 0x01
    57e0:	9e 01       	movw	r18, r28
    57e2:	2c 5f       	subi	r18, 0xFC	; 252
    57e4:	3f 4f       	sbci	r19, 0xFF	; 255
    57e6:	b9 01       	movw	r22, r18
    57e8:	20 e0       	ldi	r18, 0x00	; 0
    57ea:	30 e0       	ldi	r19, 0x00	; 0
    57ec:	a9 01       	movw	r20, r18
    57ee:	00 e0       	ldi	r16, 0x00	; 0
    57f0:	0e 94 37 1e 	call	0x3c6e	; 0x3c6e <xQueueGenericReceive>
    57f4:	81 30       	cpi	r24, 0x01	; 1
    57f6:	01 f5       	brne	.+64     	; 0x5838 <vPolledQueueConsumer+0x84>
			{
				if( usData != usExpectedValue )
    57f8:	2c 81       	ldd	r18, Y+4	; 0x04
    57fa:	3d 81       	ldd	r19, Y+5	; 0x05
    57fc:	89 81       	ldd	r24, Y+1	; 0x01
    57fe:	9a 81       	ldd	r25, Y+2	; 0x02
    5800:	28 17       	cp	r18, r24
    5802:	39 07       	cpc	r19, r25
    5804:	39 f0       	breq	.+14     	; 0x5814 <vPolledQueueConsumer+0x60>
				{
					/* This is not what we expected to receive so an error has
					occurred. */
					xError = pdTRUE;
    5806:	81 e0       	ldi	r24, 0x01	; 1
    5808:	8b 83       	std	Y+3, r24	; 0x03

					/* Catch-up to the value we received so our next expected
					value should again be correct. */
					usExpectedValue = usData;
    580a:	8c 81       	ldd	r24, Y+4	; 0x04
    580c:	9d 81       	ldd	r25, Y+5	; 0x05
    580e:	9a 83       	std	Y+2, r25	; 0x02
    5810:	89 83       	std	Y+1, r24	; 0x01
    5812:	0d c0       	rjmp	.+26     	; 0x582e <vPolledQueueConsumer+0x7a>
				}
				else
				{
					if( xError == pdFALSE )
    5814:	8b 81       	ldd	r24, Y+3	; 0x03
    5816:	88 23       	and	r24, r24
    5818:	51 f4       	brne	.+20     	; 0x582e <vPolledQueueConsumer+0x7a>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
    581a:	0f b6       	in	r0, 0x3f	; 63
    581c:	f8 94       	cli
    581e:	0f 92       	push	r0
							xPollingConsumerCount++;
    5820:	80 91 b5 0d 	lds	r24, 0x0DB5
    5824:	8f 5f       	subi	r24, 0xFF	; 255
    5826:	80 93 b5 0d 	sts	0x0DB5, r24
						portEXIT_CRITICAL();
    582a:	0f 90       	pop	r0
    582c:	0f be       	out	0x3f, r0	; 63
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
    582e:	89 81       	ldd	r24, Y+1	; 0x01
    5830:	9a 81       	ldd	r25, Y+2	; 0x02
    5832:	01 96       	adiw	r24, 0x01	; 1
    5834:	9a 83       	std	Y+2, r25	; 0x02
    5836:	89 83       	std	Y+1, r24	; 0x01
signed portBASE_TYPE xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
    5838:	8e 81       	ldd	r24, Y+6	; 0x06
    583a:	9f 81       	ldd	r25, Y+7	; 0x07
    583c:	fc 01       	movw	r30, r24
    583e:	80 81       	ld	r24, Z
    5840:	91 81       	ldd	r25, Z+1	; 0x01
    5842:	0e 94 76 1f 	call	0x3eec	; 0x3eec <uxQueueMessagesWaiting>
    5846:	88 23       	and	r24, r24
    5848:	31 f6       	brne	.-116    	; 0x57d6 <vPolledQueueConsumer+0x22>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
    584a:	84 eb       	ldi	r24, 0xB4	; 180
    584c:	90 e0       	ldi	r25, 0x00	; 0
    584e:	0e 94 6f 23 	call	0x46de	; 0x46de <vTaskDelay>
	}
    5852:	00 00       	nop
signed portBASE_TYPE xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
    5854:	f1 cf       	rjmp	.-30     	; 0x5838 <vPolledQueueConsumer+0x84>

00005856 <xArePollingQueuesStillRunning>:
} /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

/* This is called to check that all the created tasks are still running with no errors. */
portBASE_TYPE xArePollingQueuesStillRunning( void )
{
    5856:	cf 93       	push	r28
    5858:	df 93       	push	r29
    585a:	0f 92       	push	r0
    585c:	cd b7       	in	r28, 0x3d	; 61
    585e:	de b7       	in	r29, 0x3e	; 62

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    5860:	80 91 b5 0d 	lds	r24, 0x0DB5
    5864:	88 23       	and	r24, r24
    5866:	21 f0       	breq	.+8      	; 0x5870 <xArePollingQueuesStillRunning+0x1a>
		( xPollingProducerCount == pollqINITIAL_VALUE )
    5868:	80 91 b6 0d 	lds	r24, 0x0DB6

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    586c:	88 23       	and	r24, r24
    586e:	11 f4       	brne	.+4      	; 0x5874 <xArePollingQueuesStillRunning+0x1e>
		( xPollingProducerCount == pollqINITIAL_VALUE )
	  )
	{
		xReturn = pdFALSE;
    5870:	19 82       	std	Y+1, r1	; 0x01
    5872:	02 c0       	rjmp	.+4      	; 0x5878 <xArePollingQueuesStillRunning+0x22>
	}
	else
	{
		xReturn = pdTRUE;
    5874:	81 e0       	ldi	r24, 0x01	; 1
    5876:	89 83       	std	Y+1, r24	; 0x01
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
    5878:	10 92 b5 0d 	sts	0x0DB5, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
    587c:	10 92 b6 0d 	sts	0x0DB6, r1

	return xReturn;
    5880:	89 81       	ldd	r24, Y+1	; 0x01
}
    5882:	0f 90       	pop	r0
    5884:	df 91       	pop	r29
    5886:	cf 91       	pop	r28
    5888:	08 95       	ret

0000588a <vPrintInitialise>:
static xQueueHandle xPrintQueue;

/*-----------------------------------------------------------*/

void vPrintInitialise( void )
{
    588a:	cf 93       	push	r28
    588c:	df 93       	push	r29
    588e:	0f 92       	push	r0
    5890:	cd b7       	in	r28, 0x3d	; 61
    5892:	de b7       	in	r29, 0x3e	; 62
const unsigned portBASE_TYPE uxQueueSize = 20;
    5894:	84 e1       	ldi	r24, 0x14	; 20
    5896:	89 83       	std	Y+1, r24	; 0x01

	/* Create the queue on which errors will be reported. */
	xPrintQueue = xQueueCreate( uxQueueSize, ( unsigned portBASE_TYPE ) sizeof( char * ) );
    5898:	89 81       	ldd	r24, Y+1	; 0x01
    589a:	62 e0       	ldi	r22, 0x02	; 2
    589c:	40 e0       	ldi	r20, 0x00	; 0
    589e:	0e 94 c2 1c 	call	0x3984	; 0x3984 <xQueueGenericCreate>
    58a2:	90 93 ba 0d 	sts	0x0DBA, r25
    58a6:	80 93 b9 0d 	sts	0x0DB9, r24
}
    58aa:	0f 90       	pop	r0
    58ac:	df 91       	pop	r29
    58ae:	cf 91       	pop	r28
    58b0:	08 95       	ret

000058b2 <vPrintDisplayMessage>:
/*-----------------------------------------------------------*/

void vPrintDisplayMessage( const char * const * ppcMessageToSend )
{
    58b2:	cf 93       	push	r28
    58b4:	df 93       	push	r29
    58b6:	00 d0       	rcall	.+0      	; 0x58b8 <vPrintDisplayMessage+0x6>
    58b8:	cd b7       	in	r28, 0x3d	; 61
    58ba:	de b7       	in	r29, 0x3e	; 62
    58bc:	9a 83       	std	Y+2, r25	; 0x02
    58be:	89 83       	std	Y+1, r24	; 0x01
		xQueueSend( xPrintQueue, ( void * ) ppcMessageToSend, ( uint32_t ) 0 );
	#else
    	/* Stop warnings. */
		( void ) ppcMessageToSend;
	#endif
}
    58c0:	0f 90       	pop	r0
    58c2:	0f 90       	pop	r0
    58c4:	df 91       	pop	r29
    58c6:	cf 91       	pop	r28
    58c8:	08 95       	ret

000058ca <pcPrintGetNextMessage>:
/*-----------------------------------------------------------*/

const char *pcPrintGetNextMessage( uint32_t xPrintRate )
{
    58ca:	0f 93       	push	r16
    58cc:	cf 93       	push	r28
    58ce:	df 93       	push	r29
    58d0:	00 d0       	rcall	.+0      	; 0x58d2 <pcPrintGetNextMessage+0x8>
    58d2:	00 d0       	rcall	.+0      	; 0x58d4 <pcPrintGetNextMessage+0xa>
    58d4:	00 d0       	rcall	.+0      	; 0x58d6 <pcPrintGetNextMessage+0xc>
    58d6:	cd b7       	in	r28, 0x3d	; 61
    58d8:	de b7       	in	r29, 0x3e	; 62
    58da:	6b 83       	std	Y+3, r22	; 0x03
    58dc:	7c 83       	std	Y+4, r23	; 0x04
    58de:	8d 83       	std	Y+5, r24	; 0x05
    58e0:	9e 83       	std	Y+6, r25	; 0x06
char *pcMessage;

	if( xQueueReceive( xPrintQueue, &pcMessage, xPrintRate ) == pdPASS )
    58e2:	80 91 b9 0d 	lds	r24, 0x0DB9
    58e6:	90 91 ba 0d 	lds	r25, 0x0DBA
    58ea:	2b 81       	ldd	r18, Y+3	; 0x03
    58ec:	3c 81       	ldd	r19, Y+4	; 0x04
    58ee:	4d 81       	ldd	r20, Y+5	; 0x05
    58f0:	5e 81       	ldd	r21, Y+6	; 0x06
    58f2:	be 01       	movw	r22, r28
    58f4:	6f 5f       	subi	r22, 0xFF	; 255
    58f6:	7f 4f       	sbci	r23, 0xFF	; 255
    58f8:	00 e0       	ldi	r16, 0x00	; 0
    58fa:	0e 94 37 1e 	call	0x3c6e	; 0x3c6e <xQueueGenericReceive>
    58fe:	81 30       	cpi	r24, 0x01	; 1
    5900:	19 f4       	brne	.+6      	; 0x5908 <pcPrintGetNextMessage+0x3e>
	{
		return pcMessage;
    5902:	89 81       	ldd	r24, Y+1	; 0x01
    5904:	9a 81       	ldd	r25, Y+2	; 0x02
    5906:	02 c0       	rjmp	.+4      	; 0x590c <pcPrintGetNextMessage+0x42>
	}
	else
	{
		return NULL;
    5908:	80 e0       	ldi	r24, 0x00	; 0
    590a:	90 e0       	ldi	r25, 0x00	; 0
	}
}
    590c:	26 96       	adiw	r28, 0x06	; 6
    590e:	0f b6       	in	r0, 0x3f	; 63
    5910:	f8 94       	cli
    5912:	de bf       	out	0x3e, r29	; 62
    5914:	0f be       	out	0x3f, r0	; 63
    5916:	cd bf       	out	0x3d, r28	; 61
    5918:	df 91       	pop	r29
    591a:	cf 91       	pop	r28
    591c:	0f 91       	pop	r16
    591e:	08 95       	ret

00005920 <vStartRegTestTasks>:
portBASE_TYPE xRegTestError = pdFALSE;

/*-----------------------------------------------------------*/

void vStartRegTestTasks( void )
{
    5920:	af 92       	push	r10
    5922:	bf 92       	push	r11
    5924:	cf 92       	push	r12
    5926:	df 92       	push	r13
    5928:	ef 92       	push	r14
    592a:	ff 92       	push	r15
    592c:	0f 93       	push	r16
    592e:	cf 93       	push	r28
    5930:	df 93       	push	r29
    5932:	cd b7       	in	r28, 0x3d	; 61
    5934:	de b7       	in	r29, 0x3e	; 62
	xTaskCreate( prvRegisterCheck1, ( signed char * ) "Reg1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
    5936:	8b ed       	ldi	r24, 0xDB	; 219
    5938:	9c e2       	ldi	r25, 0x2C	; 44
    593a:	2c e2       	ldi	r18, 0x2C	; 44
    593c:	31 e0       	ldi	r19, 0x01	; 1
    593e:	b9 01       	movw	r22, r18
    5940:	48 ec       	ldi	r20, 0xC8	; 200
    5942:	50 e0       	ldi	r21, 0x00	; 0
    5944:	20 e0       	ldi	r18, 0x00	; 0
    5946:	30 e0       	ldi	r19, 0x00	; 0
    5948:	00 e0       	ldi	r16, 0x00	; 0
    594a:	ee 24       	eor	r14, r14
    594c:	ff 24       	eor	r15, r15
    594e:	cc 24       	eor	r12, r12
    5950:	dd 24       	eor	r13, r13
    5952:	aa 24       	eor	r10, r10
    5954:	bb 24       	eor	r11, r11
    5956:	0e 94 99 21 	call	0x4332	; 0x4332 <xTaskGenericCreate>
	xTaskCreate( prvRegisterCheck2, ( signed char * ) "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );		
    595a:	84 e8       	ldi	r24, 0x84	; 132
    595c:	9d e2       	ldi	r25, 0x2D	; 45
    595e:	21 e3       	ldi	r18, 0x31	; 49
    5960:	31 e0       	ldi	r19, 0x01	; 1
    5962:	b9 01       	movw	r22, r18
    5964:	48 ec       	ldi	r20, 0xC8	; 200
    5966:	50 e0       	ldi	r21, 0x00	; 0
    5968:	20 e0       	ldi	r18, 0x00	; 0
    596a:	30 e0       	ldi	r19, 0x00	; 0
    596c:	00 e0       	ldi	r16, 0x00	; 0
    596e:	ee 24       	eor	r14, r14
    5970:	ff 24       	eor	r15, r15
    5972:	cc 24       	eor	r12, r12
    5974:	dd 24       	eor	r13, r13
    5976:	aa 24       	eor	r10, r10
    5978:	bb 24       	eor	r11, r11
    597a:	0e 94 99 21 	call	0x4332	; 0x4332 <xTaskGenericCreate>
}
    597e:	df 91       	pop	r29
    5980:	cf 91       	pop	r28
    5982:	0f 91       	pop	r16
    5984:	ff 90       	pop	r15
    5986:	ef 90       	pop	r14
    5988:	df 90       	pop	r13
    598a:	cf 90       	pop	r12
    598c:	bf 90       	pop	r11
    598e:	af 90       	pop	r10
    5990:	08 95       	ret

00005992 <xAreRegTestTasksStillRunning>:
/*-----------------------------------------------------------*/

portBASE_TYPE xAreRegTestTasksStillRunning( void )
{
    5992:	cf 93       	push	r28
    5994:	df 93       	push	r29
    5996:	0f 92       	push	r0
    5998:	cd b7       	in	r28, 0x3d	; 61
    599a:	de b7       	in	r29, 0x3e	; 62
portBASE_TYPE xReturn;

	/* If a register was found to contain an unexpected value then the
	xRegTestError variable would have been set to a non zero value. */
	if( xRegTestError == pdFALSE )
    599c:	80 91 bb 0d 	lds	r24, 0x0DBB
    59a0:	88 23       	and	r24, r24
    59a2:	19 f4       	brne	.+6      	; 0x59aa <xAreRegTestTasksStillRunning+0x18>
	{
		xReturn = pdTRUE;
    59a4:	81 e0       	ldi	r24, 0x01	; 1
    59a6:	89 83       	std	Y+1, r24	; 0x01
    59a8:	01 c0       	rjmp	.+2      	; 0x59ac <xAreRegTestTasksStillRunning+0x1a>
	}
	else
	{
		xReturn = pdFALSE;
    59aa:	19 82       	std	Y+1, r1	; 0x01
	}
	
	return xReturn;
    59ac:	89 81       	ldd	r24, Y+1	; 0x01
}
    59ae:	0f 90       	pop	r0
    59b0:	df 91       	pop	r29
    59b2:	cf 91       	pop	r28
    59b4:	08 95       	ret

000059b6 <prvRegisterCheck1>:
/*-----------------------------------------------------------*/

static void prvRegisterCheck1( void *pvParameters )
{
    59b6:	cf 93       	push	r28
    59b8:	df 93       	push	r29
    59ba:	00 d0       	rcall	.+0      	; 0x59bc <prvRegisterCheck1+0x6>
    59bc:	cd b7       	in	r28, 0x3d	; 61
    59be:	de b7       	in	r29, 0x3e	; 62
    59c0:	9a 83       	std	Y+2, r25	; 0x02
    59c2:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	5"		);		
    59c4:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r0,		r31"	);
    59c6:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	6"		);
    59c8:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r1,		r31"	);
    59ca:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	7"		);
    59cc:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r2,		r31"	);
    59ce:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	8"		);
    59d0:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r3,		r31"	);
    59d2:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	9"		);
    59d4:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r4,		r31"	);
    59d6:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	10"		);
    59d8:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r5,		r31"	);
    59da:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	11"		);
    59dc:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r6,		r31"	);
    59de:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	12"		);
    59e0:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r7,		r31"	);
    59e2:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	13"		);
    59e4:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r8,		r31"	);
    59e6:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	14"		);
    59e8:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r9,		r31"	);
    59ea:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	15"		);
    59ec:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r10,	r31"	);
    59ee:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	16"		);
    59f0:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r11,	r31"	);
    59f2:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	17"		);
    59f4:	f1 e1       	ldi	r31, 0x11	; 17
		asm( 	"MOV	r12,	r31"	);
    59f6:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	18"		);
    59f8:	f2 e1       	ldi	r31, 0x12	; 18
		asm( 	"MOV	r13,	r31"	);
    59fa:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	19"		);
    59fc:	f3 e1       	ldi	r31, 0x13	; 19
		asm( 	"MOV	r14,	r31"	);
    59fe:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	20"		);
    5a00:	f4 e1       	ldi	r31, 0x14	; 20
		asm( 	"MOV	r15,	r31"	);
    5a02:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	21"		);
    5a04:	05 e1       	ldi	r16, 0x15	; 21
		asm(	"LDI	r17,	22"		);
    5a06:	16 e1       	ldi	r17, 0x16	; 22
		asm(	"LDI	r18,	23"		);
    5a08:	27 e1       	ldi	r18, 0x17	; 23
		asm(	"LDI	r19,	24"		);
    5a0a:	38 e1       	ldi	r19, 0x18	; 24
		asm(	"LDI	r20,	25"		);
    5a0c:	49 e1       	ldi	r20, 0x19	; 25
		asm(	"LDI	r21,	26"		);
    5a0e:	5a e1       	ldi	r21, 0x1A	; 26
		asm(	"LDI	r22,	27"		);
    5a10:	6b e1       	ldi	r22, 0x1B	; 27
		asm(	"LDI	r23,	28"		);
    5a12:	7c e1       	ldi	r23, 0x1C	; 28
		asm(	"LDI	r24,	29"		);
    5a14:	8d e1       	ldi	r24, 0x1D	; 29
		asm(	"LDI	r25,	30"		);
    5a16:	9e e1       	ldi	r25, 0x1E	; 30
		asm(	"LDI	r26,	31"		);
    5a18:	af e1       	ldi	r26, 0x1F	; 31
		asm(	"LDI	r27,	32"		);
    5a1a:	b0 e2       	ldi	r27, 0x20	; 32
		asm(	"LDI	r30,	33"		);
    5a1c:	e1 e2       	ldi	r30, 0x21	; 33

		asm(	"LDI	r31,	5"			);
    5a1e:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r0"			);
    5a20:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
    5a22:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	6"			);
    5a26:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r1"			);
    5a28:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
    5a2a:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	7"			);
    5a2e:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r2"			);
    5a30:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
    5a32:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	8"			);
    5a36:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r3"			);
    5a38:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
    5a3a:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	9"			);
    5a3e:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r4"			);
    5a40:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
    5a42:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	10"			);
    5a46:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r5"			);
    5a48:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
    5a4a:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	11"			);
    5a4e:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r6"			);
    5a50:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
    5a52:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	12"			);
    5a56:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r7"			);
    5a58:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
    5a5a:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	13"			);
    5a5e:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r8"			);
    5a60:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
    5a62:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	14"			);
    5a66:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r9"			);
    5a68:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
    5a6a:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	15"			);
    5a6e:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r10"		);
    5a70:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
    5a72:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	16"			);
    5a76:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r11"		);
    5a78:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
    5a7a:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	17"			);
    5a7e:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r12"		);
    5a80:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
    5a82:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	18"			);
    5a86:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r13"		);
    5a88:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
    5a8a:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	19"			);
    5a8e:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r14"		);
    5a90:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
    5a92:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	20"			);
    5a96:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r15"		);
    5a98:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
    5a9a:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	21"			);
    5a9e:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r16"		);
    5aa0:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
    5aa2:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	22"			);
    5aa6:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r17"		);
    5aa8:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
    5aaa:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	23"			);
    5aae:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r18"		);
    5ab0:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
    5ab2:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	24"			);
    5ab6:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r19"		);
    5ab8:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
    5aba:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	25"			);
    5abe:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r20"		);
    5ac0:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
    5ac2:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	26"			);
    5ac6:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r21"		);
    5ac8:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
    5aca:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	27"			);
    5ace:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r22"		);
    5ad0:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
    5ad2:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	28"			);
    5ad6:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r23"		);
    5ad8:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
    5ada:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	29"			);
    5ade:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r24"		);
    5ae0:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
    5ae2:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	30"			);
    5ae6:	fe e1       	ldi	r31, 0x1E	; 30
		asm(	"CPSE	r31,	r25"		);
    5ae8:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
    5aea:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	31"			);
    5aee:	ff e1       	ldi	r31, 0x1F	; 31
		asm(	"CPSE	r31,	r26"		);
    5af0:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
    5af2:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	32"			);
    5af6:	f0 e2       	ldi	r31, 0x20	; 32
		asm(	"CPSE	r31,	r27"		);
    5af8:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
    5afa:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	33"			);
    5afe:	f1 e2       	ldi	r31, 0x21	; 33
		asm(	"CPSE	r31,	r30"		);
    5b00:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
    5b02:	00 92 bb 0d 	sts	0x0DBB, r0
	}
    5b06:	5e cf       	rjmp	.-324    	; 0x59c4 <prvRegisterCheck1+0xe>

00005b08 <prvRegisterCheck2>:
}
/*-----------------------------------------------------------*/

static void prvRegisterCheck2( void *pvParameters )
{
    5b08:	cf 93       	push	r28
    5b0a:	df 93       	push	r29
    5b0c:	00 d0       	rcall	.+0      	; 0x5b0e <prvRegisterCheck2+0x6>
    5b0e:	cd b7       	in	r28, 0x3d	; 61
    5b10:	de b7       	in	r29, 0x3e	; 62
    5b12:	9a 83       	std	Y+2, r25	; 0x02
    5b14:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	1"		);		
    5b16:	f1 e0       	ldi	r31, 0x01	; 1
		asm( 	"MOV	r0,		r31"	);
    5b18:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	2"		);
    5b1a:	f2 e0       	ldi	r31, 0x02	; 2
		asm( 	"MOV	r1,		r31"	);
    5b1c:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	3"		);
    5b1e:	f3 e0       	ldi	r31, 0x03	; 3
		asm( 	"MOV	r2,		r31"	);
    5b20:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	4"		);
    5b22:	f4 e0       	ldi	r31, 0x04	; 4
		asm( 	"MOV	r3,		r31"	);
    5b24:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	5"		);
    5b26:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r4,		r31"	);
    5b28:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	6"		);
    5b2a:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r5,		r31"	);
    5b2c:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	7"		);
    5b2e:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r6,		r31"	);
    5b30:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	8"		);
    5b32:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r7,		r31"	);
    5b34:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	9"		);
    5b36:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r8,		r31"	);
    5b38:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	10"		);
    5b3a:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r9,		r31"	);
    5b3c:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	11"		);
    5b3e:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r10,	r31"	);
    5b40:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	12"		);
    5b42:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r11,	r31"	);
    5b44:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	13"		);
    5b46:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r12,	r31"	);
    5b48:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	14"		);
    5b4a:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r13,	r31"	);
    5b4c:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	15"		);
    5b4e:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r14,	r31"	);
    5b50:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	16"		);
    5b52:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r15,	r31"	);
    5b54:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	17"		);
    5b56:	01 e1       	ldi	r16, 0x11	; 17
		asm(	"LDI	r17,	18"		);
    5b58:	12 e1       	ldi	r17, 0x12	; 18
		asm(	"LDI	r18,	19"		);
    5b5a:	23 e1       	ldi	r18, 0x13	; 19
		asm(	"LDI	r19,	20"		);
    5b5c:	34 e1       	ldi	r19, 0x14	; 20
		asm(	"LDI	r20,	21"		);
    5b5e:	45 e1       	ldi	r20, 0x15	; 21
		asm(	"LDI	r21,	22"		);
    5b60:	56 e1       	ldi	r21, 0x16	; 22
		asm(	"LDI	r22,	23"		);
    5b62:	67 e1       	ldi	r22, 0x17	; 23
		asm(	"LDI	r23,	24"		);
    5b64:	78 e1       	ldi	r23, 0x18	; 24
		asm(	"LDI	r24,	25"		);
    5b66:	89 e1       	ldi	r24, 0x19	; 25
		asm(	"LDI	r25,	26"		);
    5b68:	9a e1       	ldi	r25, 0x1A	; 26
		asm(	"LDI	r26,	27"		);
    5b6a:	ab e1       	ldi	r26, 0x1B	; 27
		asm(	"LDI	r27,	28"		);
    5b6c:	bc e1       	ldi	r27, 0x1C	; 28
		asm(	"LDI	r30,	29"		);
    5b6e:	ed e1       	ldi	r30, 0x1D	; 29

		asm(	"LDI	r31,	1"			);
    5b70:	f1 e0       	ldi	r31, 0x01	; 1
		asm(	"CPSE	r31,	r0"			);
    5b72:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
    5b74:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	2"			);
    5b78:	f2 e0       	ldi	r31, 0x02	; 2
		asm(	"CPSE	r31,	r1"			);
    5b7a:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
    5b7c:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	3"			);
    5b80:	f3 e0       	ldi	r31, 0x03	; 3
		asm(	"CPSE	r31,	r2"			);
    5b82:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
    5b84:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	4"			);
    5b88:	f4 e0       	ldi	r31, 0x04	; 4
		asm(	"CPSE	r31,	r3"			);
    5b8a:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
    5b8c:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	5"			);
    5b90:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r4"			);
    5b92:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
    5b94:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	6"			);
    5b98:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r5"			);
    5b9a:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
    5b9c:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	7"			);
    5ba0:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r6"			);
    5ba2:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
    5ba4:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	8"			);
    5ba8:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r7"			);
    5baa:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
    5bac:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	9"			);
    5bb0:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r8"			);
    5bb2:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
    5bb4:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	10"			);
    5bb8:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r9"			);
    5bba:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
    5bbc:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	11"			);
    5bc0:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r10"		);
    5bc2:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
    5bc4:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	12"			);
    5bc8:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r11"		);
    5bca:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
    5bcc:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	13"			);
    5bd0:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r12"		);
    5bd2:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
    5bd4:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	14"			);
    5bd8:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r13"		);
    5bda:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
    5bdc:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	15"			);
    5be0:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r14"		);
    5be2:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
    5be4:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	16"			);
    5be8:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r15"		);
    5bea:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
    5bec:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	17"			);
    5bf0:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r16"		);
    5bf2:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
    5bf4:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	18"			);
    5bf8:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r17"		);
    5bfa:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
    5bfc:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	19"			);
    5c00:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r18"		);
    5c02:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
    5c04:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	20"			);
    5c08:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r19"		);
    5c0a:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
    5c0c:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	21"			);
    5c10:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r20"		);
    5c12:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
    5c14:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	22"			);
    5c18:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r21"		);
    5c1a:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
    5c1c:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	23"			);
    5c20:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r22"		);
    5c22:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
    5c24:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	24"			);
    5c28:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r23"		);
    5c2a:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
    5c2c:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	25"			);
    5c30:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r24"		);
    5c32:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
    5c34:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	26"			);
    5c38:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r25"		);
    5c3a:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
    5c3c:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	27"			);
    5c40:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r26"		);
    5c42:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
    5c44:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	28"			);
    5c48:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r27"		);
    5c4a:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
    5c4c:	00 92 bb 0d 	sts	0x0DBB, r0
		asm(	"LDI	r31,	29"			);
    5c50:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r30"		);
    5c52:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
    5c54:	00 92 bb 0d 	sts	0x0DBB, r0
	}
    5c58:	5e cf       	rjmp	.-324    	; 0x5b16 <prvRegisterCheck2+0xe>

00005c5a <xSerialPortInitMinimal>:
	UCSR0B = ucInByte;										\
}
/*-----------------------------------------------------------*/

xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
    5c5a:	cf 93       	push	r28
    5c5c:	df 93       	push	r29
    5c5e:	cd b7       	in	r28, 0x3d	; 61
    5c60:	de b7       	in	r29, 0x3e	; 62
    5c62:	2a 97       	sbiw	r28, 0x0a	; 10
    5c64:	0f b6       	in	r0, 0x3f	; 63
    5c66:	f8 94       	cli
    5c68:	de bf       	out	0x3e, r29	; 62
    5c6a:	0f be       	out	0x3f, r0	; 63
    5c6c:	cd bf       	out	0x3d, r28	; 61
    5c6e:	6e 83       	std	Y+6, r22	; 0x06
    5c70:	7f 83       	std	Y+7, r23	; 0x07
    5c72:	88 87       	std	Y+8, r24	; 0x08
    5c74:	99 87       	std	Y+9, r25	; 0x09
    5c76:	4a 87       	std	Y+10, r20	; 0x0a
unsigned long ulBaudRateCounter;
unsigned char ucByte;

	portENTER_CRITICAL();
    5c78:	0f b6       	in	r0, 0x3f	; 63
    5c7a:	f8 94       	cli
    5c7c:	0f 92       	push	r0
	{
		/* Create the queues used by the com test task. */
		xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
    5c7e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5c80:	61 e0       	ldi	r22, 0x01	; 1
    5c82:	40 e0       	ldi	r20, 0x00	; 0
    5c84:	0e 94 c2 1c 	call	0x3984	; 0x3984 <xQueueGenericCreate>
    5c88:	90 93 bd 0d 	sts	0x0DBD, r25
    5c8c:	80 93 bc 0d 	sts	0x0DBC, r24
		xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
    5c90:	8a 85       	ldd	r24, Y+10	; 0x0a
    5c92:	61 e0       	ldi	r22, 0x01	; 1
    5c94:	40 e0       	ldi	r20, 0x00	; 0
    5c96:	0e 94 c2 1c 	call	0x3984	; 0x3984 <xQueueGenericCreate>
    5c9a:	90 93 bf 0d 	sts	0x0DBF, r25
    5c9e:	80 93 be 0d 	sts	0x0DBE, r24

		/* Calculate the baud rate register value from the equation in the
		data sheet. */
		ulBaudRateCounter = ( configCPU_CLOCK_HZ / ( serBAUD_DIV_CONSTANT * ulWantedBaud ) ) - ( unsigned long ) 1;
    5ca2:	8e 81       	ldd	r24, Y+6	; 0x06
    5ca4:	9f 81       	ldd	r25, Y+7	; 0x07
    5ca6:	a8 85       	ldd	r26, Y+8	; 0x08
    5ca8:	b9 85       	ldd	r27, Y+9	; 0x09
    5caa:	88 0f       	add	r24, r24
    5cac:	99 1f       	adc	r25, r25
    5cae:	aa 1f       	adc	r26, r26
    5cb0:	bb 1f       	adc	r27, r27
    5cb2:	88 0f       	add	r24, r24
    5cb4:	99 1f       	adc	r25, r25
    5cb6:	aa 1f       	adc	r26, r26
    5cb8:	bb 1f       	adc	r27, r27
    5cba:	88 0f       	add	r24, r24
    5cbc:	99 1f       	adc	r25, r25
    5cbe:	aa 1f       	adc	r26, r26
    5cc0:	bb 1f       	adc	r27, r27
    5cc2:	88 0f       	add	r24, r24
    5cc4:	99 1f       	adc	r25, r25
    5cc6:	aa 1f       	adc	r26, r26
    5cc8:	bb 1f       	adc	r27, r27
    5cca:	9c 01       	movw	r18, r24
    5ccc:	ad 01       	movw	r20, r26
    5cce:	80 e0       	ldi	r24, 0x00	; 0
    5cd0:	92 e1       	ldi	r25, 0x12	; 18
    5cd2:	aa e7       	ldi	r26, 0x7A	; 122
    5cd4:	b0 e0       	ldi	r27, 0x00	; 0
    5cd6:	bc 01       	movw	r22, r24
    5cd8:	cd 01       	movw	r24, r26
    5cda:	0e 94 68 36 	call	0x6cd0	; 0x6cd0 <__udivmodsi4>
    5cde:	da 01       	movw	r26, r20
    5ce0:	c9 01       	movw	r24, r18
    5ce2:	01 97       	sbiw	r24, 0x01	; 1
    5ce4:	a1 09       	sbc	r26, r1
    5ce6:	b1 09       	sbc	r27, r1
    5ce8:	89 83       	std	Y+1, r24	; 0x01
    5cea:	9a 83       	std	Y+2, r25	; 0x02
    5cec:	ab 83       	std	Y+3, r26	; 0x03
    5cee:	bc 83       	std	Y+4, r27	; 0x04

		/* Set the baud rate. */	
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
    5cf0:	89 81       	ldd	r24, Y+1	; 0x01
    5cf2:	8d 83       	std	Y+5, r24	; 0x05
		//MOD: atmega1284p
		//UBRRL = ucByte;
		UBRR0L = ucByte;
    5cf4:	84 ec       	ldi	r24, 0xC4	; 196
    5cf6:	90 e0       	ldi	r25, 0x00	; 0
    5cf8:	2d 81       	ldd	r18, Y+5	; 0x05
    5cfa:	fc 01       	movw	r30, r24
    5cfc:	20 83       	st	Z, r18

		ulBaudRateCounter >>= ( unsigned long ) 8;
    5cfe:	89 81       	ldd	r24, Y+1	; 0x01
    5d00:	9a 81       	ldd	r25, Y+2	; 0x02
    5d02:	ab 81       	ldd	r26, Y+3	; 0x03
    5d04:	bc 81       	ldd	r27, Y+4	; 0x04
    5d06:	89 2f       	mov	r24, r25
    5d08:	9a 2f       	mov	r25, r26
    5d0a:	ab 2f       	mov	r26, r27
    5d0c:	bb 27       	eor	r27, r27
    5d0e:	89 83       	std	Y+1, r24	; 0x01
    5d10:	9a 83       	std	Y+2, r25	; 0x02
    5d12:	ab 83       	std	Y+3, r26	; 0x03
    5d14:	bc 83       	std	Y+4, r27	; 0x04
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
    5d16:	89 81       	ldd	r24, Y+1	; 0x01
    5d18:	8d 83       	std	Y+5, r24	; 0x05
		//MOD: atmega1284p
		//UBRRH = ucByte;
		UBRR0H = ucByte;
    5d1a:	85 ec       	ldi	r24, 0xC5	; 197
    5d1c:	90 e0       	ldi	r25, 0x00	; 0
    5d1e:	2d 81       	ldd	r18, Y+5	; 0x05
    5d20:	fc 01       	movw	r30, r24
    5d22:	20 83       	st	Z, r18

		/* Enable the Rx interrupt.  The Tx interrupt will get enabled
		later. Also enable the Rx and Tx. */
		//MOD: atmega1284p
		//UCSRB = ( serRX_INT_ENABLE | serRX_ENABLE | serTX_ENABLE );
		UCSR0B = ( serRX_INT_ENABLE | serRX_ENABLE | serTX_ENABLE );
    5d24:	81 ec       	ldi	r24, 0xC1	; 193
    5d26:	90 e0       	ldi	r25, 0x00	; 0
    5d28:	28 e9       	ldi	r18, 0x98	; 152
    5d2a:	fc 01       	movw	r30, r24
    5d2c:	20 83       	st	Z, r18

		/* Set the data bits to 8. */
		//MOD: atmega1284p
		//UCSRC = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );
		UCSR0C = ( serEIGHT_DATA_BITS );
    5d2e:	82 ec       	ldi	r24, 0xC2	; 194
    5d30:	90 e0       	ldi	r25, 0x00	; 0
    5d32:	23 e0       	ldi	r18, 0x03	; 3
    5d34:	fc 01       	movw	r30, r24
    5d36:	20 83       	st	Z, r18

	}
	portEXIT_CRITICAL();
    5d38:	0f 90       	pop	r0
    5d3a:	0f be       	out	0x3f, r0	; 63
	
	/* Unlike other ports, this serial code does not allow for more than one
	com port.  We therefore don't return a pointer to a port structure and can
	instead just return NULL. */
	return NULL;
    5d3c:	80 e0       	ldi	r24, 0x00	; 0
    5d3e:	90 e0       	ldi	r25, 0x00	; 0
}
    5d40:	2a 96       	adiw	r28, 0x0a	; 10
    5d42:	0f b6       	in	r0, 0x3f	; 63
    5d44:	f8 94       	cli
    5d46:	de bf       	out	0x3e, r29	; 62
    5d48:	0f be       	out	0x3f, r0	; 63
    5d4a:	cd bf       	out	0x3d, r28	; 61
    5d4c:	df 91       	pop	r29
    5d4e:	cf 91       	pop	r28
    5d50:	08 95       	ret

00005d52 <xSerialGetChar>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialGetChar( xComPortHandle pxPort, signed char *pcRxedChar, uint32_t xBlockTime )
{
    5d52:	0f 93       	push	r16
    5d54:	cf 93       	push	r28
    5d56:	df 93       	push	r29
    5d58:	cd b7       	in	r28, 0x3d	; 61
    5d5a:	de b7       	in	r29, 0x3e	; 62
    5d5c:	28 97       	sbiw	r28, 0x08	; 8
    5d5e:	0f b6       	in	r0, 0x3f	; 63
    5d60:	f8 94       	cli
    5d62:	de bf       	out	0x3e, r29	; 62
    5d64:	0f be       	out	0x3f, r0	; 63
    5d66:	cd bf       	out	0x3d, r28	; 61
    5d68:	9a 83       	std	Y+2, r25	; 0x02
    5d6a:	89 83       	std	Y+1, r24	; 0x01
    5d6c:	7c 83       	std	Y+4, r23	; 0x04
    5d6e:	6b 83       	std	Y+3, r22	; 0x03
    5d70:	2d 83       	std	Y+5, r18	; 0x05
    5d72:	3e 83       	std	Y+6, r19	; 0x06
    5d74:	4f 83       	std	Y+7, r20	; 0x07
    5d76:	58 87       	std	Y+8, r21	; 0x08
	/* Only one port is supported. */
	( void ) pxPort;

	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
    5d78:	80 91 bc 0d 	lds	r24, 0x0DBC
    5d7c:	90 91 bd 0d 	lds	r25, 0x0DBD
    5d80:	6b 81       	ldd	r22, Y+3	; 0x03
    5d82:	7c 81       	ldd	r23, Y+4	; 0x04
    5d84:	2d 81       	ldd	r18, Y+5	; 0x05
    5d86:	3e 81       	ldd	r19, Y+6	; 0x06
    5d88:	4f 81       	ldd	r20, Y+7	; 0x07
    5d8a:	58 85       	ldd	r21, Y+8	; 0x08
    5d8c:	00 e0       	ldi	r16, 0x00	; 0
    5d8e:	0e 94 37 1e 	call	0x3c6e	; 0x3c6e <xQueueGenericReceive>
    5d92:	88 23       	and	r24, r24
    5d94:	11 f0       	breq	.+4      	; 0x5d9a <xSerialGetChar+0x48>
	{
		return pdTRUE;
    5d96:	81 e0       	ldi	r24, 0x01	; 1
    5d98:	01 c0       	rjmp	.+2      	; 0x5d9c <xSerialGetChar+0x4a>
	}
	else
	{
		return pdFALSE;
    5d9a:	80 e0       	ldi	r24, 0x00	; 0
	}
}
    5d9c:	28 96       	adiw	r28, 0x08	; 8
    5d9e:	0f b6       	in	r0, 0x3f	; 63
    5da0:	f8 94       	cli
    5da2:	de bf       	out	0x3e, r29	; 62
    5da4:	0f be       	out	0x3f, r0	; 63
    5da6:	cd bf       	out	0x3d, r28	; 61
    5da8:	df 91       	pop	r29
    5daa:	cf 91       	pop	r28
    5dac:	0f 91       	pop	r16
    5dae:	08 95       	ret

00005db0 <xSerialPutChar>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, uint32_t xBlockTime )
{
    5db0:	0f 93       	push	r16
    5db2:	cf 93       	push	r28
    5db4:	df 93       	push	r29
    5db6:	cd b7       	in	r28, 0x3d	; 61
    5db8:	de b7       	in	r29, 0x3e	; 62
    5dba:	28 97       	sbiw	r28, 0x08	; 8
    5dbc:	0f b6       	in	r0, 0x3f	; 63
    5dbe:	f8 94       	cli
    5dc0:	de bf       	out	0x3e, r29	; 62
    5dc2:	0f be       	out	0x3f, r0	; 63
    5dc4:	cd bf       	out	0x3d, r28	; 61
    5dc6:	9b 83       	std	Y+3, r25	; 0x03
    5dc8:	8a 83       	std	Y+2, r24	; 0x02
    5dca:	6c 83       	std	Y+4, r22	; 0x04
    5dcc:	2d 83       	std	Y+5, r18	; 0x05
    5dce:	3e 83       	std	Y+6, r19	; 0x06
    5dd0:	4f 83       	std	Y+7, r20	; 0x07
    5dd2:	58 87       	std	Y+8, r21	; 0x08
	/* Only one port is supported. */
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
    5dd4:	80 91 be 0d 	lds	r24, 0x0DBE
    5dd8:	90 91 bf 0d 	lds	r25, 0x0DBF
    5ddc:	be 01       	movw	r22, r28
    5dde:	6c 5f       	subi	r22, 0xFC	; 252
    5de0:	7f 4f       	sbci	r23, 0xFF	; 255
    5de2:	2d 81       	ldd	r18, Y+5	; 0x05
    5de4:	3e 81       	ldd	r19, Y+6	; 0x06
    5de6:	4f 81       	ldd	r20, Y+7	; 0x07
    5de8:	58 85       	ldd	r21, Y+8	; 0x08
    5dea:	00 e0       	ldi	r16, 0x00	; 0
    5dec:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <xQueueGenericSend>
    5df0:	81 30       	cpi	r24, 0x01	; 1
    5df2:	11 f0       	breq	.+4      	; 0x5df8 <xSerialPutChar+0x48>
	{
		return pdFAIL;
    5df4:	80 e0       	ldi	r24, 0x00	; 0
    5df6:	0e c0       	rjmp	.+28     	; 0x5e14 <xSerialPutChar+0x64>
	}

	vInterruptOn();
    5df8:	81 ec       	ldi	r24, 0xC1	; 193
    5dfa:	90 e0       	ldi	r25, 0x00	; 0
    5dfc:	fc 01       	movw	r30, r24
    5dfe:	80 81       	ld	r24, Z
    5e00:	89 83       	std	Y+1, r24	; 0x01
    5e02:	89 81       	ldd	r24, Y+1	; 0x01
    5e04:	80 64       	ori	r24, 0x40	; 64
    5e06:	89 83       	std	Y+1, r24	; 0x01
    5e08:	81 ec       	ldi	r24, 0xC1	; 193
    5e0a:	90 e0       	ldi	r25, 0x00	; 0
    5e0c:	29 81       	ldd	r18, Y+1	; 0x01
    5e0e:	fc 01       	movw	r30, r24
    5e10:	20 83       	st	Z, r18

	return pdPASS;
    5e12:	81 e0       	ldi	r24, 0x01	; 1
}
    5e14:	28 96       	adiw	r28, 0x08	; 8
    5e16:	0f b6       	in	r0, 0x3f	; 63
    5e18:	f8 94       	cli
    5e1a:	de bf       	out	0x3e, r29	; 62
    5e1c:	0f be       	out	0x3f, r0	; 63
    5e1e:	cd bf       	out	0x3d, r28	; 61
    5e20:	df 91       	pop	r29
    5e22:	cf 91       	pop	r28
    5e24:	0f 91       	pop	r16
    5e26:	08 95       	ret

00005e28 <vSerialClose>:
/*-----------------------------------------------------------*/

void vSerialClose( xComPortHandle xPort )
{
    5e28:	cf 93       	push	r28
    5e2a:	df 93       	push	r29
    5e2c:	00 d0       	rcall	.+0      	; 0x5e2e <vSerialClose+0x6>
    5e2e:	00 d0       	rcall	.+0      	; 0x5e30 <vSerialClose+0x8>
    5e30:	cd b7       	in	r28, 0x3d	; 61
    5e32:	de b7       	in	r29, 0x3e	; 62
    5e34:	9c 83       	std	Y+4, r25	; 0x04
    5e36:	8b 83       	std	Y+3, r24	; 0x03
	( void ) xPort;

	/* Turn off the interrupts.  We may also want to delete the queues and/or
	re-install the original ISR. */

	portENTER_CRITICAL();
    5e38:	0f b6       	in	r0, 0x3f	; 63
    5e3a:	f8 94       	cli
    5e3c:	0f 92       	push	r0
	{
		vInterruptOff();
    5e3e:	81 ec       	ldi	r24, 0xC1	; 193
    5e40:	90 e0       	ldi	r25, 0x00	; 0
    5e42:	fc 01       	movw	r30, r24
    5e44:	80 81       	ld	r24, Z
    5e46:	89 83       	std	Y+1, r24	; 0x01
    5e48:	89 81       	ldd	r24, Y+1	; 0x01
    5e4a:	8f 7b       	andi	r24, 0xBF	; 191
    5e4c:	89 83       	std	Y+1, r24	; 0x01
    5e4e:	81 ec       	ldi	r24, 0xC1	; 193
    5e50:	90 e0       	ldi	r25, 0x00	; 0
    5e52:	29 81       	ldd	r18, Y+1	; 0x01
    5e54:	fc 01       	movw	r30, r24
    5e56:	20 83       	st	Z, r18
		ucByte = UCSR0B;
    5e58:	81 ec       	ldi	r24, 0xC1	; 193
    5e5a:	90 e0       	ldi	r25, 0x00	; 0
    5e5c:	fc 01       	movw	r30, r24
    5e5e:	80 81       	ld	r24, Z
    5e60:	8a 83       	std	Y+2, r24	; 0x02
		ucByte &= ~serRX_INT_ENABLE;
    5e62:	8a 81       	ldd	r24, Y+2	; 0x02
    5e64:	8f 77       	andi	r24, 0x7F	; 127
    5e66:	8a 83       	std	Y+2, r24	; 0x02
		UCSR0B = ucByte;
    5e68:	81 ec       	ldi	r24, 0xC1	; 193
    5e6a:	90 e0       	ldi	r25, 0x00	; 0
    5e6c:	2a 81       	ldd	r18, Y+2	; 0x02
    5e6e:	fc 01       	movw	r30, r24
    5e70:	20 83       	st	Z, r18
	}
	portEXIT_CRITICAL();
    5e72:	0f 90       	pop	r0
    5e74:	0f be       	out	0x3f, r0	; 63
}
    5e76:	0f 90       	pop	r0
    5e78:	0f 90       	pop	r0
    5e7a:	0f 90       	pop	r0
    5e7c:	0f 90       	pop	r0
    5e7e:	df 91       	pop	r29
    5e80:	cf 91       	pop	r28
    5e82:	08 95       	ret

00005e84 <SIG_UART_RECV>:
/*-----------------------------------------------------------*/

SIGNAL( SIG_UART_RECV )
{
    5e84:	1f 92       	push	r1
    5e86:	0f 92       	push	r0
    5e88:	0f b6       	in	r0, 0x3f	; 63
    5e8a:	0f 92       	push	r0
    5e8c:	00 90 5b 00 	lds	r0, 0x005B
    5e90:	0f 92       	push	r0
    5e92:	11 24       	eor	r1, r1
    5e94:	2f 93       	push	r18
    5e96:	3f 93       	push	r19
    5e98:	4f 93       	push	r20
    5e9a:	5f 93       	push	r21
    5e9c:	6f 93       	push	r22
    5e9e:	7f 93       	push	r23
    5ea0:	8f 93       	push	r24
    5ea2:	9f 93       	push	r25
    5ea4:	af 93       	push	r26
    5ea6:	bf 93       	push	r27
    5ea8:	ef 93       	push	r30
    5eaa:	ff 93       	push	r31
    5eac:	cf 93       	push	r28
    5eae:	df 93       	push	r29
    5eb0:	00 d0       	rcall	.+0      	; 0x5eb2 <SIG_UART_RECV+0x2e>
    5eb2:	cd b7       	in	r28, 0x3d	; 61
    5eb4:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
    5eb6:	1a 82       	std	Y+2, r1	; 0x02

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR0;
    5eb8:	86 ec       	ldi	r24, 0xC6	; 198
    5eba:	90 e0       	ldi	r25, 0x00	; 0
    5ebc:	fc 01       	movw	r30, r24
    5ebe:	80 81       	ld	r24, Z
    5ec0:	89 83       	std	Y+1, r24	; 0x01

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
    5ec2:	80 91 bc 0d 	lds	r24, 0x0DBC
    5ec6:	90 91 bd 0d 	lds	r25, 0x0DBD
    5eca:	9e 01       	movw	r18, r28
    5ecc:	2e 5f       	subi	r18, 0xFE	; 254
    5ece:	3f 4f       	sbci	r19, 0xFF	; 255
    5ed0:	ae 01       	movw	r20, r28
    5ed2:	4f 5f       	subi	r20, 0xFF	; 255
    5ed4:	5f 4f       	sbci	r21, 0xFF	; 255
    5ed6:	ba 01       	movw	r22, r20
    5ed8:	a9 01       	movw	r20, r18
    5eda:	20 e0       	ldi	r18, 0x00	; 0
    5edc:	0e 94 da 1d 	call	0x3bb4	; 0x3bb4 <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
    5ee0:	8a 81       	ldd	r24, Y+2	; 0x02
    5ee2:	88 23       	and	r24, r24
    5ee4:	11 f0       	breq	.+4      	; 0x5eea <SIG_UART_RECV+0x66>
	{
		taskYIELD();
    5ee6:	0e 94 47 1b 	call	0x368e	; 0x368e <vPortYield>
	}
}
    5eea:	0f 90       	pop	r0
    5eec:	0f 90       	pop	r0
    5eee:	df 91       	pop	r29
    5ef0:	cf 91       	pop	r28
    5ef2:	ff 91       	pop	r31
    5ef4:	ef 91       	pop	r30
    5ef6:	bf 91       	pop	r27
    5ef8:	af 91       	pop	r26
    5efa:	9f 91       	pop	r25
    5efc:	8f 91       	pop	r24
    5efe:	7f 91       	pop	r23
    5f00:	6f 91       	pop	r22
    5f02:	5f 91       	pop	r21
    5f04:	4f 91       	pop	r20
    5f06:	3f 91       	pop	r19
    5f08:	2f 91       	pop	r18
    5f0a:	0f 90       	pop	r0
    5f0c:	00 92 5b 00 	sts	0x005B, r0
    5f10:	0f 90       	pop	r0
    5f12:	0f be       	out	0x3f, r0	; 63
    5f14:	0f 90       	pop	r0
    5f16:	1f 90       	pop	r1
    5f18:	18 95       	reti

00005f1a <SIG_UART_DATA>:
/*-----------------------------------------------------------*/

SIGNAL( SIG_UART_DATA )
{
    5f1a:	1f 92       	push	r1
    5f1c:	0f 92       	push	r0
    5f1e:	0f b6       	in	r0, 0x3f	; 63
    5f20:	0f 92       	push	r0
    5f22:	00 90 5b 00 	lds	r0, 0x005B
    5f26:	0f 92       	push	r0
    5f28:	11 24       	eor	r1, r1
    5f2a:	2f 93       	push	r18
    5f2c:	3f 93       	push	r19
    5f2e:	4f 93       	push	r20
    5f30:	5f 93       	push	r21
    5f32:	6f 93       	push	r22
    5f34:	7f 93       	push	r23
    5f36:	8f 93       	push	r24
    5f38:	9f 93       	push	r25
    5f3a:	af 93       	push	r26
    5f3c:	bf 93       	push	r27
    5f3e:	ef 93       	push	r30
    5f40:	ff 93       	push	r31
    5f42:	cf 93       	push	r28
    5f44:	df 93       	push	r29
    5f46:	00 d0       	rcall	.+0      	; 0x5f48 <SIG_UART_DATA+0x2e>
    5f48:	0f 92       	push	r0
    5f4a:	cd b7       	in	r28, 0x3d	; 61
    5f4c:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
    5f4e:	80 91 be 0d 	lds	r24, 0x0DBE
    5f52:	90 91 bf 0d 	lds	r25, 0x0DBF
    5f56:	ae 01       	movw	r20, r28
    5f58:	4e 5f       	subi	r20, 0xFE	; 254
    5f5a:	5f 4f       	sbci	r21, 0xFF	; 255
    5f5c:	9e 01       	movw	r18, r28
    5f5e:	2d 5f       	subi	r18, 0xFD	; 253
    5f60:	3f 4f       	sbci	r19, 0xFF	; 255
    5f62:	ba 01       	movw	r22, r20
    5f64:	a9 01       	movw	r20, r18
    5f66:	0e 94 15 1f 	call	0x3e2a	; 0x3e2a <xQueueReceiveFromISR>
    5f6a:	81 30       	cpi	r24, 0x01	; 1
    5f6c:	31 f4       	brne	.+12     	; 0x5f7a <SIG_UART_DATA+0x60>
	{
		/* Send the next character queued for Tx. */
		//MOD: atmega1284p
		//UDR = cChar;
		UDR0 = cChar;
    5f6e:	86 ec       	ldi	r24, 0xC6	; 198
    5f70:	90 e0       	ldi	r25, 0x00	; 0
    5f72:	2a 81       	ldd	r18, Y+2	; 0x02
    5f74:	fc 01       	movw	r30, r24
    5f76:	20 83       	st	Z, r18
    5f78:	0d c0       	rjmp	.+26     	; 0x5f94 <SIG_UART_DATA+0x7a>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
    5f7a:	81 ec       	ldi	r24, 0xC1	; 193
    5f7c:	90 e0       	ldi	r25, 0x00	; 0
    5f7e:	fc 01       	movw	r30, r24
    5f80:	80 81       	ld	r24, Z
    5f82:	89 83       	std	Y+1, r24	; 0x01
    5f84:	89 81       	ldd	r24, Y+1	; 0x01
    5f86:	8f 7b       	andi	r24, 0xBF	; 191
    5f88:	89 83       	std	Y+1, r24	; 0x01
    5f8a:	81 ec       	ldi	r24, 0xC1	; 193
    5f8c:	90 e0       	ldi	r25, 0x00	; 0
    5f8e:	29 81       	ldd	r18, Y+1	; 0x01
    5f90:	fc 01       	movw	r30, r24
    5f92:	20 83       	st	Z, r18
	}
}
    5f94:	23 96       	adiw	r28, 0x03	; 3
    5f96:	de bf       	out	0x3e, r29	; 62
    5f98:	cd bf       	out	0x3d, r28	; 61
    5f9a:	df 91       	pop	r29
    5f9c:	cf 91       	pop	r28
    5f9e:	ff 91       	pop	r31
    5fa0:	ef 91       	pop	r30
    5fa2:	bf 91       	pop	r27
    5fa4:	af 91       	pop	r26
    5fa6:	9f 91       	pop	r25
    5fa8:	8f 91       	pop	r24
    5faa:	7f 91       	pop	r23
    5fac:	6f 91       	pop	r22
    5fae:	5f 91       	pop	r21
    5fb0:	4f 91       	pop	r20
    5fb2:	3f 91       	pop	r19
    5fb4:	2f 91       	pop	r18
    5fb6:	0f 90       	pop	r0
    5fb8:	00 92 5b 00 	sts	0x005B, r0
    5fbc:	0f 90       	pop	r0
    5fbe:	0f be       	out	0x3f, r0	; 63
    5fc0:	0f 90       	pop	r0
    5fc2:	1f 90       	pop	r1
    5fc4:	18 95       	reti

00005fc6 <startSystemControlTask>:
*/
static portBASE_TYPE xControlTaskStatus = pdPASS;


void startSystemControlTask( unsigned portBASE_TYPE uxPriority, xQueueHandle* measQueue, xQueueHandle* statQueue )
{  
    5fc6:	af 92       	push	r10
    5fc8:	bf 92       	push	r11
    5fca:	cf 92       	push	r12
    5fcc:	df 92       	push	r13
    5fce:	ef 92       	push	r14
    5fd0:	ff 92       	push	r15
    5fd2:	0f 93       	push	r16
    5fd4:	cf 93       	push	r28
    5fd6:	df 93       	push	r29
    5fd8:	cd b7       	in	r28, 0x3d	; 61
    5fda:	de b7       	in	r29, 0x3e	; 62
    5fdc:	27 97       	sbiw	r28, 0x07	; 7
    5fde:	0f b6       	in	r0, 0x3f	; 63
    5fe0:	f8 94       	cli
    5fe2:	de bf       	out	0x3e, r29	; 62
    5fe4:	0f be       	out	0x3f, r0	; 63
    5fe6:	cd bf       	out	0x3d, r28	; 61
    5fe8:	8b 83       	std	Y+3, r24	; 0x03
    5fea:	7d 83       	std	Y+5, r23	; 0x05
    5fec:	6c 83       	std	Y+4, r22	; 0x04
    5fee:	5f 83       	std	Y+7, r21	; 0x07
    5ff0:	4e 83       	std	Y+6, r20	; 0x06
    adcInit();
    5ff2:	0e 94 6a 07 	call	0xed4	; 0xed4 <adcInit>
        
    //Set high side driver pins to outputs
    DDRC |= ( (1<<PC6) | (1<<PC7) );    
    5ff6:	87 e2       	ldi	r24, 0x27	; 39
    5ff8:	90 e0       	ldi	r25, 0x00	; 0
    5ffa:	27 e2       	ldi	r18, 0x27	; 39
    5ffc:	30 e0       	ldi	r19, 0x00	; 0
    5ffe:	f9 01       	movw	r30, r18
    6000:	20 81       	ld	r18, Z
    6002:	20 6c       	ori	r18, 0xC0	; 192
    6004:	fc 01       	movw	r30, r24
    6006:	20 83       	st	Z, r18
    //switch on high side driver
    PORTC |=  ( (1<<PC6) | (1<<PC7) );       
    6008:	88 e2       	ldi	r24, 0x28	; 40
    600a:	90 e0       	ldi	r25, 0x00	; 0
    600c:	28 e2       	ldi	r18, 0x28	; 40
    600e:	30 e0       	ldi	r19, 0x00	; 0
    6010:	f9 01       	movw	r30, r18
    6012:	20 81       	ld	r18, Z
    6014:	20 6c       	ori	r18, 0xC0	; 192
    6016:	fc 01       	movw	r30, r24
    6018:	20 83       	st	Z, r18
        
    //create task parameter
    systemControlTaskParameters *taskParams;
    taskParams = ( systemControlTaskParameters * ) pvPortMalloc( sizeof( systemControlTaskParameters ) );
    601a:	84 e0       	ldi	r24, 0x04	; 4
    601c:	90 e0       	ldi	r25, 0x00	; 0
    601e:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <pvPortMalloc>
    6022:	9a 83       	std	Y+2, r25	; 0x02
    6024:	89 83       	std	Y+1, r24	; 0x01
    taskParams->measurementQueue = *measQueue;
    6026:	8c 81       	ldd	r24, Y+4	; 0x04
    6028:	9d 81       	ldd	r25, Y+5	; 0x05
    602a:	fc 01       	movw	r30, r24
    602c:	20 81       	ld	r18, Z
    602e:	31 81       	ldd	r19, Z+1	; 0x01
    6030:	89 81       	ldd	r24, Y+1	; 0x01
    6032:	9a 81       	ldd	r25, Y+2	; 0x02
    6034:	fc 01       	movw	r30, r24
    6036:	31 83       	std	Z+1, r19	; 0x01
    6038:	20 83       	st	Z, r18
    taskParams->statusQueue = *statQueue;
    603a:	8e 81       	ldd	r24, Y+6	; 0x06
    603c:	9f 81       	ldd	r25, Y+7	; 0x07
    603e:	fc 01       	movw	r30, r24
    6040:	20 81       	ld	r18, Z
    6042:	31 81       	ldd	r19, Z+1	; 0x01
    6044:	89 81       	ldd	r24, Y+1	; 0x01
    6046:	9a 81       	ldd	r25, Y+2	; 0x02
    6048:	fc 01       	movw	r30, r24
    604a:	33 83       	std	Z+3, r19	; 0x03
    604c:	22 83       	std	Z+2, r18	; 0x02
    
    xTaskCreate( executeSystemControlTask, ( signed char * ) "sysContrTask", sysControlTaskSTACK_SIZE,  ( void * ) taskParams , uxPriority, ( xTaskHandle * ) NULL );
    604e:	89 e4       	ldi	r24, 0x49	; 73
    6050:	90 e3       	ldi	r25, 0x30	; 48
    6052:	47 e3       	ldi	r20, 0x37	; 55
    6054:	51 e0       	ldi	r21, 0x01	; 1
    6056:	29 81       	ldd	r18, Y+1	; 0x01
    6058:	3a 81       	ldd	r19, Y+2	; 0x02
    605a:	ba 01       	movw	r22, r20
    605c:	48 ec       	ldi	r20, 0xC8	; 200
    605e:	50 e0       	ldi	r21, 0x00	; 0
    6060:	0b 81       	ldd	r16, Y+3	; 0x03
    6062:	ee 24       	eor	r14, r14
    6064:	ff 24       	eor	r15, r15
    6066:	cc 24       	eor	r12, r12
    6068:	dd 24       	eor	r13, r13
    606a:	aa 24       	eor	r10, r10
    606c:	bb 24       	eor	r11, r11
    606e:	0e 94 99 21 	call	0x4332	; 0x4332 <xTaskGenericCreate>
}
    6072:	27 96       	adiw	r28, 0x07	; 7
    6074:	0f b6       	in	r0, 0x3f	; 63
    6076:	f8 94       	cli
    6078:	de bf       	out	0x3e, r29	; 62
    607a:	0f be       	out	0x3f, r0	; 63
    607c:	cd bf       	out	0x3d, r28	; 61
    607e:	df 91       	pop	r29
    6080:	cf 91       	pop	r28
    6082:	0f 91       	pop	r16
    6084:	ff 90       	pop	r15
    6086:	ef 90       	pop	r14
    6088:	df 90       	pop	r13
    608a:	cf 90       	pop	r12
    608c:	bf 90       	pop	r11
    608e:	af 90       	pop	r10
    6090:	08 95       	ret

00006092 <executeSystemControlTask>:


static portTASK_FUNCTION( executeSystemControlTask, pvParameters )
{
    6092:	0f 93       	push	r16
    6094:	cf 93       	push	r28
    6096:	df 93       	push	r29
    6098:	cd b7       	in	r28, 0x3d	; 61
    609a:	de b7       	in	r29, 0x3e	; 62
    609c:	2d 97       	sbiw	r28, 0x0d	; 13
    609e:	0f b6       	in	r0, 0x3f	; 63
    60a0:	f8 94       	cli
    60a2:	de bf       	out	0x3e, r29	; 62
    60a4:	0f be       	out	0x3f, r0	; 63
    60a6:	cd bf       	out	0x3d, r28	; 61
    60a8:	9d 87       	std	Y+13, r25	; 0x0d
    60aa:	8c 87       	std	Y+12, r24	; 0x0c
    systemControlTaskParameters *taskParams;
    
    measurementQueueMsg *measurementMsg;
    statusQueueMsg *statusMsg;
    
    uint8_t successFlag=0;
    60ac:	19 82       	std	Y+1, r1	; 0x01
    
    taskParams = ( systemControlTaskParameters * ) pvParameters;
    60ae:	8c 85       	ldd	r24, Y+12	; 0x0c
    60b0:	9d 85       	ldd	r25, Y+13	; 0x0d
    60b2:	9b 83       	std	Y+3, r25	; 0x03
    60b4:	8a 83       	std	Y+2, r24	; 0x02
        
    //Initialize the wake up time with the current time
    xLastWakeUpTime = xTaskGetTickCount();    
    60b6:	0e 94 76 24 	call	0x48ec	; 0x48ec <xTaskGetTickCount>
    60ba:	cc 01       	movw	r24, r24
    60bc:	a0 e0       	ldi	r26, 0x00	; 0
    60be:	b0 e0       	ldi	r27, 0x00	; 0
    60c0:	8e 83       	std	Y+6, r24	; 0x06
    60c2:	9f 83       	std	Y+7, r25	; 0x07
    60c4:	a8 87       	std	Y+8, r26	; 0x08
    60c6:	b9 87       	std	Y+9, r27	; 0x09
    
    for(;;)
    {
        vTaskDelayUntil( &xLastWakeUpTime, SYSTEM_CONTROL_TASK_CYCLE );
    60c8:	ce 01       	movw	r24, r28
    60ca:	06 96       	adiw	r24, 0x06	; 6
    60cc:	64 ef       	ldi	r22, 0xF4	; 244
    60ce:	71 e0       	ldi	r23, 0x01	; 1
    60d0:	0e 94 e9 22 	call	0x45d2	; 0x45d2 <vTaskDelayUntil>
                
        //Execute this task each 50ms
        batteryVoltage_mVolt = measureBattVoltage();
    60d4:	0e 94 2a 08 	call	0x1054	; 0x1054 <measureBattVoltage>
    60d8:	9d 83       	std	Y+5, r25	; 0x05
    60da:	8c 83       	std	Y+4, r24	; 0x04
        //consumerCurrent_mAmps = measureConsumerCurrent();
        //!!measure also solar voltage!!!
        
        //send new battery voltage value via measurement queue
        //first: prepare message
        measurementMsg->valueId = ID_BATTERY_VOLTAGE;
    60dc:	8a 85       	ldd	r24, Y+10	; 0x0a
    60de:	9b 85       	ldd	r25, Y+11	; 0x0b
    60e0:	fc 01       	movw	r30, r24
    60e2:	11 82       	std	Z+1, r1	; 0x01
    60e4:	10 82       	st	Z, r1
        measurementMsg->value = batteryVoltage_mVolt;
    60e6:	8a 85       	ldd	r24, Y+10	; 0x0a
    60e8:	9b 85       	ldd	r25, Y+11	; 0x0b
    60ea:	2c 81       	ldd	r18, Y+4	; 0x04
    60ec:	3d 81       	ldd	r19, Y+5	; 0x05
    60ee:	fc 01       	movw	r30, r24
    60f0:	33 83       	std	Z+3, r19	; 0x03
    60f2:	22 83       	std	Z+2, r18	; 0x02
           
        //second: send queue
        successFlag = xQueueSend( taskParams->measurementQueue, &measurementMsg, ( portTickType ) 10  ) ;
    60f4:	8a 81       	ldd	r24, Y+2	; 0x02
    60f6:	9b 81       	ldd	r25, Y+3	; 0x03
    60f8:	fc 01       	movw	r30, r24
    60fa:	80 81       	ld	r24, Z
    60fc:	91 81       	ldd	r25, Z+1	; 0x01
    60fe:	9e 01       	movw	r18, r28
    6100:	26 5f       	subi	r18, 0xF6	; 246
    6102:	3f 4f       	sbci	r19, 0xFF	; 255
    6104:	b9 01       	movw	r22, r18
    6106:	2a e0       	ldi	r18, 0x0A	; 10
    6108:	30 e0       	ldi	r19, 0x00	; 0
    610a:	40 e0       	ldi	r20, 0x00	; 0
    610c:	50 e0       	ldi	r21, 0x00	; 0
    610e:	00 e0       	ldi	r16, 0x00	; 0
    6110:	0e 94 23 1d 	call	0x3a46	; 0x3a46 <xQueueGenericSend>
    6114:	89 83       	std	Y+1, r24	; 0x01
    }
    6116:	d8 cf       	rjmp	.-80     	; 0x60c8 <executeSystemControlTask+0x36>

00006118 <xIsSystemControlTaskStillRunning>:
}

/* This is called to check that all the created tasks are still running. */
portBASE_TYPE xIsSystemControlTaskStillRunning( void )
{
    6118:	cf 93       	push	r28
    611a:	df 93       	push	r29
    611c:	0f 92       	push	r0
    611e:	cd b7       	in	r28, 0x3d	; 61
    6120:	de b7       	in	r29, 0x3e	; 62
    portBASE_TYPE xReturn;

	/* Evaluate task status and other relevant variables to indicate the task¥s health */
	if( xControlTaskStatus == pdFAIL )
    6122:	80 91 36 01 	lds	r24, 0x0136
    6126:	88 23       	and	r24, r24
    6128:	11 f4       	brne	.+4      	; 0x612e <xIsSystemControlTaskStillRunning+0x16>
	{
		xReturn = pdFAIL;
    612a:	19 82       	std	Y+1, r1	; 0x01
    612c:	02 c0       	rjmp	.+4      	; 0x6132 <xIsSystemControlTaskStillRunning+0x1a>
	}
	else
	{
		xReturn = pdPASS;
    612e:	81 e0       	ldi	r24, 0x01	; 1
    6130:	89 83       	std	Y+1, r24	; 0x01
	}

	return xReturn;
    6132:	89 81       	ldd	r24, Y+1	; 0x01
    6134:	0f 90       	pop	r0
    6136:	df 91       	pop	r29
    6138:	cf 91       	pop	r28
    613a:	08 95       	ret

0000613c <startSystemStatusTask>:

static portBASE_TYPE prvCheckOtherTasksAreStillRunning( void );


void startSystemStatusTask( unsigned portBASE_TYPE uxPriority, xQueueHandle *statQueue )
{
    613c:	af 92       	push	r10
    613e:	bf 92       	push	r11
    6140:	cf 92       	push	r12
    6142:	df 92       	push	r13
    6144:	ef 92       	push	r14
    6146:	ff 92       	push	r15
    6148:	0f 93       	push	r16
    614a:	cf 93       	push	r28
    614c:	df 93       	push	r29
    614e:	00 d0       	rcall	.+0      	; 0x6150 <startSystemStatusTask+0x14>
    6150:	00 d0       	rcall	.+0      	; 0x6152 <startSystemStatusTask+0x16>
    6152:	0f 92       	push	r0
    6154:	cd b7       	in	r28, 0x3d	; 61
    6156:	de b7       	in	r29, 0x3e	; 62
    6158:	8b 83       	std	Y+3, r24	; 0x03
    615a:	7d 83       	std	Y+5, r23	; 0x05
    615c:	6c 83       	std	Y+4, r22	; 0x04
    //set pins PB0 (green LED) & PB1 (red LED) to outputs
    DDRB |= ( (1<<PB0) | (1<<PB1) );
    615e:	84 e2       	ldi	r24, 0x24	; 36
    6160:	90 e0       	ldi	r25, 0x00	; 0
    6162:	24 e2       	ldi	r18, 0x24	; 36
    6164:	30 e0       	ldi	r19, 0x00	; 0
    6166:	f9 01       	movw	r30, r18
    6168:	20 81       	ld	r18, Z
    616a:	23 60       	ori	r18, 0x03	; 3
    616c:	fc 01       	movw	r30, r24
    616e:	20 83       	st	Z, r18
    
    systemStatusTaskParameters *taskParams;
    taskParams = ( systemStatusTaskParameters * ) pvPortMalloc( sizeof( systemStatusTaskParameters ) );
    6170:	82 e0       	ldi	r24, 0x02	; 2
    6172:	90 e0       	ldi	r25, 0x00	; 0
    6174:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <pvPortMalloc>
    6178:	9a 83       	std	Y+2, r25	; 0x02
    617a:	89 83       	std	Y+1, r24	; 0x01
    taskParams->statusQueue = *statQueue;
    617c:	8c 81       	ldd	r24, Y+4	; 0x04
    617e:	9d 81       	ldd	r25, Y+5	; 0x05
    6180:	fc 01       	movw	r30, r24
    6182:	20 81       	ld	r18, Z
    6184:	31 81       	ldd	r19, Z+1	; 0x01
    6186:	89 81       	ldd	r24, Y+1	; 0x01
    6188:	9a 81       	ldd	r25, Y+2	; 0x02
    618a:	fc 01       	movw	r30, r24
    618c:	31 83       	std	Z+1, r19	; 0x01
    618e:	20 83       	st	Z, r18

    xTaskCreate( executeSystemStatusTask, ( signed char * ) "SysStatTask", sysStatusTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
    6190:	89 ee       	ldi	r24, 0xE9	; 233
    6192:	90 e3       	ldi	r25, 0x30	; 48
    6194:	44 e4       	ldi	r20, 0x44	; 68
    6196:	51 e0       	ldi	r21, 0x01	; 1
    6198:	29 81       	ldd	r18, Y+1	; 0x01
    619a:	3a 81       	ldd	r19, Y+2	; 0x02
    619c:	ba 01       	movw	r22, r20
    619e:	48 ec       	ldi	r20, 0xC8	; 200
    61a0:	50 e0       	ldi	r21, 0x00	; 0
    61a2:	0b 81       	ldd	r16, Y+3	; 0x03
    61a4:	ee 24       	eor	r14, r14
    61a6:	ff 24       	eor	r15, r15
    61a8:	cc 24       	eor	r12, r12
    61aa:	dd 24       	eor	r13, r13
    61ac:	aa 24       	eor	r10, r10
    61ae:	bb 24       	eor	r11, r11
    61b0:	0e 94 99 21 	call	0x4332	; 0x4332 <xTaskGenericCreate>
}
    61b4:	0f 90       	pop	r0
    61b6:	0f 90       	pop	r0
    61b8:	0f 90       	pop	r0
    61ba:	0f 90       	pop	r0
    61bc:	0f 90       	pop	r0
    61be:	df 91       	pop	r29
    61c0:	cf 91       	pop	r28
    61c2:	0f 91       	pop	r16
    61c4:	ff 90       	pop	r15
    61c6:	ef 90       	pop	r14
    61c8:	df 90       	pop	r13
    61ca:	cf 90       	pop	r12
    61cc:	bf 90       	pop	r11
    61ce:	af 90       	pop	r10
    61d0:	08 95       	ret

000061d2 <executeSystemStatusTask>:


static portTASK_FUNCTION( executeSystemStatusTask, pvParameters )
{
    61d2:	cf 93       	push	r28
    61d4:	df 93       	push	r29
    61d6:	cd b7       	in	r28, 0x3d	; 61
    61d8:	de b7       	in	r29, 0x3e	; 62
    61da:	28 97       	sbiw	r28, 0x08	; 8
    61dc:	0f b6       	in	r0, 0x3f	; 63
    61de:	f8 94       	cli
    61e0:	de bf       	out	0x3e, r29	; 62
    61e2:	0f be       	out	0x3f, r0	; 63
    61e4:	cd bf       	out	0x3d, r28	; 61
    61e6:	98 87       	std	Y+8, r25	; 0x08
    61e8:	8f 83       	std	Y+7, r24	; 0x07
    uint32_t xLastWakeUpTime;
    uint16_t ledCycleCounter = 0;
    61ea:	1a 82       	std	Y+2, r1	; 0x02
    61ec:	19 82       	std	Y+1, r1	; 0x01
    
    //Initialize the wake up time with the current time
    xLastWakeUpTime = xTaskGetTickCount();
    61ee:	0e 94 76 24 	call	0x48ec	; 0x48ec <xTaskGetTickCount>
    61f2:	cc 01       	movw	r24, r24
    61f4:	a0 e0       	ldi	r26, 0x00	; 0
    61f6:	b0 e0       	ldi	r27, 0x00	; 0
    61f8:	8b 83       	std	Y+3, r24	; 0x03
    61fa:	9c 83       	std	Y+4, r25	; 0x04
    61fc:	ad 83       	std	Y+5, r26	; 0x05
    61fe:	be 83       	std	Y+6, r27	; 0x06
    6200:	01 c0       	rjmp	.+2      	; 0x6204 <executeSystemStatusTask+0x32>
        if( ledCycleCounter > 65000 )
        {
            ledCycleCounter = 0;
        }
       
    }
    6202:	00 00       	nop
    xLastWakeUpTime = xTaskGetTickCount();

    for(;;)
    {
        //Execute this task each 50ms
        vTaskDelayUntil( &xLastWakeUpTime, SYSTEM_STATUS_TASK_CYCLE );
    6204:	ce 01       	movw	r24, r28
    6206:	03 96       	adiw	r24, 0x03	; 3
    6208:	64 e6       	ldi	r22, 0x64	; 100
    620a:	70 e0       	ldi	r23, 0x00	; 0
    620c:	0e 94 e9 22 	call	0x45d2	; 0x45d2 <vTaskDelayUntil>

        ledCycleCounter += 50;
    6210:	89 81       	ldd	r24, Y+1	; 0x01
    6212:	9a 81       	ldd	r25, Y+2	; 0x02
    6214:	c2 96       	adiw	r24, 0x32	; 50
    6216:	9a 83       	std	Y+2, r25	; 0x02
    6218:	89 83       	std	Y+1, r24	; 0x01

        if( prvCheckOtherTasksAreStillRunning() )
    621a:	0e 94 3e 31 	call	0x627c	; 0x627c <prvCheckOtherTasksAreStillRunning>
        {
            //signal error condition
        }

        //toogle the green led each 500ms
        if( ledCycleCounter % GREEN_LED_TOGGLE_CYCLE == 0 )
    621e:	89 81       	ldd	r24, Y+1	; 0x01
    6220:	9a 81       	ldd	r25, Y+2	; 0x02
    6222:	24 ef       	ldi	r18, 0xF4	; 244
    6224:	31 e0       	ldi	r19, 0x01	; 1
    6226:	b9 01       	movw	r22, r18
    6228:	0e 94 54 36 	call	0x6ca8	; 0x6ca8 <__udivmodhi4>
    622c:	00 97       	sbiw	r24, 0x00	; 0
    622e:	51 f4       	brne	.+20     	; 0x6244 <executeSystemStatusTask+0x72>
        {
            PORTB ^= (1<<PB0);
    6230:	85 e2       	ldi	r24, 0x25	; 37
    6232:	90 e0       	ldi	r25, 0x00	; 0
    6234:	25 e2       	ldi	r18, 0x25	; 37
    6236:	30 e0       	ldi	r19, 0x00	; 0
    6238:	f9 01       	movw	r30, r18
    623a:	30 81       	ld	r19, Z
    623c:	21 e0       	ldi	r18, 0x01	; 1
    623e:	23 27       	eor	r18, r19
    6240:	fc 01       	movw	r30, r24
    6242:	20 83       	st	Z, r18
        }
        
        //toogle the red led each 200ms
        if( ledCycleCounter % RED_LED_TOGGLE_CYCLE == 0 )
    6244:	89 81       	ldd	r24, Y+1	; 0x01
    6246:	9a 81       	ldd	r25, Y+2	; 0x02
    6248:	28 ec       	ldi	r18, 0xC8	; 200
    624a:	30 e0       	ldi	r19, 0x00	; 0
    624c:	b9 01       	movw	r22, r18
    624e:	0e 94 54 36 	call	0x6ca8	; 0x6ca8 <__udivmodhi4>
    6252:	00 97       	sbiw	r24, 0x00	; 0
    6254:	51 f4       	brne	.+20     	; 0x626a <executeSystemStatusTask+0x98>
        {
            PORTB ^= (1<<PB1);
    6256:	85 e2       	ldi	r24, 0x25	; 37
    6258:	90 e0       	ldi	r25, 0x00	; 0
    625a:	25 e2       	ldi	r18, 0x25	; 37
    625c:	30 e0       	ldi	r19, 0x00	; 0
    625e:	f9 01       	movw	r30, r18
    6260:	30 81       	ld	r19, Z
    6262:	22 e0       	ldi	r18, 0x02	; 2
    6264:	23 27       	eor	r18, r19
    6266:	fc 01       	movw	r30, r24
    6268:	20 83       	st	Z, r18
        }
        
        
        if( ledCycleCounter > 65000 )
    626a:	89 81       	ldd	r24, Y+1	; 0x01
    626c:	9a 81       	ldd	r25, Y+2	; 0x02
    626e:	fd ef       	ldi	r31, 0xFD	; 253
    6270:	89 3e       	cpi	r24, 0xE9	; 233
    6272:	9f 07       	cpc	r25, r31
    6274:	30 f2       	brcs	.-116    	; 0x6202 <executeSystemStatusTask+0x30>
        {
            ledCycleCounter = 0;
    6276:	1a 82       	std	Y+2, r1	; 0x02
    6278:	19 82       	std	Y+1, r1	; 0x01
        }
       
    }
    627a:	c3 cf       	rjmp	.-122    	; 0x6202 <executeSystemStatusTask+0x30>

0000627c <prvCheckOtherTasksAreStillRunning>:

/*
 * Checks the unique counts of other tasks to ensure they are still operational.
 */
static portBASE_TYPE prvCheckOtherTasksAreStillRunning( void )
{
    627c:	cf 93       	push	r28
    627e:	df 93       	push	r29
    6280:	cd b7       	in	r28, 0x3d	; 61
    6282:	de b7       	in	r29, 0x3e	; 62
    static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xIsSystemControlTaskStillRunning() != pdTRUE )
    6284:	0e 94 8c 30 	call	0x6118	; 0x6118 <xIsSystemControlTaskStillRunning>
    6288:	81 30       	cpi	r24, 0x01	; 1
    628a:	19 f0       	breq	.+6      	; 0x6292 <prvCheckOtherTasksAreStillRunning+0x16>
	{
		xErrorHasOccurred = pdTRUE;
    628c:	81 e0       	ldi	r24, 0x01	; 1
    628e:	80 93 c0 0d 	sts	0x0DC0, r24
	}

	if( xIsUserInterfaceTaskStillRunning() != pdTRUE )
    6292:	0e 94 0b 35 	call	0x6a16	; 0x6a16 <xIsUserInterfaceTaskStillRunning>
    6296:	81 30       	cpi	r24, 0x01	; 1
    6298:	91 05       	cpc	r25, r1
    629a:	19 f0       	breq	.+6      	; 0x62a2 <prvCheckOtherTasksAreStillRunning+0x26>
	{
		xErrorHasOccurred = pdTRUE;
    629c:	81 e0       	ldi	r24, 0x01	; 1
    629e:	80 93 c0 0d 	sts	0x0DC0, r24
	if( xErrorHasOccurred == pdFALSE )
	{
        //signal that everything is ok
	}

    return ( xErrorHasOccurred );
    62a2:	80 91 c0 0d 	lds	r24, 0x0DC0
    62a6:	df 91       	pop	r29
    62a8:	cf 91       	pop	r28
    62aa:	08 95       	ret

000062ac <startUserInterfaceTask>:
   Used to signal an error condition inside this task
*/
static portBASE_TYPE xUiTaskStatus = pdPASS;

void startUserInterfaceTask( unsigned portBASE_TYPE uxPriority, xQueueHandle *measQueue )
{
    62ac:	af 92       	push	r10
    62ae:	bf 92       	push	r11
    62b0:	cf 92       	push	r12
    62b2:	df 92       	push	r13
    62b4:	ef 92       	push	r14
    62b6:	ff 92       	push	r15
    62b8:	0f 93       	push	r16
    62ba:	cf 93       	push	r28
    62bc:	df 93       	push	r29
    62be:	00 d0       	rcall	.+0      	; 0x62c0 <startUserInterfaceTask+0x14>
    62c0:	00 d0       	rcall	.+0      	; 0x62c2 <startUserInterfaceTask+0x16>
    62c2:	0f 92       	push	r0
    62c4:	cd b7       	in	r28, 0x3d	; 61
    62c6:	de b7       	in	r29, 0x3e	; 62
    62c8:	8b 83       	std	Y+3, r24	; 0x03
    62ca:	7d 83       	std	Y+5, r23	; 0x05
    62cc:	6c 83       	std	Y+4, r22	; 0x04
    interfaceTaskParameters *taskParams;
    taskParams = ( interfaceTaskParameters * ) pvPortMalloc( sizeof( interfaceTaskParameters ) );
    62ce:	82 e0       	ldi	r24, 0x02	; 2
    62d0:	90 e0       	ldi	r25, 0x00	; 0
    62d2:	0e 94 64 17 	call	0x2ec8	; 0x2ec8 <pvPortMalloc>
    62d6:	9a 83       	std	Y+2, r25	; 0x02
    62d8:	89 83       	std	Y+1, r24	; 0x01
    taskParams->measurementQueue = *measQueue;
    62da:	8c 81       	ldd	r24, Y+4	; 0x04
    62dc:	9d 81       	ldd	r25, Y+5	; 0x05
    62de:	fc 01       	movw	r30, r24
    62e0:	20 81       	ld	r18, Z
    62e2:	31 81       	ldd	r19, Z+1	; 0x01
    62e4:	89 81       	ldd	r24, Y+1	; 0x01
    62e6:	9a 81       	ldd	r25, Y+2	; 0x02
    62e8:	fc 01       	movw	r30, r24
    62ea:	31 83       	std	Z+1, r19	; 0x01
    62ec:	20 83       	st	Z, r18
    
    xTaskCreate( executeUserInterfaceTask, ( signed char * ) "UiTask", uiTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
    62ee:	88 e9       	ldi	r24, 0x98	; 152
    62f0:	91 e3       	ldi	r25, 0x31	; 49
    62f2:	41 e5       	ldi	r20, 0x51	; 81
    62f4:	51 e0       	ldi	r21, 0x01	; 1
    62f6:	29 81       	ldd	r18, Y+1	; 0x01
    62f8:	3a 81       	ldd	r19, Y+2	; 0x02
    62fa:	ba 01       	movw	r22, r20
    62fc:	48 ec       	ldi	r20, 0xC8	; 200
    62fe:	50 e0       	ldi	r21, 0x00	; 0
    6300:	0b 81       	ldd	r16, Y+3	; 0x03
    6302:	ee 24       	eor	r14, r14
    6304:	ff 24       	eor	r15, r15
    6306:	cc 24       	eor	r12, r12
    6308:	dd 24       	eor	r13, r13
    630a:	aa 24       	eor	r10, r10
    630c:	bb 24       	eor	r11, r11
    630e:	0e 94 99 21 	call	0x4332	; 0x4332 <xTaskGenericCreate>
}
    6312:	0f 90       	pop	r0
    6314:	0f 90       	pop	r0
    6316:	0f 90       	pop	r0
    6318:	0f 90       	pop	r0
    631a:	0f 90       	pop	r0
    631c:	df 91       	pop	r29
    631e:	cf 91       	pop	r28
    6320:	0f 91       	pop	r16
    6322:	ff 90       	pop	r15
    6324:	ef 90       	pop	r14
    6326:	df 90       	pop	r13
    6328:	cf 90       	pop	r12
    632a:	bf 90       	pop	r11
    632c:	af 90       	pop	r10
    632e:	08 95       	ret

00006330 <executeUserInterfaceTask>:


static portTASK_FUNCTION( executeUserInterfaceTask, pvParameters )
{
    6330:	0f 93       	push	r16
    6332:	cf 93       	push	r28
    6334:	df 93       	push	r29
    6336:	cd b7       	in	r28, 0x3d	; 61
    6338:	de b7       	in	r29, 0x3e	; 62
    633a:	6e 97       	sbiw	r28, 0x1e	; 30
    633c:	0f b6       	in	r0, 0x3f	; 63
    633e:	f8 94       	cli
    6340:	de bf       	out	0x3e, r29	; 62
    6342:	0f be       	out	0x3f, r0	; 63
    6344:	cd bf       	out	0x3d, r28	; 61
    6346:	9e 8f       	std	Y+30, r25	; 0x1e
    6348:	8d 8f       	std	Y+29, r24	; 0x1d
    uint32_t xLastWakeUpTime;
    uint8_t currentView = TOPVIEW_CURRENT_MONITOR;
    634a:	8a e0       	ldi	r24, 0x0A	; 10
    634c:	89 83       	std	Y+1, r24	; 0x01
    uint8_t lastView = VIEW_UNDEFINED;
    634e:	8f ef       	ldi	r24, 0xFF	; 255
    6350:	8a 83       	std	Y+2, r24	; 0x02
    
    uint8_t viewButton;
    uint8_t viewButtonDebouncer = 0;
    6352:	1b 82       	std	Y+3, r1	; 0x03
    uint8_t viewButtonPressEvent = 0;
    6354:	1c 82       	std	Y+4, r1	; 0x04
    uint8_t viewButtonHoldEvent = 0;
    6356:	18 8a       	std	Y+16, r1	; 0x10
    
    uint8_t actionButton;
    uint8_t actionButtonDebouncer = 0;
    6358:	1d 82       	std	Y+5, r1	; 0x05
    uint8_t actionButtonPressEvent = 0;
    635a:	1e 82       	std	Y+6, r1	; 0x06
    uint8_t actionButtonHoldEvent = 0;
    635c:	19 8a       	std	Y+17, r1	; 0x11
    
    uint8_t receivedNewMessage = 0;
    635e:	1a 8a       	std	Y+18, r1	; 0x12
    uint8_t measurementValueUpdated = 0;
    6360:	1f 82       	std	Y+7, r1	; 0x07
    
    //the measurement values to be displayed
    uint16_t batteryVoltage = 0;
    6362:	19 86       	std	Y+9, r1	; 0x09
    6364:	18 86       	std	Y+8, r1	; 0x08
    uint16_t solarVoltage = 0;
    6366:	1b 86       	std	Y+11, r1	; 0x0b
    6368:	1a 86       	std	Y+10, r1	; 0x0a
    uint16_t solarCurrent = 0;
    636a:	1d 86       	std	Y+13, r1	; 0x0d
    636c:	1c 86       	std	Y+12, r1	; 0x0c
    uint16_t consumerCurrent = 0;
    636e:	1f 86       	std	Y+15, r1	; 0x0f
    6370:	1e 86       	std	Y+14, r1	; 0x0e
    
    systemControlTaskParameters *taskParams;
    
    //set pins PD2 (action button) & PD3 (view switch button) to inputs 
    //(external pull-ups connected)
    DDRD &= ~( (1<<PD2) | (1<<PD3) );
    6372:	8a e2       	ldi	r24, 0x2A	; 42
    6374:	90 e0       	ldi	r25, 0x00	; 0
    6376:	2a e2       	ldi	r18, 0x2A	; 42
    6378:	30 e0       	ldi	r19, 0x00	; 0
    637a:	f9 01       	movw	r30, r18
    637c:	20 81       	ld	r18, Z
    637e:	23 7f       	andi	r18, 0xF3	; 243
    6380:	fc 01       	movw	r30, r24
    6382:	20 83       	st	Z, r18
    
    taskParams = ( interfaceTaskParameters * ) pvParameters;
    6384:	8d 8d       	ldd	r24, Y+29	; 0x1d
    6386:	9e 8d       	ldd	r25, Y+30	; 0x1e
    6388:	9c 8b       	std	Y+20, r25	; 0x14
    638a:	8b 8b       	std	Y+19, r24	; 0x13
    
    //Initialize the wake up time with the current time
    xLastWakeUpTime = xTaskGetTickCount();
    638c:	0e 94 76 24 	call	0x48ec	; 0x48ec <xTaskGetTickCount>
    6390:	cc 01       	movw	r24, r24
    6392:	a0 e0       	ldi	r26, 0x00	; 0
    6394:	b0 e0       	ldi	r27, 0x00	; 0
    6396:	8f 8b       	std	Y+23, r24	; 0x17
    6398:	98 8f       	std	Y+24, r25	; 0x18
    639a:	a9 8f       	std	Y+25, r26	; 0x19
    639c:	ba 8f       	std	Y+26, r27	; 0x1a
    
    for(;;)
    {
        
        //Execute this task each 15ms
        vTaskDelayUntil( &xLastWakeUpTime, USER_INTERFACE_TASK_CYCLE );
    639e:	ce 01       	movw	r24, r28
    63a0:	47 96       	adiw	r24, 0x17	; 23
    63a2:	6f e0       	ldi	r22, 0x0F	; 15
    63a4:	70 e0       	ldi	r23, 0x00	; 0
    63a6:	0e 94 e9 22 	call	0x45d2	; 0x45d2 <vTaskDelayUntil>
        
        PORTD ^= (1<<PIND7);
    63aa:	8b e2       	ldi	r24, 0x2B	; 43
    63ac:	90 e0       	ldi	r25, 0x00	; 0
    63ae:	2b e2       	ldi	r18, 0x2B	; 43
    63b0:	30 e0       	ldi	r19, 0x00	; 0
    63b2:	f9 01       	movw	r30, r18
    63b4:	30 81       	ld	r19, Z
    63b6:	20 e8       	ldi	r18, 0x80	; 128
    63b8:	23 27       	eor	r18, r19
    63ba:	fc 01       	movw	r30, r24
    63bc:	20 83       	st	Z, r18
        
        //check if there are new items to read in the measurement value queue
        receivedNewMessage = xQueueReceive( taskParams->measurementQueue, &( measurementMsg ), ( portTickType ) 10 );
    63be:	8b 89       	ldd	r24, Y+19	; 0x13
    63c0:	9c 89       	ldd	r25, Y+20	; 0x14
    63c2:	fc 01       	movw	r30, r24
    63c4:	80 81       	ld	r24, Z
    63c6:	91 81       	ldd	r25, Z+1	; 0x01
    63c8:	9e 01       	movw	r18, r28
    63ca:	25 5e       	subi	r18, 0xE5	; 229
    63cc:	3f 4f       	sbci	r19, 0xFF	; 255
    63ce:	b9 01       	movw	r22, r18
    63d0:	2a e0       	ldi	r18, 0x0A	; 10
    63d2:	30 e0       	ldi	r19, 0x00	; 0
    63d4:	40 e0       	ldi	r20, 0x00	; 0
    63d6:	50 e0       	ldi	r21, 0x00	; 0
    63d8:	00 e0       	ldi	r16, 0x00	; 0
    63da:	0e 94 37 1e 	call	0x3c6e	; 0x3c6e <xQueueGenericReceive>
    63de:	8a 8b       	std	Y+18, r24	; 0x12
        
        //if a queue element has been successfully received -> evaluate message type and update display value      
        if( receivedNewMessage )
    63e0:	8a 89       	ldd	r24, Y+18	; 0x12
    63e2:	88 23       	and	r24, r24
    63e4:	09 f4       	brne	.+2      	; 0x63e8 <executeUserInterfaceTask+0xb8>
    63e6:	40 c0       	rjmp	.+128    	; 0x6468 <executeUserInterfaceTask+0x138>
        {
            if( measurementMsg->valueId == ID_BATTERY_VOLTAGE )
    63e8:	8b 8d       	ldd	r24, Y+27	; 0x1b
    63ea:	9c 8d       	ldd	r25, Y+28	; 0x1c
    63ec:	fc 01       	movw	r30, r24
    63ee:	80 81       	ld	r24, Z
    63f0:	91 81       	ldd	r25, Z+1	; 0x01
    63f2:	00 97       	sbiw	r24, 0x00	; 0
    63f4:	41 f4       	brne	.+16     	; 0x6406 <executeUserInterfaceTask+0xd6>
            {
                batteryVoltage = measurementMsg->value;
    63f6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    63f8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    63fa:	fc 01       	movw	r30, r24
    63fc:	82 81       	ldd	r24, Z+2	; 0x02
    63fe:	93 81       	ldd	r25, Z+3	; 0x03
    6400:	99 87       	std	Y+9, r25	; 0x09
    6402:	88 87       	std	Y+8, r24	; 0x08
    6404:	2f c0       	rjmp	.+94     	; 0x6464 <executeUserInterfaceTask+0x134>
            }
            else if( measurementMsg->valueId == ID_SOLAR_VOLTAGE )
    6406:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6408:	9c 8d       	ldd	r25, Y+28	; 0x1c
    640a:	fc 01       	movw	r30, r24
    640c:	80 81       	ld	r24, Z
    640e:	91 81       	ldd	r25, Z+1	; 0x01
    6410:	81 30       	cpi	r24, 0x01	; 1
    6412:	91 05       	cpc	r25, r1
    6414:	41 f4       	brne	.+16     	; 0x6426 <executeUserInterfaceTask+0xf6>
            {
                solarVoltage = measurementMsg->value;
    6416:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6418:	9c 8d       	ldd	r25, Y+28	; 0x1c
    641a:	fc 01       	movw	r30, r24
    641c:	82 81       	ldd	r24, Z+2	; 0x02
    641e:	93 81       	ldd	r25, Z+3	; 0x03
    6420:	9b 87       	std	Y+11, r25	; 0x0b
    6422:	8a 87       	std	Y+10, r24	; 0x0a
    6424:	1f c0       	rjmp	.+62     	; 0x6464 <executeUserInterfaceTask+0x134>
            }
            else if( measurementMsg->valueId == ID_SOLAR_CURRENT )
    6426:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6428:	9c 8d       	ldd	r25, Y+28	; 0x1c
    642a:	fc 01       	movw	r30, r24
    642c:	80 81       	ld	r24, Z
    642e:	91 81       	ldd	r25, Z+1	; 0x01
    6430:	82 30       	cpi	r24, 0x02	; 2
    6432:	91 05       	cpc	r25, r1
    6434:	41 f4       	brne	.+16     	; 0x6446 <executeUserInterfaceTask+0x116>
            {
                solarCurrent = measurementMsg->value;
    6436:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6438:	9c 8d       	ldd	r25, Y+28	; 0x1c
    643a:	fc 01       	movw	r30, r24
    643c:	82 81       	ldd	r24, Z+2	; 0x02
    643e:	93 81       	ldd	r25, Z+3	; 0x03
    6440:	9d 87       	std	Y+13, r25	; 0x0d
    6442:	8c 87       	std	Y+12, r24	; 0x0c
    6444:	0f c0       	rjmp	.+30     	; 0x6464 <executeUserInterfaceTask+0x134>
            }
            else if( measurementMsg->valueId == ID_CONSUMER_CURRENT )
    6446:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6448:	9c 8d       	ldd	r25, Y+28	; 0x1c
    644a:	fc 01       	movw	r30, r24
    644c:	80 81       	ld	r24, Z
    644e:	91 81       	ldd	r25, Z+1	; 0x01
    6450:	83 30       	cpi	r24, 0x03	; 3
    6452:	91 05       	cpc	r25, r1
    6454:	39 f4       	brne	.+14     	; 0x6464 <executeUserInterfaceTask+0x134>
            {
                consumerCurrent = measurementMsg->value;
    6456:	8b 8d       	ldd	r24, Y+27	; 0x1b
    6458:	9c 8d       	ldd	r25, Y+28	; 0x1c
    645a:	fc 01       	movw	r30, r24
    645c:	82 81       	ldd	r24, Z+2	; 0x02
    645e:	93 81       	ldd	r25, Z+3	; 0x03
    6460:	9f 87       	std	Y+15, r25	; 0x0f
    6462:	8e 87       	std	Y+14, r24	; 0x0e
            }
            measurementValueUpdated = 1;
    6464:	81 e0       	ldi	r24, 0x01	; 1
    6466:	8f 83       	std	Y+7, r24	; 0x07
        }
       
        //read state of input buttons
        viewButton = READ_VIEWBUTTON;
    6468:	89 e2       	ldi	r24, 0x29	; 41
    646a:	90 e0       	ldi	r25, 0x00	; 0
    646c:	fc 01       	movw	r30, r24
    646e:	80 81       	ld	r24, Z
    6470:	88 2f       	mov	r24, r24
    6472:	90 e0       	ldi	r25, 0x00	; 0
    6474:	84 70       	andi	r24, 0x04	; 4
    6476:	90 70       	andi	r25, 0x00	; 0
    6478:	95 95       	asr	r25
    647a:	87 95       	ror	r24
    647c:	95 95       	asr	r25
    647e:	87 95       	ror	r24
    6480:	8d 8b       	std	Y+21, r24	; 0x15
        actionButton = READ_ACTIONBUTTON;
    6482:	89 e2       	ldi	r24, 0x29	; 41
    6484:	90 e0       	ldi	r25, 0x00	; 0
    6486:	fc 01       	movw	r30, r24
    6488:	80 81       	ld	r24, Z
    648a:	88 2f       	mov	r24, r24
    648c:	90 e0       	ldi	r25, 0x00	; 0
    648e:	88 70       	andi	r24, 0x08	; 8
    6490:	90 70       	andi	r25, 0x00	; 0
    6492:	95 95       	asr	r25
    6494:	87 95       	ror	r24
    6496:	95 95       	asr	r25
    6498:	87 95       	ror	r24
    649a:	95 95       	asr	r25
    649c:	87 95       	ror	r24
    649e:	8e 8b       	std	Y+22, r24	; 0x16
        
        //************************************************************************************************
        //-> debounce handler for view button
        //debounce buttons for ~45ms (3 task calls)
        if( viewButton == BUTTON_PRESSED && viewButtonDebouncer < 3 )
    64a0:	8d 89       	ldd	r24, Y+21	; 0x15
    64a2:	88 23       	and	r24, r24
    64a4:	41 f4       	brne	.+16     	; 0x64b6 <executeUserInterfaceTask+0x186>
    64a6:	8b 81       	ldd	r24, Y+3	; 0x03
    64a8:	83 30       	cpi	r24, 0x03	; 3
    64aa:	28 f4       	brcc	.+10     	; 0x64b6 <executeUserInterfaceTask+0x186>
        {
            //button pressed -> debounce in progress
            viewButtonDebouncer++;
    64ac:	8b 81       	ldd	r24, Y+3	; 0x03
    64ae:	8f 5f       	subi	r24, 0xFF	; 255
    64b0:	8b 83       	std	Y+3, r24	; 0x03
            viewButtonPressEvent = 0;
    64b2:	1c 82       	std	Y+4, r1	; 0x04
    64b4:	29 c0       	rjmp	.+82     	; 0x6508 <executeUserInterfaceTask+0x1d8>
        }
        else if( viewButton == BUTTON_PRESSED && viewButtonDebouncer == 3 )
    64b6:	8d 89       	ldd	r24, Y+21	; 0x15
    64b8:	88 23       	and	r24, r24
    64ba:	49 f4       	brne	.+18     	; 0x64ce <executeUserInterfaceTask+0x19e>
    64bc:	8b 81       	ldd	r24, Y+3	; 0x03
    64be:	83 30       	cpi	r24, 0x03	; 3
    64c0:	31 f4       	brne	.+12     	; 0x64ce <executeUserInterfaceTask+0x19e>
        {
            //button still pressed and debouncing finished
            viewButtonDebouncer++;
    64c2:	8b 81       	ldd	r24, Y+3	; 0x03
    64c4:	8f 5f       	subi	r24, 0xFF	; 255
    64c6:	8b 83       	std	Y+3, r24	; 0x03
            viewButtonPressEvent = 1;                            
    64c8:	81 e0       	ldi	r24, 0x01	; 1
    64ca:	8c 83       	std	Y+4, r24	; 0x04
    64cc:	1d c0       	rjmp	.+58     	; 0x6508 <executeUserInterfaceTask+0x1d8>
        }                    
        else if( viewButton == BUTTON_PRESSED && viewButtonDebouncer >=3 && viewButtonDebouncer < 134 )
    64ce:	8d 89       	ldd	r24, Y+21	; 0x15
    64d0:	88 23       	and	r24, r24
    64d2:	59 f4       	brne	.+22     	; 0x64ea <executeUserInterfaceTask+0x1ba>
    64d4:	8b 81       	ldd	r24, Y+3	; 0x03
    64d6:	83 30       	cpi	r24, 0x03	; 3
    64d8:	40 f0       	brcs	.+16     	; 0x64ea <executeUserInterfaceTask+0x1ba>
    64da:	8b 81       	ldd	r24, Y+3	; 0x03
    64dc:	86 38       	cpi	r24, 0x86	; 134
    64de:	28 f4       	brcc	.+10     	; 0x64ea <executeUserInterfaceTask+0x1ba>
        {
            //single press event finished -> check for button hold
            viewButtonDebouncer++;
    64e0:	8b 81       	ldd	r24, Y+3	; 0x03
    64e2:	8f 5f       	subi	r24, 0xFF	; 255
    64e4:	8b 83       	std	Y+3, r24	; 0x03
            viewButtonPressEvent = 0;
    64e6:	1c 82       	std	Y+4, r1	; 0x04
    64e8:	0f c0       	rjmp	.+30     	; 0x6508 <executeUserInterfaceTask+0x1d8>
        }
        else if( viewButton == BUTTON_PRESSED && viewButtonDebouncer >= 134 )
    64ea:	8d 89       	ldd	r24, Y+21	; 0x15
    64ec:	88 23       	and	r24, r24
    64ee:	31 f4       	brne	.+12     	; 0x64fc <executeUserInterfaceTask+0x1cc>
    64f0:	8b 81       	ldd	r24, Y+3	; 0x03
    64f2:	86 38       	cpi	r24, 0x86	; 134
    64f4:	18 f0       	brcs	.+6      	; 0x64fc <executeUserInterfaceTask+0x1cc>
        {
            viewButtonHoldEvent = 1;
    64f6:	81 e0       	ldi	r24, 0x01	; 1
    64f8:	88 8b       	std	Y+16, r24	; 0x10
    64fa:	06 c0       	rjmp	.+12     	; 0x6508 <executeUserInterfaceTask+0x1d8>
        }        
        else if( viewButton == BUTTON_RELEASED )
    64fc:	8d 89       	ldd	r24, Y+21	; 0x15
    64fe:	81 30       	cpi	r24, 0x01	; 1
    6500:	19 f4       	brne	.+6      	; 0x6508 <executeUserInterfaceTask+0x1d8>
        {
            //button has been released or bounced
            viewButtonDebouncer = 0;
    6502:	1b 82       	std	Y+3, r1	; 0x03
            viewButtonPressEvent = 0;
    6504:	1c 82       	std	Y+4, r1	; 0x04
            viewButtonHoldEvent = 0;
    6506:	18 8a       	std	Y+16, r1	; 0x10
        

        //************************************************************************************************
        //-> debounce handler for action button   
        //debounce buttons for ~45ms (3 task calls)
        if( actionButton == BUTTON_PRESSED && actionButtonDebouncer < 3 )
    6508:	8e 89       	ldd	r24, Y+22	; 0x16
    650a:	88 23       	and	r24, r24
    650c:	41 f4       	brne	.+16     	; 0x651e <executeUserInterfaceTask+0x1ee>
    650e:	8d 81       	ldd	r24, Y+5	; 0x05
    6510:	83 30       	cpi	r24, 0x03	; 3
    6512:	28 f4       	brcc	.+10     	; 0x651e <executeUserInterfaceTask+0x1ee>
        {
            //button pressed -> debounce in progress
            actionButtonDebouncer++;
    6514:	8d 81       	ldd	r24, Y+5	; 0x05
    6516:	8f 5f       	subi	r24, 0xFF	; 255
    6518:	8d 83       	std	Y+5, r24	; 0x05
            actionButtonPressEvent = 0;
    651a:	1e 82       	std	Y+6, r1	; 0x06
    651c:	29 c0       	rjmp	.+82     	; 0x6570 <executeUserInterfaceTask+0x240>
        }
        else if( actionButton == BUTTON_PRESSED && actionButtonDebouncer == 3 )
    651e:	8e 89       	ldd	r24, Y+22	; 0x16
    6520:	88 23       	and	r24, r24
    6522:	49 f4       	brne	.+18     	; 0x6536 <executeUserInterfaceTask+0x206>
    6524:	8d 81       	ldd	r24, Y+5	; 0x05
    6526:	83 30       	cpi	r24, 0x03	; 3
    6528:	31 f4       	brne	.+12     	; 0x6536 <executeUserInterfaceTask+0x206>
        {
            //button still pressed and debouncing finished
            actionButtonDebouncer++;
    652a:	8d 81       	ldd	r24, Y+5	; 0x05
    652c:	8f 5f       	subi	r24, 0xFF	; 255
    652e:	8d 83       	std	Y+5, r24	; 0x05
            actionButtonPressEvent = 1;
    6530:	81 e0       	ldi	r24, 0x01	; 1
    6532:	8e 83       	std	Y+6, r24	; 0x06
    6534:	1d c0       	rjmp	.+58     	; 0x6570 <executeUserInterfaceTask+0x240>
        }
        else if( actionButton == BUTTON_PRESSED && actionButtonDebouncer >=3 && actionButtonDebouncer < 134 )
    6536:	8e 89       	ldd	r24, Y+22	; 0x16
    6538:	88 23       	and	r24, r24
    653a:	59 f4       	brne	.+22     	; 0x6552 <executeUserInterfaceTask+0x222>
    653c:	8d 81       	ldd	r24, Y+5	; 0x05
    653e:	83 30       	cpi	r24, 0x03	; 3
    6540:	40 f0       	brcs	.+16     	; 0x6552 <executeUserInterfaceTask+0x222>
    6542:	8d 81       	ldd	r24, Y+5	; 0x05
    6544:	86 38       	cpi	r24, 0x86	; 134
    6546:	28 f4       	brcc	.+10     	; 0x6552 <executeUserInterfaceTask+0x222>
        {
            //single press event finished -> check for button hold
            actionButtonDebouncer++;
    6548:	8d 81       	ldd	r24, Y+5	; 0x05
    654a:	8f 5f       	subi	r24, 0xFF	; 255
    654c:	8d 83       	std	Y+5, r24	; 0x05
            actionButtonPressEvent = 0;
    654e:	1e 82       	std	Y+6, r1	; 0x06
    6550:	0f c0       	rjmp	.+30     	; 0x6570 <executeUserInterfaceTask+0x240>
        }
        else if( actionButton == BUTTON_PRESSED && actionButtonDebouncer >= 134 )
    6552:	8e 89       	ldd	r24, Y+22	; 0x16
    6554:	88 23       	and	r24, r24
    6556:	31 f4       	brne	.+12     	; 0x6564 <executeUserInterfaceTask+0x234>
    6558:	8d 81       	ldd	r24, Y+5	; 0x05
    655a:	86 38       	cpi	r24, 0x86	; 134
    655c:	18 f0       	brcs	.+6      	; 0x6564 <executeUserInterfaceTask+0x234>
        {
            actionButtonHoldEvent = 1;
    655e:	81 e0       	ldi	r24, 0x01	; 1
    6560:	89 8b       	std	Y+17, r24	; 0x11
    6562:	06 c0       	rjmp	.+12     	; 0x6570 <executeUserInterfaceTask+0x240>
        }
        else if( actionButton == BUTTON_RELEASED )
    6564:	8e 89       	ldd	r24, Y+22	; 0x16
    6566:	81 30       	cpi	r24, 0x01	; 1
    6568:	19 f4       	brne	.+6      	; 0x6570 <executeUserInterfaceTask+0x240>
        {
            //button has been released or bounced
            actionButtonDebouncer = 0;
    656a:	1d 82       	std	Y+5, r1	; 0x05
            actionButtonPressEvent = 0;
    656c:	1e 82       	std	Y+6, r1	; 0x06
            actionButtonHoldEvent = 0;
    656e:	19 8a       	std	Y+17, r1	; 0x11
        
        //************************************************************************************************
        //-> display screen handler       
                                        
        //evaluate button events and update display state
        if( viewButtonPressEvent  )
    6570:	8c 81       	ldd	r24, Y+4	; 0x04
    6572:	88 23       	and	r24, r24
    6574:	c1 f0       	breq	.+48     	; 0x65a6 <executeUserInterfaceTask+0x276>
        {
            if( IS_TOP_VIEW( currentView ) )
    6576:	89 81       	ldd	r24, Y+1	; 0x01
    6578:	9a e0       	ldi	r25, 0x0A	; 10
    657a:	69 2f       	mov	r22, r25
    657c:	0e 94 48 36 	call	0x6c90	; 0x6c90 <__udivmodqi4>
    6580:	89 2f       	mov	r24, r25
    6582:	88 2f       	mov	r24, r24
    6584:	90 e0       	ldi	r25, 0x00	; 0
    6586:	81 70       	andi	r24, 0x01	; 1
    6588:	90 70       	andi	r25, 0x00	; 0
    658a:	00 97       	sbiw	r24, 0x00	; 0
    658c:	39 f4       	brne	.+14     	; 0x659c <executeUserInterfaceTask+0x26c>
            {
                // special handling for switchOff top view
                //-> send controller into sleep mode
                if( currentView == TOPVIEW_SWITCH_OFF )
    658e:	89 81       	ldd	r24, Y+1	; 0x01
    6590:	8c 33       	cpi	r24, 0x3C	; 60
    6592:	39 f0       	breq	.+14     	; 0x65a2 <executeUserInterfaceTask+0x272>
                {
                    //TODO: enable sleep mode
                }
                else
                {
                    currentView++;
    6594:	89 81       	ldd	r24, Y+1	; 0x01
    6596:	8f 5f       	subi	r24, 0xFF	; 255
    6598:	89 83       	std	Y+1, r24	; 0x01
    659a:	03 c0       	rjmp	.+6      	; 0x65a2 <executeUserInterfaceTask+0x272>
                }                
            }
            else
            {
                currentView--;
    659c:	89 81       	ldd	r24, Y+1	; 0x01
    659e:	81 50       	subi	r24, 0x01	; 1
    65a0:	89 83       	std	Y+1, r24	; 0x01
            }
            lcd_clear_all();
    65a2:	0e 94 86 0b 	call	0x170c	; 0x170c <lcd_clear_all>
        }
        
        if( actionButtonPressEvent )
    65a6:	8e 81       	ldd	r24, Y+6	; 0x06
    65a8:	88 23       	and	r24, r24
    65aa:	a9 f0       	breq	.+42     	; 0x65d6 <executeUserInterfaceTask+0x2a6>
        {
            if( IS_TOP_VIEW( currentView ) )
    65ac:	89 81       	ldd	r24, Y+1	; 0x01
    65ae:	9a e0       	ldi	r25, 0x0A	; 10
    65b0:	69 2f       	mov	r22, r25
    65b2:	0e 94 48 36 	call	0x6c90	; 0x6c90 <__udivmodqi4>
    65b6:	89 2f       	mov	r24, r25
    65b8:	88 2f       	mov	r24, r24
    65ba:	90 e0       	ldi	r25, 0x00	; 0
    65bc:	81 70       	andi	r24, 0x01	; 1
    65be:	90 70       	andi	r25, 0x00	; 0
    65c0:	00 97       	sbiw	r24, 0x00	; 0
    65c2:	49 f4       	brne	.+18     	; 0x65d6 <executeUserInterfaceTask+0x2a6>
            {
                if( currentView == TOPVIEW_SWITCH_OFF )
    65c4:	89 81       	ldd	r24, Y+1	; 0x01
    65c6:	8c 33       	cpi	r24, 0x3C	; 60
    65c8:	19 f4       	brne	.+6      	; 0x65d0 <executeUserInterfaceTask+0x2a0>
                {
                    currentView = TOPVIEW_CURRENT_MONITOR;
    65ca:	8a e0       	ldi	r24, 0x0A	; 10
    65cc:	89 83       	std	Y+1, r24	; 0x01
    65ce:	03 c0       	rjmp	.+6      	; 0x65d6 <executeUserInterfaceTask+0x2a6>
                }
                else
                {
                    currentView += 10;
    65d0:	89 81       	ldd	r24, Y+1	; 0x01
    65d2:	86 5f       	subi	r24, 0xF6	; 246
    65d4:	89 83       	std	Y+1, r24	; 0x01
                }                
            }
        }        
                        
        //draw this only if the current view is a top view and the last view was a detail view
        if( ( currentView % 10 == 0 && lastView % 10 != 0) || ( lastView == TOPVIEW_SWITCH_OFF && currentView != TOPVIEW_SWITCH_OFF ) )
    65d6:	89 81       	ldd	r24, Y+1	; 0x01
    65d8:	9a e0       	ldi	r25, 0x0A	; 10
    65da:	69 2f       	mov	r22, r25
    65dc:	0e 94 48 36 	call	0x6c90	; 0x6c90 <__udivmodqi4>
    65e0:	89 2f       	mov	r24, r25
    65e2:	88 23       	and	r24, r24
    65e4:	41 f4       	brne	.+16     	; 0x65f6 <executeUserInterfaceTask+0x2c6>
    65e6:	8a 81       	ldd	r24, Y+2	; 0x02
    65e8:	9a e0       	ldi	r25, 0x0A	; 10
    65ea:	69 2f       	mov	r22, r25
    65ec:	0e 94 48 36 	call	0x6c90	; 0x6c90 <__udivmodqi4>
    65f0:	89 2f       	mov	r24, r25
    65f2:	88 23       	and	r24, r24
    65f4:	31 f4       	brne	.+12     	; 0x6602 <executeUserInterfaceTask+0x2d2>
    65f6:	8a 81       	ldd	r24, Y+2	; 0x02
    65f8:	8c 33       	cpi	r24, 0x3C	; 60
    65fa:	c1 f5       	brne	.+112    	; 0x666c <executeUserInterfaceTask+0x33c>
    65fc:	89 81       	ldd	r24, Y+1	; 0x01
    65fe:	8c 33       	cpi	r24, 0x3C	; 60
    6600:	a9 f1       	breq	.+106    	; 0x666c <executeUserInterfaceTask+0x33c>
        {
            lcd_set_font( FONT_FIXED_8, NORMAL );
    6602:	8c e8       	ldi	r24, 0x8C	; 140
    6604:	96 e0       	ldi	r25, 0x06	; 6
    6606:	60 e0       	ldi	r22, 0x00	; 0
    6608:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <lcd_set_font>
            lcd_moveto_xy  ( 0, 80 );
    660c:	80 e0       	ldi	r24, 0x00	; 0
    660e:	60 e5       	ldi	r22, 0x50	; 80
    6610:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
            lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("* next-> "));
    6614:	29 e9       	ldi	r18, 0x99	; 153
    6616:	3d e0       	ldi	r19, 0x0D	; 13
    6618:	8c e8       	ldi	r24, 0x8C	; 140
    661a:	96 e0       	ldi	r25, 0x06	; 6
    661c:	60 e0       	ldi	r22, 0x00	; 0
    661e:	a9 01       	movw	r20, r18
    6620:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
            lcd_moveto_xy  ( 1, 80 );
    6624:	81 e0       	ldi	r24, 0x01	; 1
    6626:	60 e5       	ldi	r22, 0x50	; 80
    6628:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
            lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("*        "));
    662c:	23 ea       	ldi	r18, 0xA3	; 163
    662e:	3d e0       	ldi	r19, 0x0D	; 13
    6630:	8c e8       	ldi	r24, 0x8C	; 140
    6632:	96 e0       	ldi	r25, 0x06	; 6
    6634:	60 e0       	ldi	r22, 0x00	; 0
    6636:	a9 01       	movw	r20, r18
    6638:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
            lcd_moveto_xy  ( 2, 80 );
    663c:	82 e0       	ldi	r24, 0x02	; 2
    663e:	60 e5       	ldi	r22, 0x50	; 80
    6640:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
            lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("*        "));
    6644:	2d ea       	ldi	r18, 0xAD	; 173
    6646:	3d e0       	ldi	r19, 0x0D	; 13
    6648:	8c e8       	ldi	r24, 0x8C	; 140
    664a:	96 e0       	ldi	r25, 0x06	; 6
    664c:	60 e0       	ldi	r22, 0x00	; 0
    664e:	a9 01       	movw	r20, r18
    6650:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
            lcd_moveto_xy  ( 3, 80 );
    6654:	83 e0       	ldi	r24, 0x03	; 3
    6656:	60 e5       	ldi	r22, 0x50	; 80
    6658:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
            lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("* detail "));
    665c:	27 eb       	ldi	r18, 0xB7	; 183
    665e:	3d e0       	ldi	r19, 0x0D	; 13
    6660:	8c e8       	ldi	r24, 0x8C	; 140
    6662:	96 e0       	ldi	r25, 0x06	; 6
    6664:	60 e0       	ldi	r22, 0x00	; 0
    6666:	a9 01       	movw	r20, r18
    6668:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
        }
       
       
        //manage display output for current view
        switch( currentView )
    666c:	89 81       	ldd	r24, Y+1	; 0x01
    666e:	88 2f       	mov	r24, r24
    6670:	90 e0       	ldi	r25, 0x00	; 0
    6672:	8e 31       	cpi	r24, 0x1E	; 30
    6674:	91 05       	cpc	r25, r1
    6676:	09 f4       	brne	.+2      	; 0x667a <executeUserInterfaceTask+0x34a>
    6678:	f9 c0       	rjmp	.+498    	; 0x686c <executeUserInterfaceTask+0x53c>
    667a:	8f 31       	cpi	r24, 0x1F	; 31
    667c:	91 05       	cpc	r25, r1
    667e:	bc f4       	brge	.+46     	; 0x66ae <executeUserInterfaceTask+0x37e>
    6680:	8b 30       	cpi	r24, 0x0B	; 11
    6682:	91 05       	cpc	r25, r1
    6684:	09 f4       	brne	.+2      	; 0x6688 <executeUserInterfaceTask+0x358>
    6686:	47 c0       	rjmp	.+142    	; 0x6716 <executeUserInterfaceTask+0x3e6>
    6688:	8c 30       	cpi	r24, 0x0C	; 12
    668a:	91 05       	cpc	r25, r1
    668c:	3c f4       	brge	.+14     	; 0x669c <executeUserInterfaceTask+0x36c>
    668e:	00 97       	sbiw	r24, 0x00	; 0
    6690:	09 f4       	brne	.+2      	; 0x6694 <executeUserInterfaceTask+0x364>
    6692:	a6 c1       	rjmp	.+844    	; 0x69e0 <executeUserInterfaceTask+0x6b0>
    6694:	8a 30       	cpi	r24, 0x0A	; 10
    6696:	91 05       	cpc	r25, r1
    6698:	39 f1       	breq	.+78     	; 0x66e8 <executeUserInterfaceTask+0x3b8>
    669a:	b9 c1       	rjmp	.+882    	; 0x6a0e <executeUserInterfaceTask+0x6de>
    669c:	84 31       	cpi	r24, 0x14	; 20
    669e:	91 05       	cpc	r25, r1
    66a0:	09 f4       	brne	.+2      	; 0x66a4 <executeUserInterfaceTask+0x374>
    66a2:	83 c0       	rjmp	.+262    	; 0x67aa <executeUserInterfaceTask+0x47a>
    66a4:	85 31       	cpi	r24, 0x15	; 21
    66a6:	91 05       	cpc	r25, r1
    66a8:	09 f4       	brne	.+2      	; 0x66ac <executeUserInterfaceTask+0x37c>
    66aa:	96 c0       	rjmp	.+300    	; 0x67d8 <executeUserInterfaceTask+0x4a8>
    66ac:	b0 c1       	rjmp	.+864    	; 0x6a0e <executeUserInterfaceTask+0x6de>
    66ae:	89 32       	cpi	r24, 0x29	; 41
    66b0:	91 05       	cpc	r25, r1
    66b2:	09 f4       	brne	.+2      	; 0x66b6 <executeUserInterfaceTask+0x386>
    66b4:	23 c1       	rjmp	.+582    	; 0x68fc <executeUserInterfaceTask+0x5cc>
    66b6:	8a 32       	cpi	r24, 0x2A	; 42
    66b8:	91 05       	cpc	r25, r1
    66ba:	4c f4       	brge	.+18     	; 0x66ce <executeUserInterfaceTask+0x39e>
    66bc:	8f 31       	cpi	r24, 0x1F	; 31
    66be:	91 05       	cpc	r25, r1
    66c0:	09 f4       	brne	.+2      	; 0x66c4 <executeUserInterfaceTask+0x394>
    66c2:	eb c0       	rjmp	.+470    	; 0x689a <executeUserInterfaceTask+0x56a>
    66c4:	88 32       	cpi	r24, 0x28	; 40
    66c6:	91 05       	cpc	r25, r1
    66c8:	09 f4       	brne	.+2      	; 0x66cc <executeUserInterfaceTask+0x39c>
    66ca:	01 c1       	rjmp	.+514    	; 0x68ce <executeUserInterfaceTask+0x59e>
    66cc:	a0 c1       	rjmp	.+832    	; 0x6a0e <executeUserInterfaceTask+0x6de>
    66ce:	83 33       	cpi	r24, 0x33	; 51
    66d0:	91 05       	cpc	r25, r1
    66d2:	09 f4       	brne	.+2      	; 0x66d6 <executeUserInterfaceTask+0x3a6>
    66d4:	44 c1       	rjmp	.+648    	; 0x695e <executeUserInterfaceTask+0x62e>
    66d6:	8c 33       	cpi	r24, 0x3C	; 60
    66d8:	91 05       	cpc	r25, r1
    66da:	09 f4       	brne	.+2      	; 0x66de <executeUserInterfaceTask+0x3ae>
    66dc:	5a c1       	rjmp	.+692    	; 0x6992 <executeUserInterfaceTask+0x662>
    66de:	82 33       	cpi	r24, 0x32	; 50
    66e0:	91 05       	cpc	r25, r1
    66e2:	09 f4       	brne	.+2      	; 0x66e6 <executeUserInterfaceTask+0x3b6>
    66e4:	25 c1       	rjmp	.+586    	; 0x6930 <executeUserInterfaceTask+0x600>
    66e6:	93 c1       	rjmp	.+806    	; 0x6a0e <executeUserInterfaceTask+0x6de>
            {
                break;
            }
            case TOPVIEW_CURRENT_MONITOR:
            {
                if( currentView != lastView )
    66e8:	99 81       	ldd	r25, Y+1	; 0x01
    66ea:	8a 81       	ldd	r24, Y+2	; 0x02
    66ec:	98 17       	cp	r25, r24
    66ee:	09 f4       	brne	.+2      	; 0x66f2 <executeUserInterfaceTask+0x3c2>
    66f0:	79 c1       	rjmp	.+754    	; 0x69e4 <executeUserInterfaceTask+0x6b4>
                {
                    lcd_set_font( FONT_PROP_16, NORMAL );
    66f2:	8f e8       	ldi	r24, 0x8F	; 143
    66f4:	9d e0       	ldi	r25, 0x0D	; 13
    66f6:	60 e0       	ldi	r22, 0x00	; 0
    66f8:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <lcd_set_font>
                    lcd_moveto_xy  ( 1, 0 );
    66fc:	81 e0       	ldi	r24, 0x01	; 1
    66fe:	60 e0       	ldi	r22, 0x00	; 0
    6700:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
                    lcd_put_string_P( FONT_PROP_16, NORMAL, PSTR("CurrentMon"));
    6704:	21 ec       	ldi	r18, 0xC1	; 193
    6706:	3d e0       	ldi	r19, 0x0D	; 13
    6708:	8f e8       	ldi	r24, 0x8F	; 143
    670a:	9d e0       	ldi	r25, 0x0D	; 13
    670c:	60 e0       	ldi	r22, 0x00	; 0
    670e:	a9 01       	movw	r20, r18
    6710:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                }     
                break;                
    6714:	67 c1       	rjmp	.+718    	; 0x69e4 <executeUserInterfaceTask+0x6b4>
            }     
            case DETAILVIEW_CURRENT_MONITOR:
            {
                if( currentView != lastView || measurementValueUpdated )
    6716:	99 81       	ldd	r25, Y+1	; 0x01
    6718:	8a 81       	ldd	r24, Y+2	; 0x02
    671a:	98 17       	cp	r25, r24
    671c:	21 f4       	brne	.+8      	; 0x6726 <executeUserInterfaceTask+0x3f6>
    671e:	8f 81       	ldd	r24, Y+7	; 0x07
    6720:	88 23       	and	r24, r24
    6722:	09 f4       	brne	.+2      	; 0x6726 <executeUserInterfaceTask+0x3f6>
    6724:	61 c1       	rjmp	.+706    	; 0x69e8 <executeUserInterfaceTask+0x6b8>
                {
                    lcd_set_font( FONT_FIXED_8, NORMAL );
    6726:	8c e8       	ldi	r24, 0x8C	; 140
    6728:	96 e0       	ldi	r25, 0x06	; 6
    672a:	60 e0       	ldi	r22, 0x00	; 0
    672c:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <lcd_set_font>
                    lcd_moveto_xy  ( 0, 0 );
    6730:	80 e0       	ldi	r24, 0x00	; 0
    6732:	60 e0       	ldi	r22, 0x00	; 0
    6734:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("Current Monitor:"));
    6738:	2c ec       	ldi	r18, 0xCC	; 204
    673a:	3d e0       	ldi	r19, 0x0D	; 13
    673c:	8c e8       	ldi	r24, 0x8C	; 140
    673e:	96 e0       	ldi	r25, 0x06	; 6
    6740:	60 e0       	ldi	r22, 0x00	; 0
    6742:	a9 01       	movw	r20, r18
    6744:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                    lcd_moveto_xy  ( 2, 0 );
    6748:	82 e0       	ldi	r24, 0x02	; 2
    674a:	60 e0       	ldi	r22, 0x00	; 0
    674c:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("Solar: "));
    6750:	2d ed       	ldi	r18, 0xDD	; 221
    6752:	3d e0       	ldi	r19, 0x0D	; 13
    6754:	8c e8       	ldi	r24, 0x8C	; 140
    6756:	96 e0       	ldi	r25, 0x06	; 6
    6758:	60 e0       	ldi	r22, 0x00	; 0
    675a:	a9 01       	movw	r20, r18
    675c:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                    lcd_put_uint( solarCurrent );
    6760:	8c 85       	ldd	r24, Y+12	; 0x0c
    6762:	9d 85       	ldd	r25, Y+13	; 0x0d
    6764:	0e 94 4d 13 	call	0x269a	; 0x269a <lcd_put_uint>
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR(" mA"));
    6768:	25 ee       	ldi	r18, 0xE5	; 229
    676a:	3d e0       	ldi	r19, 0x0D	; 13
    676c:	8c e8       	ldi	r24, 0x8C	; 140
    676e:	96 e0       	ldi	r25, 0x06	; 6
    6770:	60 e0       	ldi	r22, 0x00	; 0
    6772:	a9 01       	movw	r20, r18
    6774:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                    lcd_moveto_xy  ( 3, 0 );
    6778:	83 e0       	ldi	r24, 0x03	; 3
    677a:	60 e0       	ldi	r22, 0x00	; 0
    677c:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("Consumer: "));
    6780:	29 ee       	ldi	r18, 0xE9	; 233
    6782:	3d e0       	ldi	r19, 0x0D	; 13
    6784:	8c e8       	ldi	r24, 0x8C	; 140
    6786:	96 e0       	ldi	r25, 0x06	; 6
    6788:	60 e0       	ldi	r22, 0x00	; 0
    678a:	a9 01       	movw	r20, r18
    678c:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                    lcd_put_uint( consumerCurrent );
    6790:	8e 85       	ldd	r24, Y+14	; 0x0e
    6792:	9f 85       	ldd	r25, Y+15	; 0x0f
    6794:	0e 94 4d 13 	call	0x269a	; 0x269a <lcd_put_uint>
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR(" mA"));
    6798:	24 ef       	ldi	r18, 0xF4	; 244
    679a:	3d e0       	ldi	r19, 0x0D	; 13
    679c:	8c e8       	ldi	r24, 0x8C	; 140
    679e:	96 e0       	ldi	r25, 0x06	; 6
    67a0:	60 e0       	ldi	r22, 0x00	; 0
    67a2:	a9 01       	movw	r20, r18
    67a4:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                }
                break;              
    67a8:	1f c1       	rjmp	.+574    	; 0x69e8 <executeUserInterfaceTask+0x6b8>
            }            
            case TOPVIEW_VOLTAGE_MONITOR:
            {
                if( currentView != lastView )
    67aa:	99 81       	ldd	r25, Y+1	; 0x01
    67ac:	8a 81       	ldd	r24, Y+2	; 0x02
    67ae:	98 17       	cp	r25, r24
    67b0:	09 f4       	brne	.+2      	; 0x67b4 <executeUserInterfaceTask+0x484>
    67b2:	1c c1       	rjmp	.+568    	; 0x69ec <executeUserInterfaceTask+0x6bc>
                {
                    lcd_set_font( FONT_PROP_16, NORMAL );
    67b4:	8f e8       	ldi	r24, 0x8F	; 143
    67b6:	9d e0       	ldi	r25, 0x0D	; 13
    67b8:	60 e0       	ldi	r22, 0x00	; 0
    67ba:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <lcd_set_font>
                    lcd_moveto_xy  ( 1, 0 );
    67be:	81 e0       	ldi	r24, 0x01	; 1
    67c0:	60 e0       	ldi	r22, 0x00	; 0
    67c2:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
                    lcd_put_string_P( FONT_PROP_16, NORMAL, PSTR("VoltageMon"));
    67c6:	28 ef       	ldi	r18, 0xF8	; 248
    67c8:	3d e0       	ldi	r19, 0x0D	; 13
    67ca:	8f e8       	ldi	r24, 0x8F	; 143
    67cc:	9d e0       	ldi	r25, 0x0D	; 13
    67ce:	60 e0       	ldi	r22, 0x00	; 0
    67d0:	a9 01       	movw	r20, r18
    67d2:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                } 
                break;                               
    67d6:	0a c1       	rjmp	.+532    	; 0x69ec <executeUserInterfaceTask+0x6bc>
            }         
            case DETAILVIEW_VOLTAGE_MONITOR:
            {
                if( currentView != lastView || measurementValueUpdated )
    67d8:	99 81       	ldd	r25, Y+1	; 0x01
    67da:	8a 81       	ldd	r24, Y+2	; 0x02
    67dc:	98 17       	cp	r25, r24
    67de:	21 f4       	brne	.+8      	; 0x67e8 <executeUserInterfaceTask+0x4b8>
    67e0:	8f 81       	ldd	r24, Y+7	; 0x07
    67e2:	88 23       	and	r24, r24
    67e4:	09 f4       	brne	.+2      	; 0x67e8 <executeUserInterfaceTask+0x4b8>
    67e6:	04 c1       	rjmp	.+520    	; 0x69f0 <executeUserInterfaceTask+0x6c0>
                {
                    lcd_set_font( FONT_FIXED_8, NORMAL );
    67e8:	8c e8       	ldi	r24, 0x8C	; 140
    67ea:	96 e0       	ldi	r25, 0x06	; 6
    67ec:	60 e0       	ldi	r22, 0x00	; 0
    67ee:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <lcd_set_font>
                    lcd_moveto_xy  ( 0, 0 );
    67f2:	80 e0       	ldi	r24, 0x00	; 0
    67f4:	60 e0       	ldi	r22, 0x00	; 0
    67f6:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("Voltage Monitor:"));
    67fa:	23 e0       	ldi	r18, 0x03	; 3
    67fc:	3e e0       	ldi	r19, 0x0E	; 14
    67fe:	8c e8       	ldi	r24, 0x8C	; 140
    6800:	96 e0       	ldi	r25, 0x06	; 6
    6802:	60 e0       	ldi	r22, 0x00	; 0
    6804:	a9 01       	movw	r20, r18
    6806:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                    lcd_moveto_xy  ( 2, 0 );
    680a:	82 e0       	ldi	r24, 0x02	; 2
    680c:	60 e0       	ldi	r22, 0x00	; 0
    680e:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("Battery: "));
    6812:	24 e1       	ldi	r18, 0x14	; 20
    6814:	3e e0       	ldi	r19, 0x0E	; 14
    6816:	8c e8       	ldi	r24, 0x8C	; 140
    6818:	96 e0       	ldi	r25, 0x06	; 6
    681a:	60 e0       	ldi	r22, 0x00	; 0
    681c:	a9 01       	movw	r20, r18
    681e:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                    lcd_put_uint( batteryVoltage );
    6822:	88 85       	ldd	r24, Y+8	; 0x08
    6824:	99 85       	ldd	r25, Y+9	; 0x09
    6826:	0e 94 4d 13 	call	0x269a	; 0x269a <lcd_put_uint>
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR(" mV"));
    682a:	2e e1       	ldi	r18, 0x1E	; 30
    682c:	3e e0       	ldi	r19, 0x0E	; 14
    682e:	8c e8       	ldi	r24, 0x8C	; 140
    6830:	96 e0       	ldi	r25, 0x06	; 6
    6832:	60 e0       	ldi	r22, 0x00	; 0
    6834:	a9 01       	movw	r20, r18
    6836:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                    lcd_moveto_xy  ( 3, 0 );
    683a:	83 e0       	ldi	r24, 0x03	; 3
    683c:	60 e0       	ldi	r22, 0x00	; 0
    683e:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("Solar: "));
    6842:	22 e2       	ldi	r18, 0x22	; 34
    6844:	3e e0       	ldi	r19, 0x0E	; 14
    6846:	8c e8       	ldi	r24, 0x8C	; 140
    6848:	96 e0       	ldi	r25, 0x06	; 6
    684a:	60 e0       	ldi	r22, 0x00	; 0
    684c:	a9 01       	movw	r20, r18
    684e:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                    lcd_put_uint( solarVoltage );
    6852:	8a 85       	ldd	r24, Y+10	; 0x0a
    6854:	9b 85       	ldd	r25, Y+11	; 0x0b
    6856:	0e 94 4d 13 	call	0x269a	; 0x269a <lcd_put_uint>
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR(" mV"));
    685a:	2a e2       	ldi	r18, 0x2A	; 42
    685c:	3e e0       	ldi	r19, 0x0E	; 14
    685e:	8c e8       	ldi	r24, 0x8C	; 140
    6860:	96 e0       	ldi	r25, 0x06	; 6
    6862:	60 e0       	ldi	r22, 0x00	; 0
    6864:	a9 01       	movw	r20, r18
    6866:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                }                
                break;                
    686a:	c2 c0       	rjmp	.+388    	; 0x69f0 <executeUserInterfaceTask+0x6c0>
            }
            case TOPVIEW_TEMPERATURE_MONITOR:
            {
                if( currentView != lastView )
    686c:	99 81       	ldd	r25, Y+1	; 0x01
    686e:	8a 81       	ldd	r24, Y+2	; 0x02
    6870:	98 17       	cp	r25, r24
    6872:	09 f4       	brne	.+2      	; 0x6876 <executeUserInterfaceTask+0x546>
    6874:	bf c0       	rjmp	.+382    	; 0x69f4 <executeUserInterfaceTask+0x6c4>
                {
                    lcd_set_font( FONT_PROP_16, NORMAL );
    6876:	8f e8       	ldi	r24, 0x8F	; 143
    6878:	9d e0       	ldi	r25, 0x0D	; 13
    687a:	60 e0       	ldi	r22, 0x00	; 0
    687c:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <lcd_set_font>
                    lcd_moveto_xy  ( 1, 0 );
    6880:	81 e0       	ldi	r24, 0x01	; 1
    6882:	60 e0       	ldi	r22, 0x00	; 0
    6884:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
                    lcd_put_string_P( FONT_PROP_16, NORMAL, PSTR("TempMon   "));
    6888:	2e e2       	ldi	r18, 0x2E	; 46
    688a:	3e e0       	ldi	r19, 0x0E	; 14
    688c:	8f e8       	ldi	r24, 0x8F	; 143
    688e:	9d e0       	ldi	r25, 0x0D	; 13
    6890:	60 e0       	ldi	r22, 0x00	; 0
    6892:	a9 01       	movw	r20, r18
    6894:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                }   
                break;                             
    6898:	ad c0       	rjmp	.+346    	; 0x69f4 <executeUserInterfaceTask+0x6c4>
            }
            case DETAILVIEW_TEMPERATURE_MONITOR:
            {
                if( currentView != lastView || measurementValueUpdated )
    689a:	99 81       	ldd	r25, Y+1	; 0x01
    689c:	8a 81       	ldd	r24, Y+2	; 0x02
    689e:	98 17       	cp	r25, r24
    68a0:	21 f4       	brne	.+8      	; 0x68aa <executeUserInterfaceTask+0x57a>
    68a2:	8f 81       	ldd	r24, Y+7	; 0x07
    68a4:	88 23       	and	r24, r24
    68a6:	09 f4       	brne	.+2      	; 0x68aa <executeUserInterfaceTask+0x57a>
    68a8:	a7 c0       	rjmp	.+334    	; 0x69f8 <executeUserInterfaceTask+0x6c8>
                {
                    lcd_set_font( FONT_FIXED_8, NORMAL );
    68aa:	8c e8       	ldi	r24, 0x8C	; 140
    68ac:	96 e0       	ldi	r25, 0x06	; 6
    68ae:	60 e0       	ldi	r22, 0x00	; 0
    68b0:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <lcd_set_font>
                    lcd_moveto_xy  ( 0, 0 );
    68b4:	80 e0       	ldi	r24, 0x00	; 0
    68b6:	60 e0       	ldi	r22, 0x00	; 0
    68b8:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("Temperature Monitor:"));
    68bc:	29 e3       	ldi	r18, 0x39	; 57
    68be:	3e e0       	ldi	r19, 0x0E	; 14
    68c0:	8c e8       	ldi	r24, 0x8C	; 140
    68c2:	96 e0       	ldi	r25, 0x06	; 6
    68c4:	60 e0       	ldi	r22, 0x00	; 0
    68c6:	a9 01       	movw	r20, r18
    68c8:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                }                
                break;                
    68cc:	95 c0       	rjmp	.+298    	; 0x69f8 <executeUserInterfaceTask+0x6c8>
            }                 
            case TOPVIEW_SYSTEM_STATUS:
            {
                if( currentView != lastView )
    68ce:	99 81       	ldd	r25, Y+1	; 0x01
    68d0:	8a 81       	ldd	r24, Y+2	; 0x02
    68d2:	98 17       	cp	r25, r24
    68d4:	09 f4       	brne	.+2      	; 0x68d8 <executeUserInterfaceTask+0x5a8>
    68d6:	92 c0       	rjmp	.+292    	; 0x69fc <executeUserInterfaceTask+0x6cc>
                {
                    lcd_set_font( FONT_PROP_16, NORMAL );
    68d8:	8f e8       	ldi	r24, 0x8F	; 143
    68da:	9d e0       	ldi	r25, 0x0D	; 13
    68dc:	60 e0       	ldi	r22, 0x00	; 0
    68de:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <lcd_set_font>
                    lcd_moveto_xy  ( 1, 0 );
    68e2:	81 e0       	ldi	r24, 0x01	; 1
    68e4:	60 e0       	ldi	r22, 0x00	; 0
    68e6:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
                    lcd_put_string_P( FONT_PROP_16, NORMAL, PSTR("SysStatus "));
    68ea:	2e e4       	ldi	r18, 0x4E	; 78
    68ec:	3e e0       	ldi	r19, 0x0E	; 14
    68ee:	8f e8       	ldi	r24, 0x8F	; 143
    68f0:	9d e0       	ldi	r25, 0x0D	; 13
    68f2:	60 e0       	ldi	r22, 0x00	; 0
    68f4:	a9 01       	movw	r20, r18
    68f6:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                }               
                break;                 
    68fa:	80 c0       	rjmp	.+256    	; 0x69fc <executeUserInterfaceTask+0x6cc>
            }           
            case DETAILVIEW_SYSTEM_STATUS:
            {
                if( currentView != lastView || measurementValueUpdated )
    68fc:	99 81       	ldd	r25, Y+1	; 0x01
    68fe:	8a 81       	ldd	r24, Y+2	; 0x02
    6900:	98 17       	cp	r25, r24
    6902:	21 f4       	brne	.+8      	; 0x690c <executeUserInterfaceTask+0x5dc>
    6904:	8f 81       	ldd	r24, Y+7	; 0x07
    6906:	88 23       	and	r24, r24
    6908:	09 f4       	brne	.+2      	; 0x690c <executeUserInterfaceTask+0x5dc>
    690a:	7a c0       	rjmp	.+244    	; 0x6a00 <executeUserInterfaceTask+0x6d0>
                {
                    lcd_set_font( FONT_FIXED_8, NORMAL );
    690c:	8c e8       	ldi	r24, 0x8C	; 140
    690e:	96 e0       	ldi	r25, 0x06	; 6
    6910:	60 e0       	ldi	r22, 0x00	; 0
    6912:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <lcd_set_font>
                    lcd_moveto_xy  ( 0, 0 );
    6916:	80 e0       	ldi	r24, 0x00	; 0
    6918:	60 e0       	ldi	r22, 0x00	; 0
    691a:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("System Status:"));
    691e:	29 e5       	ldi	r18, 0x59	; 89
    6920:	3e e0       	ldi	r19, 0x0E	; 14
    6922:	8c e8       	ldi	r24, 0x8C	; 140
    6924:	96 e0       	ldi	r25, 0x06	; 6
    6926:	60 e0       	ldi	r22, 0x00	; 0
    6928:	a9 01       	movw	r20, r18
    692a:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                }                
                break;                
    692e:	68 c0       	rjmp	.+208    	; 0x6a00 <executeUserInterfaceTask+0x6d0>
            }
            case TOPVIEW_LOGGING:
            {
                if( currentView != lastView )
    6930:	99 81       	ldd	r25, Y+1	; 0x01
    6932:	8a 81       	ldd	r24, Y+2	; 0x02
    6934:	98 17       	cp	r25, r24
    6936:	09 f4       	brne	.+2      	; 0x693a <executeUserInterfaceTask+0x60a>
    6938:	65 c0       	rjmp	.+202    	; 0x6a04 <executeUserInterfaceTask+0x6d4>
                {
                    lcd_set_font( FONT_PROP_16, NORMAL );
    693a:	8f e8       	ldi	r24, 0x8F	; 143
    693c:	9d e0       	ldi	r25, 0x0D	; 13
    693e:	60 e0       	ldi	r22, 0x00	; 0
    6940:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <lcd_set_font>
                    lcd_moveto_xy  ( 1, 0 );
    6944:	81 e0       	ldi	r24, 0x01	; 1
    6946:	60 e0       	ldi	r22, 0x00	; 0
    6948:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
                    lcd_put_string_P( FONT_PROP_16, NORMAL, PSTR("Logging    "));
    694c:	28 e6       	ldi	r18, 0x68	; 104
    694e:	3e e0       	ldi	r19, 0x0E	; 14
    6950:	8f e8       	ldi	r24, 0x8F	; 143
    6952:	9d e0       	ldi	r25, 0x0D	; 13
    6954:	60 e0       	ldi	r22, 0x00	; 0
    6956:	a9 01       	movw	r20, r18
    6958:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                }      
                break;                              
    695c:	53 c0       	rjmp	.+166    	; 0x6a04 <executeUserInterfaceTask+0x6d4>
            }                 
            case DETAILVIEW_LOGGING:
            {
                if( currentView != lastView || measurementValueUpdated)
    695e:	99 81       	ldd	r25, Y+1	; 0x01
    6960:	8a 81       	ldd	r24, Y+2	; 0x02
    6962:	98 17       	cp	r25, r24
    6964:	21 f4       	brne	.+8      	; 0x696e <executeUserInterfaceTask+0x63e>
    6966:	8f 81       	ldd	r24, Y+7	; 0x07
    6968:	88 23       	and	r24, r24
    696a:	09 f4       	brne	.+2      	; 0x696e <executeUserInterfaceTask+0x63e>
    696c:	4d c0       	rjmp	.+154    	; 0x6a08 <executeUserInterfaceTask+0x6d8>
                {
                    lcd_set_font( FONT_FIXED_8, NORMAL );
    696e:	8c e8       	ldi	r24, 0x8C	; 140
    6970:	96 e0       	ldi	r25, 0x06	; 6
    6972:	60 e0       	ldi	r22, 0x00	; 0
    6974:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <lcd_set_font>
                    lcd_moveto_xy  ( 0, 0 );
    6978:	80 e0       	ldi	r24, 0x00	; 0
    697a:	60 e0       	ldi	r22, 0x00	; 0
    697c:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("Logging:"));
    6980:	24 e7       	ldi	r18, 0x74	; 116
    6982:	3e e0       	ldi	r19, 0x0E	; 14
    6984:	8c e8       	ldi	r24, 0x8C	; 140
    6986:	96 e0       	ldi	r25, 0x06	; 6
    6988:	60 e0       	ldi	r22, 0x00	; 0
    698a:	a9 01       	movw	r20, r18
    698c:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                } 
                break;                
    6990:	3b c0       	rjmp	.+118    	; 0x6a08 <executeUserInterfaceTask+0x6d8>
            }            
            case TOPVIEW_SWITCH_OFF:
            {
                if( currentView != lastView )
    6992:	99 81       	ldd	r25, Y+1	; 0x01
    6994:	8a 81       	ldd	r24, Y+2	; 0x02
    6996:	98 17       	cp	r25, r24
    6998:	c9 f1       	breq	.+114    	; 0x6a0c <executeUserInterfaceTask+0x6dc>
                {
                    lcd_set_font( FONT_PROP_16, NORMAL );
    699a:	8f e8       	ldi	r24, 0x8F	; 143
    699c:	9d e0       	ldi	r25, 0x0D	; 13
    699e:	60 e0       	ldi	r22, 0x00	; 0
    69a0:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <lcd_set_font>
                    lcd_moveto_xy  ( 1, 0 );
    69a4:	81 e0       	ldi	r24, 0x01	; 1
    69a6:	60 e0       	ldi	r22, 0x00	; 0
    69a8:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
                    lcd_put_string_P( FONT_PROP_16, NORMAL, PSTR("SwitchOff "));
    69ac:	2d e7       	ldi	r18, 0x7D	; 125
    69ae:	3e e0       	ldi	r19, 0x0E	; 14
    69b0:	8f e8       	ldi	r24, 0x8F	; 143
    69b2:	9d e0       	ldi	r25, 0x0D	; 13
    69b4:	60 e0       	ldi	r22, 0x00	; 0
    69b6:	a9 01       	movw	r20, r18
    69b8:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                    lcd_set_font( FONT_FIXED_8, NORMAL );
    69bc:	8c e8       	ldi	r24, 0x8C	; 140
    69be:	96 e0       	ldi	r25, 0x06	; 6
    69c0:	60 e0       	ldi	r22, 0x00	; 0
    69c2:	0e 94 12 0e 	call	0x1c24	; 0x1c24 <lcd_set_font>
                    lcd_moveto_xy  ( 3, 80 );
    69c6:	83 e0       	ldi	r24, 0x03	; 3
    69c8:	60 e5       	ldi	r22, 0x50	; 80
    69ca:	0e 94 1b 09 	call	0x1236	; 0x1236 <lcd_moveto_xy>
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("* do it "));
    69ce:	28 e8       	ldi	r18, 0x88	; 136
    69d0:	3e e0       	ldi	r19, 0x0E	; 14
    69d2:	8c e8       	ldi	r24, 0x8C	; 140
    69d4:	96 e0       	ldi	r25, 0x06	; 6
    69d6:	60 e0       	ldi	r22, 0x00	; 0
    69d8:	a9 01       	movw	r20, r18
    69da:	0e 94 6a 11 	call	0x22d4	; 0x22d4 <lcd_put_string_P>
                }                
                break;
    69de:	16 c0       	rjmp	.+44     	; 0x6a0c <executeUserInterfaceTask+0x6dc>
        //manage display output for current view
        switch( currentView )
        {
            case TOPVIEW_STARTUP_SCREEN:
            {
                break;
    69e0:	00 00       	nop
    69e2:	15 c0       	rjmp	.+42     	; 0x6a0e <executeUserInterfaceTask+0x6de>
                {
                    lcd_set_font( FONT_PROP_16, NORMAL );
                    lcd_moveto_xy  ( 1, 0 );
                    lcd_put_string_P( FONT_PROP_16, NORMAL, PSTR("CurrentMon"));
                }     
                break;                
    69e4:	00 00       	nop
    69e6:	13 c0       	rjmp	.+38     	; 0x6a0e <executeUserInterfaceTask+0x6de>
                    lcd_moveto_xy  ( 3, 0 );
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("Consumer: "));
                    lcd_put_uint( consumerCurrent );
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR(" mA"));
                }
                break;              
    69e8:	00 00       	nop
    69ea:	11 c0       	rjmp	.+34     	; 0x6a0e <executeUserInterfaceTask+0x6de>
                {
                    lcd_set_font( FONT_PROP_16, NORMAL );
                    lcd_moveto_xy  ( 1, 0 );
                    lcd_put_string_P( FONT_PROP_16, NORMAL, PSTR("VoltageMon"));
                } 
                break;                               
    69ec:	00 00       	nop
    69ee:	0f c0       	rjmp	.+30     	; 0x6a0e <executeUserInterfaceTask+0x6de>
                    lcd_moveto_xy  ( 3, 0 );
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("Solar: "));
                    lcd_put_uint( solarVoltage );
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR(" mV"));
                }                
                break;                
    69f0:	00 00       	nop
    69f2:	0d c0       	rjmp	.+26     	; 0x6a0e <executeUserInterfaceTask+0x6de>
                {
                    lcd_set_font( FONT_PROP_16, NORMAL );
                    lcd_moveto_xy  ( 1, 0 );
                    lcd_put_string_P( FONT_PROP_16, NORMAL, PSTR("TempMon   "));
                }   
                break;                             
    69f4:	00 00       	nop
    69f6:	0b c0       	rjmp	.+22     	; 0x6a0e <executeUserInterfaceTask+0x6de>
                {
                    lcd_set_font( FONT_FIXED_8, NORMAL );
                    lcd_moveto_xy  ( 0, 0 );
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("Temperature Monitor:"));
                }                
                break;                
    69f8:	00 00       	nop
    69fa:	09 c0       	rjmp	.+18     	; 0x6a0e <executeUserInterfaceTask+0x6de>
                {
                    lcd_set_font( FONT_PROP_16, NORMAL );
                    lcd_moveto_xy  ( 1, 0 );
                    lcd_put_string_P( FONT_PROP_16, NORMAL, PSTR("SysStatus "));
                }               
                break;                 
    69fc:	00 00       	nop
    69fe:	07 c0       	rjmp	.+14     	; 0x6a0e <executeUserInterfaceTask+0x6de>
                {
                    lcd_set_font( FONT_FIXED_8, NORMAL );
                    lcd_moveto_xy  ( 0, 0 );
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("System Status:"));
                }                
                break;                
    6a00:	00 00       	nop
    6a02:	05 c0       	rjmp	.+10     	; 0x6a0e <executeUserInterfaceTask+0x6de>
                {
                    lcd_set_font( FONT_PROP_16, NORMAL );
                    lcd_moveto_xy  ( 1, 0 );
                    lcd_put_string_P( FONT_PROP_16, NORMAL, PSTR("Logging    "));
                }      
                break;                              
    6a04:	00 00       	nop
    6a06:	03 c0       	rjmp	.+6      	; 0x6a0e <executeUserInterfaceTask+0x6de>
                {
                    lcd_set_font( FONT_FIXED_8, NORMAL );
                    lcd_moveto_xy  ( 0, 0 );
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("Logging:"));
                } 
                break;                
    6a08:	00 00       	nop
    6a0a:	01 c0       	rjmp	.+2      	; 0x6a0e <executeUserInterfaceTask+0x6de>
                    lcd_put_string_P( FONT_PROP_16, NORMAL, PSTR("SwitchOff "));
                    lcd_set_font( FONT_FIXED_8, NORMAL );
                    lcd_moveto_xy  ( 3, 80 );
                    lcd_put_string_P( FONT_FIXED_8, NORMAL, PSTR("* do it "));
                }                
                break;
    6a0c:	00 00       	nop
            {
                
            }      
        }
        
        lastView = currentView;
    6a0e:	89 81       	ldd	r24, Y+1	; 0x01
    6a10:	8a 83       	std	Y+2, r24	; 0x02
        measurementValueUpdated = 0;
    6a12:	1f 82       	std	Y+7, r1	; 0x07
    }
    6a14:	c4 cc       	rjmp	.-1656   	; 0x639e <executeUserInterfaceTask+0x6e>

00006a16 <xIsUserInterfaceTaskStillRunning>:
}

/* This is called to check that all the created tasks are still running. */
portBASE_TYPE xIsUserInterfaceTaskStillRunning( void )
{
    6a16:	cf 93       	push	r28
    6a18:	df 93       	push	r29
    6a1a:	0f 92       	push	r0
    6a1c:	cd b7       	in	r28, 0x3d	; 61
    6a1e:	de b7       	in	r29, 0x3e	; 62
    portBASE_TYPE xReturn;

    /* Evaluate task status and other relevant variables to indicate the task¥s health */
    if( xUiTaskStatus == pdFAIL )
    6a20:	80 91 50 01 	lds	r24, 0x0150
    6a24:	88 23       	and	r24, r24
    6a26:	11 f4       	brne	.+4      	; 0x6a2c <xIsUserInterfaceTaskStillRunning+0x16>
    {
        xReturn = pdFAIL;
    6a28:	19 82       	std	Y+1, r1	; 0x01
    6a2a:	02 c0       	rjmp	.+4      	; 0x6a30 <xIsUserInterfaceTaskStillRunning+0x1a>
    }
    else
    {
        xReturn = pdPASS;
    6a2c:	81 e0       	ldi	r24, 0x01	; 1
    6a2e:	89 83       	std	Y+1, r24	; 0x01
    }

    return xReturn;
    6a30:	89 81       	ldd	r24, Y+1	; 0x01
    6a32:	0f 90       	pop	r0
    6a34:	df 91       	pop	r29
    6a36:	cf 91       	pop	r28
    6a38:	08 95       	ret

00006a3a <__cmpsf2>:
    6a3a:	2f d0       	rcall	.+94     	; 0x6a9a <__fp_cmp>
    6a3c:	08 f4       	brcc	.+2      	; 0x6a40 <__cmpsf2+0x6>
    6a3e:	81 e0       	ldi	r24, 0x01	; 1
    6a40:	08 95       	ret

00006a42 <__fixunssfsi>:
    6a42:	57 d0       	rcall	.+174    	; 0x6af2 <__fp_splitA>
    6a44:	88 f0       	brcs	.+34     	; 0x6a68 <__fixunssfsi+0x26>
    6a46:	9f 57       	subi	r25, 0x7F	; 127
    6a48:	90 f0       	brcs	.+36     	; 0x6a6e <__fixunssfsi+0x2c>
    6a4a:	b9 2f       	mov	r27, r25
    6a4c:	99 27       	eor	r25, r25
    6a4e:	b7 51       	subi	r27, 0x17	; 23
    6a50:	a0 f0       	brcs	.+40     	; 0x6a7a <__fixunssfsi+0x38>
    6a52:	d1 f0       	breq	.+52     	; 0x6a88 <__fixunssfsi+0x46>
    6a54:	66 0f       	add	r22, r22
    6a56:	77 1f       	adc	r23, r23
    6a58:	88 1f       	adc	r24, r24
    6a5a:	99 1f       	adc	r25, r25
    6a5c:	1a f0       	brmi	.+6      	; 0x6a64 <__fixunssfsi+0x22>
    6a5e:	ba 95       	dec	r27
    6a60:	c9 f7       	brne	.-14     	; 0x6a54 <__fixunssfsi+0x12>
    6a62:	12 c0       	rjmp	.+36     	; 0x6a88 <__fixunssfsi+0x46>
    6a64:	b1 30       	cpi	r27, 0x01	; 1
    6a66:	81 f0       	breq	.+32     	; 0x6a88 <__fixunssfsi+0x46>
    6a68:	5e d0       	rcall	.+188    	; 0x6b26 <__fp_zero>
    6a6a:	b1 e0       	ldi	r27, 0x01	; 1
    6a6c:	08 95       	ret
    6a6e:	5b c0       	rjmp	.+182    	; 0x6b26 <__fp_zero>
    6a70:	67 2f       	mov	r22, r23
    6a72:	78 2f       	mov	r23, r24
    6a74:	88 27       	eor	r24, r24
    6a76:	b8 5f       	subi	r27, 0xF8	; 248
    6a78:	39 f0       	breq	.+14     	; 0x6a88 <__fixunssfsi+0x46>
    6a7a:	b9 3f       	cpi	r27, 0xF9	; 249
    6a7c:	cc f3       	brlt	.-14     	; 0x6a70 <__fixunssfsi+0x2e>
    6a7e:	86 95       	lsr	r24
    6a80:	77 95       	ror	r23
    6a82:	67 95       	ror	r22
    6a84:	b3 95       	inc	r27
    6a86:	d9 f7       	brne	.-10     	; 0x6a7e <__fixunssfsi+0x3c>
    6a88:	3e f4       	brtc	.+14     	; 0x6a98 <__fixunssfsi+0x56>
    6a8a:	90 95       	com	r25
    6a8c:	80 95       	com	r24
    6a8e:	70 95       	com	r23
    6a90:	61 95       	neg	r22
    6a92:	7f 4f       	sbci	r23, 0xFF	; 255
    6a94:	8f 4f       	sbci	r24, 0xFF	; 255
    6a96:	9f 4f       	sbci	r25, 0xFF	; 255
    6a98:	08 95       	ret

00006a9a <__fp_cmp>:
    6a9a:	99 0f       	add	r25, r25
    6a9c:	00 08       	sbc	r0, r0
    6a9e:	55 0f       	add	r21, r21
    6aa0:	aa 0b       	sbc	r26, r26
    6aa2:	e0 e8       	ldi	r30, 0x80	; 128
    6aa4:	fe ef       	ldi	r31, 0xFE	; 254
    6aa6:	16 16       	cp	r1, r22
    6aa8:	17 06       	cpc	r1, r23
    6aaa:	e8 07       	cpc	r30, r24
    6aac:	f9 07       	cpc	r31, r25
    6aae:	c0 f0       	brcs	.+48     	; 0x6ae0 <__fp_cmp+0x46>
    6ab0:	12 16       	cp	r1, r18
    6ab2:	13 06       	cpc	r1, r19
    6ab4:	e4 07       	cpc	r30, r20
    6ab6:	f5 07       	cpc	r31, r21
    6ab8:	98 f0       	brcs	.+38     	; 0x6ae0 <__fp_cmp+0x46>
    6aba:	62 1b       	sub	r22, r18
    6abc:	73 0b       	sbc	r23, r19
    6abe:	84 0b       	sbc	r24, r20
    6ac0:	95 0b       	sbc	r25, r21
    6ac2:	39 f4       	brne	.+14     	; 0x6ad2 <__fp_cmp+0x38>
    6ac4:	0a 26       	eor	r0, r26
    6ac6:	61 f0       	breq	.+24     	; 0x6ae0 <__fp_cmp+0x46>
    6ac8:	23 2b       	or	r18, r19
    6aca:	24 2b       	or	r18, r20
    6acc:	25 2b       	or	r18, r21
    6ace:	21 f4       	brne	.+8      	; 0x6ad8 <__fp_cmp+0x3e>
    6ad0:	08 95       	ret
    6ad2:	0a 26       	eor	r0, r26
    6ad4:	09 f4       	brne	.+2      	; 0x6ad8 <__fp_cmp+0x3e>
    6ad6:	a1 40       	sbci	r26, 0x01	; 1
    6ad8:	a6 95       	lsr	r26
    6ada:	8f ef       	ldi	r24, 0xFF	; 255
    6adc:	81 1d       	adc	r24, r1
    6ade:	81 1d       	adc	r24, r1
    6ae0:	08 95       	ret

00006ae2 <__fp_split3>:
    6ae2:	57 fd       	sbrc	r21, 7
    6ae4:	90 58       	subi	r25, 0x80	; 128
    6ae6:	44 0f       	add	r20, r20
    6ae8:	55 1f       	adc	r21, r21
    6aea:	59 f0       	breq	.+22     	; 0x6b02 <__fp_splitA+0x10>
    6aec:	5f 3f       	cpi	r21, 0xFF	; 255
    6aee:	71 f0       	breq	.+28     	; 0x6b0c <__fp_splitA+0x1a>
    6af0:	47 95       	ror	r20

00006af2 <__fp_splitA>:
    6af2:	88 0f       	add	r24, r24
    6af4:	97 fb       	bst	r25, 7
    6af6:	99 1f       	adc	r25, r25
    6af8:	61 f0       	breq	.+24     	; 0x6b12 <__fp_splitA+0x20>
    6afa:	9f 3f       	cpi	r25, 0xFF	; 255
    6afc:	79 f0       	breq	.+30     	; 0x6b1c <__fp_splitA+0x2a>
    6afe:	87 95       	ror	r24
    6b00:	08 95       	ret
    6b02:	12 16       	cp	r1, r18
    6b04:	13 06       	cpc	r1, r19
    6b06:	14 06       	cpc	r1, r20
    6b08:	55 1f       	adc	r21, r21
    6b0a:	f2 cf       	rjmp	.-28     	; 0x6af0 <__fp_split3+0xe>
    6b0c:	46 95       	lsr	r20
    6b0e:	f1 df       	rcall	.-30     	; 0x6af2 <__fp_splitA>
    6b10:	08 c0       	rjmp	.+16     	; 0x6b22 <__fp_splitA+0x30>
    6b12:	16 16       	cp	r1, r22
    6b14:	17 06       	cpc	r1, r23
    6b16:	18 06       	cpc	r1, r24
    6b18:	99 1f       	adc	r25, r25
    6b1a:	f1 cf       	rjmp	.-30     	; 0x6afe <__fp_splitA+0xc>
    6b1c:	86 95       	lsr	r24
    6b1e:	71 05       	cpc	r23, r1
    6b20:	61 05       	cpc	r22, r1
    6b22:	08 94       	sec
    6b24:	08 95       	ret

00006b26 <__fp_zero>:
    6b26:	e8 94       	clt

00006b28 <__fp_szero>:
    6b28:	bb 27       	eor	r27, r27
    6b2a:	66 27       	eor	r22, r22
    6b2c:	77 27       	eor	r23, r23
    6b2e:	cb 01       	movw	r24, r22
    6b30:	97 f9       	bld	r25, 7
    6b32:	08 95       	ret

00006b34 <__gesf2>:
    6b34:	b2 df       	rcall	.-156    	; 0x6a9a <__fp_cmp>
    6b36:	08 f4       	brcc	.+2      	; 0x6b3a <__gesf2+0x6>
    6b38:	8f ef       	ldi	r24, 0xFF	; 255
    6b3a:	08 95       	ret

00006b3c <__mulsf3>:
    6b3c:	0b d0       	rcall	.+22     	; 0x6b54 <__mulsf3x>
    6b3e:	78 c0       	rjmp	.+240    	; 0x6c30 <__fp_round>
    6b40:	69 d0       	rcall	.+210    	; 0x6c14 <__fp_pscA>
    6b42:	28 f0       	brcs	.+10     	; 0x6b4e <__mulsf3+0x12>
    6b44:	6e d0       	rcall	.+220    	; 0x6c22 <__fp_pscB>
    6b46:	18 f0       	brcs	.+6      	; 0x6b4e <__mulsf3+0x12>
    6b48:	95 23       	and	r25, r21
    6b4a:	09 f0       	breq	.+2      	; 0x6b4e <__mulsf3+0x12>
    6b4c:	5a c0       	rjmp	.+180    	; 0x6c02 <__fp_inf>
    6b4e:	5f c0       	rjmp	.+190    	; 0x6c0e <__fp_nan>
    6b50:	11 24       	eor	r1, r1
    6b52:	ea cf       	rjmp	.-44     	; 0x6b28 <__fp_szero>

00006b54 <__mulsf3x>:
    6b54:	c6 df       	rcall	.-116    	; 0x6ae2 <__fp_split3>
    6b56:	a0 f3       	brcs	.-24     	; 0x6b40 <__mulsf3+0x4>

00006b58 <__mulsf3_pse>:
    6b58:	95 9f       	mul	r25, r21
    6b5a:	d1 f3       	breq	.-12     	; 0x6b50 <__mulsf3+0x14>
    6b5c:	95 0f       	add	r25, r21
    6b5e:	50 e0       	ldi	r21, 0x00	; 0
    6b60:	55 1f       	adc	r21, r21
    6b62:	62 9f       	mul	r22, r18
    6b64:	f0 01       	movw	r30, r0
    6b66:	72 9f       	mul	r23, r18
    6b68:	bb 27       	eor	r27, r27
    6b6a:	f0 0d       	add	r31, r0
    6b6c:	b1 1d       	adc	r27, r1
    6b6e:	63 9f       	mul	r22, r19
    6b70:	aa 27       	eor	r26, r26
    6b72:	f0 0d       	add	r31, r0
    6b74:	b1 1d       	adc	r27, r1
    6b76:	aa 1f       	adc	r26, r26
    6b78:	64 9f       	mul	r22, r20
    6b7a:	66 27       	eor	r22, r22
    6b7c:	b0 0d       	add	r27, r0
    6b7e:	a1 1d       	adc	r26, r1
    6b80:	66 1f       	adc	r22, r22
    6b82:	82 9f       	mul	r24, r18
    6b84:	22 27       	eor	r18, r18
    6b86:	b0 0d       	add	r27, r0
    6b88:	a1 1d       	adc	r26, r1
    6b8a:	62 1f       	adc	r22, r18
    6b8c:	73 9f       	mul	r23, r19
    6b8e:	b0 0d       	add	r27, r0
    6b90:	a1 1d       	adc	r26, r1
    6b92:	62 1f       	adc	r22, r18
    6b94:	83 9f       	mul	r24, r19
    6b96:	a0 0d       	add	r26, r0
    6b98:	61 1d       	adc	r22, r1
    6b9a:	22 1f       	adc	r18, r18
    6b9c:	74 9f       	mul	r23, r20
    6b9e:	33 27       	eor	r19, r19
    6ba0:	a0 0d       	add	r26, r0
    6ba2:	61 1d       	adc	r22, r1
    6ba4:	23 1f       	adc	r18, r19
    6ba6:	84 9f       	mul	r24, r20
    6ba8:	60 0d       	add	r22, r0
    6baa:	21 1d       	adc	r18, r1
    6bac:	82 2f       	mov	r24, r18
    6bae:	76 2f       	mov	r23, r22
    6bb0:	6a 2f       	mov	r22, r26
    6bb2:	11 24       	eor	r1, r1
    6bb4:	9f 57       	subi	r25, 0x7F	; 127
    6bb6:	50 40       	sbci	r21, 0x00	; 0
    6bb8:	8a f0       	brmi	.+34     	; 0x6bdc <__mulsf3_pse+0x84>
    6bba:	e1 f0       	breq	.+56     	; 0x6bf4 <__mulsf3_pse+0x9c>
    6bbc:	88 23       	and	r24, r24
    6bbe:	4a f0       	brmi	.+18     	; 0x6bd2 <__mulsf3_pse+0x7a>
    6bc0:	ee 0f       	add	r30, r30
    6bc2:	ff 1f       	adc	r31, r31
    6bc4:	bb 1f       	adc	r27, r27
    6bc6:	66 1f       	adc	r22, r22
    6bc8:	77 1f       	adc	r23, r23
    6bca:	88 1f       	adc	r24, r24
    6bcc:	91 50       	subi	r25, 0x01	; 1
    6bce:	50 40       	sbci	r21, 0x00	; 0
    6bd0:	a9 f7       	brne	.-22     	; 0x6bbc <__mulsf3_pse+0x64>
    6bd2:	9e 3f       	cpi	r25, 0xFE	; 254
    6bd4:	51 05       	cpc	r21, r1
    6bd6:	70 f0       	brcs	.+28     	; 0x6bf4 <__mulsf3_pse+0x9c>
    6bd8:	14 c0       	rjmp	.+40     	; 0x6c02 <__fp_inf>
    6bda:	a6 cf       	rjmp	.-180    	; 0x6b28 <__fp_szero>
    6bdc:	5f 3f       	cpi	r21, 0xFF	; 255
    6bde:	ec f3       	brlt	.-6      	; 0x6bda <__mulsf3_pse+0x82>
    6be0:	98 3e       	cpi	r25, 0xE8	; 232
    6be2:	dc f3       	brlt	.-10     	; 0x6bda <__mulsf3_pse+0x82>
    6be4:	86 95       	lsr	r24
    6be6:	77 95       	ror	r23
    6be8:	67 95       	ror	r22
    6bea:	b7 95       	ror	r27
    6bec:	f7 95       	ror	r31
    6bee:	e7 95       	ror	r30
    6bf0:	9f 5f       	subi	r25, 0xFF	; 255
    6bf2:	c1 f7       	brne	.-16     	; 0x6be4 <__mulsf3_pse+0x8c>
    6bf4:	fe 2b       	or	r31, r30
    6bf6:	88 0f       	add	r24, r24
    6bf8:	91 1d       	adc	r25, r1
    6bfa:	96 95       	lsr	r25
    6bfc:	87 95       	ror	r24
    6bfe:	97 f9       	bld	r25, 7
    6c00:	08 95       	ret

00006c02 <__fp_inf>:
    6c02:	97 f9       	bld	r25, 7
    6c04:	9f 67       	ori	r25, 0x7F	; 127
    6c06:	80 e8       	ldi	r24, 0x80	; 128
    6c08:	70 e0       	ldi	r23, 0x00	; 0
    6c0a:	60 e0       	ldi	r22, 0x00	; 0
    6c0c:	08 95       	ret

00006c0e <__fp_nan>:
    6c0e:	9f ef       	ldi	r25, 0xFF	; 255
    6c10:	80 ec       	ldi	r24, 0xC0	; 192
    6c12:	08 95       	ret

00006c14 <__fp_pscA>:
    6c14:	00 24       	eor	r0, r0
    6c16:	0a 94       	dec	r0
    6c18:	16 16       	cp	r1, r22
    6c1a:	17 06       	cpc	r1, r23
    6c1c:	18 06       	cpc	r1, r24
    6c1e:	09 06       	cpc	r0, r25
    6c20:	08 95       	ret

00006c22 <__fp_pscB>:
    6c22:	00 24       	eor	r0, r0
    6c24:	0a 94       	dec	r0
    6c26:	12 16       	cp	r1, r18
    6c28:	13 06       	cpc	r1, r19
    6c2a:	14 06       	cpc	r1, r20
    6c2c:	05 06       	cpc	r0, r21
    6c2e:	08 95       	ret

00006c30 <__fp_round>:
    6c30:	09 2e       	mov	r0, r25
    6c32:	03 94       	inc	r0
    6c34:	00 0c       	add	r0, r0
    6c36:	11 f4       	brne	.+4      	; 0x6c3c <__fp_round+0xc>
    6c38:	88 23       	and	r24, r24
    6c3a:	52 f0       	brmi	.+20     	; 0x6c50 <__fp_round+0x20>
    6c3c:	bb 0f       	add	r27, r27
    6c3e:	40 f4       	brcc	.+16     	; 0x6c50 <__fp_round+0x20>
    6c40:	bf 2b       	or	r27, r31
    6c42:	11 f4       	brne	.+4      	; 0x6c48 <__fp_round+0x18>
    6c44:	60 ff       	sbrs	r22, 0
    6c46:	04 c0       	rjmp	.+8      	; 0x6c50 <__fp_round+0x20>
    6c48:	6f 5f       	subi	r22, 0xFF	; 255
    6c4a:	7f 4f       	sbci	r23, 0xFF	; 255
    6c4c:	8f 4f       	sbci	r24, 0xFF	; 255
    6c4e:	9f 4f       	sbci	r25, 0xFF	; 255
    6c50:	08 95       	ret

00006c52 <__mulsi3>:
    6c52:	62 9f       	mul	r22, r18
    6c54:	d0 01       	movw	r26, r0
    6c56:	73 9f       	mul	r23, r19
    6c58:	f0 01       	movw	r30, r0
    6c5a:	82 9f       	mul	r24, r18
    6c5c:	e0 0d       	add	r30, r0
    6c5e:	f1 1d       	adc	r31, r1
    6c60:	64 9f       	mul	r22, r20
    6c62:	e0 0d       	add	r30, r0
    6c64:	f1 1d       	adc	r31, r1
    6c66:	92 9f       	mul	r25, r18
    6c68:	f0 0d       	add	r31, r0
    6c6a:	83 9f       	mul	r24, r19
    6c6c:	f0 0d       	add	r31, r0
    6c6e:	74 9f       	mul	r23, r20
    6c70:	f0 0d       	add	r31, r0
    6c72:	65 9f       	mul	r22, r21
    6c74:	f0 0d       	add	r31, r0
    6c76:	99 27       	eor	r25, r25
    6c78:	72 9f       	mul	r23, r18
    6c7a:	b0 0d       	add	r27, r0
    6c7c:	e1 1d       	adc	r30, r1
    6c7e:	f9 1f       	adc	r31, r25
    6c80:	63 9f       	mul	r22, r19
    6c82:	b0 0d       	add	r27, r0
    6c84:	e1 1d       	adc	r30, r1
    6c86:	f9 1f       	adc	r31, r25
    6c88:	bd 01       	movw	r22, r26
    6c8a:	cf 01       	movw	r24, r30
    6c8c:	11 24       	eor	r1, r1
    6c8e:	08 95       	ret

00006c90 <__udivmodqi4>:
    6c90:	99 1b       	sub	r25, r25
    6c92:	79 e0       	ldi	r23, 0x09	; 9
    6c94:	04 c0       	rjmp	.+8      	; 0x6c9e <__udivmodqi4_ep>

00006c96 <__udivmodqi4_loop>:
    6c96:	99 1f       	adc	r25, r25
    6c98:	96 17       	cp	r25, r22
    6c9a:	08 f0       	brcs	.+2      	; 0x6c9e <__udivmodqi4_ep>
    6c9c:	96 1b       	sub	r25, r22

00006c9e <__udivmodqi4_ep>:
    6c9e:	88 1f       	adc	r24, r24
    6ca0:	7a 95       	dec	r23
    6ca2:	c9 f7       	brne	.-14     	; 0x6c96 <__udivmodqi4_loop>
    6ca4:	80 95       	com	r24
    6ca6:	08 95       	ret

00006ca8 <__udivmodhi4>:
    6ca8:	aa 1b       	sub	r26, r26
    6caa:	bb 1b       	sub	r27, r27
    6cac:	51 e1       	ldi	r21, 0x11	; 17
    6cae:	07 c0       	rjmp	.+14     	; 0x6cbe <__udivmodhi4_ep>

00006cb0 <__udivmodhi4_loop>:
    6cb0:	aa 1f       	adc	r26, r26
    6cb2:	bb 1f       	adc	r27, r27
    6cb4:	a6 17       	cp	r26, r22
    6cb6:	b7 07       	cpc	r27, r23
    6cb8:	10 f0       	brcs	.+4      	; 0x6cbe <__udivmodhi4_ep>
    6cba:	a6 1b       	sub	r26, r22
    6cbc:	b7 0b       	sbc	r27, r23

00006cbe <__udivmodhi4_ep>:
    6cbe:	88 1f       	adc	r24, r24
    6cc0:	99 1f       	adc	r25, r25
    6cc2:	5a 95       	dec	r21
    6cc4:	a9 f7       	brne	.-22     	; 0x6cb0 <__udivmodhi4_loop>
    6cc6:	80 95       	com	r24
    6cc8:	90 95       	com	r25
    6cca:	bc 01       	movw	r22, r24
    6ccc:	cd 01       	movw	r24, r26
    6cce:	08 95       	ret

00006cd0 <__udivmodsi4>:
    6cd0:	a1 e2       	ldi	r26, 0x21	; 33
    6cd2:	1a 2e       	mov	r1, r26
    6cd4:	aa 1b       	sub	r26, r26
    6cd6:	bb 1b       	sub	r27, r27
    6cd8:	fd 01       	movw	r30, r26
    6cda:	0d c0       	rjmp	.+26     	; 0x6cf6 <__udivmodsi4_ep>

00006cdc <__udivmodsi4_loop>:
    6cdc:	aa 1f       	adc	r26, r26
    6cde:	bb 1f       	adc	r27, r27
    6ce0:	ee 1f       	adc	r30, r30
    6ce2:	ff 1f       	adc	r31, r31
    6ce4:	a2 17       	cp	r26, r18
    6ce6:	b3 07       	cpc	r27, r19
    6ce8:	e4 07       	cpc	r30, r20
    6cea:	f5 07       	cpc	r31, r21
    6cec:	20 f0       	brcs	.+8      	; 0x6cf6 <__udivmodsi4_ep>
    6cee:	a2 1b       	sub	r26, r18
    6cf0:	b3 0b       	sbc	r27, r19
    6cf2:	e4 0b       	sbc	r30, r20
    6cf4:	f5 0b       	sbc	r31, r21

00006cf6 <__udivmodsi4_ep>:
    6cf6:	66 1f       	adc	r22, r22
    6cf8:	77 1f       	adc	r23, r23
    6cfa:	88 1f       	adc	r24, r24
    6cfc:	99 1f       	adc	r25, r25
    6cfe:	1a 94       	dec	r1
    6d00:	69 f7       	brne	.-38     	; 0x6cdc <__udivmodsi4_loop>
    6d02:	60 95       	com	r22
    6d04:	70 95       	com	r23
    6d06:	80 95       	com	r24
    6d08:	90 95       	com	r25
    6d0a:	9b 01       	movw	r18, r22
    6d0c:	ac 01       	movw	r20, r24
    6d0e:	bd 01       	movw	r22, r26
    6d10:	cf 01       	movw	r24, r30
    6d12:	08 95       	ret

00006d14 <__divmodsi4>:
    6d14:	97 fb       	bst	r25, 7
    6d16:	09 2e       	mov	r0, r25
    6d18:	05 26       	eor	r0, r21
    6d1a:	0e d0       	rcall	.+28     	; 0x6d38 <__divmodsi4_neg1>
    6d1c:	57 fd       	sbrc	r21, 7
    6d1e:	04 d0       	rcall	.+8      	; 0x6d28 <__divmodsi4_neg2>
    6d20:	d7 df       	rcall	.-82     	; 0x6cd0 <__udivmodsi4>
    6d22:	0a d0       	rcall	.+20     	; 0x6d38 <__divmodsi4_neg1>
    6d24:	00 1c       	adc	r0, r0
    6d26:	38 f4       	brcc	.+14     	; 0x6d36 <__divmodsi4_exit>

00006d28 <__divmodsi4_neg2>:
    6d28:	50 95       	com	r21
    6d2a:	40 95       	com	r20
    6d2c:	30 95       	com	r19
    6d2e:	21 95       	neg	r18
    6d30:	3f 4f       	sbci	r19, 0xFF	; 255
    6d32:	4f 4f       	sbci	r20, 0xFF	; 255
    6d34:	5f 4f       	sbci	r21, 0xFF	; 255

00006d36 <__divmodsi4_exit>:
    6d36:	08 95       	ret

00006d38 <__divmodsi4_neg1>:
    6d38:	f6 f7       	brtc	.-4      	; 0x6d36 <__divmodsi4_exit>
    6d3a:	90 95       	com	r25
    6d3c:	80 95       	com	r24
    6d3e:	70 95       	com	r23
    6d40:	61 95       	neg	r22
    6d42:	7f 4f       	sbci	r23, 0xFF	; 255
    6d44:	8f 4f       	sbci	r24, 0xFF	; 255
    6d46:	9f 4f       	sbci	r25, 0xFF	; 255
    6d48:	08 95       	ret

00006d4a <memcpy>:
    6d4a:	fb 01       	movw	r30, r22
    6d4c:	dc 01       	movw	r26, r24
    6d4e:	02 c0       	rjmp	.+4      	; 0x6d54 <memcpy+0xa>
    6d50:	01 90       	ld	r0, Z+
    6d52:	0d 92       	st	X+, r0
    6d54:	41 50       	subi	r20, 0x01	; 1
    6d56:	50 40       	sbci	r21, 0x00	; 0
    6d58:	d8 f7       	brcc	.-10     	; 0x6d50 <memcpy+0x6>
    6d5a:	08 95       	ret

00006d5c <memset>:
    6d5c:	dc 01       	movw	r26, r24
    6d5e:	01 c0       	rjmp	.+2      	; 0x6d62 <memset+0x6>
    6d60:	6d 93       	st	X+, r22
    6d62:	41 50       	subi	r20, 0x01	; 1
    6d64:	50 40       	sbci	r21, 0x00	; 0
    6d66:	e0 f7       	brcc	.-8      	; 0x6d60 <memset+0x4>
    6d68:	08 95       	ret

00006d6a <strncpy>:
    6d6a:	fb 01       	movw	r30, r22
    6d6c:	dc 01       	movw	r26, r24
    6d6e:	41 50       	subi	r20, 0x01	; 1
    6d70:	50 40       	sbci	r21, 0x00	; 0
    6d72:	48 f0       	brcs	.+18     	; 0x6d86 <strncpy+0x1c>
    6d74:	01 90       	ld	r0, Z+
    6d76:	0d 92       	st	X+, r0
    6d78:	00 20       	and	r0, r0
    6d7a:	c9 f7       	brne	.-14     	; 0x6d6e <strncpy+0x4>
    6d7c:	01 c0       	rjmp	.+2      	; 0x6d80 <strncpy+0x16>
    6d7e:	1d 92       	st	X+, r1
    6d80:	41 50       	subi	r20, 0x01	; 1
    6d82:	50 40       	sbci	r21, 0x00	; 0
    6d84:	e0 f7       	brcc	.-8      	; 0x6d7e <strncpy+0x14>
    6d86:	08 95       	ret

00006d88 <itoa>:
    6d88:	fb 01       	movw	r30, r22
    6d8a:	9f 01       	movw	r18, r30
    6d8c:	e8 94       	clt
    6d8e:	42 30       	cpi	r20, 0x02	; 2
    6d90:	c4 f0       	brlt	.+48     	; 0x6dc2 <itoa+0x3a>
    6d92:	45 32       	cpi	r20, 0x25	; 37
    6d94:	b4 f4       	brge	.+44     	; 0x6dc2 <itoa+0x3a>
    6d96:	4a 30       	cpi	r20, 0x0A	; 10
    6d98:	29 f4       	brne	.+10     	; 0x6da4 <itoa+0x1c>
    6d9a:	97 fb       	bst	r25, 7
    6d9c:	1e f4       	brtc	.+6      	; 0x6da4 <itoa+0x1c>
    6d9e:	90 95       	com	r25
    6da0:	81 95       	neg	r24
    6da2:	9f 4f       	sbci	r25, 0xFF	; 255
    6da4:	64 2f       	mov	r22, r20
    6da6:	77 27       	eor	r23, r23
    6da8:	0e 94 54 36 	call	0x6ca8	; 0x6ca8 <__udivmodhi4>
    6dac:	80 5d       	subi	r24, 0xD0	; 208
    6dae:	8a 33       	cpi	r24, 0x3A	; 58
    6db0:	0c f0       	brlt	.+2      	; 0x6db4 <itoa+0x2c>
    6db2:	89 5d       	subi	r24, 0xD9	; 217
    6db4:	81 93       	st	Z+, r24
    6db6:	cb 01       	movw	r24, r22
    6db8:	00 97       	sbiw	r24, 0x00	; 0
    6dba:	a1 f7       	brne	.-24     	; 0x6da4 <itoa+0x1c>
    6dbc:	16 f4       	brtc	.+4      	; 0x6dc2 <itoa+0x3a>
    6dbe:	5d e2       	ldi	r21, 0x2D	; 45
    6dc0:	51 93       	st	Z+, r21
    6dc2:	10 82       	st	Z, r1
    6dc4:	c9 01       	movw	r24, r18
    6dc6:	0c 94 4d 37 	jmp	0x6e9a	; 0x6e9a <strrev>

00006dca <ltoa>:
    6dca:	fa 01       	movw	r30, r20
    6dcc:	cf 93       	push	r28
    6dce:	ff 93       	push	r31
    6dd0:	ef 93       	push	r30
    6dd2:	22 30       	cpi	r18, 0x02	; 2
    6dd4:	44 f1       	brlt	.+80     	; 0x6e26 <ltoa+0x5c>
    6dd6:	25 32       	cpi	r18, 0x25	; 37
    6dd8:	34 f5       	brge	.+76     	; 0x6e26 <ltoa+0x5c>
    6dda:	c2 2f       	mov	r28, r18
    6ddc:	e8 94       	clt
    6dde:	ca 30       	cpi	r28, 0x0A	; 10
    6de0:	49 f4       	brne	.+18     	; 0x6df4 <ltoa+0x2a>
    6de2:	97 fb       	bst	r25, 7
    6de4:	3e f4       	brtc	.+14     	; 0x6df4 <ltoa+0x2a>
    6de6:	90 95       	com	r25
    6de8:	80 95       	com	r24
    6dea:	70 95       	com	r23
    6dec:	61 95       	neg	r22
    6dee:	7f 4f       	sbci	r23, 0xFF	; 255
    6df0:	8f 4f       	sbci	r24, 0xFF	; 255
    6df2:	9f 4f       	sbci	r25, 0xFF	; 255
    6df4:	2c 2f       	mov	r18, r28
    6df6:	33 27       	eor	r19, r19
    6df8:	44 27       	eor	r20, r20
    6dfa:	55 27       	eor	r21, r21
    6dfc:	ff 93       	push	r31
    6dfe:	ef 93       	push	r30
    6e00:	0e 94 68 36 	call	0x6cd0	; 0x6cd0 <__udivmodsi4>
    6e04:	ef 91       	pop	r30
    6e06:	ff 91       	pop	r31
    6e08:	60 5d       	subi	r22, 0xD0	; 208
    6e0a:	6a 33       	cpi	r22, 0x3A	; 58
    6e0c:	0c f0       	brlt	.+2      	; 0x6e10 <ltoa+0x46>
    6e0e:	69 5d       	subi	r22, 0xD9	; 217
    6e10:	61 93       	st	Z+, r22
    6e12:	b9 01       	movw	r22, r18
    6e14:	ca 01       	movw	r24, r20
    6e16:	60 50       	subi	r22, 0x00	; 0
    6e18:	70 40       	sbci	r23, 0x00	; 0
    6e1a:	80 40       	sbci	r24, 0x00	; 0
    6e1c:	90 40       	sbci	r25, 0x00	; 0
    6e1e:	51 f7       	brne	.-44     	; 0x6df4 <ltoa+0x2a>
    6e20:	16 f4       	brtc	.+4      	; 0x6e26 <ltoa+0x5c>
    6e22:	cd e2       	ldi	r28, 0x2D	; 45
    6e24:	c1 93       	st	Z+, r28
    6e26:	10 82       	st	Z, r1
    6e28:	8f 91       	pop	r24
    6e2a:	9f 91       	pop	r25
    6e2c:	cf 91       	pop	r28
    6e2e:	0c 94 4d 37 	jmp	0x6e9a	; 0x6e9a <strrev>

00006e32 <utoa>:
    6e32:	fb 01       	movw	r30, r22
    6e34:	9f 01       	movw	r18, r30
    6e36:	42 30       	cpi	r20, 0x02	; 2
    6e38:	74 f0       	brlt	.+28     	; 0x6e56 <utoa+0x24>
    6e3a:	45 32       	cpi	r20, 0x25	; 37
    6e3c:	64 f4       	brge	.+24     	; 0x6e56 <utoa+0x24>
    6e3e:	64 2f       	mov	r22, r20
    6e40:	77 27       	eor	r23, r23
    6e42:	0e 94 54 36 	call	0x6ca8	; 0x6ca8 <__udivmodhi4>
    6e46:	80 5d       	subi	r24, 0xD0	; 208
    6e48:	8a 33       	cpi	r24, 0x3A	; 58
    6e4a:	0c f0       	brlt	.+2      	; 0x6e4e <utoa+0x1c>
    6e4c:	89 5d       	subi	r24, 0xD9	; 217
    6e4e:	81 93       	st	Z+, r24
    6e50:	cb 01       	movw	r24, r22
    6e52:	00 97       	sbiw	r24, 0x00	; 0
    6e54:	a1 f7       	brne	.-24     	; 0x6e3e <utoa+0xc>
    6e56:	10 82       	st	Z, r1
    6e58:	c9 01       	movw	r24, r18
    6e5a:	0c 94 4d 37 	jmp	0x6e9a	; 0x6e9a <strrev>

00006e5e <__eerd_block_m1284p>:
    6e5e:	dc 01       	movw	r26, r24
    6e60:	cb 01       	movw	r24, r22

00006e62 <__eerd_blraw_m1284p>:
    6e62:	fc 01       	movw	r30, r24
    6e64:	f9 99       	sbic	0x1f, 1	; 31
    6e66:	fe cf       	rjmp	.-4      	; 0x6e64 <__eerd_blraw_m1284p+0x2>
    6e68:	06 c0       	rjmp	.+12     	; 0x6e76 <__eerd_blraw_m1284p+0x14>
    6e6a:	f2 bd       	out	0x22, r31	; 34
    6e6c:	e1 bd       	out	0x21, r30	; 33
    6e6e:	f8 9a       	sbi	0x1f, 0	; 31
    6e70:	31 96       	adiw	r30, 0x01	; 1
    6e72:	00 b4       	in	r0, 0x20	; 32
    6e74:	0d 92       	st	X+, r0
    6e76:	41 50       	subi	r20, 0x01	; 1
    6e78:	50 40       	sbci	r21, 0x00	; 0
    6e7a:	b8 f7       	brcc	.-18     	; 0x6e6a <__eerd_blraw_m1284p+0x8>
    6e7c:	08 95       	ret

00006e7e <__eewr_byte_m1284p>:
    6e7e:	26 2f       	mov	r18, r22

00006e80 <__eewr_r18_m1284p>:
    6e80:	f9 99       	sbic	0x1f, 1	; 31
    6e82:	fe cf       	rjmp	.-4      	; 0x6e80 <__eewr_r18_m1284p>
    6e84:	1f ba       	out	0x1f, r1	; 31
    6e86:	92 bd       	out	0x22, r25	; 34
    6e88:	81 bd       	out	0x21, r24	; 33
    6e8a:	20 bd       	out	0x20, r18	; 32
    6e8c:	0f b6       	in	r0, 0x3f	; 63
    6e8e:	f8 94       	cli
    6e90:	fa 9a       	sbi	0x1f, 2	; 31
    6e92:	f9 9a       	sbi	0x1f, 1	; 31
    6e94:	0f be       	out	0x3f, r0	; 63
    6e96:	01 96       	adiw	r24, 0x01	; 1
    6e98:	08 95       	ret

00006e9a <strrev>:
    6e9a:	dc 01       	movw	r26, r24
    6e9c:	fc 01       	movw	r30, r24
    6e9e:	67 2f       	mov	r22, r23
    6ea0:	71 91       	ld	r23, Z+
    6ea2:	77 23       	and	r23, r23
    6ea4:	e1 f7       	brne	.-8      	; 0x6e9e <strrev+0x4>
    6ea6:	32 97       	sbiw	r30, 0x02	; 2
    6ea8:	04 c0       	rjmp	.+8      	; 0x6eb2 <strrev+0x18>
    6eaa:	7c 91       	ld	r23, X
    6eac:	6d 93       	st	X+, r22
    6eae:	70 83       	st	Z, r23
    6eb0:	62 91       	ld	r22, -Z
    6eb2:	ae 17       	cp	r26, r30
    6eb4:	bf 07       	cpc	r27, r31
    6eb6:	c8 f3       	brcs	.-14     	; 0x6eaa <strrev+0x10>
    6eb8:	08 95       	ret

00006eba <_exit>:
    6eba:	f8 94       	cli

00006ebc <__stop_program>:
    6ebc:	ff cf       	rjmp	.-2      	; 0x6ebc <__stop_program>
