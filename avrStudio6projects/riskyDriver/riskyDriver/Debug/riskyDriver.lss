
riskyDriver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002f1e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000002a  00800060  00002f1e  00002fb2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000005c1  0080008a  0080008a  00002fdc  2**0
                  ALLOC
  3 .stab         000032f4  00000000  00000000  00002fdc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000a0a  00000000  00000000  000062d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000300  00000000  00000000  00006ce0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00003ab0  00000000  00000000  00006fe0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000013d6  00000000  00000000  0000aa90  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000218b  00000000  00000000  0000be66  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000bd0  00000000  00000000  0000dff4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000164d  00000000  00000000  0000ebc4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002d07  00000000  00000000  00010211  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000f0  00000000  00000000  00012f18  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__ctors_end>
       4:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
       8:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
       c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      10:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      14:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      18:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      1c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      20:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      24:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      28:	0c 94 6b 0a 	jmp	0x14d6	; 0x14d6 <__vector_10>
      2c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      30:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      34:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      38:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      3c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      40:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      44:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      48:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      4c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      50:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      54:	07 63       	ori	r16, 0x37	; 55
      56:	42 36       	cpi	r20, 0x62	; 98
      58:	b7 9b       	sbis	0x16, 7	; 22
      5a:	d8 a7       	lds	r29, 0x78
      5c:	1a 39       	cpi	r17, 0x9A	; 154
      5e:	68 56       	subi	r22, 0x68	; 104
      60:	18 ae       	sts	0xb8, r17
      62:	ba ab       	sts	0x5a, r27
      64:	55 8c       	ldd	r5, Z+29	; 0x1d
      66:	1d 3c       	cpi	r17, 0xCD	; 205
      68:	b7 cc       	rjmp	.-1682   	; 0xfffff9d8 <__eeprom_end+0xff7ef9d8>
      6a:	57 63       	ori	r21, 0x37	; 55
      6c:	bd 6d       	ori	r27, 0xDD	; 221
      6e:	ed fd       	.word	0xfded	; ????
      70:	75 3e       	cpi	r23, 0xE5	; 229
      72:	f6 17       	cp	r31, r22
      74:	72 31       	cpi	r23, 0x12	; 18
      76:	bf 00       	.word	0x00bf	; ????
      78:	00 00       	nop
      7a:	80 3f       	cpi	r24, 0xF0	; 240
      7c:	08 00       	.word	0x0008	; ????
      7e:	00 00       	nop
      80:	be 92       	st	-X, r11
      82:	24 49       	sbci	r18, 0x94	; 148
      84:	12 3e       	cpi	r17, 0xE2	; 226
      86:	ab aa       	sts	0x9b, r26
      88:	aa 2a       	or	r10, r26
      8a:	be cd       	rjmp	.-1156   	; 0xfffffc08 <__eeprom_end+0xff7efc08>
      8c:	cc cc       	rjmp	.-1640   	; 0xfffffa26 <__eeprom_end+0xff7efa26>
      8e:	4c 3e       	cpi	r20, 0xEC	; 236
      90:	00 00       	nop
      92:	00 80       	ld	r0, Z
      94:	be ab       	sts	0x5e, r27
      96:	aa aa       	sts	0x9a, r26
      98:	aa 3e       	cpi	r26, 0xEA	; 234
      9a:	00 00       	nop
      9c:	00 00       	nop
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	00 00       	nop
      a6:	00 00       	nop
      a8:	00 08       	sbc	r0, r0
      aa:	41 78       	andi	r20, 0x81	; 129
      ac:	d3 bb       	out	0x13, r29	; 19
      ae:	43 87       	std	Z+11, r20	; 0x0b
      b0:	d1 13       	cpse	r29, r17
      b2:	3d 19       	sub	r19, r13
      b4:	0e 3c       	cpi	r16, 0xCE	; 206
      b6:	c3 bd       	out	0x23, r28	; 35
      b8:	42 82       	std	Z+2, r4	; 0x02
      ba:	ad 2b       	or	r26, r29
      bc:	3e 68       	ori	r19, 0x8E	; 142
      be:	ec 82       	std	Y+4, r14	; 0x04
      c0:	76 be       	out	0x36, r7	; 54
      c2:	d9 8f       	std	Y+25, r29	; 0x19
      c4:	e1 a9       	sts	0x41, r30
      c6:	3e 4c       	sbci	r19, 0xCE	; 206
      c8:	80 ef       	ldi	r24, 0xF0	; 240
      ca:	ff be       	out	0x3f, r15	; 63
      cc:	01 c4       	rjmp	.+2050   	; 0x8d0 <bmp085_getaltitude+0x32>
      ce:	ff 7f       	andi	r31, 0xFF	; 255
      d0:	3f 00       	.word	0x003f	; ????
      d2:	00 00       	nop
	...

000000d6 <__ctors_end>:
      d6:	11 24       	eor	r1, r1
      d8:	1f be       	out	0x3f, r1	; 63
      da:	cf e5       	ldi	r28, 0x5F	; 95
      dc:	d8 e0       	ldi	r29, 0x08	; 8
      de:	de bf       	out	0x3e, r29	; 62
      e0:	cd bf       	out	0x3d, r28	; 61

000000e2 <__do_copy_data>:
      e2:	10 e0       	ldi	r17, 0x00	; 0
      e4:	a0 e6       	ldi	r26, 0x60	; 96
      e6:	b0 e0       	ldi	r27, 0x00	; 0
      e8:	ee e1       	ldi	r30, 0x1E	; 30
      ea:	ff e2       	ldi	r31, 0x2F	; 47
      ec:	02 c0       	rjmp	.+4      	; 0xf2 <__do_copy_data+0x10>
      ee:	05 90       	lpm	r0, Z+
      f0:	0d 92       	st	X+, r0
      f2:	aa 38       	cpi	r26, 0x8A	; 138
      f4:	b1 07       	cpc	r27, r17
      f6:	d9 f7       	brne	.-10     	; 0xee <__do_copy_data+0xc>

000000f8 <__do_clear_bss>:
      f8:	16 e0       	ldi	r17, 0x06	; 6
      fa:	aa e8       	ldi	r26, 0x8A	; 138
      fc:	b0 e0       	ldi	r27, 0x00	; 0
      fe:	01 c0       	rjmp	.+2      	; 0x102 <.do_clear_bss_start>

00000100 <.do_clear_bss_loop>:
     100:	1d 92       	st	X+, r1

00000102 <.do_clear_bss_start>:
     102:	ab 34       	cpi	r26, 0x4B	; 75
     104:	b1 07       	cpc	r27, r17
     106:	e1 f7       	brne	.-8      	; 0x100 <.do_clear_bss_loop>
     108:	0e 94 77 05 	call	0xaee	; 0xaee <main>
     10c:	0c 94 8d 17 	jmp	0x2f1a	; 0x2f1a <_exit>

00000110 <__bad_interrupt>:
     110:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000114 <bmp085_writemem>:
#include BMP085_I2CFLEURYPATH

/*
 * i2c write
 */
void bmp085_writemem(uint8_t reg, uint8_t value) {
     114:	cf 93       	push	r28
     116:	df 93       	push	r29
     118:	d8 2f       	mov	r29, r24
     11a:	c6 2f       	mov	r28, r22
	i2c_start_wait(BMP085_ADDR | I2C_WRITE);
     11c:	8e ee       	ldi	r24, 0xEE	; 238
     11e:	0e 94 35 05 	call	0xa6a	; 0xa6a <i2c_start_wait>
	i2c_write(reg);
     122:	8d 2f       	mov	r24, r29
     124:	0e 94 5c 05 	call	0xab8	; 0xab8 <i2c_write>
	i2c_write(value);
     128:	8c 2f       	mov	r24, r28
     12a:	0e 94 5c 05 	call	0xab8	; 0xab8 <i2c_write>
	i2c_stop();
     12e:	0e 94 56 05 	call	0xaac	; 0xaac <i2c_stop>
}
     132:	df 91       	pop	r29
     134:	cf 91       	pop	r28
     136:	08 95       	ret

00000138 <bmp085_readmem>:

/*
 * i2c read
 */
void bmp085_readmem(uint8_t reg, uint8_t buff[], uint8_t bytes) {
     138:	df 92       	push	r13
     13a:	ef 92       	push	r14
     13c:	ff 92       	push	r15
     13e:	0f 93       	push	r16
     140:	1f 93       	push	r17
     142:	cf 93       	push	r28
     144:	df 93       	push	r29
     146:	e8 2e       	mov	r14, r24
     148:	c6 2f       	mov	r28, r22
     14a:	07 2f       	mov	r16, r23
     14c:	d4 2e       	mov	r13, r20
	uint8_t i =0;
	i2c_start_wait(BMP085_ADDR | I2C_WRITE);
     14e:	8e ee       	ldi	r24, 0xEE	; 238
     150:	0e 94 35 05 	call	0xa6a	; 0xa6a <i2c_start_wait>
	i2c_write(reg);
     154:	8e 2d       	mov	r24, r14
     156:	0e 94 5c 05 	call	0xab8	; 0xab8 <i2c_write>
	i2c_rep_start(BMP085_ADDR | I2C_READ);
     15a:	8f ee       	ldi	r24, 0xEF	; 239
     15c:	0e 94 53 05 	call	0xaa6	; 0xaa6 <i2c_rep_start>
	for(i=0; i<bytes; i++) {
     160:	dd 20       	and	r13, r13
     162:	d1 f0       	breq	.+52     	; 0x198 <bmp085_readmem+0x60>
     164:	ec 2e       	mov	r14, r28
     166:	f0 2e       	mov	r15, r16
     168:	00 e0       	ldi	r16, 0x00	; 0
     16a:	10 e0       	ldi	r17, 0x00	; 0
		if(i==bytes-1)
     16c:	cd 2d       	mov	r28, r13
     16e:	d0 e0       	ldi	r29, 0x00	; 0
     170:	21 97       	sbiw	r28, 0x01	; 1
     172:	0c 17       	cp	r16, r28
     174:	1d 07       	cpc	r17, r29
     176:	29 f4       	brne	.+10     	; 0x182 <bmp085_readmem+0x4a>
			buff[i] = i2c_readNak();
     178:	0e 94 70 05 	call	0xae0	; 0xae0 <i2c_readNak>
     17c:	f7 01       	movw	r30, r14
     17e:	80 83       	st	Z, r24
     180:	04 c0       	rjmp	.+8      	; 0x18a <bmp085_readmem+0x52>
		else
			buff[i] = i2c_readAck();
     182:	0e 94 69 05 	call	0xad2	; 0xad2 <i2c_readAck>
     186:	f7 01       	movw	r30, r14
     188:	80 83       	st	Z, r24
     18a:	0f 5f       	subi	r16, 0xFF	; 255
     18c:	1f 4f       	sbci	r17, 0xFF	; 255
     18e:	08 94       	sec
     190:	e1 1c       	adc	r14, r1
     192:	f1 1c       	adc	r15, r1
void bmp085_readmem(uint8_t reg, uint8_t buff[], uint8_t bytes) {
	uint8_t i =0;
	i2c_start_wait(BMP085_ADDR | I2C_WRITE);
	i2c_write(reg);
	i2c_rep_start(BMP085_ADDR | I2C_READ);
	for(i=0; i<bytes; i++) {
     194:	0d 15       	cp	r16, r13
     196:	68 f3       	brcs	.-38     	; 0x172 <bmp085_readmem+0x3a>
		if(i==bytes-1)
			buff[i] = i2c_readNak();
		else
			buff[i] = i2c_readAck();
	}
	i2c_stop();
     198:	0e 94 56 05 	call	0xaac	; 0xaac <i2c_stop>
}
     19c:	df 91       	pop	r29
     19e:	cf 91       	pop	r28
     1a0:	1f 91       	pop	r17
     1a2:	0f 91       	pop	r16
     1a4:	ff 90       	pop	r15
     1a6:	ef 90       	pop	r14
     1a8:	df 90       	pop	r13
     1aa:	08 95       	ret

000001ac <bmp085_avaragefilter>:


#if BMP085_FILTERPRESSURE == 1
#define BMP085_AVARAGECOEF 21
static long k[BMP085_AVARAGECOEF];
long bmp085_avaragefilter(long input) {
     1ac:	0f 93       	push	r16
     1ae:	1f 93       	push	r17
     1b0:	cf 93       	push	r28
     1b2:	df 93       	push	r29
     1b4:	ab 01       	movw	r20, r22
     1b6:	bc 01       	movw	r22, r24
	uint8_t i=0;
	long sum=0;
     1b8:	ca e8       	ldi	r28, 0x8A	; 138
     1ba:	d0 e0       	ldi	r29, 0x00	; 0


#if BMP085_FILTERPRESSURE == 1
#define BMP085_AVARAGECOEF 21
static long k[BMP085_AVARAGECOEF];
long bmp085_avaragefilter(long input) {
     1bc:	2e ed       	ldi	r18, 0xDE	; 222
     1be:	30 e0       	ldi	r19, 0x00	; 0
     1c0:	fe 01       	movw	r30, r28
	uint8_t i=0;
	long sum=0;
	for (i=0; i<BMP085_AVARAGECOEF; i++) {
		k[i] = k[i+1];
     1c2:	84 81       	ldd	r24, Z+4	; 0x04
     1c4:	95 81       	ldd	r25, Z+5	; 0x05
     1c6:	a6 81       	ldd	r26, Z+6	; 0x06
     1c8:	b7 81       	ldd	r27, Z+7	; 0x07
     1ca:	81 93       	st	Z+, r24
     1cc:	91 93       	st	Z+, r25
     1ce:	a1 93       	st	Z+, r26
     1d0:	b1 93       	st	Z+, r27
#define BMP085_AVARAGECOEF 21
static long k[BMP085_AVARAGECOEF];
long bmp085_avaragefilter(long input) {
	uint8_t i=0;
	long sum=0;
	for (i=0; i<BMP085_AVARAGECOEF; i++) {
     1d2:	e2 17       	cp	r30, r18
     1d4:	f3 07       	cpc	r31, r19
     1d6:	a9 f7       	brne	.-22     	; 0x1c2 <bmp085_avaragefilter+0x16>
		k[i] = k[i+1];
	}
	k[BMP085_AVARAGECOEF-1] = input;
     1d8:	40 93 da 00 	sts	0x00DA, r20
     1dc:	50 93 db 00 	sts	0x00DB, r21
     1e0:	60 93 dc 00 	sts	0x00DC, r22
     1e4:	70 93 dd 00 	sts	0x00DD, r23
#if BMP085_FILTERPRESSURE == 1
#define BMP085_AVARAGECOEF 21
static long k[BMP085_AVARAGECOEF];
long bmp085_avaragefilter(long input) {
	uint8_t i=0;
	long sum=0;
     1e8:	80 e0       	ldi	r24, 0x00	; 0
     1ea:	90 e0       	ldi	r25, 0x00	; 0
     1ec:	dc 01       	movw	r26, r24
	for (i=0; i<BMP085_AVARAGECOEF; i++) {
		k[i] = k[i+1];
	}
	k[BMP085_AVARAGECOEF-1] = input;
	for (i=0; i<BMP085_AVARAGECOEF; i++) {
		sum += k[i];
     1ee:	49 91       	ld	r20, Y+
     1f0:	59 91       	ld	r21, Y+
     1f2:	69 91       	ld	r22, Y+
     1f4:	79 91       	ld	r23, Y+
     1f6:	84 0f       	add	r24, r20
     1f8:	95 1f       	adc	r25, r21
     1fa:	a6 1f       	adc	r26, r22
     1fc:	b7 1f       	adc	r27, r23
	long sum=0;
	for (i=0; i<BMP085_AVARAGECOEF; i++) {
		k[i] = k[i+1];
	}
	k[BMP085_AVARAGECOEF-1] = input;
	for (i=0; i<BMP085_AVARAGECOEF; i++) {
     1fe:	c2 17       	cp	r28, r18
     200:	d3 07       	cpc	r29, r19
     202:	a9 f7       	brne	.-22     	; 0x1ee <bmp085_avaragefilter+0x42>
		sum += k[i];
	}
	return (sum /BMP085_AVARAGECOEF) ;
     204:	bc 01       	movw	r22, r24
     206:	cd 01       	movw	r24, r26
     208:	25 e1       	ldi	r18, 0x15	; 21
     20a:	30 e0       	ldi	r19, 0x00	; 0
     20c:	40 e0       	ldi	r20, 0x00	; 0
     20e:	50 e0       	ldi	r21, 0x00	; 0
     210:	0e 94 53 17 	call	0x2ea6	; 0x2ea6 <__divmodsi4>
}
     214:	62 2f       	mov	r22, r18
     216:	73 2f       	mov	r23, r19
     218:	84 2f       	mov	r24, r20
     21a:	95 2f       	mov	r25, r21
     21c:	df 91       	pop	r29
     21e:	cf 91       	pop	r28
     220:	1f 91       	pop	r17
     222:	0f 91       	pop	r16
     224:	08 95       	ret

00000226 <bmp085_getcalibration>:
#endif

/*
 * read calibration registers
 */
void bmp085_getcalibration() {
     226:	cf 93       	push	r28
     228:	df 93       	push	r29
     22a:	00 d0       	rcall	.+0      	; 0x22c <bmp085_getcalibration+0x6>
     22c:	cd b7       	in	r28, 0x3d	; 61
     22e:	de b7       	in	r29, 0x3e	; 62
	uint8_t buff[2];
	memset(buff, 0, sizeof(buff));
     230:	1a 82       	std	Y+2, r1	; 0x02
     232:	19 82       	std	Y+1, r1	; 0x01

	bmp085_readmem(BMP085_REGAC1, buff, 2);
     234:	8a ea       	ldi	r24, 0xAA	; 170
     236:	be 01       	movw	r22, r28
     238:	6f 5f       	subi	r22, 0xFF	; 255
     23a:	7f 4f       	sbci	r23, 0xFF	; 255
     23c:	42 e0       	ldi	r20, 0x02	; 2
     23e:	0e 94 9c 00 	call	0x138	; 0x138 <bmp085_readmem>
	bmp085_regac1 = ((int)buff[0] <<8 | ((int)buff[1]));
     242:	99 81       	ldd	r25, Y+1	; 0x01
     244:	80 e0       	ldi	r24, 0x00	; 0
     246:	2a 81       	ldd	r18, Y+2	; 0x02
     248:	30 e0       	ldi	r19, 0x00	; 0
     24a:	82 2b       	or	r24, r18
     24c:	93 2b       	or	r25, r19
     24e:	90 93 42 06 	sts	0x0642, r25
     252:	80 93 41 06 	sts	0x0641, r24
	bmp085_readmem(BMP085_REGAC2, buff, 2);
     256:	8c ea       	ldi	r24, 0xAC	; 172
     258:	be 01       	movw	r22, r28
     25a:	6f 5f       	subi	r22, 0xFF	; 255
     25c:	7f 4f       	sbci	r23, 0xFF	; 255
     25e:	42 e0       	ldi	r20, 0x02	; 2
     260:	0e 94 9c 00 	call	0x138	; 0x138 <bmp085_readmem>
	bmp085_regac2 = ((int)buff[0] <<8 | ((int)buff[1]));
     264:	99 81       	ldd	r25, Y+1	; 0x01
     266:	80 e0       	ldi	r24, 0x00	; 0
     268:	2a 81       	ldd	r18, Y+2	; 0x02
     26a:	30 e0       	ldi	r19, 0x00	; 0
     26c:	82 2b       	or	r24, r18
     26e:	93 2b       	or	r25, r19
     270:	90 93 4a 06 	sts	0x064A, r25
     274:	80 93 49 06 	sts	0x0649, r24
	bmp085_readmem(BMP085_REGAC3, buff, 2);
     278:	8e ea       	ldi	r24, 0xAE	; 174
     27a:	be 01       	movw	r22, r28
     27c:	6f 5f       	subi	r22, 0xFF	; 255
     27e:	7f 4f       	sbci	r23, 0xFF	; 255
     280:	42 e0       	ldi	r20, 0x02	; 2
     282:	0e 94 9c 00 	call	0x138	; 0x138 <bmp085_readmem>
	bmp085_regac3 = ((int)buff[0] <<8 | ((int)buff[1]));
     286:	99 81       	ldd	r25, Y+1	; 0x01
     288:	80 e0       	ldi	r24, 0x00	; 0
     28a:	2a 81       	ldd	r18, Y+2	; 0x02
     28c:	30 e0       	ldi	r19, 0x00	; 0
     28e:	82 2b       	or	r24, r18
     290:	93 2b       	or	r25, r19
     292:	90 93 36 06 	sts	0x0636, r25
     296:	80 93 35 06 	sts	0x0635, r24
	bmp085_readmem(BMP085_REGAC4, buff, 2);
     29a:	80 eb       	ldi	r24, 0xB0	; 176
     29c:	be 01       	movw	r22, r28
     29e:	6f 5f       	subi	r22, 0xFF	; 255
     2a0:	7f 4f       	sbci	r23, 0xFF	; 255
     2a2:	42 e0       	ldi	r20, 0x02	; 2
     2a4:	0e 94 9c 00 	call	0x138	; 0x138 <bmp085_readmem>
	bmp085_regac4 = ((unsigned int)buff[0] <<8 | ((unsigned int)buff[1]));
     2a8:	99 81       	ldd	r25, Y+1	; 0x01
     2aa:	80 e0       	ldi	r24, 0x00	; 0
     2ac:	2a 81       	ldd	r18, Y+2	; 0x02
     2ae:	30 e0       	ldi	r19, 0x00	; 0
     2b0:	82 2b       	or	r24, r18
     2b2:	93 2b       	or	r25, r19
     2b4:	90 93 2e 06 	sts	0x062E, r25
     2b8:	80 93 2d 06 	sts	0x062D, r24
	bmp085_readmem(BMP085_REGAC5, buff, 2);
     2bc:	82 eb       	ldi	r24, 0xB2	; 178
     2be:	be 01       	movw	r22, r28
     2c0:	6f 5f       	subi	r22, 0xFF	; 255
     2c2:	7f 4f       	sbci	r23, 0xFF	; 255
     2c4:	42 e0       	ldi	r20, 0x02	; 2
     2c6:	0e 94 9c 00 	call	0x138	; 0x138 <bmp085_readmem>
	bmp085_regac5 = ((unsigned int)buff[0] <<8 | ((unsigned int)buff[1]));
     2ca:	99 81       	ldd	r25, Y+1	; 0x01
     2cc:	80 e0       	ldi	r24, 0x00	; 0
     2ce:	2a 81       	ldd	r18, Y+2	; 0x02
     2d0:	30 e0       	ldi	r19, 0x00	; 0
     2d2:	82 2b       	or	r24, r18
     2d4:	93 2b       	or	r25, r19
     2d6:	90 93 46 06 	sts	0x0646, r25
     2da:	80 93 45 06 	sts	0x0645, r24
	bmp085_readmem(BMP085_REGAC6, buff, 2);
     2de:	84 eb       	ldi	r24, 0xB4	; 180
     2e0:	be 01       	movw	r22, r28
     2e2:	6f 5f       	subi	r22, 0xFF	; 255
     2e4:	7f 4f       	sbci	r23, 0xFF	; 255
     2e6:	42 e0       	ldi	r20, 0x02	; 2
     2e8:	0e 94 9c 00 	call	0x138	; 0x138 <bmp085_readmem>
	bmp085_regac6 = ((unsigned int)buff[0] <<8 | ((unsigned int)buff[1]));
     2ec:	99 81       	ldd	r25, Y+1	; 0x01
     2ee:	80 e0       	ldi	r24, 0x00	; 0
     2f0:	2a 81       	ldd	r18, Y+2	; 0x02
     2f2:	30 e0       	ldi	r19, 0x00	; 0
     2f4:	82 2b       	or	r24, r18
     2f6:	93 2b       	or	r25, r19
     2f8:	90 93 3e 06 	sts	0x063E, r25
     2fc:	80 93 3d 06 	sts	0x063D, r24
	bmp085_readmem(BMP085_REGB1, buff, 2);
     300:	86 eb       	ldi	r24, 0xB6	; 182
     302:	be 01       	movw	r22, r28
     304:	6f 5f       	subi	r22, 0xFF	; 255
     306:	7f 4f       	sbci	r23, 0xFF	; 255
     308:	42 e0       	ldi	r20, 0x02	; 2
     30a:	0e 94 9c 00 	call	0x138	; 0x138 <bmp085_readmem>
	bmp085_regb1 = ((int)buff[0] <<8 | ((int)buff[1]));
     30e:	99 81       	ldd	r25, Y+1	; 0x01
     310:	80 e0       	ldi	r24, 0x00	; 0
     312:	2a 81       	ldd	r18, Y+2	; 0x02
     314:	30 e0       	ldi	r19, 0x00	; 0
     316:	82 2b       	or	r24, r18
     318:	93 2b       	or	r25, r19
     31a:	90 93 3c 06 	sts	0x063C, r25
     31e:	80 93 3b 06 	sts	0x063B, r24
	bmp085_readmem(BMP085_REGB2, buff, 2);
     322:	88 eb       	ldi	r24, 0xB8	; 184
     324:	be 01       	movw	r22, r28
     326:	6f 5f       	subi	r22, 0xFF	; 255
     328:	7f 4f       	sbci	r23, 0xFF	; 255
     32a:	42 e0       	ldi	r20, 0x02	; 2
     32c:	0e 94 9c 00 	call	0x138	; 0x138 <bmp085_readmem>
	bmp085_regb2 = ((int)buff[0] <<8 | ((int)buff[1]));
     330:	99 81       	ldd	r25, Y+1	; 0x01
     332:	80 e0       	ldi	r24, 0x00	; 0
     334:	2a 81       	ldd	r18, Y+2	; 0x02
     336:	30 e0       	ldi	r19, 0x00	; 0
     338:	82 2b       	or	r24, r18
     33a:	93 2b       	or	r25, r19
     33c:	90 93 30 06 	sts	0x0630, r25
     340:	80 93 2f 06 	sts	0x062F, r24
	bmp085_readmem(BMP085_REGMB, buff, 2);
     344:	8a eb       	ldi	r24, 0xBA	; 186
     346:	be 01       	movw	r22, r28
     348:	6f 5f       	subi	r22, 0xFF	; 255
     34a:	7f 4f       	sbci	r23, 0xFF	; 255
     34c:	42 e0       	ldi	r20, 0x02	; 2
     34e:	0e 94 9c 00 	call	0x138	; 0x138 <bmp085_readmem>
	bmp085_regmb = ((int)buff[0] <<8 | ((int)buff[1]));
     352:	99 81       	ldd	r25, Y+1	; 0x01
     354:	80 e0       	ldi	r24, 0x00	; 0
     356:	2a 81       	ldd	r18, Y+2	; 0x02
     358:	30 e0       	ldi	r19, 0x00	; 0
     35a:	82 2b       	or	r24, r18
     35c:	93 2b       	or	r25, r19
     35e:	90 93 44 06 	sts	0x0644, r25
     362:	80 93 43 06 	sts	0x0643, r24
	bmp085_readmem(BMP085_REGMC, buff, 2);
     366:	8c eb       	ldi	r24, 0xBC	; 188
     368:	be 01       	movw	r22, r28
     36a:	6f 5f       	subi	r22, 0xFF	; 255
     36c:	7f 4f       	sbci	r23, 0xFF	; 255
     36e:	42 e0       	ldi	r20, 0x02	; 2
     370:	0e 94 9c 00 	call	0x138	; 0x138 <bmp085_readmem>
	bmp085_regmc = ((int)buff[0] <<8 | ((int)buff[1]));
     374:	99 81       	ldd	r25, Y+1	; 0x01
     376:	80 e0       	ldi	r24, 0x00	; 0
     378:	2a 81       	ldd	r18, Y+2	; 0x02
     37a:	30 e0       	ldi	r19, 0x00	; 0
     37c:	82 2b       	or	r24, r18
     37e:	93 2b       	or	r25, r19
     380:	90 93 48 06 	sts	0x0648, r25
     384:	80 93 47 06 	sts	0x0647, r24
	bmp085_readmem(BMP085_REGMD, buff, 2);
     388:	8e eb       	ldi	r24, 0xBE	; 190
     38a:	be 01       	movw	r22, r28
     38c:	6f 5f       	subi	r22, 0xFF	; 255
     38e:	7f 4f       	sbci	r23, 0xFF	; 255
     390:	42 e0       	ldi	r20, 0x02	; 2
     392:	0e 94 9c 00 	call	0x138	; 0x138 <bmp085_readmem>
	bmp085_regmd = ((int)buff[0] <<8 | ((int)buff[1]));
     396:	99 81       	ldd	r25, Y+1	; 0x01
     398:	80 e0       	ldi	r24, 0x00	; 0
     39a:	2a 81       	ldd	r18, Y+2	; 0x02
     39c:	30 e0       	ldi	r19, 0x00	; 0
     39e:	82 2b       	or	r24, r18
     3a0:	93 2b       	or	r25, r19
     3a2:	90 93 40 06 	sts	0x0640, r25
     3a6:	80 93 3f 06 	sts	0x063F, r24
}
     3aa:	0f 90       	pop	r0
     3ac:	0f 90       	pop	r0
     3ae:	df 91       	pop	r29
     3b0:	cf 91       	pop	r28
     3b2:	08 95       	ret

000003b4 <bmp085_getrawtemperature>:

/*
 * get raw temperature as read by registers, and do some calculation to convert it
 */
void bmp085_getrawtemperature() {
     3b4:	cf 92       	push	r12
     3b6:	df 92       	push	r13
     3b8:	ef 92       	push	r14
     3ba:	ff 92       	push	r15
     3bc:	0f 93       	push	r16
     3be:	1f 93       	push	r17
     3c0:	cf 93       	push	r28
     3c2:	df 93       	push	r29
     3c4:	00 d0       	rcall	.+0      	; 0x3c6 <bmp085_getrawtemperature+0x12>
     3c6:	cd b7       	in	r28, 0x3d	; 61
     3c8:	de b7       	in	r29, 0x3e	; 62
	uint8_t buff[2];
	memset(buff, 0, sizeof(buff));
     3ca:	1a 82       	std	Y+2, r1	; 0x02
     3cc:	19 82       	std	Y+1, r1	; 0x01
	long ut,x1,x2;

	//read raw temperature
	bmp085_writemem(BMP085_REGCONTROL, BMP085_REGREADTEMPERATURE);
     3ce:	84 ef       	ldi	r24, 0xF4	; 244
     3d0:	6e e2       	ldi	r22, 0x2E	; 46
     3d2:	0e 94 8a 00 	call	0x114	; 0x114 <bmp085_writemem>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3d6:	81 ee       	ldi	r24, 0xE1	; 225
     3d8:	94 e0       	ldi	r25, 0x04	; 4
     3da:	01 97       	sbiw	r24, 0x01	; 1
     3dc:	f1 f7       	brne	.-4      	; 0x3da <bmp085_getrawtemperature+0x26>
     3de:	00 c0       	rjmp	.+0      	; 0x3e0 <bmp085_getrawtemperature+0x2c>
     3e0:	00 00       	nop
	_delay_ms(5); // min. 4.5ms read Temp delay
	bmp085_readmem(BMP085_REGCONTROLOUTPUT, buff, 2);
     3e2:	86 ef       	ldi	r24, 0xF6	; 246
     3e4:	be 01       	movw	r22, r28
     3e6:	6f 5f       	subi	r22, 0xFF	; 255
     3e8:	7f 4f       	sbci	r23, 0xFF	; 255
     3ea:	42 e0       	ldi	r20, 0x02	; 2
     3ec:	0e 94 9c 00 	call	0x138	; 0x138 <bmp085_readmem>
	ut = ((long)buff[0] << 8 | ((long)buff[1])); //uncompensated temperature value
     3f0:	49 81       	ldd	r20, Y+1	; 0x01
     3f2:	50 e0       	ldi	r21, 0x00	; 0
     3f4:	60 e0       	ldi	r22, 0x00	; 0
     3f6:	70 e0       	ldi	r23, 0x00	; 0
     3f8:	76 2f       	mov	r23, r22
     3fa:	65 2f       	mov	r22, r21
     3fc:	54 2f       	mov	r21, r20
     3fe:	44 27       	eor	r20, r20
     400:	8a 81       	ldd	r24, Y+2	; 0x02
     402:	90 e0       	ldi	r25, 0x00	; 0
     404:	a0 e0       	ldi	r26, 0x00	; 0
     406:	b0 e0       	ldi	r27, 0x00	; 0
     408:	48 2b       	or	r20, r24
     40a:	59 2b       	or	r21, r25
     40c:	6a 2b       	or	r22, r26
     40e:	7b 2b       	or	r23, r27

	//calculate raw temperature
	x1 = ((long)ut - bmp085_regac6) * bmp085_regac5 >> 15;
     410:	80 91 3d 06 	lds	r24, 0x063D
     414:	90 91 3e 06 	lds	r25, 0x063E
     418:	a0 e0       	ldi	r26, 0x00	; 0
     41a:	b0 e0       	ldi	r27, 0x00	; 0
     41c:	8a 01       	movw	r16, r20
     41e:	9b 01       	movw	r18, r22
     420:	08 1b       	sub	r16, r24
     422:	19 0b       	sbc	r17, r25
     424:	2a 0b       	sbc	r18, r26
     426:	3b 0b       	sbc	r19, r27
     428:	c9 01       	movw	r24, r18
     42a:	b8 01       	movw	r22, r16
     42c:	20 91 45 06 	lds	r18, 0x0645
     430:	30 91 46 06 	lds	r19, 0x0646
     434:	40 e0       	ldi	r20, 0x00	; 0
     436:	50 e0       	ldi	r21, 0x00	; 0
     438:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <__mulsi3>
     43c:	6b 01       	movw	r12, r22
     43e:	7c 01       	movw	r14, r24
     440:	0b 2e       	mov	r0, r27
     442:	bf e0       	ldi	r27, 0x0F	; 15
     444:	f5 94       	asr	r15
     446:	e7 94       	ror	r14
     448:	d7 94       	ror	r13
     44a:	c7 94       	ror	r12
     44c:	ba 95       	dec	r27
     44e:	d1 f7       	brne	.-12     	; 0x444 <bmp085_getrawtemperature+0x90>
     450:	b0 2d       	mov	r27, r0
	x2 = ((long)bmp085_regmc << 11) / (x1 + bmp085_regmd);
     452:	80 91 47 06 	lds	r24, 0x0647
     456:	90 91 48 06 	lds	r25, 0x0648
     45a:	aa 27       	eor	r26, r26
     45c:	97 fd       	sbrc	r25, 7
     45e:	a0 95       	com	r26
     460:	ba 2f       	mov	r27, r26
     462:	bc 01       	movw	r22, r24
     464:	cd 01       	movw	r24, r26
     466:	05 2e       	mov	r0, r21
     468:	5b e0       	ldi	r21, 0x0B	; 11
     46a:	66 0f       	add	r22, r22
     46c:	77 1f       	adc	r23, r23
     46e:	88 1f       	adc	r24, r24
     470:	99 1f       	adc	r25, r25
     472:	5a 95       	dec	r21
     474:	d1 f7       	brne	.-12     	; 0x46a <bmp085_getrawtemperature+0xb6>
     476:	50 2d       	mov	r21, r0
     478:	20 91 3f 06 	lds	r18, 0x063F
     47c:	30 91 40 06 	lds	r19, 0x0640
     480:	44 27       	eor	r20, r20
     482:	37 fd       	sbrc	r19, 7
     484:	40 95       	com	r20
     486:	54 2f       	mov	r21, r20
     488:	2c 0d       	add	r18, r12
     48a:	3d 1d       	adc	r19, r13
     48c:	4e 1d       	adc	r20, r14
     48e:	5f 1d       	adc	r21, r15
     490:	0e 94 53 17 	call	0x2ea6	; 0x2ea6 <__divmodsi4>
	bmp085_rawtemperature = x1 + x2;
     494:	c2 0e       	add	r12, r18
     496:	d3 1e       	adc	r13, r19
     498:	e4 1e       	adc	r14, r20
     49a:	f5 1e       	adc	r15, r21
     49c:	c0 92 37 06 	sts	0x0637, r12
     4a0:	d0 92 38 06 	sts	0x0638, r13
     4a4:	e0 92 39 06 	sts	0x0639, r14
     4a8:	f0 92 3a 06 	sts	0x063A, r15
}
     4ac:	0f 90       	pop	r0
     4ae:	0f 90       	pop	r0
     4b0:	df 91       	pop	r29
     4b2:	cf 91       	pop	r28
     4b4:	1f 91       	pop	r17
     4b6:	0f 91       	pop	r16
     4b8:	ff 90       	pop	r15
     4ba:	ef 90       	pop	r14
     4bc:	df 90       	pop	r13
     4be:	cf 90       	pop	r12
     4c0:	08 95       	ret

000004c2 <bmp085_getrawpressure>:

/*
 * get raw pressure as read by registers, and do some calculation to convert it
 */
void bmp085_getrawpressure() {
     4c2:	4f 92       	push	r4
     4c4:	5f 92       	push	r5
     4c6:	6f 92       	push	r6
     4c8:	7f 92       	push	r7
     4ca:	8f 92       	push	r8
     4cc:	9f 92       	push	r9
     4ce:	af 92       	push	r10
     4d0:	bf 92       	push	r11
     4d2:	cf 92       	push	r12
     4d4:	df 92       	push	r13
     4d6:	ef 92       	push	r14
     4d8:	ff 92       	push	r15
     4da:	0f 93       	push	r16
     4dc:	1f 93       	push	r17
     4de:	cf 93       	push	r28
     4e0:	df 93       	push	r29
     4e2:	cd b7       	in	r28, 0x3d	; 61
     4e4:	de b7       	in	r29, 0x3e	; 62
     4e6:	2f 97       	sbiw	r28, 0x0f	; 15
     4e8:	0f b6       	in	r0, 0x3f	; 63
     4ea:	f8 94       	cli
     4ec:	de bf       	out	0x3e, r29	; 62
     4ee:	0f be       	out	0x3f, r0	; 63
     4f0:	cd bf       	out	0x3d, r28	; 61
	uint8_t buff[3];
	memset(buff, 0, sizeof(buff));
     4f2:	8e 01       	movw	r16, r28
     4f4:	0f 5f       	subi	r16, 0xFF	; 255
     4f6:	1f 4f       	sbci	r17, 0xFF	; 255
     4f8:	83 e0       	ldi	r24, 0x03	; 3
     4fa:	f8 01       	movw	r30, r16
     4fc:	11 92       	st	Z+, r1
     4fe:	8a 95       	dec	r24
     500:	e9 f7       	brne	.-6      	; 0x4fc <bmp085_getrawpressure+0x3a>
	long up,x1,x2,x3,b3,b6,p;
	unsigned long b4,b7;

	#if BMP085_AUTOUPDATETEMP == 1
	bmp085_getrawtemperature();
     502:	0e 94 da 01 	call	0x3b4	; 0x3b4 <bmp085_getrawtemperature>
	#endif

	//read raw pressure
	bmp085_writemem(BMP085_REGCONTROL, BMP085_REGREADPRESSURE+(BMP085_MODE << 6));
     506:	84 ef       	ldi	r24, 0xF4	; 244
     508:	64 ef       	ldi	r22, 0xF4	; 244
     50a:	0e 94 8a 00 	call	0x114	; 0x114 <bmp085_writemem>
     50e:	83 e6       	ldi	r24, 0x63	; 99
     510:	99 e1       	ldi	r25, 0x19	; 25
     512:	01 97       	sbiw	r24, 0x01	; 1
     514:	f1 f7       	brne	.-4      	; 0x512 <bmp085_getrawpressure+0x50>
     516:	00 c0       	rjmp	.+0      	; 0x518 <bmp085_getrawpressure+0x56>
     518:	00 00       	nop
	_delay_ms(2 + (3<<BMP085_MODE));
	bmp085_readmem(BMP085_REGCONTROLOUTPUT, buff, 3);
     51a:	86 ef       	ldi	r24, 0xF6	; 246
     51c:	b8 01       	movw	r22, r16
     51e:	43 e0       	ldi	r20, 0x03	; 3
     520:	0e 94 9c 00 	call	0x138	; 0x138 <bmp085_readmem>
	up = ((((long)buff[0] <<16) | ((long)buff[1] <<8) | ((long)buff[2])) >> (8-BMP085_MODE)); // uncompensated pressure value

	//calculate raw pressure
	b6 = bmp085_rawtemperature - 4000;
     524:	80 91 37 06 	lds	r24, 0x0637
     528:	90 91 38 06 	lds	r25, 0x0638
     52c:	a0 91 39 06 	lds	r26, 0x0639
     530:	b0 91 3a 06 	lds	r27, 0x063A
     534:	0f 2e       	mov	r0, r31
     536:	f0 e6       	ldi	r31, 0x60	; 96
     538:	cf 2e       	mov	r12, r31
     53a:	f0 ef       	ldi	r31, 0xF0	; 240
     53c:	df 2e       	mov	r13, r31
     53e:	ff ef       	ldi	r31, 0xFF	; 255
     540:	ef 2e       	mov	r14, r31
     542:	ff ef       	ldi	r31, 0xFF	; 255
     544:	ff 2e       	mov	r15, r31
     546:	f0 2d       	mov	r31, r0
     548:	c8 0e       	add	r12, r24
     54a:	d9 1e       	adc	r13, r25
     54c:	ea 1e       	adc	r14, r26
     54e:	fb 1e       	adc	r15, r27
	x1 = (bmp085_regb2* (b6 * b6) >> 12) >> 11;
     550:	c7 01       	movw	r24, r14
     552:	b6 01       	movw	r22, r12
     554:	a7 01       	movw	r20, r14
     556:	96 01       	movw	r18, r12
     558:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <__mulsi3>
     55c:	6c 83       	std	Y+4, r22	; 0x04
     55e:	7d 83       	std	Y+5, r23	; 0x05
     560:	8e 83       	std	Y+6, r24	; 0x06
     562:	9f 83       	std	Y+7, r25	; 0x07
	x2 = (bmp085_regac2 * b6) >> 11;
	x3 = x1 + x2;
	b3 = (((((long)bmp085_regac1) * 4 + x3) << BMP085_MODE) + 2) >> 2;
	x1 = (bmp085_regac3 * b6) >> 13;
     564:	60 91 35 06 	lds	r22, 0x0635
     568:	70 91 36 06 	lds	r23, 0x0636
     56c:	88 27       	eor	r24, r24
     56e:	77 fd       	sbrc	r23, 7
     570:	80 95       	com	r24
     572:	98 2f       	mov	r25, r24
     574:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <__mulsi3>
     578:	4b 01       	movw	r8, r22
     57a:	5c 01       	movw	r10, r24
     57c:	07 2e       	mov	r0, r23
     57e:	7d e0       	ldi	r23, 0x0D	; 13
     580:	b5 94       	asr	r11
     582:	a7 94       	ror	r10
     584:	97 94       	ror	r9
     586:	87 94       	ror	r8
     588:	7a 95       	dec	r23
     58a:	d1 f7       	brne	.-12     	; 0x580 <bmp085_getrawpressure+0xbe>
     58c:	70 2d       	mov	r23, r0
	x2 = (bmp085_regb1 * ((b6 * b6) >> 12)) >> 16;
     58e:	60 91 3b 06 	lds	r22, 0x063B
     592:	70 91 3c 06 	lds	r23, 0x063C
     596:	88 27       	eor	r24, r24
     598:	77 fd       	sbrc	r23, 7
     59a:	80 95       	com	r24
     59c:	98 2f       	mov	r25, r24
     59e:	2c 81       	ldd	r18, Y+4	; 0x04
     5a0:	3d 81       	ldd	r19, Y+5	; 0x05
     5a2:	4e 81       	ldd	r20, Y+6	; 0x06
     5a4:	5f 81       	ldd	r21, Y+7	; 0x07
     5a6:	01 2e       	mov	r0, r17
     5a8:	1c e0       	ldi	r17, 0x0C	; 12
     5aa:	55 95       	asr	r21
     5ac:	47 95       	ror	r20
     5ae:	37 95       	ror	r19
     5b0:	27 95       	ror	r18
     5b2:	1a 95       	dec	r17
     5b4:	d1 f7       	brne	.-12     	; 0x5aa <bmp085_getrawpressure+0xe8>
     5b6:	10 2d       	mov	r17, r0
     5b8:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <__mulsi3>
     5bc:	dc 01       	movw	r26, r24
     5be:	cb 01       	movw	r24, r22
     5c0:	cd 01       	movw	r24, r26
     5c2:	bb 27       	eor	r27, r27
     5c4:	97 fd       	sbrc	r25, 7
     5c6:	b0 95       	com	r27
     5c8:	ab 2f       	mov	r26, r27
	x3 = ((x1 + x2) + 2) >> 2;
     5ca:	88 0d       	add	r24, r8
     5cc:	99 1d       	adc	r25, r9
     5ce:	aa 1d       	adc	r26, r10
     5d0:	bb 1d       	adc	r27, r11
     5d2:	02 96       	adiw	r24, 0x02	; 2
     5d4:	a1 1d       	adc	r26, r1
     5d6:	b1 1d       	adc	r27, r1
     5d8:	b5 95       	asr	r27
     5da:	a7 95       	ror	r26
     5dc:	97 95       	ror	r25
     5de:	87 95       	ror	r24
     5e0:	b5 95       	asr	r27
     5e2:	a7 95       	ror	r26
     5e4:	97 95       	ror	r25
     5e6:	87 95       	ror	r24
	b4 = (bmp085_regac4 * (uint32_t)(x3 + 32768)) >> 15;
     5e8:	bc 01       	movw	r22, r24
     5ea:	cd 01       	movw	r24, r26
     5ec:	60 50       	subi	r22, 0x00	; 0
     5ee:	70 48       	sbci	r23, 0x80	; 128
     5f0:	8f 4f       	sbci	r24, 0xFF	; 255
     5f2:	9f 4f       	sbci	r25, 0xFF	; 255
     5f4:	20 91 2d 06 	lds	r18, 0x062D
     5f8:	30 91 2e 06 	lds	r19, 0x062E
     5fc:	40 e0       	ldi	r20, 0x00	; 0
     5fe:	50 e0       	ldi	r21, 0x00	; 0
     600:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <__mulsi3>
     604:	dc 01       	movw	r26, r24
     606:	cb 01       	movw	r24, r22
     608:	9c 01       	movw	r18, r24
     60a:	ad 01       	movw	r20, r26
     60c:	01 2e       	mov	r0, r17
     60e:	1f e0       	ldi	r17, 0x0F	; 15
     610:	56 95       	lsr	r21
     612:	47 95       	ror	r20
     614:	37 95       	ror	r19
     616:	27 95       	ror	r18
     618:	1a 95       	dec	r17
     61a:	d1 f7       	brne	.-12     	; 0x610 <bmp085_getrawpressure+0x14e>
     61c:	10 2d       	mov	r17, r0
     61e:	2c 87       	std	Y+12, r18	; 0x0c
     620:	3d 87       	std	Y+13, r19	; 0x0d
     622:	4e 87       	std	Y+14, r20	; 0x0e
     624:	5f 87       	std	Y+15, r21	; 0x0f

	//read raw pressure
	bmp085_writemem(BMP085_REGCONTROL, BMP085_REGREADPRESSURE+(BMP085_MODE << 6));
	_delay_ms(2 + (3<<BMP085_MODE));
	bmp085_readmem(BMP085_REGCONTROLOUTPUT, buff, 3);
	up = ((((long)buff[0] <<16) | ((long)buff[1] <<8) | ((long)buff[2])) >> (8-BMP085_MODE)); // uncompensated pressure value
     626:	49 81       	ldd	r20, Y+1	; 0x01
     628:	50 e0       	ldi	r21, 0x00	; 0
     62a:	60 e0       	ldi	r22, 0x00	; 0
     62c:	70 e0       	ldi	r23, 0x00	; 0
     62e:	ba 01       	movw	r22, r20
     630:	55 27       	eor	r21, r21
     632:	44 27       	eor	r20, r20
     634:	8a 81       	ldd	r24, Y+2	; 0x02
     636:	90 e0       	ldi	r25, 0x00	; 0
     638:	a0 e0       	ldi	r26, 0x00	; 0
     63a:	b0 e0       	ldi	r27, 0x00	; 0
     63c:	ba 2f       	mov	r27, r26
     63e:	a9 2f       	mov	r26, r25
     640:	98 2f       	mov	r25, r24
     642:	88 27       	eor	r24, r24
     644:	48 2b       	or	r20, r24
     646:	59 2b       	or	r21, r25
     648:	6a 2b       	or	r22, r26
     64a:	7b 2b       	or	r23, r27
     64c:	8b 81       	ldd	r24, Y+3	; 0x03
     64e:	90 e0       	ldi	r25, 0x00	; 0
     650:	a0 e0       	ldi	r26, 0x00	; 0
     652:	b0 e0       	ldi	r27, 0x00	; 0
     654:	84 2b       	or	r24, r20
     656:	95 2b       	or	r25, r21
     658:	a6 2b       	or	r26, r22
     65a:	b7 2b       	or	r27, r23
     65c:	9c 01       	movw	r18, r24
     65e:	ad 01       	movw	r20, r26
     660:	68 94       	set
     662:	14 f8       	bld	r1, 4
     664:	55 95       	asr	r21
     666:	47 95       	ror	r20
     668:	37 95       	ror	r19
     66a:	27 95       	ror	r18
     66c:	16 94       	lsr	r1
     66e:	d1 f7       	brne	.-12     	; 0x664 <bmp085_getrawpressure+0x1a2>
     670:	28 87       	std	Y+8, r18	; 0x08
     672:	39 87       	std	Y+9, r19	; 0x09
     674:	4a 87       	std	Y+10, r20	; 0x0a
     676:	5b 87       	std	Y+11, r21	; 0x0b
	//calculate raw pressure
	b6 = bmp085_rawtemperature - 4000;
	x1 = (bmp085_regb2* (b6 * b6) >> 12) >> 11;
	x2 = (bmp085_regac2 * b6) >> 11;
	x3 = x1 + x2;
	b3 = (((((long)bmp085_regac1) * 4 + x3) << BMP085_MODE) + 2) >> 2;
     678:	40 90 41 06 	lds	r4, 0x0641
     67c:	50 90 42 06 	lds	r5, 0x0642
     680:	66 24       	eor	r6, r6
     682:	57 fc       	sbrc	r5, 7
     684:	60 94       	com	r6
     686:	76 2c       	mov	r7, r6
     688:	44 0c       	add	r4, r4
     68a:	55 1c       	adc	r5, r5
     68c:	66 1c       	adc	r6, r6
     68e:	77 1c       	adc	r7, r7
     690:	44 0c       	add	r4, r4
     692:	55 1c       	adc	r5, r5
     694:	66 1c       	adc	r6, r6
     696:	77 1c       	adc	r7, r7
	bmp085_readmem(BMP085_REGCONTROLOUTPUT, buff, 3);
	up = ((((long)buff[0] <<16) | ((long)buff[1] <<8) | ((long)buff[2])) >> (8-BMP085_MODE)); // uncompensated pressure value

	//calculate raw pressure
	b6 = bmp085_rawtemperature - 4000;
	x1 = (bmp085_regb2* (b6 * b6) >> 12) >> 11;
     698:	60 91 2f 06 	lds	r22, 0x062F
     69c:	70 91 30 06 	lds	r23, 0x0630
     6a0:	88 27       	eor	r24, r24
     6a2:	77 fd       	sbrc	r23, 7
     6a4:	80 95       	com	r24
     6a6:	98 2f       	mov	r25, r24
     6a8:	2c 81       	ldd	r18, Y+4	; 0x04
     6aa:	3d 81       	ldd	r19, Y+5	; 0x05
     6ac:	4e 81       	ldd	r20, Y+6	; 0x06
     6ae:	5f 81       	ldd	r21, Y+7	; 0x07
     6b0:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <__mulsi3>
     6b4:	4b 01       	movw	r8, r22
     6b6:	5c 01       	movw	r10, r24
     6b8:	07 2e       	mov	r0, r23
     6ba:	77 e1       	ldi	r23, 0x17	; 23
     6bc:	b5 94       	asr	r11
     6be:	a7 94       	ror	r10
     6c0:	97 94       	ror	r9
     6c2:	87 94       	ror	r8
     6c4:	7a 95       	dec	r23
     6c6:	d1 f7       	brne	.-12     	; 0x6bc <bmp085_getrawpressure+0x1fa>
     6c8:	70 2d       	mov	r23, r0
	x2 = (bmp085_regac2 * b6) >> 11;
     6ca:	60 91 49 06 	lds	r22, 0x0649
     6ce:	70 91 4a 06 	lds	r23, 0x064A
     6d2:	88 27       	eor	r24, r24
     6d4:	77 fd       	sbrc	r23, 7
     6d6:	80 95       	com	r24
     6d8:	98 2f       	mov	r25, r24
     6da:	a7 01       	movw	r20, r14
     6dc:	96 01       	movw	r18, r12
     6de:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <__mulsi3>
     6e2:	dc 01       	movw	r26, r24
     6e4:	cb 01       	movw	r24, r22
     6e6:	07 2e       	mov	r0, r23
     6e8:	7b e0       	ldi	r23, 0x0B	; 11
     6ea:	b5 95       	asr	r27
     6ec:	a7 95       	ror	r26
     6ee:	97 95       	ror	r25
     6f0:	87 95       	ror	r24
     6f2:	7a 95       	dec	r23
     6f4:	d1 f7       	brne	.-12     	; 0x6ea <bmp085_getrawpressure+0x228>
     6f6:	70 2d       	mov	r23, r0
	x3 = x1 + x2;
     6f8:	88 0e       	add	r8, r24
     6fa:	99 1e       	adc	r9, r25
     6fc:	aa 1e       	adc	r10, r26
     6fe:	bb 1e       	adc	r11, r27
	b3 = (((((long)bmp085_regac1) * 4 + x3) << BMP085_MODE) + 2) >> 2;
     700:	84 0c       	add	r8, r4
     702:	95 1c       	adc	r9, r5
     704:	a6 1c       	adc	r10, r6
     706:	b7 1c       	adc	r11, r7
     708:	88 0c       	add	r8, r8
     70a:	99 1c       	adc	r9, r9
     70c:	aa 1c       	adc	r10, r10
     70e:	bb 1c       	adc	r11, r11
	x1 = (bmp085_regac3 * b6) >> 13;
	x2 = (bmp085_regb1 * ((b6 * b6) >> 12)) >> 16;
	x3 = ((x1 + x2) + 2) >> 2;
	b4 = (bmp085_regac4 * (uint32_t)(x3 + 32768)) >> 15;
	b7 = ((uint32_t)up - b3) * (50000 >> BMP085_MODE);
     710:	68 85       	ldd	r22, Y+8	; 0x08
     712:	79 85       	ldd	r23, Y+9	; 0x09
     714:	8a 85       	ldd	r24, Y+10	; 0x0a
     716:	9b 85       	ldd	r25, Y+11	; 0x0b
     718:	68 19       	sub	r22, r8
     71a:	79 09       	sbc	r23, r9
     71c:	8a 09       	sbc	r24, r10
     71e:	9b 09       	sbc	r25, r11
     720:	2a e6       	ldi	r18, 0x6A	; 106
     722:	38 e1       	ldi	r19, 0x18	; 24
     724:	40 e0       	ldi	r20, 0x00	; 0
     726:	50 e0       	ldi	r21, 0x00	; 0
     728:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <__mulsi3>
	p = b7 < 0x80000000 ? (b7 << 1) / b4 : (b7 / b4) << 1;
     72c:	99 23       	and	r25, r25
     72e:	6c f0       	brlt	.+26     	; 0x74a <bmp085_getrawpressure+0x288>
     730:	66 0f       	add	r22, r22
     732:	77 1f       	adc	r23, r23
     734:	88 1f       	adc	r24, r24
     736:	99 1f       	adc	r25, r25
     738:	2c 85       	ldd	r18, Y+12	; 0x0c
     73a:	3d 85       	ldd	r19, Y+13	; 0x0d
     73c:	4e 85       	ldd	r20, Y+14	; 0x0e
     73e:	5f 85       	ldd	r21, Y+15	; 0x0f
     740:	0e 94 31 17 	call	0x2e62	; 0x2e62 <__udivmodsi4>
     744:	69 01       	movw	r12, r18
     746:	7a 01       	movw	r14, r20
     748:	0c c0       	rjmp	.+24     	; 0x762 <bmp085_getrawpressure+0x2a0>
     74a:	2c 85       	ldd	r18, Y+12	; 0x0c
     74c:	3d 85       	ldd	r19, Y+13	; 0x0d
     74e:	4e 85       	ldd	r20, Y+14	; 0x0e
     750:	5f 85       	ldd	r21, Y+15	; 0x0f
     752:	0e 94 31 17 	call	0x2e62	; 0x2e62 <__udivmodsi4>
     756:	69 01       	movw	r12, r18
     758:	7a 01       	movw	r14, r20
     75a:	cc 0c       	add	r12, r12
     75c:	dd 1c       	adc	r13, r13
     75e:	ee 1c       	adc	r14, r14
     760:	ff 1c       	adc	r15, r15
	x1 = (p >> 8) * (p >> 8);
     762:	55 27       	eor	r21, r21
     764:	f7 fc       	sbrc	r15, 7
     766:	5a 95       	dec	r21
     768:	4f 2d       	mov	r20, r15
     76a:	3e 2d       	mov	r19, r14
     76c:	2d 2d       	mov	r18, r13
     76e:	ca 01       	movw	r24, r20
     770:	b9 01       	movw	r22, r18
     772:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <__mulsi3>
	x1 = (x1 * 3038) >> 16;
     776:	2e ed       	ldi	r18, 0xDE	; 222
     778:	3b e0       	ldi	r19, 0x0B	; 11
     77a:	40 e0       	ldi	r20, 0x00	; 0
     77c:	50 e0       	ldi	r21, 0x00	; 0
     77e:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <__mulsi3>
     782:	4c 01       	movw	r8, r24
     784:	bb 24       	eor	r11, r11
     786:	97 fc       	sbrc	r9, 7
     788:	b0 94       	com	r11
     78a:	ab 2c       	mov	r10, r11
	x2 = (-7357 * p) >> 16;
     78c:	c7 01       	movw	r24, r14
     78e:	b6 01       	movw	r22, r12
     790:	23 e4       	ldi	r18, 0x43	; 67
     792:	33 ee       	ldi	r19, 0xE3	; 227
     794:	4f ef       	ldi	r20, 0xFF	; 255
     796:	5f ef       	ldi	r21, 0xFF	; 255
     798:	0e 94 fe 16 	call	0x2dfc	; 0x2dfc <__mulsi3>
     79c:	dc 01       	movw	r26, r24
     79e:	cb 01       	movw	r24, r22
     7a0:	cd 01       	movw	r24, r26
     7a2:	bb 27       	eor	r27, r27
     7a4:	97 fd       	sbrc	r25, 7
     7a6:	b0 95       	com	r27
     7a8:	ab 2f       	mov	r26, r27
	bmp085_rawpressure = p + ((x1 + x2 + 3791) >> 4);
     7aa:	88 0d       	add	r24, r8
     7ac:	99 1d       	adc	r25, r9
     7ae:	aa 1d       	adc	r26, r10
     7b0:	bb 1d       	adc	r27, r11
     7b2:	81 53       	subi	r24, 0x31	; 49
     7b4:	91 4f       	sbci	r25, 0xF1	; 241
     7b6:	af 4f       	sbci	r26, 0xFF	; 255
     7b8:	bf 4f       	sbci	r27, 0xFF	; 255
     7ba:	4c 01       	movw	r8, r24
     7bc:	5d 01       	movw	r10, r26
     7be:	68 94       	set
     7c0:	13 f8       	bld	r1, 3
     7c2:	b5 94       	asr	r11
     7c4:	a7 94       	ror	r10
     7c6:	97 94       	ror	r9
     7c8:	87 94       	ror	r8
     7ca:	16 94       	lsr	r1
     7cc:	d1 f7       	brne	.-12     	; 0x7c2 <bmp085_getrawpressure+0x300>
     7ce:	c8 0c       	add	r12, r8
     7d0:	d9 1c       	adc	r13, r9
     7d2:	ea 1c       	adc	r14, r10
     7d4:	fb 1c       	adc	r15, r11
     7d6:	c0 92 31 06 	sts	0x0631, r12
     7da:	d0 92 32 06 	sts	0x0632, r13
     7de:	e0 92 33 06 	sts	0x0633, r14
     7e2:	f0 92 34 06 	sts	0x0634, r15

	#if BMP085_FILTERPRESSURE == 1
	bmp085_rawpressure = bmp085_avaragefilter(bmp085_rawpressure);
     7e6:	c7 01       	movw	r24, r14
     7e8:	b6 01       	movw	r22, r12
     7ea:	0e 94 d6 00 	call	0x1ac	; 0x1ac <bmp085_avaragefilter>
     7ee:	dc 01       	movw	r26, r24
     7f0:	cb 01       	movw	r24, r22
     7f2:	80 93 31 06 	sts	0x0631, r24
     7f6:	90 93 32 06 	sts	0x0632, r25
     7fa:	a0 93 33 06 	sts	0x0633, r26
     7fe:	b0 93 34 06 	sts	0x0634, r27
	#endif
}
     802:	2f 96       	adiw	r28, 0x0f	; 15
     804:	0f b6       	in	r0, 0x3f	; 63
     806:	f8 94       	cli
     808:	de bf       	out	0x3e, r29	; 62
     80a:	0f be       	out	0x3f, r0	; 63
     80c:	cd bf       	out	0x3d, r28	; 61
     80e:	df 91       	pop	r29
     810:	cf 91       	pop	r28
     812:	1f 91       	pop	r17
     814:	0f 91       	pop	r16
     816:	ff 90       	pop	r15
     818:	ef 90       	pop	r14
     81a:	df 90       	pop	r13
     81c:	cf 90       	pop	r12
     81e:	bf 90       	pop	r11
     820:	af 90       	pop	r10
     822:	9f 90       	pop	r9
     824:	8f 90       	pop	r8
     826:	7f 90       	pop	r7
     828:	6f 90       	pop	r6
     82a:	5f 90       	pop	r5
     82c:	4f 90       	pop	r4
     82e:	08 95       	ret

00000830 <bmp085_gettemperature>:

/*
 * get celsius temperature
 */
double bmp085_gettemperature() {
	bmp085_getrawtemperature();
     830:	0e 94 da 01 	call	0x3b4	; 0x3b4 <bmp085_getrawtemperature>
	double temperature = ((bmp085_rawtemperature + 8)>>4);
     834:	80 91 37 06 	lds	r24, 0x0637
     838:	90 91 38 06 	lds	r25, 0x0638
     83c:	a0 91 39 06 	lds	r26, 0x0639
     840:	b0 91 3a 06 	lds	r27, 0x063A
     844:	08 96       	adiw	r24, 0x08	; 8
     846:	a1 1d       	adc	r26, r1
     848:	b1 1d       	adc	r27, r1
     84a:	bc 01       	movw	r22, r24
     84c:	cd 01       	movw	r24, r26
     84e:	68 94       	set
     850:	13 f8       	bld	r1, 3
     852:	95 95       	asr	r25
     854:	87 95       	ror	r24
     856:	77 95       	ror	r23
     858:	67 95       	ror	r22
     85a:	16 94       	lsr	r1
     85c:	d1 f7       	brne	.-12     	; 0x852 <bmp085_gettemperature+0x22>
     85e:	0e 94 aa 14 	call	0x2954	; 0x2954 <__floatsisf>
	temperature = temperature /10;
     862:	46 2f       	mov	r20, r22
     864:	57 2f       	mov	r21, r23
     866:	68 2f       	mov	r22, r24
     868:	79 2f       	mov	r23, r25
     86a:	cb 01       	movw	r24, r22
     86c:	ba 01       	movw	r22, r20
     86e:	20 e0       	ldi	r18, 0x00	; 0
     870:	30 e0       	ldi	r19, 0x00	; 0
     872:	40 e2       	ldi	r20, 0x20	; 32
     874:	51 e4       	ldi	r21, 0x41	; 65
     876:	0e 94 40 14 	call	0x2880	; 0x2880 <__divsf3>
	return temperature;
}
     87a:	46 2f       	mov	r20, r22
     87c:	57 2f       	mov	r21, r23
     87e:	68 2f       	mov	r22, r24
     880:	79 2f       	mov	r23, r25
     882:	cb 01       	movw	r24, r22
     884:	ba 01       	movw	r22, r20
     886:	08 95       	ret

00000888 <bmp085_getpressure>:

/*
 * get pressure
 */
int32_t bmp085_getpressure() {
	bmp085_getrawpressure();
     888:	0e 94 61 02 	call	0x4c2	; 0x4c2 <bmp085_getrawpressure>
	return bmp085_rawpressure + BMP085_UNITPAOFFSET;
     88c:	60 91 31 06 	lds	r22, 0x0631
     890:	70 91 32 06 	lds	r23, 0x0632
}
     894:	80 91 33 06 	lds	r24, 0x0633
     898:	90 91 34 06 	lds	r25, 0x0634
     89c:	08 95       	ret

0000089e <bmp085_getaltitude>:

/*
 * get altitude
 */
double bmp085_getaltitude() {
     89e:	0f 93       	push	r16
     8a0:	1f 93       	push	r17
	bmp085_getrawpressure();
     8a2:	0e 94 61 02 	call	0x4c2	; 0x4c2 <bmp085_getrawpressure>
	return ((1 - pow(bmp085_rawpressure/(double)101325, 0.1903 )) / 0.0000225577) + BMP085_UNITMOFFSET;
     8a6:	60 91 31 06 	lds	r22, 0x0631
     8aa:	70 91 32 06 	lds	r23, 0x0632
     8ae:	80 91 33 06 	lds	r24, 0x0633
     8b2:	90 91 34 06 	lds	r25, 0x0634
     8b6:	0e 94 aa 14 	call	0x2954	; 0x2954 <__floatsisf>
     8ba:	20 e8       	ldi	r18, 0x80	; 128
     8bc:	36 ee       	ldi	r19, 0xE6	; 230
     8be:	45 ec       	ldi	r20, 0xC5	; 197
     8c0:	57 e4       	ldi	r21, 0x47	; 71
     8c2:	0e 94 40 14 	call	0x2880	; 0x2880 <__divsf3>
     8c6:	21 e0       	ldi	r18, 0x01	; 1
     8c8:	3e ed       	ldi	r19, 0xDE	; 222
     8ca:	42 e4       	ldi	r20, 0x42	; 66
     8cc:	5e e3       	ldi	r21, 0x3E	; 62
     8ce:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <pow>
     8d2:	b6 2f       	mov	r27, r22
     8d4:	a7 2f       	mov	r26, r23
     8d6:	38 2f       	mov	r19, r24
     8d8:	29 2f       	mov	r18, r25
     8da:	60 e0       	ldi	r22, 0x00	; 0
     8dc:	70 e0       	ldi	r23, 0x00	; 0
     8de:	80 e8       	ldi	r24, 0x80	; 128
     8e0:	9f e3       	ldi	r25, 0x3F	; 63
     8e2:	42 2f       	mov	r20, r18
     8e4:	0b 2f       	mov	r16, r27
     8e6:	1a 2f       	mov	r17, r26
     8e8:	23 2f       	mov	r18, r19
     8ea:	34 2f       	mov	r19, r20
     8ec:	a9 01       	movw	r20, r18
     8ee:	98 01       	movw	r18, r16
     8f0:	0e 94 db 13 	call	0x27b6	; 0x27b6 <__subsf3>
     8f4:	2b e4       	ldi	r18, 0x4B	; 75
     8f6:	3a e3       	ldi	r19, 0x3A	; 58
     8f8:	4d eb       	ldi	r20, 0xBD	; 189
     8fa:	57 e3       	ldi	r21, 0x37	; 55
     8fc:	0e 94 40 14 	call	0x2880	; 0x2880 <__divsf3>
     900:	20 e0       	ldi	r18, 0x00	; 0
     902:	30 e0       	ldi	r19, 0x00	; 0
     904:	a9 01       	movw	r20, r18
     906:	0e 94 dc 13 	call	0x27b8	; 0x27b8 <__addsf3>
}
     90a:	46 2f       	mov	r20, r22
     90c:	57 2f       	mov	r21, r23
     90e:	68 2f       	mov	r22, r24
     910:	79 2f       	mov	r23, r25
     912:	cb 01       	movw	r24, r22
     914:	ba 01       	movw	r22, r20
     916:	1f 91       	pop	r17
     918:	0f 91       	pop	r16
     91a:	08 95       	ret

0000091c <bmp085_init>:

/*
 * init bmp085
 */
void bmp085_init() {
     91c:	cf 93       	push	r28
	#if BMP085_I2CINIT == 1
	//init i2c
	i2c_init();
     91e:	0e 94 13 05 	call	0xa26	; 0xa26 <i2c_init>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     922:	83 e0       	ldi	r24, 0x03	; 3
     924:	8a 95       	dec	r24
     926:	f1 f7       	brne	.-4      	; 0x924 <bmp085_init+0x8>
     928:	00 00       	nop
	_delay_us(10);
	#endif

	bmp085_getcalibration(); //get calibration data
     92a:	0e 94 13 01 	call	0x226	; 0x226 <bmp085_getcalibration>
	bmp085_getrawtemperature(); //update raw temperature, at least the first time
     92e:	0e 94 da 01 	call	0x3b4	; 0x3b4 <bmp085_getrawtemperature>
     932:	c5 e1       	ldi	r28, 0x15	; 21

	#if BMP085_FILTERPRESSURE == 1
	//initialize the avarage filter
	uint8_t i=0;
	for (i=0; i<BMP085_AVARAGECOEF; i++) {
		bmp085_getrawpressure();
     934:	0e 94 61 02 	call	0x4c2	; 0x4c2 <bmp085_getrawpressure>
     938:	c1 50       	subi	r28, 0x01	; 1
	bmp085_getrawtemperature(); //update raw temperature, at least the first time

	#if BMP085_FILTERPRESSURE == 1
	//initialize the avarage filter
	uint8_t i=0;
	for (i=0; i<BMP085_AVARAGECOEF; i++) {
     93a:	e1 f7       	brne	.-8      	; 0x934 <bmp085_init+0x18>
		bmp085_getrawpressure();
	}
	#endif
}
     93c:	cf 91       	pop	r28
     93e:	08 95       	ret

00000940 <adcInit>:
{
  
  uint16_t result;
 									
								
  ADMUX &= ~((1<<REFS1) | (1<<REFS0)); // externe Referenzspannung nutzen (typischerweise Vcc-Pegel)
     940:	87 b1       	in	r24, 0x07	; 7
     942:	8f 73       	andi	r24, 0x3F	; 63
     944:	87 b9       	out	0x07, r24	; 7


  ADCSRA |= ((1<<ADEN) | (1<<ADPS2) | (1<<ADPS1));    	// ADC Prescaler whlen. BIT0 bis BII 2 in ADCSRA
     946:	86 b1       	in	r24, 0x06	; 6
     948:	86 68       	ori	r24, 0x86	; 134
     94a:	86 b9       	out	0x06, r24	; 6
                               					    // UND ADC aktivieren



  //Erste conversion anstoen, danach luft der ADC im free run mode
  ADCSRA |= (1<<ADSC);	
     94c:	36 9a       	sbi	0x06, 6	; 6
  

  //Auf Abschluss der Konvertierung warten
  //Das Register ADCSRA wird mit "1<<ADSC" maskiert. Da ADSC den Wert 6 hat, wartet das while 
  //also solange, bis das Bit6 von ADCSRA == 0 wird.
  while (ADCSRA & (1<<ADSC) ) {}
     94e:	36 99       	sbic	0x06, 6	; 6
     950:	fe cf       	rjmp	.-4      	; 0x94e <adcInit+0xe>
  	
  //ADCSRA |= (1<<ADIE);		// ADC - > Interrupt Enable		
  
  /* ADCW muss einmal gelesen werden, sonst wird Ergebnis der nchsten
     Wandlung nicht bernommen. */
  result = ADCW;		 
     952:	84 b1       	in	r24, 0x04	; 4
     954:	95 b1       	in	r25, 0x05	; 5
   
}
     956:	08 95       	ret

00000958 <adcRead15>:
{
	uint16_t result=0;
	
	// 	Kanal waehlen(durch Parameterbergabe)	
	//  Kanle 4 bis 7 sind verfgbar
	if ((channel >= 4) && (channel <=7))
     958:	98 2f       	mov	r25, r24
     95a:	94 50       	subi	r25, 0x04	; 4
     95c:	94 30       	cpi	r25, 0x04	; 4
     95e:	08 f4       	brcc	.+2      	; 0x962 <adcRead15+0xa>
 		ADMUX = channel;                  // 	Kanal waehlen(durch Parameterbergabe)
     960:	87 b9       	out	0x07, r24	; 7

	//Erste conversion anstoen, danach luft der ADC im free run mode
  	ADCSRA |= (1<<ADSC);	
     962:	36 9a       	sbi	0x06, 6	; 6
  

  	//Auf Abschluss der Konvertierung warten
	while (ADCSRA & (1<<ADSC) ) {}
     964:	36 99       	sbic	0x06, 6	; 6
     966:	fe cf       	rjmp	.-4      	; 0x964 <adcRead15+0xc>
	
	//result in bit value
	result = ADCW;
     968:	44 b1       	in	r20, 0x04	; 4
     96a:	55 b1       	in	r21, 0x05	; 5
	//convert result into voltage value
	//korrektes runden mit +(divisor>>1)
	//ohne die 16bit casts wrde das zwischenergebnis auf die bitwertigkeit des
	//niedrigsten teil des terms reduziert (hier 8 bit von 100 oder 15)
	result = ((result * (uint16_t)15 * (int16_t)100)+(1023>>1)) / (uint16_t)1023;
     96c:	2c ed       	ldi	r18, 0xDC	; 220
     96e:	35 e0       	ldi	r19, 0x05	; 5
     970:	42 9f       	mul	r20, r18
     972:	c0 01       	movw	r24, r0
     974:	43 9f       	mul	r20, r19
     976:	90 0d       	add	r25, r0
     978:	52 9f       	mul	r21, r18
     97a:	90 0d       	add	r25, r0
     97c:	11 24       	eor	r1, r1
     97e:	81 50       	subi	r24, 0x01	; 1
     980:	9e 4f       	sbci	r25, 0xFE	; 254
     982:	6f ef       	ldi	r22, 0xFF	; 255
     984:	73 e0       	ldi	r23, 0x03	; 3
     986:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <__udivmodhi4>
     98a:	86 2f       	mov	r24, r22
     98c:	97 2f       	mov	r25, r23

	return result;
}
     98e:	08 95       	ret

00000990 <adcRead5>:
{
	uint16_t result=0;
	
	// 	Kanal waehlen(durch Parameterbergabe)	
	//  Kanle 4 bis 7 sind verfgbar
	if ((channel >= 4) && (channel <=7))
     990:	98 2f       	mov	r25, r24
     992:	94 50       	subi	r25, 0x04	; 4
     994:	94 30       	cpi	r25, 0x04	; 4
     996:	08 f4       	brcc	.+2      	; 0x99a <adcRead5+0xa>
 		ADMUX = channel;                  // 	Kanal waehlen(durch Parameterbergabe)
     998:	87 b9       	out	0x07, r24	; 7

	//Erste conversion anstoen, danach luft der ADC im free run mode
  	ADCSRA |= (1<<ADSC);	
     99a:	36 9a       	sbi	0x06, 6	; 6
  

  	//Auf Abschluss der Konvertierung warten
	while (ADCSRA & (1<<ADSC) ) {}
     99c:	36 99       	sbic	0x06, 6	; 6
     99e:	fe cf       	rjmp	.-4      	; 0x99c <adcRead5+0xc>
	
	//result in bit value
	result = ADCW;
     9a0:	44 b1       	in	r20, 0x04	; 4
     9a2:	55 b1       	in	r21, 0x05	; 5
	//convert result into voltage value
	//korrektes runden mit +(divisor>>1)
	//ohne die 16bit casts wrde das zwischenergebnis auf die bitwertigkeit des
	//niedrigsten teil des terms reduziert (hier 8 bit von 100 oder 15)
	result = ((result * (uint16_t)5 * (uint16_t)100) + (1023>>1)) / (uint16_t)1023;
     9a4:	24 ef       	ldi	r18, 0xF4	; 244
     9a6:	31 e0       	ldi	r19, 0x01	; 1
     9a8:	42 9f       	mul	r20, r18
     9aa:	c0 01       	movw	r24, r0
     9ac:	43 9f       	mul	r20, r19
     9ae:	90 0d       	add	r25, r0
     9b0:	52 9f       	mul	r21, r18
     9b2:	90 0d       	add	r25, r0
     9b4:	11 24       	eor	r1, r1
     9b6:	81 50       	subi	r24, 0x01	; 1
     9b8:	9e 4f       	sbci	r25, 0xFE	; 254
     9ba:	6f ef       	ldi	r22, 0xFF	; 255
     9bc:	73 e0       	ldi	r23, 0x03	; 3
     9be:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <__udivmodhi4>
     9c2:	86 2f       	mov	r24, r22
     9c4:	97 2f       	mov	r25, r23

	return result;

}
     9c6:	08 95       	ret

000009c8 <myInit>:
	//Enable interrupts for INT0, INT1, INT2	
	//GICR  |= (1<<BIT7) | (1<<BIT6) | (1<<BIT5); 
	GICR |= (1<<BIT5); //only INT2

*/
}
     9c8:	08 95       	ret

000009ca <pwmInit>:

#include "pwmInit.h"

void pwmInit(uint16_t compare)
{
	DDRD |= (1<<BIT4) | (1<<BIT5);		//D.4&5 als Ausgnge definieren
     9ca:	21 b3       	in	r18, 0x11	; 17
     9cc:	20 63       	ori	r18, 0x30	; 48
     9ce:	21 bb       	out	0x11, r18	; 17
	
	//PWM, Phase Correct with ICR1 as TOP value
	//TOP: 625
	TCCR1A |= (1<<WGM11);	
     9d0:	2f b5       	in	r18, 0x2f	; 47
     9d2:	22 60       	ori	r18, 0x02	; 2
     9d4:	2f bd       	out	0x2f, r18	; 47
	TCCR1A &= ~(1<<WGM10);	
     9d6:	2f b5       	in	r18, 0x2f	; 47
     9d8:	2e 7f       	andi	r18, 0xFE	; 254
     9da:	2f bd       	out	0x2f, r18	; 47

	TCCR1B |= (1<<WGM13);
     9dc:	2e b5       	in	r18, 0x2e	; 46
     9de:	20 61       	ori	r18, 0x10	; 16
     9e0:	2e bd       	out	0x2e, r18	; 46
	TCCR1B &= ~(1<<WGM12);
     9e2:	2e b5       	in	r18, 0x2e	; 46
     9e4:	27 7f       	andi	r18, 0xF7	; 247
     9e6:	2e bd       	out	0x2e, r18	; 46

	ICR1 = 625;
     9e8:	21 e7       	ldi	r18, 0x71	; 113
     9ea:	32 e0       	ldi	r19, 0x02	; 2
     9ec:	37 bd       	out	0x27, r19	; 39
     9ee:	26 bd       	out	0x26, r18	; 38
	

	//Nicht invertierende PWM, KanalA -> auf Pin D.5
	//- Clear OC1A/OC1B on Compare Match when up-counting. 
	//- Set OC1A/OC1B on Compare Match when downcounting.
	TCCR1A |= (1<<COM1A1); 	
     9f0:	2f b5       	in	r18, 0x2f	; 47
     9f2:	20 68       	ori	r18, 0x80	; 128
     9f4:	2f bd       	out	0x2f, r18	; 47
	TCCR1A &= ~(1<<COM1A0);
     9f6:	2f b5       	in	r18, 0x2f	; 47
     9f8:	2f 7b       	andi	r18, 0xBF	; 191
     9fa:	2f bd       	out	0x2f, r18	; 47

	//Prescaler = 64
	TCCR1B |= (1<<CS10) | (1<<CS11);
     9fc:	2e b5       	in	r18, 0x2e	; 46
     9fe:	23 60       	ori	r18, 0x03	; 3
     a00:	2e bd       	out	0x2e, r18	; 46
	TCCR1B |= ~(1<<CS12); 
     a02:	2e b5       	in	r18, 0x2e	; 46
     a04:	2b 6f       	ori	r18, 0xFB	; 251
     a06:	2e bd       	out	0x2e, r18	; 46
		1 	1 	0 	Externer Pin 1, negative Flanke
		1 	1 	1 	Externer Pin 1, positive Flanke 
	*/
	
	//OCR1A->16bit register
	OCR1A=compare;	//Vergleichswert laden
     a08:	9b bd       	out	0x2b, r25	; 43
     a0a:	8a bd       	out	0x2a, r24	; 42
	
	
}
     a0c:	08 95       	ret

00000a0e <pwmUpdate>:


void pwmUpdate(uint16_t compare)
{
	OCR1A=compare;	
     a0e:	9b bd       	out	0x2b, r25	; 43
     a10:	8a bd       	out	0x2a, r24	; 42
}
     a12:	08 95       	ret

00000a14 <timer_init>:
#include "timerInit.h"

void timer_init(uint16_t compare)
{

	TCCR1B |= (1<<WGM12);	//CTC Mode:
     a14:	2e b5       	in	r18, 0x2e	; 46
     a16:	28 60       	ori	r18, 0x08	; 8
     a18:	2e bd       	out	0x2e, r18	; 46
							//Timer1 zhlt hoch, bei compare match wird er wieder zu 0 gesetzt

	TCCR1B |= (1<<CS10); //Prescaler nicht aktiviert - es liegt der Systemtakt an
     a1a:	2e b5       	in	r18, 0x2e	; 46
     a1c:	21 60       	ori	r18, 0x01	; 1
     a1e:	2e bd       	out	0x2e, r18	; 46
	1 	0 	1 	CK / 1024
	1 	1 	0 	Externer Pin 1, negative Flanke
	1 	1 	1 	Externer Pin 1, positive Flanke 
*/
	
	OCR1A=compare;	//Vergleichswert laden
     a20:	9b bd       	out	0x2b, r25	; 43
     a22:	8a bd       	out	0x2a, r24	; 42
	
	
}
     a24:	08 95       	ret

00000a26 <i2c_init>:
*************************************************************************/
void i2c_init(void)
{
  /* initialize TWI clock: 100 kHz clock, TWPS = 0 => prescaler = 1 */
  
  TWSR = 0;                         /* no prescaler */
     a26:	11 b8       	out	0x01, r1	; 1
  TWBR = ((F_CPU/SCL_CLOCK)-16)/2;  /* must be > 10 for stable operation */
     a28:	80 ec       	ldi	r24, 0xC0	; 192
     a2a:	80 b9       	out	0x00, r24	; 0

}/* i2c_init */
     a2c:	08 95       	ret

00000a2e <i2c_start>:
unsigned char i2c_start(unsigned char address)
{
    uint8_t   twst;

	// send START condition
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
     a2e:	94 ea       	ldi	r25, 0xA4	; 164
     a30:	96 bf       	out	0x36, r25	; 54

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));
     a32:	06 b6       	in	r0, 0x36	; 54
     a34:	07 fe       	sbrs	r0, 7
     a36:	fd cf       	rjmp	.-6      	; 0xa32 <i2c_start+0x4>

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
     a38:	91 b1       	in	r25, 0x01	; 1
     a3a:	98 7f       	andi	r25, 0xF8	; 248
	if ( (twst != TW_START) && (twst != TW_REP_START)) return 1;
     a3c:	98 30       	cpi	r25, 0x08	; 8
     a3e:	11 f0       	breq	.+4      	; 0xa44 <i2c_start+0x16>
     a40:	90 31       	cpi	r25, 0x10	; 16
     a42:	79 f4       	brne	.+30     	; 0xa62 <i2c_start+0x34>

	// send device address
	TWDR = address;
     a44:	83 b9       	out	0x03, r24	; 3
	TWCR = (1<<TWINT) | (1<<TWEN);
     a46:	84 e8       	ldi	r24, 0x84	; 132
     a48:	86 bf       	out	0x36, r24	; 54

	// wail until transmission completed and ACK/NACK has been received
	while(!(TWCR & (1<<TWINT)));
     a4a:	06 b6       	in	r0, 0x36	; 54
     a4c:	07 fe       	sbrs	r0, 7
     a4e:	fd cf       	rjmp	.-6      	; 0xa4a <i2c_start+0x1c>

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
     a50:	91 b1       	in	r25, 0x01	; 1
     a52:	98 7f       	andi	r25, 0xF8	; 248
	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) return 1;
     a54:	98 31       	cpi	r25, 0x18	; 24
     a56:	39 f0       	breq	.+14     	; 0xa66 <i2c_start+0x38>

/*************************************************************************	
  Issues a start condition and sends address and transfer direction.
  return 0 = device accessible, 1= failed to access device
*************************************************************************/
unsigned char i2c_start(unsigned char address)
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	90 34       	cpi	r25, 0x40	; 64
     a5c:	29 f4       	brne	.+10     	; 0xa68 <i2c_start+0x3a>
     a5e:	80 e0       	ldi	r24, 0x00	; 0
     a60:	08 95       	ret
	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
	if ( (twst != TW_START) && (twst != TW_REP_START)) return 1;
     a62:	81 e0       	ldi	r24, 0x01	; 1
     a64:	08 95       	ret

	// check value of TWI Status Register. Mask prescaler bits.
	twst = TW_STATUS & 0xF8;
	if ( (twst != TW_MT_SLA_ACK) && (twst != TW_MR_SLA_ACK) ) return 1;

	return 0;
     a66:	80 e0       	ldi	r24, 0x00	; 0

}/* i2c_start */
     a68:	08 95       	ret

00000a6a <i2c_start_wait>:


    while ( 1 )
    {
	    // send START condition
	    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
     a6a:	24 ea       	ldi	r18, 0xA4	; 164
    	twst = TW_STATUS & 0xF8;
    	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
    
    	// send device address
    	TWDR = address;
    	TWCR = (1<<TWINT) | (1<<TWEN);
     a6c:	34 e8       	ldi	r19, 0x84	; 132
    	// check value of TWI Status Register. Mask prescaler bits.
    	twst = TW_STATUS & 0xF8;
    	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
    	{    	    
    	    /* device busy, send stop condition to terminate write operation */
	        TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
     a6e:	44 e9       	ldi	r20, 0x94	; 148


    while ( 1 )
    {
	    // send START condition
	    TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
     a70:	26 bf       	out	0x36, r18	; 54
    
    	// wait until transmission completed
    	while(!(TWCR & (1<<TWINT)));
     a72:	06 b6       	in	r0, 0x36	; 54
     a74:	07 fe       	sbrs	r0, 7
     a76:	fd cf       	rjmp	.-6      	; 0xa72 <i2c_start_wait+0x8>
    
    	// check value of TWI Status Register. Mask prescaler bits.
    	twst = TW_STATUS & 0xF8;
     a78:	91 b1       	in	r25, 0x01	; 1
     a7a:	98 7f       	andi	r25, 0xF8	; 248
    	if ( (twst != TW_START) && (twst != TW_REP_START)) continue;
     a7c:	98 30       	cpi	r25, 0x08	; 8
     a7e:	11 f0       	breq	.+4      	; 0xa84 <i2c_start_wait+0x1a>
     a80:	90 31       	cpi	r25, 0x10	; 16
     a82:	b1 f7       	brne	.-20     	; 0xa70 <i2c_start_wait+0x6>
    
    	// send device address
    	TWDR = address;
     a84:	83 b9       	out	0x03, r24	; 3
    	TWCR = (1<<TWINT) | (1<<TWEN);
     a86:	36 bf       	out	0x36, r19	; 54
    
    	// wail until transmission completed
    	while(!(TWCR & (1<<TWINT)));
     a88:	06 b6       	in	r0, 0x36	; 54
     a8a:	07 fe       	sbrs	r0, 7
     a8c:	fd cf       	rjmp	.-6      	; 0xa88 <i2c_start_wait+0x1e>
    
    	// check value of TWI Status Register. Mask prescaler bits.
    	twst = TW_STATUS & 0xF8;
     a8e:	91 b1       	in	r25, 0x01	; 1
     a90:	98 7f       	andi	r25, 0xF8	; 248
    	if ( (twst == TW_MT_SLA_NACK )||(twst ==TW_MR_DATA_NACK) ) 
     a92:	90 32       	cpi	r25, 0x20	; 32
     a94:	11 f0       	breq	.+4      	; 0xa9a <i2c_start_wait+0x30>
     a96:	98 35       	cpi	r25, 0x58	; 88
     a98:	29 f4       	brne	.+10     	; 0xaa4 <i2c_start_wait+0x3a>
    	{    	    
    	    /* device busy, send stop condition to terminate write operation */
	        TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
     a9a:	46 bf       	out	0x36, r20	; 54
	        
	        // wait until stop condition is executed and bus released
	        while(TWCR & (1<<TWSTO));
     a9c:	06 b6       	in	r0, 0x36	; 54
     a9e:	04 fc       	sbrc	r0, 4
     aa0:	fd cf       	rjmp	.-6      	; 0xa9c <i2c_start_wait+0x32>
     aa2:	e6 cf       	rjmp	.-52     	; 0xa70 <i2c_start_wait+0x6>
     aa4:	08 95       	ret

00000aa6 <i2c_rep_start>:
 Return:  0 device accessible
          1 failed to access device
*************************************************************************/
unsigned char i2c_rep_start(unsigned char address)
{
    return i2c_start( address );
     aa6:	0e 94 17 05 	call	0xa2e	; 0xa2e <i2c_start>

}/* i2c_rep_start */
     aaa:	08 95       	ret

00000aac <i2c_stop>:
 Terminates the data transfer and releases the I2C bus
*************************************************************************/
void i2c_stop(void)
{
    /* send stop condition */
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
     aac:	84 e9       	ldi	r24, 0x94	; 148
     aae:	86 bf       	out	0x36, r24	; 54
	
	// wait until stop condition is executed and bus released
	while(TWCR & (1<<TWSTO));
     ab0:	06 b6       	in	r0, 0x36	; 54
     ab2:	04 fc       	sbrc	r0, 4
     ab4:	fd cf       	rjmp	.-6      	; 0xab0 <i2c_stop+0x4>

}/* i2c_stop */
     ab6:	08 95       	ret

00000ab8 <i2c_write>:
unsigned char i2c_write( unsigned char data )
{	
    uint8_t   twst;
    
	// send data to the previously addressed device
	TWDR = data;
     ab8:	83 b9       	out	0x03, r24	; 3
	TWCR = (1<<TWINT) | (1<<TWEN);
     aba:	84 e8       	ldi	r24, 0x84	; 132
     abc:	86 bf       	out	0x36, r24	; 54

	// wait until transmission completed
	while(!(TWCR & (1<<TWINT)));
     abe:	06 b6       	in	r0, 0x36	; 54
     ac0:	07 fe       	sbrs	r0, 7
     ac2:	fd cf       	rjmp	.-6      	; 0xabe <i2c_write+0x6>

	// check value of TWI Status Register. Mask prescaler bits
	twst = TW_STATUS & 0xF8;
     ac4:	91 b1       	in	r25, 0x01	; 1
     ac6:	98 7f       	andi	r25, 0xF8	; 248
	if( twst != TW_MT_DATA_ACK) return 1;
     ac8:	81 e0       	ldi	r24, 0x01	; 1
     aca:	98 32       	cpi	r25, 0x28	; 40
     acc:	09 f4       	brne	.+2      	; 0xad0 <i2c_write+0x18>
     ace:	80 e0       	ldi	r24, 0x00	; 0
	return 0;

}/* i2c_write */
     ad0:	08 95       	ret

00000ad2 <i2c_readAck>:
 
 Return:  byte read from I2C device
*************************************************************************/
unsigned char i2c_readAck(void)
{
	TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
     ad2:	84 ec       	ldi	r24, 0xC4	; 196
     ad4:	86 bf       	out	0x36, r24	; 54
	while(!(TWCR & (1<<TWINT)));    
     ad6:	06 b6       	in	r0, 0x36	; 54
     ad8:	07 fe       	sbrs	r0, 7
     ada:	fd cf       	rjmp	.-6      	; 0xad6 <i2c_readAck+0x4>

    return TWDR;
     adc:	83 b1       	in	r24, 0x03	; 3

}/* i2c_readAck */
     ade:	08 95       	ret

00000ae0 <i2c_readNak>:
 
 Return:  byte read from I2C device
*************************************************************************/
unsigned char i2c_readNak(void)
{
	TWCR = (1<<TWINT) | (1<<TWEN);
     ae0:	84 e8       	ldi	r24, 0x84	; 132
     ae2:	86 bf       	out	0x36, r24	; 54
	while(!(TWCR & (1<<TWINT)));
     ae4:	06 b6       	in	r0, 0x36	; 54
     ae6:	07 fe       	sbrs	r0, 7
     ae8:	fd cf       	rjmp	.-6      	; 0xae4 <i2c_readNak+0x4>
	
    return TWDR;
     aea:	83 b1       	in	r24, 0x03	; 3

}/* i2c_readNak */
     aec:	08 95       	ret

00000aee <main>:
void vApplicationIdleHook( void );

/*-----------------------------------------------------------*/

int main( void )
{  
     aee:	cf 93       	push	r28
     af0:	df 93       	push	r29
     af2:	00 d0       	rcall	.+0      	; 0xaf4 <main+0x6>
     af4:	00 d0       	rcall	.+0      	; 0xaf6 <main+0x8>
     af6:	cd b7       	in	r28, 0x3d	; 61
     af8:	de b7       	in	r29, 0x3e	; 62
	int32_t temperature = 0;
	int32_t pressure = 0;
	int16_t BMP085_calibration_int16_t[8];
	int16_t BMP085_calibration_uint16_t[3];
	uint8_t error_code=0;   
	volatile int32_t altitude=0;   
     afa:	19 82       	std	Y+1, r1	; 0x01
     afc:	1a 82       	std	Y+2, r1	; 0x02
     afe:	1b 82       	std	Y+3, r1	; 0x03
     b00:	1c 82       	std	Y+4, r1	; 0x04
    
    //Initialize TWI 1000Hz
    //i2cSetBitrate(1000);	
    //TWIM_Init(); 

    bmp085_init();
     b02:	0e 94 8e 04 	call	0x91c	; 0x91c <bmp085_init>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     b06:	8f ef       	ldi	r24, 0xFF	; 255
     b08:	90 e7       	ldi	r25, 0x70	; 112
     b0a:	a2 e0       	ldi	r26, 0x02	; 2
     b0c:	81 50       	subi	r24, 0x01	; 1
     b0e:	90 40       	sbci	r25, 0x00	; 0
     b10:	a0 40       	sbci	r26, 0x00	; 0
     b12:	e1 f7       	brne	.-8      	; 0xb0c <main+0x1e>
     b14:	00 c0       	rjmp	.+0      	; 0xb16 <main+0x28>
     b16:	00 00       	nop
     b18:	f6 cf       	rjmp	.-20     	; 0xb06 <main+0x18>

00000b1a <vApplicationIdleHook>:
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
	//vCoRoutineSchedule();
}
     b1a:	08 95       	ret

00000b1c <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     b1c:	af 92       	push	r10
     b1e:	bf 92       	push	r11
     b20:	cf 92       	push	r12
     b22:	df 92       	push	r13
     b24:	ef 92       	push	r14
     b26:	ff 92       	push	r15
     b28:	0f 93       	push	r16
     b2a:	1f 93       	push	r17
     b2c:	cf 93       	push	r28
     b2e:	df 93       	push	r29
     b30:	6c 01       	movw	r12, r24
     b32:	e6 2e       	mov	r14, r22
     b34:	f4 2e       	mov	r15, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     b36:	8a e1       	ldi	r24, 0x1A	; 26
     b38:	90 e0       	ldi	r25, 0x00	; 0
     b3a:	0e 94 01 08 	call	0x1002	; 0x1002 <pvPortMalloc>
     b3e:	8c 01       	movw	r16, r24
	if( pxCoRoutine )
     b40:	00 97       	sbiw	r24, 0x00	; 0
     b42:	09 f4       	brne	.+2      	; 0xb46 <xCoRoutineCreate+0x2a>
     b44:	62 c0       	rjmp	.+196    	; 0xc0a <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     b46:	80 91 de 00 	lds	r24, 0x00DE
     b4a:	90 91 df 00 	lds	r25, 0x00DF
     b4e:	00 97       	sbiw	r24, 0x00	; 0
     b50:	39 f5       	brne	.+78     	; 0xba0 <xCoRoutineCreate+0x84>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     b52:	10 93 df 00 	sts	0x00DF, r17
     b56:	00 93 de 00 	sts	0x00DE, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     b5a:	c1 ee       	ldi	r28, 0xE1	; 225
     b5c:	d0 e0       	ldi	r29, 0x00	; 0
     b5e:	ce 01       	movw	r24, r28
     b60:	0e 94 46 08 	call	0x108c	; 0x108c <vListInitialise>
     b64:	ce 01       	movw	r24, r28
     b66:	09 96       	adiw	r24, 0x09	; 9
     b68:	0e 94 46 08 	call	0x108c	; 0x108c <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     b6c:	c3 ef       	ldi	r28, 0xF3	; 243
     b6e:	d0 e0       	ldi	r29, 0x00	; 0
     b70:	ce 01       	movw	r24, r28
     b72:	0e 94 46 08 	call	0x108c	; 0x108c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     b76:	0f 2e       	mov	r0, r31
     b78:	fc ef       	ldi	r31, 0xFC	; 252
     b7a:	af 2e       	mov	r10, r31
     b7c:	f0 e0       	ldi	r31, 0x00	; 0
     b7e:	bf 2e       	mov	r11, r31
     b80:	f0 2d       	mov	r31, r0
     b82:	c5 01       	movw	r24, r10
     b84:	0e 94 46 08 	call	0x108c	; 0x108c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     b88:	85 e0       	ldi	r24, 0x05	; 5
     b8a:	91 e0       	ldi	r25, 0x01	; 1
     b8c:	0e 94 46 08 	call	0x108c	; 0x108c <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     b90:	d0 93 0f 01 	sts	0x010F, r29
     b94:	c0 93 0e 01 	sts	0x010E, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     b98:	b0 92 11 01 	sts	0x0111, r11
     b9c:	a0 92 10 01 	sts	0x0110, r10
     ba0:	ce 2d       	mov	r28, r14
     ba2:	e1 10       	cpse	r14, r1
     ba4:	c1 e0       	ldi	r28, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     ba6:	f8 01       	movw	r30, r16
     ba8:	11 8e       	std	Z+25, r1	; 0x19
     baa:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     bac:	c6 8b       	std	Z+22, r28	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     bae:	f7 8a       	std	Z+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     bb0:	c1 92       	st	Z+, r12
     bb2:	d1 92       	st	Z+, r13
     bb4:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     bb6:	cf 01       	movw	r24, r30
     bb8:	0e 94 54 08 	call	0x10a8	; 0x10a8 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     bbc:	c8 01       	movw	r24, r16
     bbe:	0c 96       	adiw	r24, 0x0c	; 12
     bc0:	0e 94 54 08 	call	0x10a8	; 0x10a8 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     bc4:	f8 01       	movw	r30, r16
     bc6:	11 87       	std	Z+9, r17	; 0x09
     bc8:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     bca:	13 8b       	std	Z+19, r17	; 0x13
     bcc:	02 8b       	std	Z+18, r16	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( uint32_t ) uxPriority );
     bce:	84 e0       	ldi	r24, 0x04	; 4
     bd0:	90 e0       	ldi	r25, 0x00	; 0
     bd2:	8c 1b       	sub	r24, r28
     bd4:	91 09       	sbc	r25, r1
     bd6:	95 87       	std	Z+13, r25	; 0x0d
     bd8:	84 87       	std	Z+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     bda:	86 89       	ldd	r24, Z+22	; 0x16
     bdc:	90 91 e0 00 	lds	r25, 0x00E0
     be0:	98 17       	cp	r25, r24
     be2:	10 f4       	brcc	.+4      	; 0xbe8 <xCoRoutineCreate+0xcc>
     be4:	80 93 e0 00 	sts	0x00E0, r24
     be8:	90 e0       	ldi	r25, 0x00	; 0
     bea:	9c 01       	movw	r18, r24
     bec:	22 0f       	add	r18, r18
     bee:	33 1f       	adc	r19, r19
     bf0:	22 0f       	add	r18, r18
     bf2:	33 1f       	adc	r19, r19
     bf4:	22 0f       	add	r18, r18
     bf6:	33 1f       	adc	r19, r19
     bf8:	82 0f       	add	r24, r18
     bfa:	93 1f       	adc	r25, r19
     bfc:	8f 51       	subi	r24, 0x1F	; 31
     bfe:	9f 4f       	sbci	r25, 0xFF	; 255
     c00:	b7 01       	movw	r22, r14
     c02:	0e 94 58 08 	call	0x10b0	; 0x10b0 <vListInsertEnd>

		xReturn = pdPASS;
     c06:	81 e0       	ldi	r24, 0x01	; 1
     c08:	01 c0       	rjmp	.+2      	; 0xc0c <xCoRoutineCreate+0xf0>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     c0a:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
     c0c:	df 91       	pop	r29
     c0e:	cf 91       	pop	r28
     c10:	1f 91       	pop	r17
     c12:	0f 91       	pop	r16
     c14:	ff 90       	pop	r15
     c16:	ef 90       	pop	r14
     c18:	df 90       	pop	r13
     c1a:	cf 90       	pop	r12
     c1c:	bf 90       	pop	r11
     c1e:	af 90       	pop	r10
     c20:	08 95       	ret

00000c22 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( uint32_t xTicksToDelay, xList *pxEventList )
{
     c22:	cf 92       	push	r12
     c24:	df 92       	push	r13
     c26:	ef 92       	push	r14
     c28:	ff 92       	push	r15
     c2a:	cf 93       	push	r28
     c2c:	df 93       	push	r29
     c2e:	dc 01       	movw	r26, r24
     c30:	cb 01       	movw	r24, r22
     c32:	ea 01       	movw	r28, r20
uint32_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     c34:	c0 90 12 01 	lds	r12, 0x0112
     c38:	d0 90 13 01 	lds	r13, 0x0113
     c3c:	e0 90 14 01 	lds	r14, 0x0114
     c40:	f0 90 15 01 	lds	r15, 0x0115
     c44:	c8 0e       	add	r12, r24
     c46:	d9 1e       	adc	r13, r25
     c48:	ea 1e       	adc	r14, r26
     c4a:	fb 1e       	adc	r15, r27

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     c4c:	80 91 de 00 	lds	r24, 0x00DE
     c50:	90 91 df 00 	lds	r25, 0x00DF
     c54:	02 96       	adiw	r24, 0x02	; 2
     c56:	0e 94 cb 08 	call	0x1196	; 0x1196 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     c5a:	e0 91 de 00 	lds	r30, 0x00DE
     c5e:	f0 91 df 00 	lds	r31, 0x00DF
     c62:	d3 82       	std	Z+3, r13	; 0x03
     c64:	c2 82       	std	Z+2, r12	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     c66:	80 91 12 01 	lds	r24, 0x0112
     c6a:	90 91 13 01 	lds	r25, 0x0113
     c6e:	a0 91 14 01 	lds	r26, 0x0114
     c72:	b0 91 15 01 	lds	r27, 0x0115
     c76:	c8 16       	cp	r12, r24
     c78:	d9 06       	cpc	r13, r25
     c7a:	ea 06       	cpc	r14, r26
     c7c:	fb 06       	cpc	r15, r27
     c7e:	50 f4       	brcc	.+20     	; 0xc94 <vCoRoutineAddToDelayedList+0x72>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     c80:	bf 01       	movw	r22, r30
     c82:	6e 5f       	subi	r22, 0xFE	; 254
     c84:	7f 4f       	sbci	r23, 0xFF	; 255
     c86:	80 91 10 01 	lds	r24, 0x0110
     c8a:	90 91 11 01 	lds	r25, 0x0111
     c8e:	0e 94 81 08 	call	0x1102	; 0x1102 <vListInsert>
     c92:	09 c0       	rjmp	.+18     	; 0xca6 <vCoRoutineAddToDelayedList+0x84>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     c94:	bf 01       	movw	r22, r30
     c96:	6e 5f       	subi	r22, 0xFE	; 254
     c98:	7f 4f       	sbci	r23, 0xFF	; 255
     c9a:	80 91 0e 01 	lds	r24, 0x010E
     c9e:	90 91 0f 01 	lds	r25, 0x010F
     ca2:	0e 94 81 08 	call	0x1102	; 0x1102 <vListInsert>
	}

	if( pxEventList )
     ca6:	20 97       	sbiw	r28, 0x00	; 0
     ca8:	49 f0       	breq	.+18     	; 0xcbc <vCoRoutineAddToDelayedList+0x9a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     caa:	60 91 de 00 	lds	r22, 0x00DE
     cae:	70 91 df 00 	lds	r23, 0x00DF
     cb2:	64 5f       	subi	r22, 0xF4	; 244
     cb4:	7f 4f       	sbci	r23, 0xFF	; 255
     cb6:	ce 01       	movw	r24, r28
     cb8:	0e 94 81 08 	call	0x1102	; 0x1102 <vListInsert>
	}
}
     cbc:	df 91       	pop	r29
     cbe:	cf 91       	pop	r28
     cc0:	ff 90       	pop	r15
     cc2:	ef 90       	pop	r14
     cc4:	df 90       	pop	r13
     cc6:	cf 90       	pop	r12
     cc8:	08 95       	ret

00000cca <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     cca:	cf 92       	push	r12
     ccc:	df 92       	push	r13
     cce:	ef 92       	push	r14
     cd0:	ff 92       	push	r15
     cd2:	0f 93       	push	r16
     cd4:	1f 93       	push	r17
     cd6:	cf 93       	push	r28
     cd8:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     cda:	80 91 05 01 	lds	r24, 0x0105
     cde:	88 23       	and	r24, r24
     ce0:	b9 f1       	breq	.+110    	; 0xd50 <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     ce2:	0f 2e       	mov	r0, r31
     ce4:	fa e0       	ldi	r31, 0x0A	; 10
     ce6:	ef 2e       	mov	r14, r31
     ce8:	f1 e0       	ldi	r31, 0x01	; 1
     cea:	ff 2e       	mov	r15, r31
     cec:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     cee:	0f 2e       	mov	r0, r31
     cf0:	f5 e0       	ldi	r31, 0x05	; 5
     cf2:	cf 2e       	mov	r12, r31
     cf4:	f1 e0       	ldi	r31, 0x01	; 1
     cf6:	df 2e       	mov	r13, r31
     cf8:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     cfa:	f8 94       	cli
		{
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     cfc:	d7 01       	movw	r26, r14
     cfe:	ed 91       	ld	r30, X+
     d00:	fc 91       	ld	r31, X
     d02:	c6 81       	ldd	r28, Z+6	; 0x06
     d04:	d7 81       	ldd	r29, Z+7	; 0x07
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     d06:	ce 01       	movw	r24, r28
     d08:	0c 96       	adiw	r24, 0x0c	; 12
     d0a:	0e 94 cb 08 	call	0x1196	; 0x1196 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     d0e:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     d10:	8e 01       	movw	r16, r28
     d12:	0e 5f       	subi	r16, 0xFE	; 254
     d14:	1f 4f       	sbci	r17, 0xFF	; 255
     d16:	c8 01       	movw	r24, r16
     d18:	0e 94 cb 08 	call	0x1196	; 0x1196 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     d1c:	8e 89       	ldd	r24, Y+22	; 0x16
     d1e:	90 91 e0 00 	lds	r25, 0x00E0
     d22:	98 17       	cp	r25, r24
     d24:	10 f4       	brcc	.+4      	; 0xd2a <vCoRoutineSchedule+0x60>
     d26:	80 93 e0 00 	sts	0x00E0, r24
     d2a:	90 e0       	ldi	r25, 0x00	; 0
     d2c:	9c 01       	movw	r18, r24
     d2e:	22 0f       	add	r18, r18
     d30:	33 1f       	adc	r19, r19
     d32:	22 0f       	add	r18, r18
     d34:	33 1f       	adc	r19, r19
     d36:	22 0f       	add	r18, r18
     d38:	33 1f       	adc	r19, r19
     d3a:	82 0f       	add	r24, r18
     d3c:	93 1f       	adc	r25, r19
     d3e:	8f 51       	subi	r24, 0x1F	; 31
     d40:	9f 4f       	sbci	r25, 0xFF	; 255
     d42:	b8 01       	movw	r22, r16
     d44:	0e 94 58 08 	call	0x10b0	; 0x10b0 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     d48:	f6 01       	movw	r30, r12
     d4a:	80 81       	ld	r24, Z
     d4c:	88 23       	and	r24, r24
     d4e:	a9 f6       	brne	.-86     	; 0xcfa <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     d50:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <xTaskGetTickCount>
     d54:	a0 e0       	ldi	r26, 0x00	; 0
     d56:	b0 e0       	ldi	r27, 0x00	; 0
     d58:	40 91 16 01 	lds	r20, 0x0116
     d5c:	50 91 17 01 	lds	r21, 0x0117
     d60:	60 91 18 01 	lds	r22, 0x0118
     d64:	70 91 19 01 	lds	r23, 0x0119
     d68:	84 1b       	sub	r24, r20
     d6a:	95 0b       	sbc	r25, r21
     d6c:	a6 0b       	sbc	r26, r22
     d6e:	b7 0b       	sbc	r27, r23
     d70:	80 93 1a 01 	sts	0x011A, r24
     d74:	90 93 1b 01 	sts	0x011B, r25
     d78:	a0 93 1c 01 	sts	0x011C, r26
     d7c:	b0 93 1d 01 	sts	0x011D, r27
     d80:	97 c0       	rjmp	.+302    	; 0xeb0 <vCoRoutineSchedule+0x1e6>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     d82:	40 91 12 01 	lds	r20, 0x0112
     d86:	50 91 13 01 	lds	r21, 0x0113
     d8a:	60 91 14 01 	lds	r22, 0x0114
     d8e:	70 91 15 01 	lds	r23, 0x0115
     d92:	4f 5f       	subi	r20, 0xFF	; 255
     d94:	5f 4f       	sbci	r21, 0xFF	; 255
     d96:	6f 4f       	sbci	r22, 0xFF	; 255
     d98:	7f 4f       	sbci	r23, 0xFF	; 255
     d9a:	40 93 12 01 	sts	0x0112, r20
     d9e:	50 93 13 01 	sts	0x0113, r21
     da2:	60 93 14 01 	sts	0x0114, r22
     da6:	70 93 15 01 	sts	0x0115, r23
		xPassedTicks--;
     daa:	01 97       	sbiw	r24, 0x01	; 1
     dac:	a1 09       	sbc	r26, r1
     dae:	b1 09       	sbc	r27, r1
     db0:	80 93 1a 01 	sts	0x011A, r24
     db4:	90 93 1b 01 	sts	0x011B, r25
     db8:	a0 93 1c 01 	sts	0x011C, r26
     dbc:	b0 93 1d 01 	sts	0x011D, r27

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     dc0:	41 15       	cp	r20, r1
     dc2:	51 05       	cpc	r21, r1
     dc4:	61 05       	cpc	r22, r1
     dc6:	71 05       	cpc	r23, r1
     dc8:	81 f4       	brne	.+32     	; 0xdea <vCoRoutineSchedule+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     dca:	80 91 0e 01 	lds	r24, 0x010E
     dce:	90 91 0f 01 	lds	r25, 0x010F
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     dd2:	20 91 10 01 	lds	r18, 0x0110
     dd6:	30 91 11 01 	lds	r19, 0x0111
     dda:	30 93 0f 01 	sts	0x010F, r19
     dde:	20 93 0e 01 	sts	0x010E, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
     de2:	90 93 11 01 	sts	0x0111, r25
     de6:	80 93 10 01 	sts	0x0110, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     dea:	e0 91 0e 01 	lds	r30, 0x010E
     dee:	f0 91 0f 01 	lds	r31, 0x010F
     df2:	80 81       	ld	r24, Z
     df4:	88 23       	and	r24, r24
     df6:	09 f4       	brne	.+2      	; 0xdfa <vCoRoutineSchedule+0x130>
     df8:	5b c0       	rjmp	.+182    	; 0xeb0 <vCoRoutineSchedule+0x1e6>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     dfa:	05 80       	ldd	r0, Z+5	; 0x05
     dfc:	f6 81       	ldd	r31, Z+6	; 0x06
     dfe:	e0 2d       	mov	r30, r0
     e00:	c6 81       	ldd	r28, Z+6	; 0x06
     e02:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     e04:	4a 81       	ldd	r20, Y+2	; 0x02
     e06:	5b 81       	ldd	r21, Y+3	; 0x03
     e08:	60 e0       	ldi	r22, 0x00	; 0
     e0a:	70 e0       	ldi	r23, 0x00	; 0
     e0c:	80 91 12 01 	lds	r24, 0x0112
     e10:	90 91 13 01 	lds	r25, 0x0113
     e14:	a0 91 14 01 	lds	r26, 0x0114
     e18:	b0 91 15 01 	lds	r27, 0x0115
     e1c:	84 17       	cp	r24, r20
     e1e:	95 07       	cpc	r25, r21
     e20:	a6 07       	cpc	r26, r22
     e22:	b7 07       	cpc	r27, r23
     e24:	b8 f4       	brcc	.+46     	; 0xe54 <vCoRoutineSchedule+0x18a>
     e26:	44 c0       	rjmp	.+136    	; 0xeb0 <vCoRoutineSchedule+0x1e6>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     e28:	05 80       	ldd	r0, Z+5	; 0x05
     e2a:	f6 81       	ldd	r31, Z+6	; 0x06
     e2c:	e0 2d       	mov	r30, r0
     e2e:	c6 81       	ldd	r28, Z+6	; 0x06
     e30:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     e32:	4a 81       	ldd	r20, Y+2	; 0x02
     e34:	5b 81       	ldd	r21, Y+3	; 0x03
     e36:	60 e0       	ldi	r22, 0x00	; 0
     e38:	70 e0       	ldi	r23, 0x00	; 0
     e3a:	80 91 12 01 	lds	r24, 0x0112
     e3e:	90 91 13 01 	lds	r25, 0x0113
     e42:	a0 91 14 01 	lds	r26, 0x0114
     e46:	b0 91 15 01 	lds	r27, 0x0115
     e4a:	84 17       	cp	r24, r20
     e4c:	95 07       	cpc	r25, r21
     e4e:	a6 07       	cpc	r26, r22
     e50:	b7 07       	cpc	r27, r23
     e52:	70 f1       	brcs	.+92     	; 0xeb0 <vCoRoutineSchedule+0x1e6>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
     e54:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );
     e56:	8e 01       	movw	r16, r28
     e58:	0e 5f       	subi	r16, 0xFE	; 254
     e5a:	1f 4f       	sbci	r17, 0xFF	; 255
     e5c:	c8 01       	movw	r24, r16
     e5e:	0e 94 cb 08 	call	0x1196	; 0x1196 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
     e62:	8c 89       	ldd	r24, Y+20	; 0x14
     e64:	9d 89       	ldd	r25, Y+21	; 0x15
     e66:	00 97       	sbiw	r24, 0x00	; 0
     e68:	21 f0       	breq	.+8      	; 0xe72 <vCoRoutineSchedule+0x1a8>
				{
					uxListRemove( &( pxCRCB->xEventListItem ) );
     e6a:	ce 01       	movw	r24, r28
     e6c:	0c 96       	adiw	r24, 0x0c	; 12
     e6e:	0e 94 cb 08 	call	0x1196	; 0x1196 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     e72:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
     e74:	8e 89       	ldd	r24, Y+22	; 0x16
     e76:	90 91 e0 00 	lds	r25, 0x00E0
     e7a:	98 17       	cp	r25, r24
     e7c:	10 f4       	brcc	.+4      	; 0xe82 <vCoRoutineSchedule+0x1b8>
     e7e:	80 93 e0 00 	sts	0x00E0, r24
     e82:	90 e0       	ldi	r25, 0x00	; 0
     e84:	9c 01       	movw	r18, r24
     e86:	22 0f       	add	r18, r18
     e88:	33 1f       	adc	r19, r19
     e8a:	22 0f       	add	r18, r18
     e8c:	33 1f       	adc	r19, r19
     e8e:	22 0f       	add	r18, r18
     e90:	33 1f       	adc	r19, r19
     e92:	82 0f       	add	r24, r18
     e94:	93 1f       	adc	r25, r19
     e96:	8f 51       	subi	r24, 0x1F	; 31
     e98:	9f 4f       	sbci	r25, 0xFF	; 255
     e9a:	b8 01       	movw	r22, r16
     e9c:	0e 94 58 08 	call	0x10b0	; 0x10b0 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     ea0:	e0 91 0e 01 	lds	r30, 0x010E
     ea4:	f0 91 0f 01 	lds	r31, 0x010F
     ea8:	80 81       	ld	r24, Z
     eaa:	88 23       	and	r24, r24
     eac:	09 f0       	breq	.+2      	; 0xeb0 <vCoRoutineSchedule+0x1e6>
     eae:	bc cf       	rjmp	.-136    	; 0xe28 <vCoRoutineSchedule+0x15e>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     eb0:	80 91 1a 01 	lds	r24, 0x011A
     eb4:	90 91 1b 01 	lds	r25, 0x011B
     eb8:	a0 91 1c 01 	lds	r26, 0x011C
     ebc:	b0 91 1d 01 	lds	r27, 0x011D
     ec0:	00 97       	sbiw	r24, 0x00	; 0
     ec2:	a1 05       	cpc	r26, r1
     ec4:	b1 05       	cpc	r27, r1
     ec6:	09 f0       	breq	.+2      	; 0xeca <vCoRoutineSchedule+0x200>
     ec8:	5c cf       	rjmp	.-328    	; 0xd82 <vCoRoutineSchedule+0xb8>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
     eca:	80 91 12 01 	lds	r24, 0x0112
     ece:	90 91 13 01 	lds	r25, 0x0113
     ed2:	a0 91 14 01 	lds	r26, 0x0114
     ed6:	b0 91 15 01 	lds	r27, 0x0115
     eda:	80 93 16 01 	sts	0x0116, r24
     ede:	90 93 17 01 	sts	0x0117, r25
     ee2:	a0 93 18 01 	sts	0x0118, r26
     ee6:	b0 93 19 01 	sts	0x0119, r27

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     eea:	20 91 e0 00 	lds	r18, 0x00E0
     eee:	82 2f       	mov	r24, r18
     ef0:	90 e0       	ldi	r25, 0x00	; 0
     ef2:	fc 01       	movw	r30, r24
     ef4:	ee 0f       	add	r30, r30
     ef6:	ff 1f       	adc	r31, r31
     ef8:	ee 0f       	add	r30, r30
     efa:	ff 1f       	adc	r31, r31
     efc:	ee 0f       	add	r30, r30
     efe:	ff 1f       	adc	r31, r31
     f00:	e8 0f       	add	r30, r24
     f02:	f9 1f       	adc	r31, r25
     f04:	ef 51       	subi	r30, 0x1F	; 31
     f06:	ff 4f       	sbci	r31, 0xFF	; 255
     f08:	30 81       	ld	r19, Z
     f0a:	33 23       	and	r19, r19
     f0c:	d9 f4       	brne	.+54     	; 0xf44 <vCoRoutineSchedule+0x27a>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     f0e:	22 23       	and	r18, r18
     f10:	31 f4       	brne	.+12     	; 0xf1e <vCoRoutineSchedule+0x254>
     f12:	47 c0       	rjmp	.+142    	; 0xfa2 <vCoRoutineSchedule+0x2d8>
     f14:	22 23       	and	r18, r18
     f16:	19 f4       	brne	.+6      	; 0xf1e <vCoRoutineSchedule+0x254>
     f18:	20 93 e0 00 	sts	0x00E0, r18
     f1c:	42 c0       	rjmp	.+132    	; 0xfa2 <vCoRoutineSchedule+0x2d8>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     f1e:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     f20:	82 2f       	mov	r24, r18
     f22:	90 e0       	ldi	r25, 0x00	; 0
     f24:	fc 01       	movw	r30, r24
     f26:	ee 0f       	add	r30, r30
     f28:	ff 1f       	adc	r31, r31
     f2a:	ee 0f       	add	r30, r30
     f2c:	ff 1f       	adc	r31, r31
     f2e:	ee 0f       	add	r30, r30
     f30:	ff 1f       	adc	r31, r31
     f32:	e8 0f       	add	r30, r24
     f34:	f9 1f       	adc	r31, r25
     f36:	ef 51       	subi	r30, 0x1F	; 31
     f38:	ff 4f       	sbci	r31, 0xFF	; 255
     f3a:	30 81       	ld	r19, Z
     f3c:	33 23       	and	r19, r19
     f3e:	51 f3       	breq	.-44     	; 0xf14 <vCoRoutineSchedule+0x24a>
     f40:	20 93 e0 00 	sts	0x00E0, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     f44:	fc 01       	movw	r30, r24
     f46:	ee 0f       	add	r30, r30
     f48:	ff 1f       	adc	r31, r31
     f4a:	ee 0f       	add	r30, r30
     f4c:	ff 1f       	adc	r31, r31
     f4e:	ee 0f       	add	r30, r30
     f50:	ff 1f       	adc	r31, r31
     f52:	8e 0f       	add	r24, r30
     f54:	9f 1f       	adc	r25, r31
     f56:	fc 01       	movw	r30, r24
     f58:	ef 51       	subi	r30, 0x1F	; 31
     f5a:	ff 4f       	sbci	r31, 0xFF	; 255
     f5c:	a1 81       	ldd	r26, Z+1	; 0x01
     f5e:	b2 81       	ldd	r27, Z+2	; 0x02
     f60:	12 96       	adiw	r26, 0x02	; 2
     f62:	0d 90       	ld	r0, X+
     f64:	bc 91       	ld	r27, X
     f66:	a0 2d       	mov	r26, r0
     f68:	b2 83       	std	Z+2, r27	; 0x02
     f6a:	a1 83       	std	Z+1, r26	; 0x01
     f6c:	cf 01       	movw	r24, r30
     f6e:	03 96       	adiw	r24, 0x03	; 3
     f70:	a8 17       	cp	r26, r24
     f72:	b9 07       	cpc	r27, r25
     f74:	31 f4       	brne	.+12     	; 0xf82 <vCoRoutineSchedule+0x2b8>
     f76:	12 96       	adiw	r26, 0x02	; 2
     f78:	8d 91       	ld	r24, X+
     f7a:	9c 91       	ld	r25, X
     f7c:	13 97       	sbiw	r26, 0x03	; 3
     f7e:	92 83       	std	Z+2, r25	; 0x02
     f80:	81 83       	std	Z+1, r24	; 0x01
     f82:	01 80       	ldd	r0, Z+1	; 0x01
     f84:	f2 81       	ldd	r31, Z+2	; 0x02
     f86:	e0 2d       	mov	r30, r0
     f88:	a6 81       	ldd	r26, Z+6	; 0x06
     f8a:	b7 81       	ldd	r27, Z+7	; 0x07
     f8c:	b0 93 df 00 	sts	0x00DF, r27
     f90:	a0 93 de 00 	sts	0x00DE, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     f94:	ed 91       	ld	r30, X+
     f96:	fc 91       	ld	r31, X
     f98:	11 97       	sbiw	r26, 0x01	; 1
     f9a:	cd 01       	movw	r24, r26
     f9c:	57 96       	adiw	r26, 0x17	; 23
     f9e:	6c 91       	ld	r22, X
     fa0:	09 95       	icall

	return;
}
     fa2:	df 91       	pop	r29
     fa4:	cf 91       	pop	r28
     fa6:	1f 91       	pop	r17
     fa8:	0f 91       	pop	r16
     faa:	ff 90       	pop	r15
     fac:	ef 90       	pop	r14
     fae:	df 90       	pop	r13
     fb0:	cf 90       	pop	r12
     fb2:	08 95       	ret

00000fb4 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     fb4:	0f 93       	push	r16
     fb6:	1f 93       	push	r17
     fb8:	cf 93       	push	r28
     fba:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     fbc:	dc 01       	movw	r26, r24
     fbe:	15 96       	adiw	r26, 0x05	; 5
     fc0:	ed 91       	ld	r30, X+
     fc2:	fc 91       	ld	r31, X
     fc4:	16 97       	sbiw	r26, 0x06	; 6
     fc6:	06 81       	ldd	r16, Z+6	; 0x06
     fc8:	17 81       	ldd	r17, Z+7	; 0x07
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     fca:	e8 01       	movw	r28, r16
     fcc:	2c 96       	adiw	r28, 0x0c	; 12
     fce:	ce 01       	movw	r24, r28
     fd0:	0e 94 cb 08 	call	0x1196	; 0x1196 <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     fd4:	85 e0       	ldi	r24, 0x05	; 5
     fd6:	91 e0       	ldi	r25, 0x01	; 1
     fd8:	be 01       	movw	r22, r28
     fda:	0e 94 58 08 	call	0x10b0	; 0x10b0 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     fde:	e0 91 de 00 	lds	r30, 0x00DE
     fe2:	f0 91 df 00 	lds	r31, 0x00DF
	{
		xReturn = pdTRUE;
     fe6:	81 e0       	ldi	r24, 0x01	; 1
     fe8:	d8 01       	movw	r26, r16
     fea:	56 96       	adiw	r26, 0x16	; 22
     fec:	2c 91       	ld	r18, X
     fee:	56 97       	sbiw	r26, 0x16	; 22
     ff0:	96 89       	ldd	r25, Z+22	; 0x16
     ff2:	29 17       	cp	r18, r25
     ff4:	08 f4       	brcc	.+2      	; 0xff8 <xCoRoutineRemoveFromEventList+0x44>
     ff6:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     ff8:	df 91       	pop	r29
     ffa:	cf 91       	pop	r28
     ffc:	1f 91       	pop	r17
     ffe:	0f 91       	pop	r16
    1000:	08 95       	ret

00001002 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1002:	cf 93       	push	r28
    1004:	df 93       	push	r29
    1006:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1008:	0e 94 59 0f 	call	0x1eb2	; 0x1eb2 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    100c:	80 91 1e 01 	lds	r24, 0x011E
    1010:	90 91 1f 01 	lds	r25, 0x011F
    1014:	00 97       	sbiw	r24, 0x00	; 0
    1016:	31 f4       	brne	.+12     	; 0x1024 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    1018:	81 e2       	ldi	r24, 0x21	; 33
    101a:	91 e0       	ldi	r25, 0x01	; 1
    101c:	90 93 1f 01 	sts	0x011F, r25
    1020:	80 93 1e 01 	sts	0x011E, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1024:	20 91 d0 05 	lds	r18, 0x05D0
    1028:	30 91 d1 05 	lds	r19, 0x05D1
    102c:	ce 01       	movw	r24, r28
    102e:	82 0f       	add	r24, r18
    1030:	93 1f       	adc	r25, r19
    1032:	44 e0       	ldi	r20, 0x04	; 4
    1034:	8f 3a       	cpi	r24, 0xAF	; 175
    1036:	94 07       	cpc	r25, r20
    1038:	70 f4       	brcc	.+28     	; 0x1056 <pvPortMalloc+0x54>
    103a:	28 17       	cp	r18, r24
    103c:	39 07       	cpc	r19, r25
    103e:	70 f4       	brcc	.+28     	; 0x105c <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1040:	c0 91 1e 01 	lds	r28, 0x011E
    1044:	d0 91 1f 01 	lds	r29, 0x011F
    1048:	c2 0f       	add	r28, r18
    104a:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    104c:	90 93 d1 05 	sts	0x05D1, r25
    1050:	80 93 d0 05 	sts	0x05D0, r24
    1054:	05 c0       	rjmp	.+10     	; 0x1060 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1056:	c0 e0       	ldi	r28, 0x00	; 0
    1058:	d0 e0       	ldi	r29, 0x00	; 0
    105a:	02 c0       	rjmp	.+4      	; 0x1060 <pvPortMalloc+0x5e>
    105c:	c0 e0       	ldi	r28, 0x00	; 0
    105e:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
			xNextFreeByte += xWantedSize;
		}
	}
	xTaskResumeAll();
    1060:	0e 94 40 10 	call	0x2080	; 0x2080 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1064:	8c 2f       	mov	r24, r28
    1066:	9d 2f       	mov	r25, r29
    1068:	df 91       	pop	r29
    106a:	cf 91       	pop	r28
    106c:	08 95       	ret

0000106e <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    106e:	08 95       	ret

00001070 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1070:	10 92 d1 05 	sts	0x05D1, r1
    1074:	10 92 d0 05 	sts	0x05D0, r1
}
    1078:	08 95       	ret

0000107a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    107a:	20 91 d0 05 	lds	r18, 0x05D0
    107e:	30 91 d1 05 	lds	r19, 0x05D1
    1082:	8f ea       	ldi	r24, 0xAF	; 175
    1084:	94 e0       	ldi	r25, 0x04	; 4
    1086:	82 1b       	sub	r24, r18
    1088:	93 0b       	sbc	r25, r19
}
    108a:	08 95       	ret

0000108c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    108c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    108e:	03 96       	adiw	r24, 0x03	; 3
    1090:	92 83       	std	Z+2, r25	; 0x02
    1092:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1094:	2f ef       	ldi	r18, 0xFF	; 255
    1096:	3f ef       	ldi	r19, 0xFF	; 255
    1098:	34 83       	std	Z+4, r19	; 0x04
    109a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    109c:	96 83       	std	Z+6, r25	; 0x06
    109e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    10a0:	90 87       	std	Z+8, r25	; 0x08
    10a2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    10a4:	10 82       	st	Z, r1
}
    10a6:	08 95       	ret

000010a8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    10a8:	fc 01       	movw	r30, r24
    10aa:	11 86       	std	Z+9, r1	; 0x09
    10ac:	10 86       	std	Z+8, r1	; 0x08
}
    10ae:	08 95       	ret

000010b0 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    10b0:	cf 93       	push	r28
    10b2:	df 93       	push	r29
    10b4:	ec 01       	movw	r28, r24
    10b6:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    10b8:	89 81       	ldd	r24, Y+1	; 0x01
    10ba:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    10bc:	dc 01       	movw	r26, r24
    10be:	12 96       	adiw	r26, 0x02	; 2
    10c0:	2d 91       	ld	r18, X+
    10c2:	3c 91       	ld	r19, X
    10c4:	13 97       	sbiw	r26, 0x03	; 3
    10c6:	33 83       	std	Z+3, r19	; 0x03
    10c8:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    10ca:	29 81       	ldd	r18, Y+1	; 0x01
    10cc:	3a 81       	ldd	r19, Y+2	; 0x02
    10ce:	35 83       	std	Z+5, r19	; 0x05
    10d0:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    10d2:	12 96       	adiw	r26, 0x02	; 2
    10d4:	2d 91       	ld	r18, X+
    10d6:	3c 91       	ld	r19, X
    10d8:	13 97       	sbiw	r26, 0x03	; 3
    10da:	d9 01       	movw	r26, r18
    10dc:	15 96       	adiw	r26, 0x05	; 5
    10de:	7c 93       	st	X, r23
    10e0:	6e 93       	st	-X, r22
    10e2:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    10e4:	dc 01       	movw	r26, r24
    10e6:	13 96       	adiw	r26, 0x03	; 3
    10e8:	7c 93       	st	X, r23
    10ea:	6e 93       	st	-X, r22
    10ec:	12 97       	sbiw	r26, 0x02	; 2
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    10ee:	7a 83       	std	Y+2, r23	; 0x02
    10f0:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    10f2:	d1 87       	std	Z+9, r29	; 0x09
    10f4:	c0 87       	std	Z+8, r28	; 0x08

	( pxList->uxNumberOfItems )++;
    10f6:	88 81       	ld	r24, Y
    10f8:	8f 5f       	subi	r24, 0xFF	; 255
    10fa:	88 83       	st	Y, r24
}
    10fc:	df 91       	pop	r29
    10fe:	cf 91       	pop	r28
    1100:	08 95       	ret

00001102 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1102:	cf 93       	push	r28
    1104:	df 93       	push	r29
    1106:	9c 01       	movw	r18, r24
    1108:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
uint32_t xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    110a:	48 81       	ld	r20, Y
    110c:	59 81       	ldd	r21, Y+1	; 0x01
    110e:	60 e0       	ldi	r22, 0x00	; 0
    1110:	70 e0       	ldi	r23, 0x00	; 0
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1112:	4f 3f       	cpi	r20, 0xFF	; 255
    1114:	8f ef       	ldi	r24, 0xFF	; 255
    1116:	58 07       	cpc	r21, r24
    1118:	80 e0       	ldi	r24, 0x00	; 0
    111a:	68 07       	cpc	r22, r24
    111c:	80 e0       	ldi	r24, 0x00	; 0
    111e:	78 07       	cpc	r23, r24
    1120:	31 f4       	brne	.+12     	; 0x112e <vListInsert+0x2c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1122:	d9 01       	movw	r26, r18
    1124:	17 96       	adiw	r26, 0x07	; 7
    1126:	ed 91       	ld	r30, X+
    1128:	fc 91       	ld	r31, X
    112a:	18 97       	sbiw	r26, 0x08	; 8
    112c:	1f c0       	rjmp	.+62     	; 0x116c <vListInsert+0x6a>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    112e:	f9 01       	movw	r30, r18
    1130:	33 96       	adiw	r30, 0x03	; 3
    1132:	d9 01       	movw	r26, r18
    1134:	15 96       	adiw	r26, 0x05	; 5
    1136:	8d 91       	ld	r24, X+
    1138:	9c 91       	ld	r25, X
    113a:	16 97       	sbiw	r26, 0x06	; 6
    113c:	dc 01       	movw	r26, r24
    113e:	8d 91       	ld	r24, X+
    1140:	9c 91       	ld	r25, X
    1142:	a0 e0       	ldi	r26, 0x00	; 0
    1144:	b0 e0       	ldi	r27, 0x00	; 0
    1146:	48 17       	cp	r20, r24
    1148:	59 07       	cpc	r21, r25
    114a:	6a 07       	cpc	r22, r26
    114c:	7b 07       	cpc	r23, r27
    114e:	70 f0       	brcs	.+28     	; 0x116c <vListInsert+0x6a>
    1150:	02 80       	ldd	r0, Z+2	; 0x02
    1152:	f3 81       	ldd	r31, Z+3	; 0x03
    1154:	e0 2d       	mov	r30, r0
    1156:	a2 81       	ldd	r26, Z+2	; 0x02
    1158:	b3 81       	ldd	r27, Z+3	; 0x03
    115a:	8d 91       	ld	r24, X+
    115c:	9c 91       	ld	r25, X
    115e:	a0 e0       	ldi	r26, 0x00	; 0
    1160:	b0 e0       	ldi	r27, 0x00	; 0
    1162:	48 17       	cp	r20, r24
    1164:	59 07       	cpc	r21, r25
    1166:	6a 07       	cpc	r22, r26
    1168:	7b 07       	cpc	r23, r27
    116a:	90 f7       	brcc	.-28     	; 0x1150 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    116c:	a2 81       	ldd	r26, Z+2	; 0x02
    116e:	b3 81       	ldd	r27, Z+3	; 0x03
    1170:	bb 83       	std	Y+3, r27	; 0x03
    1172:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1174:	15 96       	adiw	r26, 0x05	; 5
    1176:	dc 93       	st	X, r29
    1178:	ce 93       	st	-X, r28
    117a:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
    117c:	fd 83       	std	Y+5, r31	; 0x05
    117e:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1180:	d3 83       	std	Z+3, r29	; 0x03
    1182:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1184:	39 87       	std	Y+9, r19	; 0x09
    1186:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1188:	f9 01       	movw	r30, r18
    118a:	80 81       	ld	r24, Z
    118c:	8f 5f       	subi	r24, 0xFF	; 255
    118e:	80 83       	st	Z, r24
}
    1190:	df 91       	pop	r29
    1192:	cf 91       	pop	r28
    1194:	08 95       	ret

00001196 <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
    1196:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1198:	a2 81       	ldd	r26, Z+2	; 0x02
    119a:	b3 81       	ldd	r27, Z+3	; 0x03
    119c:	84 81       	ldd	r24, Z+4	; 0x04
    119e:	95 81       	ldd	r25, Z+5	; 0x05
    11a0:	15 96       	adiw	r26, 0x05	; 5
    11a2:	9c 93       	st	X, r25
    11a4:	8e 93       	st	-X, r24
    11a6:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    11a8:	a4 81       	ldd	r26, Z+4	; 0x04
    11aa:	b5 81       	ldd	r27, Z+5	; 0x05
    11ac:	82 81       	ldd	r24, Z+2	; 0x02
    11ae:	93 81       	ldd	r25, Z+3	; 0x03
    11b0:	13 96       	adiw	r26, 0x03	; 3
    11b2:	9c 93       	st	X, r25
    11b4:	8e 93       	st	-X, r24
    11b6:	12 97       	sbiw	r26, 0x02	; 2

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    11b8:	a0 85       	ldd	r26, Z+8	; 0x08
    11ba:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    11bc:	11 96       	adiw	r26, 0x01	; 1
    11be:	8d 91       	ld	r24, X+
    11c0:	9c 91       	ld	r25, X
    11c2:	12 97       	sbiw	r26, 0x02	; 2
    11c4:	8e 17       	cp	r24, r30
    11c6:	9f 07       	cpc	r25, r31
    11c8:	31 f4       	brne	.+12     	; 0x11d6 <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    11ca:	84 81       	ldd	r24, Z+4	; 0x04
    11cc:	95 81       	ldd	r25, Z+5	; 0x05
    11ce:	12 96       	adiw	r26, 0x02	; 2
    11d0:	9c 93       	st	X, r25
    11d2:	8e 93       	st	-X, r24
    11d4:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    11d6:	11 86       	std	Z+9, r1	; 0x09
    11d8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    11da:	8c 91       	ld	r24, X
    11dc:	81 50       	subi	r24, 0x01	; 1
    11de:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    11e0:	8c 91       	ld	r24, X
}
    11e2:	08 95       	ret

000011e4 <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    11e4:	21 e1       	ldi	r18, 0x11	; 17
    11e6:	fc 01       	movw	r30, r24
    11e8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    11ea:	31 97       	sbiw	r30, 0x01	; 1
    11ec:	32 e2       	ldi	r19, 0x22	; 34
    11ee:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    11f0:	fc 01       	movw	r30, r24
    11f2:	32 97       	sbiw	r30, 0x02	; 2
    11f4:	a3 e3       	ldi	r26, 0x33	; 51
    11f6:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    11f8:	fc 01       	movw	r30, r24
    11fa:	33 97       	sbiw	r30, 0x03	; 3
    11fc:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    11fe:	fc 01       	movw	r30, r24
    1200:	34 97       	sbiw	r30, 0x04	; 4
    1202:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    1204:	fc 01       	movw	r30, r24
    1206:	35 97       	sbiw	r30, 0x05	; 5
    1208:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    120a:	fc 01       	movw	r30, r24
    120c:	36 97       	sbiw	r30, 0x06	; 6
    120e:	60 e8       	ldi	r22, 0x80	; 128
    1210:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    1212:	fc 01       	movw	r30, r24
    1214:	37 97       	sbiw	r30, 0x07	; 7
    1216:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    1218:	fc 01       	movw	r30, r24
    121a:	38 97       	sbiw	r30, 0x08	; 8
    121c:	62 e0       	ldi	r22, 0x02	; 2
    121e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    1220:	fc 01       	movw	r30, r24
    1222:	39 97       	sbiw	r30, 0x09	; 9
    1224:	63 e0       	ldi	r22, 0x03	; 3
    1226:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1228:	fc 01       	movw	r30, r24
    122a:	3a 97       	sbiw	r30, 0x0a	; 10
    122c:	64 e0       	ldi	r22, 0x04	; 4
    122e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1230:	fc 01       	movw	r30, r24
    1232:	3b 97       	sbiw	r30, 0x0b	; 11
    1234:	65 e0       	ldi	r22, 0x05	; 5
    1236:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    1238:	fc 01       	movw	r30, r24
    123a:	3c 97       	sbiw	r30, 0x0c	; 12
    123c:	66 e0       	ldi	r22, 0x06	; 6
    123e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    1240:	fc 01       	movw	r30, r24
    1242:	3d 97       	sbiw	r30, 0x0d	; 13
    1244:	67 e0       	ldi	r22, 0x07	; 7
    1246:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1248:	fc 01       	movw	r30, r24
    124a:	3e 97       	sbiw	r30, 0x0e	; 14
    124c:	68 e0       	ldi	r22, 0x08	; 8
    124e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1250:	fc 01       	movw	r30, r24
    1252:	3f 97       	sbiw	r30, 0x0f	; 15
    1254:	69 e0       	ldi	r22, 0x09	; 9
    1256:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1258:	fc 01       	movw	r30, r24
    125a:	70 97       	sbiw	r30, 0x10	; 16
    125c:	60 e1       	ldi	r22, 0x10	; 16
    125e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1260:	fc 01       	movw	r30, r24
    1262:	71 97       	sbiw	r30, 0x11	; 17
    1264:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1266:	fc 01       	movw	r30, r24
    1268:	72 97       	sbiw	r30, 0x12	; 18
    126a:	22 e1       	ldi	r18, 0x12	; 18
    126c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    126e:	fc 01       	movw	r30, r24
    1270:	73 97       	sbiw	r30, 0x13	; 19
    1272:	23 e1       	ldi	r18, 0x13	; 19
    1274:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1276:	fc 01       	movw	r30, r24
    1278:	74 97       	sbiw	r30, 0x14	; 20
    127a:	24 e1       	ldi	r18, 0x14	; 20
    127c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    127e:	fc 01       	movw	r30, r24
    1280:	75 97       	sbiw	r30, 0x15	; 21
    1282:	25 e1       	ldi	r18, 0x15	; 21
    1284:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1286:	fc 01       	movw	r30, r24
    1288:	76 97       	sbiw	r30, 0x16	; 22
    128a:	26 e1       	ldi	r18, 0x16	; 22
    128c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    128e:	fc 01       	movw	r30, r24
    1290:	77 97       	sbiw	r30, 0x17	; 23
    1292:	27 e1       	ldi	r18, 0x17	; 23
    1294:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1296:	fc 01       	movw	r30, r24
    1298:	78 97       	sbiw	r30, 0x18	; 24
    129a:	28 e1       	ldi	r18, 0x18	; 24
    129c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    129e:	fc 01       	movw	r30, r24
    12a0:	79 97       	sbiw	r30, 0x19	; 25
    12a2:	29 e1       	ldi	r18, 0x19	; 25
    12a4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    12a6:	fc 01       	movw	r30, r24
    12a8:	7a 97       	sbiw	r30, 0x1a	; 26
    12aa:	20 e2       	ldi	r18, 0x20	; 32
    12ac:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    12ae:	fc 01       	movw	r30, r24
    12b0:	7b 97       	sbiw	r30, 0x1b	; 27
    12b2:	21 e2       	ldi	r18, 0x21	; 33
    12b4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    12b6:	fc 01       	movw	r30, r24
    12b8:	7c 97       	sbiw	r30, 0x1c	; 28
    12ba:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    12bc:	fc 01       	movw	r30, r24
    12be:	7d 97       	sbiw	r30, 0x1d	; 29
    12c0:	23 e2       	ldi	r18, 0x23	; 35
    12c2:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    12c4:	fc 01       	movw	r30, r24
    12c6:	7e 97       	sbiw	r30, 0x1e	; 30
    12c8:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    12ca:	fc 01       	movw	r30, r24
    12cc:	7f 97       	sbiw	r30, 0x1f	; 31
    12ce:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    12d0:	fc 01       	movw	r30, r24
    12d2:	b0 97       	sbiw	r30, 0x20	; 32
    12d4:	26 e2       	ldi	r18, 0x26	; 38
    12d6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    12d8:	fc 01       	movw	r30, r24
    12da:	b1 97       	sbiw	r30, 0x21	; 33
    12dc:	27 e2       	ldi	r18, 0x27	; 39
    12de:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    12e0:	fc 01       	movw	r30, r24
    12e2:	b2 97       	sbiw	r30, 0x22	; 34
    12e4:	28 e2       	ldi	r18, 0x28	; 40
    12e6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    12e8:	fc 01       	movw	r30, r24
    12ea:	b3 97       	sbiw	r30, 0x23	; 35
    12ec:	29 e2       	ldi	r18, 0x29	; 41
    12ee:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    12f0:	fc 01       	movw	r30, r24
    12f2:	b4 97       	sbiw	r30, 0x24	; 36
    12f4:	20 e3       	ldi	r18, 0x30	; 48
    12f6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    12f8:	fc 01       	movw	r30, r24
    12fa:	b5 97       	sbiw	r30, 0x25	; 37
    12fc:	21 e3       	ldi	r18, 0x31	; 49
    12fe:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1300:	86 97       	sbiw	r24, 0x26	; 38
}
    1302:	08 95       	ret

00001304 <xPortStartScheduler>:
	//ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	//ulCompareMatch >>= 8;
	//ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	//OCR1AH = ucHighByte;
	//OCR1AL = ucLowByte;
    OCR0 = ulCompareMatch; 
    1304:	8d e7       	ldi	r24, 0x7D	; 125
    1306:	8c bf       	out	0x3c, r24	; 60
	/* Setup clock source and compare match behaviour. */
	//MOD: atmega32A
	//ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	//TCCR1B = ucLowByte;
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR0 = ucLowByte;
    1308:	8b e0       	ldi	r24, 0x0B	; 11
    130a:	83 bf       	out	0x33, r24	; 51
	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	//MOD: atmega32A
	//ucLowByte = TIMSK;
	//-> enable Timer1 Output Compare A
	ucLowByte = TIMSK;
    130c:	89 b7       	in	r24, 0x39	; 57
	
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    130e:	82 60       	ori	r24, 0x02	; 2
	
	//MOD: atmega1284p
	//TIMSK = ucLowByte;
	TIMSK = ucLowByte;
    1310:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1312:	a0 91 d2 05 	lds	r26, 0x05D2
    1316:	b0 91 d3 05 	lds	r27, 0x05D3
    131a:	cd 91       	ld	r28, X+
    131c:	cd bf       	out	0x3d, r28	; 61
    131e:	dd 91       	ld	r29, X+
    1320:	de bf       	out	0x3e, r29	; 62
    1322:	ff 91       	pop	r31
    1324:	ef 91       	pop	r30
    1326:	df 91       	pop	r29
    1328:	cf 91       	pop	r28
    132a:	bf 91       	pop	r27
    132c:	af 91       	pop	r26
    132e:	9f 91       	pop	r25
    1330:	8f 91       	pop	r24
    1332:	7f 91       	pop	r23
    1334:	6f 91       	pop	r22
    1336:	5f 91       	pop	r21
    1338:	4f 91       	pop	r20
    133a:	3f 91       	pop	r19
    133c:	2f 91       	pop	r18
    133e:	1f 91       	pop	r17
    1340:	0f 91       	pop	r16
    1342:	ff 90       	pop	r15
    1344:	ef 90       	pop	r14
    1346:	df 90       	pop	r13
    1348:	cf 90       	pop	r12
    134a:	bf 90       	pop	r11
    134c:	af 90       	pop	r10
    134e:	9f 90       	pop	r9
    1350:	8f 90       	pop	r8
    1352:	7f 90       	pop	r7
    1354:	6f 90       	pop	r6
    1356:	5f 90       	pop	r5
    1358:	4f 90       	pop	r4
    135a:	3f 90       	pop	r3
    135c:	2f 90       	pop	r2
    135e:	1f 90       	pop	r1
    1360:	0f 90       	pop	r0
    1362:	0f be       	out	0x3f, r0	; 63
    1364:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1366:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1368:	81 e0       	ldi	r24, 0x01	; 1
    136a:	08 95       	ret

0000136c <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    136c:	08 95       	ret

0000136e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    136e:	0f 92       	push	r0
    1370:	0f b6       	in	r0, 0x3f	; 63
    1372:	f8 94       	cli
    1374:	0f 92       	push	r0
    1376:	1f 92       	push	r1
    1378:	11 24       	eor	r1, r1
    137a:	2f 92       	push	r2
    137c:	3f 92       	push	r3
    137e:	4f 92       	push	r4
    1380:	5f 92       	push	r5
    1382:	6f 92       	push	r6
    1384:	7f 92       	push	r7
    1386:	8f 92       	push	r8
    1388:	9f 92       	push	r9
    138a:	af 92       	push	r10
    138c:	bf 92       	push	r11
    138e:	cf 92       	push	r12
    1390:	df 92       	push	r13
    1392:	ef 92       	push	r14
    1394:	ff 92       	push	r15
    1396:	0f 93       	push	r16
    1398:	1f 93       	push	r17
    139a:	2f 93       	push	r18
    139c:	3f 93       	push	r19
    139e:	4f 93       	push	r20
    13a0:	5f 93       	push	r21
    13a2:	6f 93       	push	r22
    13a4:	7f 93       	push	r23
    13a6:	8f 93       	push	r24
    13a8:	9f 93       	push	r25
    13aa:	af 93       	push	r26
    13ac:	bf 93       	push	r27
    13ae:	cf 93       	push	r28
    13b0:	df 93       	push	r29
    13b2:	ef 93       	push	r30
    13b4:	ff 93       	push	r31
    13b6:	a0 91 d2 05 	lds	r26, 0x05D2
    13ba:	b0 91 d3 05 	lds	r27, 0x05D3
    13be:	0d b6       	in	r0, 0x3d	; 61
    13c0:	0d 92       	st	X+, r0
    13c2:	0e b6       	in	r0, 0x3e	; 62
    13c4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    13c6:	0e 94 86 11 	call	0x230c	; 0x230c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    13ca:	a0 91 d2 05 	lds	r26, 0x05D2
    13ce:	b0 91 d3 05 	lds	r27, 0x05D3
    13d2:	cd 91       	ld	r28, X+
    13d4:	cd bf       	out	0x3d, r28	; 61
    13d6:	dd 91       	ld	r29, X+
    13d8:	de bf       	out	0x3e, r29	; 62
    13da:	ff 91       	pop	r31
    13dc:	ef 91       	pop	r30
    13de:	df 91       	pop	r29
    13e0:	cf 91       	pop	r28
    13e2:	bf 91       	pop	r27
    13e4:	af 91       	pop	r26
    13e6:	9f 91       	pop	r25
    13e8:	8f 91       	pop	r24
    13ea:	7f 91       	pop	r23
    13ec:	6f 91       	pop	r22
    13ee:	5f 91       	pop	r21
    13f0:	4f 91       	pop	r20
    13f2:	3f 91       	pop	r19
    13f4:	2f 91       	pop	r18
    13f6:	1f 91       	pop	r17
    13f8:	0f 91       	pop	r16
    13fa:	ff 90       	pop	r15
    13fc:	ef 90       	pop	r14
    13fe:	df 90       	pop	r13
    1400:	cf 90       	pop	r12
    1402:	bf 90       	pop	r11
    1404:	af 90       	pop	r10
    1406:	9f 90       	pop	r9
    1408:	8f 90       	pop	r8
    140a:	7f 90       	pop	r7
    140c:	6f 90       	pop	r6
    140e:	5f 90       	pop	r5
    1410:	4f 90       	pop	r4
    1412:	3f 90       	pop	r3
    1414:	2f 90       	pop	r2
    1416:	1f 90       	pop	r1
    1418:	0f 90       	pop	r0
    141a:	0f be       	out	0x3f, r0	; 63
    141c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    141e:	08 95       	ret

00001420 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1420:	0f 92       	push	r0
    1422:	0f b6       	in	r0, 0x3f	; 63
    1424:	f8 94       	cli
    1426:	0f 92       	push	r0
    1428:	1f 92       	push	r1
    142a:	11 24       	eor	r1, r1
    142c:	2f 92       	push	r2
    142e:	3f 92       	push	r3
    1430:	4f 92       	push	r4
    1432:	5f 92       	push	r5
    1434:	6f 92       	push	r6
    1436:	7f 92       	push	r7
    1438:	8f 92       	push	r8
    143a:	9f 92       	push	r9
    143c:	af 92       	push	r10
    143e:	bf 92       	push	r11
    1440:	cf 92       	push	r12
    1442:	df 92       	push	r13
    1444:	ef 92       	push	r14
    1446:	ff 92       	push	r15
    1448:	0f 93       	push	r16
    144a:	1f 93       	push	r17
    144c:	2f 93       	push	r18
    144e:	3f 93       	push	r19
    1450:	4f 93       	push	r20
    1452:	5f 93       	push	r21
    1454:	6f 93       	push	r22
    1456:	7f 93       	push	r23
    1458:	8f 93       	push	r24
    145a:	9f 93       	push	r25
    145c:	af 93       	push	r26
    145e:	bf 93       	push	r27
    1460:	cf 93       	push	r28
    1462:	df 93       	push	r29
    1464:	ef 93       	push	r30
    1466:	ff 93       	push	r31
    1468:	a0 91 d2 05 	lds	r26, 0x05D2
    146c:	b0 91 d3 05 	lds	r27, 0x05D3
    1470:	0d b6       	in	r0, 0x3d	; 61
    1472:	0d 92       	st	X+, r0
    1474:	0e b6       	in	r0, 0x3e	; 62
    1476:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1478:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <vTaskIncrementTick>
	vTaskSwitchContext();
    147c:	0e 94 86 11 	call	0x230c	; 0x230c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1480:	a0 91 d2 05 	lds	r26, 0x05D2
    1484:	b0 91 d3 05 	lds	r27, 0x05D3
    1488:	cd 91       	ld	r28, X+
    148a:	cd bf       	out	0x3d, r28	; 61
    148c:	dd 91       	ld	r29, X+
    148e:	de bf       	out	0x3e, r29	; 62
    1490:	ff 91       	pop	r31
    1492:	ef 91       	pop	r30
    1494:	df 91       	pop	r29
    1496:	cf 91       	pop	r28
    1498:	bf 91       	pop	r27
    149a:	af 91       	pop	r26
    149c:	9f 91       	pop	r25
    149e:	8f 91       	pop	r24
    14a0:	7f 91       	pop	r23
    14a2:	6f 91       	pop	r22
    14a4:	5f 91       	pop	r21
    14a6:	4f 91       	pop	r20
    14a8:	3f 91       	pop	r19
    14aa:	2f 91       	pop	r18
    14ac:	1f 91       	pop	r17
    14ae:	0f 91       	pop	r16
    14b0:	ff 90       	pop	r15
    14b2:	ef 90       	pop	r14
    14b4:	df 90       	pop	r13
    14b6:	cf 90       	pop	r12
    14b8:	bf 90       	pop	r11
    14ba:	af 90       	pop	r10
    14bc:	9f 90       	pop	r9
    14be:	8f 90       	pop	r8
    14c0:	7f 90       	pop	r7
    14c2:	6f 90       	pop	r6
    14c4:	5f 90       	pop	r5
    14c6:	4f 90       	pop	r4
    14c8:	3f 90       	pop	r3
    14ca:	2f 90       	pop	r2
    14cc:	1f 90       	pop	r1
    14ce:	0f 90       	pop	r0
    14d0:	0f be       	out	0x3f, r0	; 63
    14d2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    14d4:	08 95       	ret

000014d6 <__vector_10>:
	//ISR (TIMER1_COMPA_vect)
	ISR (TIMER0_COMP_vect) __attribute__ ( ( signal, naked ) );
	ISR (TIMER0_COMP_vect)    
	{
        //PORTB ^= (1<<PB0);
		vPortYieldFromTick();
    14d6:	0e 94 10 0a 	call	0x1420	; 0x1420 <vPortYieldFromTick>
		asm volatile ( "reti" );
    14da:	18 95       	reti

000014dc <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    14dc:	cf 93       	push	r28
    14de:	df 93       	push	r29
    14e0:	dc 01       	movw	r26, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    14e2:	cd 91       	ld	r28, X+
    14e4:	dc 91       	ld	r29, X
    14e6:	11 97       	sbiw	r26, 0x01	; 1
    14e8:	20 97       	sbiw	r28, 0x00	; 0
    14ea:	21 f1       	breq	.+72     	; 0x1534 <prvCopyDataFromQueue+0x58>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    14ec:	5c 96       	adiw	r26, 0x1c	; 28
    14ee:	4c 91       	ld	r20, X
    14f0:	5c 97       	sbiw	r26, 0x1c	; 28
    14f2:	16 96       	adiw	r26, 0x06	; 6
    14f4:	2d 91       	ld	r18, X+
    14f6:	3c 91       	ld	r19, X
    14f8:	17 97       	sbiw	r26, 0x07	; 7
    14fa:	24 0f       	add	r18, r20
    14fc:	31 1d       	adc	r19, r1
    14fe:	17 96       	adiw	r26, 0x07	; 7
    1500:	3c 93       	st	X, r19
    1502:	2e 93       	st	-X, r18
    1504:	16 97       	sbiw	r26, 0x06	; 6
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1506:	12 96       	adiw	r26, 0x02	; 2
    1508:	ed 91       	ld	r30, X+
    150a:	fc 91       	ld	r31, X
    150c:	13 97       	sbiw	r26, 0x03	; 3
    150e:	2e 17       	cp	r18, r30
    1510:	3f 07       	cpc	r19, r31
    1512:	20 f0       	brcs	.+8      	; 0x151c <prvCopyDataFromQueue+0x40>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1514:	17 96       	adiw	r26, 0x07	; 7
    1516:	dc 93       	st	X, r29
    1518:	ce 93       	st	-X, r28
    151a:	16 97       	sbiw	r26, 0x06	; 6
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    151c:	16 96       	adiw	r26, 0x06	; 6
    151e:	3c 91       	ld	r19, X
    1520:	16 97       	sbiw	r26, 0x06	; 6
    1522:	17 96       	adiw	r26, 0x07	; 7
    1524:	2c 91       	ld	r18, X
    1526:	86 2f       	mov	r24, r22
    1528:	97 2f       	mov	r25, r23
    152a:	63 2f       	mov	r22, r19
    152c:	72 2f       	mov	r23, r18
    152e:	50 e0       	ldi	r21, 0x00	; 0
    1530:	0e 94 6e 17 	call	0x2edc	; 0x2edc <memcpy>
	}
}
    1534:	df 91       	pop	r29
    1536:	cf 91       	pop	r28
    1538:	08 95       	ret

0000153a <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    153a:	cf 93       	push	r28
    153c:	df 93       	push	r29
    153e:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1540:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1542:	22 23       	and	r18, r18
    1544:	a9 f1       	breq	.+106    	; 0x15b0 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1546:	44 23       	and	r20, r20
    1548:	b9 f4       	brne	.+46     	; 0x1578 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    154a:	8c 81       	ldd	r24, Y+4	; 0x04
    154c:	9d 81       	ldd	r25, Y+5	; 0x05
    154e:	42 2f       	mov	r20, r18
    1550:	50 e0       	ldi	r21, 0x00	; 0
    1552:	0e 94 6e 17 	call	0x2edc	; 0x2edc <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1556:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1558:	8c 81       	ldd	r24, Y+4	; 0x04
    155a:	9d 81       	ldd	r25, Y+5	; 0x05
    155c:	82 0f       	add	r24, r18
    155e:	91 1d       	adc	r25, r1
    1560:	9d 83       	std	Y+5, r25	; 0x05
    1562:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1564:	2a 81       	ldd	r18, Y+2	; 0x02
    1566:	3b 81       	ldd	r19, Y+3	; 0x03
    1568:	82 17       	cp	r24, r18
    156a:	93 07       	cpc	r25, r19
    156c:	08 f1       	brcs	.+66     	; 0x15b0 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    156e:	88 81       	ld	r24, Y
    1570:	99 81       	ldd	r25, Y+1	; 0x01
    1572:	9d 83       	std	Y+5, r25	; 0x05
    1574:	8c 83       	std	Y+4, r24	; 0x04
    1576:	1c c0       	rjmp	.+56     	; 0x15b0 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1578:	8e 81       	ldd	r24, Y+6	; 0x06
    157a:	9f 81       	ldd	r25, Y+7	; 0x07
    157c:	42 2f       	mov	r20, r18
    157e:	50 e0       	ldi	r21, 0x00	; 0
    1580:	0e 94 6e 17 	call	0x2edc	; 0x2edc <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1584:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1586:	50 e0       	ldi	r21, 0x00	; 0
    1588:	50 95       	com	r21
    158a:	41 95       	neg	r20
    158c:	5f 4f       	sbci	r21, 0xFF	; 255
    158e:	8e 81       	ldd	r24, Y+6	; 0x06
    1590:	9f 81       	ldd	r25, Y+7	; 0x07
    1592:	84 0f       	add	r24, r20
    1594:	95 1f       	adc	r25, r21
    1596:	9f 83       	std	Y+7, r25	; 0x07
    1598:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    159a:	28 81       	ld	r18, Y
    159c:	39 81       	ldd	r19, Y+1	; 0x01
    159e:	82 17       	cp	r24, r18
    15a0:	93 07       	cpc	r25, r19
    15a2:	30 f4       	brcc	.+12     	; 0x15b0 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    15a4:	8a 81       	ldd	r24, Y+2	; 0x02
    15a6:	9b 81       	ldd	r25, Y+3	; 0x03
    15a8:	48 0f       	add	r20, r24
    15aa:	59 1f       	adc	r21, r25
    15ac:	5f 83       	std	Y+7, r21	; 0x07
    15ae:	4e 83       	std	Y+6, r20	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    15b0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    15b2:	8f 5f       	subi	r24, 0xFF	; 255
    15b4:	8a 8f       	std	Y+26, r24	; 0x1a
}
    15b6:	df 91       	pop	r29
    15b8:	cf 91       	pop	r28
    15ba:	08 95       	ret

000015bc <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQUEUE *pxQueue )
{
    15bc:	0f 93       	push	r16
    15be:	1f 93       	push	r17
    15c0:	cf 93       	push	r28
    15c2:	df 93       	push	r29
    15c4:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    15c6:	0f b6       	in	r0, 0x3f	; 63
    15c8:	f8 94       	cli
    15ca:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    15cc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    15ce:	18 16       	cp	r1, r24
    15d0:	c4 f4       	brge	.+48     	; 0x1602 <prvUnlockQueue+0x46>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    15d2:	89 89       	ldd	r24, Y+17	; 0x11
    15d4:	88 23       	and	r24, r24
    15d6:	29 f4       	brne	.+10     	; 0x15e2 <prvUnlockQueue+0x26>
    15d8:	14 c0       	rjmp	.+40     	; 0x1602 <prvUnlockQueue+0x46>
    15da:	89 89       	ldd	r24, Y+17	; 0x11
    15dc:	88 23       	and	r24, r24
    15de:	21 f4       	brne	.+8      	; 0x15e8 <prvUnlockQueue+0x2c>
    15e0:	10 c0       	rjmp	.+32     	; 0x1602 <prvUnlockQueue+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    15e2:	8e 01       	movw	r16, r28
    15e4:	0f 5e       	subi	r16, 0xEF	; 239
    15e6:	1f 4f       	sbci	r17, 0xFF	; 255
    15e8:	c8 01       	movw	r24, r16
    15ea:	0e 94 00 12 	call	0x2400	; 0x2400 <xTaskRemoveFromEventList>
    15ee:	88 23       	and	r24, r24
    15f0:	11 f0       	breq	.+4      	; 0x15f6 <prvUnlockQueue+0x3a>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    15f2:	0e 94 8d 12 	call	0x251a	; 0x251a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    15f6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    15f8:	81 50       	subi	r24, 0x01	; 1
    15fa:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    15fc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    15fe:	18 16       	cp	r1, r24
    1600:	64 f3       	brlt	.-40     	; 0x15da <prvUnlockQueue+0x1e>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1602:	8f ef       	ldi	r24, 0xFF	; 255
    1604:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1606:	0f 90       	pop	r0
    1608:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    160a:	0f b6       	in	r0, 0x3f	; 63
    160c:	f8 94       	cli
    160e:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1610:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1612:	18 16       	cp	r1, r24
    1614:	c4 f4       	brge	.+48     	; 0x1646 <prvUnlockQueue+0x8a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1616:	88 85       	ldd	r24, Y+8	; 0x08
    1618:	88 23       	and	r24, r24
    161a:	29 f4       	brne	.+10     	; 0x1626 <prvUnlockQueue+0x6a>
    161c:	14 c0       	rjmp	.+40     	; 0x1646 <prvUnlockQueue+0x8a>
    161e:	88 85       	ldd	r24, Y+8	; 0x08
    1620:	88 23       	and	r24, r24
    1622:	21 f4       	brne	.+8      	; 0x162c <prvUnlockQueue+0x70>
    1624:	10 c0       	rjmp	.+32     	; 0x1646 <prvUnlockQueue+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1626:	8e 01       	movw	r16, r28
    1628:	08 5f       	subi	r16, 0xF8	; 248
    162a:	1f 4f       	sbci	r17, 0xFF	; 255
    162c:	c8 01       	movw	r24, r16
    162e:	0e 94 00 12 	call	0x2400	; 0x2400 <xTaskRemoveFromEventList>
    1632:	88 23       	and	r24, r24
    1634:	11 f0       	breq	.+4      	; 0x163a <prvUnlockQueue+0x7e>
				{
					vTaskMissedYield();
    1636:	0e 94 8d 12 	call	0x251a	; 0x251a <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    163a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    163c:	81 50       	subi	r24, 0x01	; 1
    163e:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1640:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1642:	18 16       	cp	r1, r24
    1644:	64 f3       	brlt	.-40     	; 0x161e <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1646:	8f ef       	ldi	r24, 0xFF	; 255
    1648:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    164a:	0f 90       	pop	r0
    164c:	0f be       	out	0x3f, r0	; 63
}
    164e:	df 91       	pop	r29
    1650:	cf 91       	pop	r28
    1652:	1f 91       	pop	r17
    1654:	0f 91       	pop	r16
    1656:	08 95       	ret

00001658 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
    1658:	cf 93       	push	r28
    165a:	df 93       	push	r29
    165c:	ec 01       	movw	r28, r24
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    165e:	0f b6       	in	r0, 0x3f	; 63
    1660:	f8 94       	cli
    1662:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1664:	48 81       	ld	r20, Y
    1666:	59 81       	ldd	r21, Y+1	; 0x01
    1668:	2b 8d       	ldd	r18, Y+27	; 0x1b
    166a:	30 e0       	ldi	r19, 0x00	; 0
    166c:	ec 8d       	ldd	r30, Y+28	; 0x1c
    166e:	f0 e0       	ldi	r31, 0x00	; 0
    1670:	2e 9f       	mul	r18, r30
    1672:	c0 01       	movw	r24, r0
    1674:	2f 9f       	mul	r18, r31
    1676:	90 0d       	add	r25, r0
    1678:	3e 9f       	mul	r19, r30
    167a:	90 0d       	add	r25, r0
    167c:	11 24       	eor	r1, r1
    167e:	84 0f       	add	r24, r20
    1680:	95 1f       	adc	r25, r21
    1682:	9b 83       	std	Y+3, r25	; 0x03
    1684:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1686:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1688:	5d 83       	std	Y+5, r21	; 0x05
    168a:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    168c:	c9 01       	movw	r24, r18
    168e:	01 97       	sbiw	r24, 0x01	; 1
    1690:	e8 9f       	mul	r30, r24
    1692:	90 01       	movw	r18, r0
    1694:	e9 9f       	mul	r30, r25
    1696:	30 0d       	add	r19, r0
    1698:	f8 9f       	mul	r31, r24
    169a:	30 0d       	add	r19, r0
    169c:	11 24       	eor	r1, r1
    169e:	24 0f       	add	r18, r20
    16a0:	35 1f       	adc	r19, r21
    16a2:	3f 83       	std	Y+7, r19	; 0x07
    16a4:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    16a6:	8f ef       	ldi	r24, 0xFF	; 255
    16a8:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    16aa:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    16ac:	66 23       	and	r22, r22
    16ae:	61 f4       	brne	.+24     	; 0x16c8 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    16b0:	88 85       	ldd	r24, Y+8	; 0x08
    16b2:	88 23       	and	r24, r24
    16b4:	89 f0       	breq	.+34     	; 0x16d8 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    16b6:	ce 01       	movw	r24, r28
    16b8:	08 96       	adiw	r24, 0x08	; 8
    16ba:	0e 94 00 12 	call	0x2400	; 0x2400 <xTaskRemoveFromEventList>
    16be:	81 30       	cpi	r24, 0x01	; 1
    16c0:	59 f4       	brne	.+22     	; 0x16d8 <xQueueGenericReset+0x80>
				{
					portYIELD_WITHIN_API();
    16c2:	0e 94 b7 09 	call	0x136e	; 0x136e <vPortYield>
    16c6:	08 c0       	rjmp	.+16     	; 0x16d8 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    16c8:	ce 01       	movw	r24, r28
    16ca:	08 96       	adiw	r24, 0x08	; 8
    16cc:	0e 94 46 08 	call	0x108c	; 0x108c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    16d0:	ce 01       	movw	r24, r28
    16d2:	41 96       	adiw	r24, 0x11	; 17
    16d4:	0e 94 46 08 	call	0x108c	; 0x108c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    16d8:	0f 90       	pop	r0
    16da:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    16dc:	81 e0       	ldi	r24, 0x01	; 1
    16de:	df 91       	pop	r29
    16e0:	cf 91       	pop	r28
    16e2:	08 95       	ret

000016e4 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    16e4:	0f 93       	push	r16
    16e6:	1f 93       	push	r17
    16e8:	cf 93       	push	r28
    16ea:	df 93       	push	r29
    16ec:	18 2f       	mov	r17, r24
    16ee:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    16f0:	88 23       	and	r24, r24
    16f2:	f9 f0       	breq	.+62     	; 0x1732 <xQueueGenericCreate+0x4e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    16f4:	8f e1       	ldi	r24, 0x1F	; 31
    16f6:	90 e0       	ldi	r25, 0x00	; 0
    16f8:	0e 94 01 08 	call	0x1002	; 0x1002 <pvPortMalloc>
    16fc:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    16fe:	00 97       	sbiw	r24, 0x00	; 0
    1700:	d9 f0       	breq	.+54     	; 0x1738 <xQueueGenericCreate+0x54>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1702:	01 9f       	mul	r16, r17
    1704:	c0 01       	movw	r24, r0
    1706:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1708:	01 96       	adiw	r24, 0x01	; 1
    170a:	0e 94 01 08 	call	0x1002	; 0x1002 <pvPortMalloc>
    170e:	99 83       	std	Y+1, r25	; 0x01
    1710:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1712:	00 97       	sbiw	r24, 0x00	; 0
    1714:	41 f0       	breq	.+16     	; 0x1726 <xQueueGenericCreate+0x42>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1716:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1718:	0c 8f       	std	Y+28, r16	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
    171a:	ce 01       	movw	r24, r28
    171c:	61 e0       	ldi	r22, 0x01	; 1
    171e:	0e 94 2c 0b 	call	0x1658	; 0x1658 <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1722:	ce 01       	movw	r24, r28
    1724:	0b c0       	rjmp	.+22     	; 0x173c <xQueueGenericCreate+0x58>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1726:	ce 01       	movw	r24, r28
    1728:	0e 94 37 08 	call	0x106e	; 0x106e <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    172c:	80 e0       	ldi	r24, 0x00	; 0
    172e:	90 e0       	ldi	r25, 0x00	; 0
    1730:	05 c0       	rjmp	.+10     	; 0x173c <xQueueGenericCreate+0x58>
    1732:	80 e0       	ldi	r24, 0x00	; 0
    1734:	90 e0       	ldi	r25, 0x00	; 0
    1736:	02 c0       	rjmp	.+4      	; 0x173c <xQueueGenericCreate+0x58>
    1738:	80 e0       	ldi	r24, 0x00	; 0
    173a:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    173c:	df 91       	pop	r29
    173e:	cf 91       	pop	r28
    1740:	1f 91       	pop	r17
    1742:	0f 91       	pop	r16
    1744:	08 95       	ret

00001746 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, uint32_t xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1746:	8f 92       	push	r8
    1748:	9f 92       	push	r9
    174a:	bf 92       	push	r11
    174c:	cf 92       	push	r12
    174e:	df 92       	push	r13
    1750:	ef 92       	push	r14
    1752:	ff 92       	push	r15
    1754:	0f 93       	push	r16
    1756:	1f 93       	push	r17
    1758:	cf 93       	push	r28
    175a:	df 93       	push	r29
    175c:	cd b7       	in	r28, 0x3d	; 61
    175e:	de b7       	in	r29, 0x3e	; 62
    1760:	29 97       	sbiw	r28, 0x09	; 9
    1762:	0f b6       	in	r0, 0x3f	; 63
    1764:	f8 94       	cli
    1766:	de bf       	out	0x3e, r29	; 62
    1768:	0f be       	out	0x3f, r0	; 63
    176a:	cd bf       	out	0x3d, r28	; 61
    176c:	7c 01       	movw	r14, r24
    176e:	4b 01       	movw	r8, r22
    1770:	2e 83       	std	Y+6, r18	; 0x06
    1772:	3f 83       	std	Y+7, r19	; 0x07
    1774:	48 87       	std	Y+8, r20	; 0x08
    1776:	59 87       	std	Y+9, r21	; 0x09
    1778:	b0 2e       	mov	r11, r16
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    177a:	10 e0       	ldi	r17, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    177c:	01 e0       	ldi	r16, 0x01	; 1
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    177e:	cc 24       	eor	r12, r12
    1780:	dd 24       	eor	r13, r13
    1782:	68 94       	set
    1784:	c3 f8       	bld	r12, 3
    1786:	c8 0e       	add	r12, r24
    1788:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    178a:	0f b6       	in	r0, 0x3f	; 63
    178c:	f8 94       	cli
    178e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1790:	f7 01       	movw	r30, r14
    1792:	92 8d       	ldd	r25, Z+26	; 0x1a
    1794:	83 8d       	ldd	r24, Z+27	; 0x1b
    1796:	98 17       	cp	r25, r24
    1798:	a8 f4       	brcc	.+42     	; 0x17c4 <xQueueGenericSend+0x7e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    179a:	c7 01       	movw	r24, r14
    179c:	b4 01       	movw	r22, r8
    179e:	4b 2d       	mov	r20, r11
    17a0:	0e 94 9d 0a 	call	0x153a	; 0x153a <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    17a4:	f7 01       	movw	r30, r14
    17a6:	81 89       	ldd	r24, Z+17	; 0x11
    17a8:	88 23       	and	r24, r24
    17aa:	41 f0       	breq	.+16     	; 0x17bc <xQueueGenericSend+0x76>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    17ac:	c7 01       	movw	r24, r14
    17ae:	41 96       	adiw	r24, 0x11	; 17
    17b0:	0e 94 00 12 	call	0x2400	; 0x2400 <xTaskRemoveFromEventList>
    17b4:	81 30       	cpi	r24, 0x01	; 1
    17b6:	11 f4       	brne	.+4      	; 0x17bc <xQueueGenericSend+0x76>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							portYIELD_WITHIN_API();
    17b8:	0e 94 b7 09 	call	0x136e	; 0x136e <vPortYield>
						}
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    17bc:	0f 90       	pop	r0
    17be:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    17c0:	81 e0       	ldi	r24, 0x01	; 1
    17c2:	56 c0       	rjmp	.+172    	; 0x1870 <xQueueGenericSend+0x12a>
			}
			else
			{
				if( xTicksToWait == ( uint32_t ) 0 )
    17c4:	8e 81       	ldd	r24, Y+6	; 0x06
    17c6:	9f 81       	ldd	r25, Y+7	; 0x07
    17c8:	a8 85       	ldd	r26, Y+8	; 0x08
    17ca:	b9 85       	ldd	r27, Y+9	; 0x09
    17cc:	00 97       	sbiw	r24, 0x00	; 0
    17ce:	a1 05       	cpc	r26, r1
    17d0:	b1 05       	cpc	r27, r1
    17d2:	21 f4       	brne	.+8      	; 0x17dc <xQueueGenericSend+0x96>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    17d4:	0f 90       	pop	r0
    17d6:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    17d8:	80 e0       	ldi	r24, 0x00	; 0
    17da:	4a c0       	rjmp	.+148    	; 0x1870 <xQueueGenericSend+0x12a>
				}
				else if( xEntryTimeSet == pdFALSE )
    17dc:	11 23       	and	r17, r17
    17de:	29 f4       	brne	.+10     	; 0x17ea <xQueueGenericSend+0xa4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    17e0:	ce 01       	movw	r24, r28
    17e2:	01 96       	adiw	r24, 0x01	; 1
    17e4:	0e 94 48 12 	call	0x2490	; 0x2490 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    17e8:	10 2f       	mov	r17, r16
				}
			}
		}
		taskEXIT_CRITICAL();
    17ea:	0f 90       	pop	r0
    17ec:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    17ee:	0e 94 59 0f 	call	0x1eb2	; 0x1eb2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    17f2:	0f b6       	in	r0, 0x3f	; 63
    17f4:	f8 94       	cli
    17f6:	0f 92       	push	r0
    17f8:	f7 01       	movw	r30, r14
    17fa:	85 8d       	ldd	r24, Z+29	; 0x1d
    17fc:	8f 3f       	cpi	r24, 0xFF	; 255
    17fe:	09 f4       	brne	.+2      	; 0x1802 <xQueueGenericSend+0xbc>
    1800:	15 8e       	std	Z+29, r1	; 0x1d
    1802:	f7 01       	movw	r30, r14
    1804:	86 8d       	ldd	r24, Z+30	; 0x1e
    1806:	8f 3f       	cpi	r24, 0xFF	; 255
    1808:	09 f4       	brne	.+2      	; 0x180c <xQueueGenericSend+0xc6>
    180a:	16 8e       	std	Z+30, r1	; 0x1e
    180c:	0f 90       	pop	r0
    180e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1810:	ce 01       	movw	r24, r28
    1812:	01 96       	adiw	r24, 0x01	; 1
    1814:	be 01       	movw	r22, r28
    1816:	6a 5f       	subi	r22, 0xFA	; 250
    1818:	7f 4f       	sbci	r23, 0xFF	; 255
    181a:	0e 94 57 12 	call	0x24ae	; 0x24ae <xTaskCheckForTimeOut>
    181e:	88 23       	and	r24, r24
    1820:	09 f5       	brne	.+66     	; 0x1864 <xQueueGenericSend+0x11e>

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1822:	0f b6       	in	r0, 0x3f	; 63
    1824:	f8 94       	cli
    1826:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1828:	f7 01       	movw	r30, r14
    182a:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    182c:	0f 90       	pop	r0
    182e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1830:	f7 01       	movw	r30, r14
    1832:	83 8d       	ldd	r24, Z+27	; 0x1b
    1834:	98 17       	cp	r25, r24
    1836:	81 f4       	brne	.+32     	; 0x1858 <xQueueGenericSend+0x112>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1838:	6e 81       	ldd	r22, Y+6	; 0x06
    183a:	7f 81       	ldd	r23, Y+7	; 0x07
    183c:	c6 01       	movw	r24, r12
    183e:	0e 94 e3 11 	call	0x23c6	; 0x23c6 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1842:	c7 01       	movw	r24, r14
    1844:	0e 94 de 0a 	call	0x15bc	; 0x15bc <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1848:	0e 94 40 10 	call	0x2080	; 0x2080 <xTaskResumeAll>
    184c:	88 23       	and	r24, r24
    184e:	09 f0       	breq	.+2      	; 0x1852 <xQueueGenericSend+0x10c>
    1850:	9c cf       	rjmp	.-200    	; 0x178a <xQueueGenericSend+0x44>
				{
					portYIELD_WITHIN_API();
    1852:	0e 94 b7 09 	call	0x136e	; 0x136e <vPortYield>
    1856:	99 cf       	rjmp	.-206    	; 0x178a <xQueueGenericSend+0x44>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1858:	c7 01       	movw	r24, r14
    185a:	0e 94 de 0a 	call	0x15bc	; 0x15bc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    185e:	0e 94 40 10 	call	0x2080	; 0x2080 <xTaskResumeAll>
    1862:	93 cf       	rjmp	.-218    	; 0x178a <xQueueGenericSend+0x44>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1864:	c7 01       	movw	r24, r14
    1866:	0e 94 de 0a 	call	0x15bc	; 0x15bc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    186a:	0e 94 40 10 	call	0x2080	; 0x2080 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    186e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1870:	29 96       	adiw	r28, 0x09	; 9
    1872:	0f b6       	in	r0, 0x3f	; 63
    1874:	f8 94       	cli
    1876:	de bf       	out	0x3e, r29	; 62
    1878:	0f be       	out	0x3f, r0	; 63
    187a:	cd bf       	out	0x3d, r28	; 61
    187c:	df 91       	pop	r29
    187e:	cf 91       	pop	r28
    1880:	1f 91       	pop	r17
    1882:	0f 91       	pop	r16
    1884:	ff 90       	pop	r15
    1886:	ef 90       	pop	r14
    1888:	df 90       	pop	r13
    188a:	cf 90       	pop	r12
    188c:	bf 90       	pop	r11
    188e:	9f 90       	pop	r9
    1890:	8f 90       	pop	r8
    1892:	08 95       	ret

00001894 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1894:	0f 93       	push	r16
    1896:	1f 93       	push	r17
    1898:	cf 93       	push	r28
    189a:	df 93       	push	r29
    189c:	ec 01       	movw	r28, r24
    189e:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    18a0:	9a 8d       	ldd	r25, Y+26	; 0x1a
    18a2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    18a4:	98 17       	cp	r25, r24
    18a6:	e0 f4       	brcc	.+56     	; 0x18e0 <xQueueGenericSendFromISR+0x4c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    18a8:	ce 01       	movw	r24, r28
    18aa:	42 2f       	mov	r20, r18
    18ac:	0e 94 9d 0a 	call	0x153a	; 0x153a <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    18b0:	8e 8d       	ldd	r24, Y+30	; 0x1e
    18b2:	8f 3f       	cpi	r24, 0xFF	; 255
    18b4:	81 f4       	brne	.+32     	; 0x18d6 <xQueueGenericSendFromISR+0x42>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    18b6:	89 89       	ldd	r24, Y+17	; 0x11
    18b8:	88 23       	and	r24, r24
    18ba:	a1 f0       	breq	.+40     	; 0x18e4 <xQueueGenericSendFromISR+0x50>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    18bc:	ce 01       	movw	r24, r28
    18be:	41 96       	adiw	r24, 0x11	; 17
    18c0:	0e 94 00 12 	call	0x2400	; 0x2400 <xTaskRemoveFromEventList>
    18c4:	88 23       	and	r24, r24
    18c6:	81 f0       	breq	.+32     	; 0x18e8 <xQueueGenericSendFromISR+0x54>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    18c8:	01 15       	cp	r16, r1
    18ca:	11 05       	cpc	r17, r1
    18cc:	79 f0       	breq	.+30     	; 0x18ec <xQueueGenericSendFromISR+0x58>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    18ce:	81 e0       	ldi	r24, 0x01	; 1
    18d0:	f8 01       	movw	r30, r16
    18d2:	80 83       	st	Z, r24
    18d4:	0c c0       	rjmp	.+24     	; 0x18ee <xQueueGenericSendFromISR+0x5a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    18d6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    18d8:	8f 5f       	subi	r24, 0xFF	; 255
    18da:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    18dc:	81 e0       	ldi	r24, 0x01	; 1
    18de:	07 c0       	rjmp	.+14     	; 0x18ee <xQueueGenericSendFromISR+0x5a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    18e0:	80 e0       	ldi	r24, 0x00	; 0
    18e2:	05 c0       	rjmp	.+10     	; 0x18ee <xQueueGenericSendFromISR+0x5a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    18e4:	81 e0       	ldi	r24, 0x01	; 1
    18e6:	03 c0       	rjmp	.+6      	; 0x18ee <xQueueGenericSendFromISR+0x5a>
    18e8:	81 e0       	ldi	r24, 0x01	; 1
    18ea:	01 c0       	rjmp	.+2      	; 0x18ee <xQueueGenericSendFromISR+0x5a>
    18ec:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    18ee:	df 91       	pop	r29
    18f0:	cf 91       	pop	r28
    18f2:	1f 91       	pop	r17
    18f4:	0f 91       	pop	r16
    18f6:	08 95       	ret

000018f8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, uint32_t xTicksToWait, portBASE_TYPE xJustPeeking )
{
    18f8:	8f 92       	push	r8
    18fa:	9f 92       	push	r9
    18fc:	bf 92       	push	r11
    18fe:	cf 92       	push	r12
    1900:	df 92       	push	r13
    1902:	ef 92       	push	r14
    1904:	ff 92       	push	r15
    1906:	0f 93       	push	r16
    1908:	1f 93       	push	r17
    190a:	cf 93       	push	r28
    190c:	df 93       	push	r29
    190e:	cd b7       	in	r28, 0x3d	; 61
    1910:	de b7       	in	r29, 0x3e	; 62
    1912:	29 97       	sbiw	r28, 0x09	; 9
    1914:	0f b6       	in	r0, 0x3f	; 63
    1916:	f8 94       	cli
    1918:	de bf       	out	0x3e, r29	; 62
    191a:	0f be       	out	0x3f, r0	; 63
    191c:	cd bf       	out	0x3d, r28	; 61
    191e:	7c 01       	movw	r14, r24
    1920:	4b 01       	movw	r8, r22
    1922:	2e 83       	std	Y+6, r18	; 0x06
    1924:	3f 83       	std	Y+7, r19	; 0x07
    1926:	48 87       	std	Y+8, r20	; 0x08
    1928:	59 87       	std	Y+9, r21	; 0x09
    192a:	b0 2e       	mov	r11, r16
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    192c:	10 e0       	ldi	r17, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    192e:	01 e0       	ldi	r16, 0x01	; 1
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1930:	0f 2e       	mov	r0, r31
    1932:	f1 e1       	ldi	r31, 0x11	; 17
    1934:	cf 2e       	mov	r12, r31
    1936:	dd 24       	eor	r13, r13
    1938:	f0 2d       	mov	r31, r0
    193a:	c8 0e       	add	r12, r24
    193c:	d9 1e       	adc	r13, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    193e:	0f b6       	in	r0, 0x3f	; 63
    1940:	f8 94       	cli
    1942:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1944:	f7 01       	movw	r30, r14
    1946:	82 8d       	ldd	r24, Z+26	; 0x1a
    1948:	88 23       	and	r24, r24
    194a:	51 f1       	breq	.+84     	; 0x19a0 <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    194c:	06 81       	ldd	r16, Z+6	; 0x06
    194e:	17 81       	ldd	r17, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1950:	c7 01       	movw	r24, r14
    1952:	b4 01       	movw	r22, r8
    1954:	0e 94 6e 0a 	call	0x14dc	; 0x14dc <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1958:	bb 20       	and	r11, r11
    195a:	81 f4       	brne	.+32     	; 0x197c <xQueueGenericReceive+0x84>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    195c:	f7 01       	movw	r30, r14
    195e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1960:	81 50       	subi	r24, 0x01	; 1
    1962:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1964:	80 85       	ldd	r24, Z+8	; 0x08
    1966:	88 23       	and	r24, r24
    1968:	b9 f0       	breq	.+46     	; 0x1998 <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    196a:	c7 01       	movw	r24, r14
    196c:	08 96       	adiw	r24, 0x08	; 8
    196e:	0e 94 00 12 	call	0x2400	; 0x2400 <xTaskRemoveFromEventList>
    1972:	81 30       	cpi	r24, 0x01	; 1
    1974:	89 f4       	brne	.+34     	; 0x1998 <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    1976:	0e 94 b7 09 	call	0x136e	; 0x136e <vPortYield>
    197a:	0e c0       	rjmp	.+28     	; 0x1998 <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    197c:	f7 01       	movw	r30, r14
    197e:	17 83       	std	Z+7, r17	; 0x07
    1980:	06 83       	std	Z+6, r16	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1982:	81 89       	ldd	r24, Z+17	; 0x11
    1984:	88 23       	and	r24, r24
    1986:	41 f0       	breq	.+16     	; 0x1998 <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1988:	c7 01       	movw	r24, r14
    198a:	41 96       	adiw	r24, 0x11	; 17
    198c:	0e 94 00 12 	call	0x2400	; 0x2400 <xTaskRemoveFromEventList>
    1990:	88 23       	and	r24, r24
    1992:	11 f0       	breq	.+4      	; 0x1998 <xQueueGenericReceive+0xa0>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1994:	0e 94 b7 09 	call	0x136e	; 0x136e <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    1998:	0f 90       	pop	r0
    199a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    199c:	81 e0       	ldi	r24, 0x01	; 1
    199e:	54 c0       	rjmp	.+168    	; 0x1a48 <xQueueGenericReceive+0x150>
			}
			else
			{
				if( xTicksToWait == ( uint32_t ) 0 )
    19a0:	8e 81       	ldd	r24, Y+6	; 0x06
    19a2:	9f 81       	ldd	r25, Y+7	; 0x07
    19a4:	a8 85       	ldd	r26, Y+8	; 0x08
    19a6:	b9 85       	ldd	r27, Y+9	; 0x09
    19a8:	00 97       	sbiw	r24, 0x00	; 0
    19aa:	a1 05       	cpc	r26, r1
    19ac:	b1 05       	cpc	r27, r1
    19ae:	21 f4       	brne	.+8      	; 0x19b8 <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    19b0:	0f 90       	pop	r0
    19b2:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    19b4:	80 e0       	ldi	r24, 0x00	; 0
    19b6:	48 c0       	rjmp	.+144    	; 0x1a48 <xQueueGenericReceive+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    19b8:	11 23       	and	r17, r17
    19ba:	29 f4       	brne	.+10     	; 0x19c6 <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    19bc:	ce 01       	movw	r24, r28
    19be:	01 96       	adiw	r24, 0x01	; 1
    19c0:	0e 94 48 12 	call	0x2490	; 0x2490 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    19c4:	10 2f       	mov	r17, r16
				}
			}
		}
		taskEXIT_CRITICAL();
    19c6:	0f 90       	pop	r0
    19c8:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    19ca:	0e 94 59 0f 	call	0x1eb2	; 0x1eb2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    19ce:	0f b6       	in	r0, 0x3f	; 63
    19d0:	f8 94       	cli
    19d2:	0f 92       	push	r0
    19d4:	f7 01       	movw	r30, r14
    19d6:	85 8d       	ldd	r24, Z+29	; 0x1d
    19d8:	8f 3f       	cpi	r24, 0xFF	; 255
    19da:	09 f4       	brne	.+2      	; 0x19de <xQueueGenericReceive+0xe6>
    19dc:	15 8e       	std	Z+29, r1	; 0x1d
    19de:	f7 01       	movw	r30, r14
    19e0:	86 8d       	ldd	r24, Z+30	; 0x1e
    19e2:	8f 3f       	cpi	r24, 0xFF	; 255
    19e4:	09 f4       	brne	.+2      	; 0x19e8 <xQueueGenericReceive+0xf0>
    19e6:	16 8e       	std	Z+30, r1	; 0x1e
    19e8:	0f 90       	pop	r0
    19ea:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    19ec:	ce 01       	movw	r24, r28
    19ee:	01 96       	adiw	r24, 0x01	; 1
    19f0:	be 01       	movw	r22, r28
    19f2:	6a 5f       	subi	r22, 0xFA	; 250
    19f4:	7f 4f       	sbci	r23, 0xFF	; 255
    19f6:	0e 94 57 12 	call	0x24ae	; 0x24ae <xTaskCheckForTimeOut>
    19fa:	88 23       	and	r24, r24
    19fc:	f9 f4       	brne	.+62     	; 0x1a3c <xQueueGenericReceive+0x144>

static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    19fe:	0f b6       	in	r0, 0x3f	; 63
    1a00:	f8 94       	cli
    1a02:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == 0 )
    1a04:	f7 01       	movw	r30, r14
    1a06:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1a08:	0f 90       	pop	r0
    1a0a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1a0c:	88 23       	and	r24, r24
    1a0e:	81 f4       	brne	.+32     	; 0x1a30 <xQueueGenericReceive+0x138>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1a10:	6e 81       	ldd	r22, Y+6	; 0x06
    1a12:	7f 81       	ldd	r23, Y+7	; 0x07
    1a14:	c6 01       	movw	r24, r12
    1a16:	0e 94 e3 11 	call	0x23c6	; 0x23c6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1a1a:	c7 01       	movw	r24, r14
    1a1c:	0e 94 de 0a 	call	0x15bc	; 0x15bc <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1a20:	0e 94 40 10 	call	0x2080	; 0x2080 <xTaskResumeAll>
    1a24:	88 23       	and	r24, r24
    1a26:	09 f0       	breq	.+2      	; 0x1a2a <xQueueGenericReceive+0x132>
    1a28:	8a cf       	rjmp	.-236    	; 0x193e <xQueueGenericReceive+0x46>
				{
					portYIELD_WITHIN_API();
    1a2a:	0e 94 b7 09 	call	0x136e	; 0x136e <vPortYield>
    1a2e:	87 cf       	rjmp	.-242    	; 0x193e <xQueueGenericReceive+0x46>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1a30:	c7 01       	movw	r24, r14
    1a32:	0e 94 de 0a 	call	0x15bc	; 0x15bc <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1a36:	0e 94 40 10 	call	0x2080	; 0x2080 <xTaskResumeAll>
    1a3a:	81 cf       	rjmp	.-254    	; 0x193e <xQueueGenericReceive+0x46>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1a3c:	c7 01       	movw	r24, r14
    1a3e:	0e 94 de 0a 	call	0x15bc	; 0x15bc <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1a42:	0e 94 40 10 	call	0x2080	; 0x2080 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    1a46:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1a48:	29 96       	adiw	r28, 0x09	; 9
    1a4a:	0f b6       	in	r0, 0x3f	; 63
    1a4c:	f8 94       	cli
    1a4e:	de bf       	out	0x3e, r29	; 62
    1a50:	0f be       	out	0x3f, r0	; 63
    1a52:	cd bf       	out	0x3d, r28	; 61
    1a54:	df 91       	pop	r29
    1a56:	cf 91       	pop	r28
    1a58:	1f 91       	pop	r17
    1a5a:	0f 91       	pop	r16
    1a5c:	ff 90       	pop	r15
    1a5e:	ef 90       	pop	r14
    1a60:	df 90       	pop	r13
    1a62:	cf 90       	pop	r12
    1a64:	bf 90       	pop	r11
    1a66:	9f 90       	pop	r9
    1a68:	8f 90       	pop	r8
    1a6a:	08 95       	ret

00001a6c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    1a6c:	0f 93       	push	r16
    1a6e:	1f 93       	push	r17
    1a70:	cf 93       	push	r28
    1a72:	df 93       	push	r29
    1a74:	ec 01       	movw	r28, r24
    1a76:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1a78:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a7a:	88 23       	and	r24, r24
    1a7c:	f1 f0       	breq	.+60     	; 0x1aba <xQueueReceiveFromISR+0x4e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    1a7e:	ce 01       	movw	r24, r28
    1a80:	0e 94 6e 0a 	call	0x14dc	; 0x14dc <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    1a84:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1a86:	81 50       	subi	r24, 0x01	; 1
    1a88:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1a8a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1a8c:	8f 3f       	cpi	r24, 0xFF	; 255
    1a8e:	81 f4       	brne	.+32     	; 0x1ab0 <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1a90:	88 85       	ldd	r24, Y+8	; 0x08
    1a92:	88 23       	and	r24, r24
    1a94:	a1 f0       	breq	.+40     	; 0x1abe <xQueueReceiveFromISR+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1a96:	ce 01       	movw	r24, r28
    1a98:	08 96       	adiw	r24, 0x08	; 8
    1a9a:	0e 94 00 12 	call	0x2400	; 0x2400 <xTaskRemoveFromEventList>
    1a9e:	88 23       	and	r24, r24
    1aa0:	81 f0       	breq	.+32     	; 0x1ac2 <xQueueReceiveFromISR+0x56>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    1aa2:	01 15       	cp	r16, r1
    1aa4:	11 05       	cpc	r17, r1
    1aa6:	79 f0       	breq	.+30     	; 0x1ac6 <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1aa8:	81 e0       	ldi	r24, 0x01	; 1
    1aaa:	f8 01       	movw	r30, r16
    1aac:	80 83       	st	Z, r24
    1aae:	0c c0       	rjmp	.+24     	; 0x1ac8 <xQueueReceiveFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    1ab0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1ab2:	8f 5f       	subi	r24, 0xFF	; 255
    1ab4:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    1ab6:	81 e0       	ldi	r24, 0x01	; 1
    1ab8:	07 c0       	rjmp	.+14     	; 0x1ac8 <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			xReturn = pdFAIL;
    1aba:	80 e0       	ldi	r24, 0x00	; 0
    1abc:	05 c0       	rjmp	.+10     	; 0x1ac8 <xQueueReceiveFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    1abe:	81 e0       	ldi	r24, 0x01	; 1
    1ac0:	03 c0       	rjmp	.+6      	; 0x1ac8 <xQueueReceiveFromISR+0x5c>
    1ac2:	81 e0       	ldi	r24, 0x01	; 1
    1ac4:	01 c0       	rjmp	.+2      	; 0x1ac8 <xQueueReceiveFromISR+0x5c>
    1ac6:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1ac8:	df 91       	pop	r29
    1aca:	cf 91       	pop	r28
    1acc:	1f 91       	pop	r17
    1ace:	0f 91       	pop	r16
    1ad0:	08 95       	ret

00001ad2 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1ad2:	0f b6       	in	r0, 0x3f	; 63
    1ad4:	f8 94       	cli
    1ad6:	0f 92       	push	r0
		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
    1ad8:	fc 01       	movw	r30, r24
    1ada:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1adc:	0f 90       	pop	r0
    1ade:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1ae0:	08 95       	ret

00001ae2 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
    1ae2:	fc 01       	movw	r30, r24
    1ae4:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    1ae6:	08 95       	ret

00001ae8 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle xQueue )
{
    1ae8:	cf 93       	push	r28
    1aea:	df 93       	push	r29
    1aec:	ec 01       	movw	r28, r24
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		prvQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue->pcHead );
    1aee:	88 81       	ld	r24, Y
    1af0:	99 81       	ldd	r25, Y+1	; 0x01
    1af2:	0e 94 37 08 	call	0x106e	; 0x106e <vPortFree>
	vPortFree( pxQueue );
    1af6:	ce 01       	movw	r24, r28
    1af8:	0e 94 37 08 	call	0x106e	; 0x106e <vPortFree>
}
    1afc:	df 91       	pop	r29
    1afe:	cf 91       	pop	r28
    1b00:	08 95       	ret

00001b02 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == 0 )
    1b02:	fc 01       	movw	r30, r24
    1b04:	92 8d       	ldd	r25, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    1b06:	81 e0       	ldi	r24, 0x01	; 1
    1b08:	91 11       	cpse	r25, r1
    1b0a:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1b0c:	08 95       	ret

00001b0e <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
{
    1b0e:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
    1b10:	22 8d       	ldd	r18, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    1b12:	81 e0       	ldi	r24, 0x01	; 1
    1b14:	93 8d       	ldd	r25, Z+27	; 0x1b
    1b16:	29 13       	cpse	r18, r25
    1b18:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1b1a:	08 95       	ret

00001b1c <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( uint16_t xTimeToWake )
{
    1b1c:	cf 93       	push	r28
    1b1e:	df 93       	push	r29
    1b20:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    1b22:	e0 91 d2 05 	lds	r30, 0x05D2
    1b26:	f0 91 d3 05 	lds	r31, 0x05D3
    1b2a:	93 83       	std	Z+3, r25	; 0x03
    1b2c:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    1b2e:	80 91 da 05 	lds	r24, 0x05DA
    1b32:	90 91 db 05 	lds	r25, 0x05DB
    1b36:	c8 17       	cp	r28, r24
    1b38:	d9 07       	cpc	r29, r25
    1b3a:	68 f4       	brcc	.+26     	; 0x1b56 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1b3c:	80 91 de 05 	lds	r24, 0x05DE
    1b40:	90 91 df 05 	lds	r25, 0x05DF
    1b44:	60 91 d2 05 	lds	r22, 0x05D2
    1b48:	70 91 d3 05 	lds	r23, 0x05D3
    1b4c:	6e 5f       	subi	r22, 0xFE	; 254
    1b4e:	7f 4f       	sbci	r23, 0xFF	; 255
    1b50:	0e 94 81 08 	call	0x1102	; 0x1102 <vListInsert>
    1b54:	17 c0       	rjmp	.+46     	; 0x1b84 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1b56:	80 91 e0 05 	lds	r24, 0x05E0
    1b5a:	90 91 e1 05 	lds	r25, 0x05E1
    1b5e:	60 91 d2 05 	lds	r22, 0x05D2
    1b62:	70 91 d3 05 	lds	r23, 0x05D3
    1b66:	6e 5f       	subi	r22, 0xFE	; 254
    1b68:	7f 4f       	sbci	r23, 0xFF	; 255
    1b6a:	0e 94 81 08 	call	0x1102	; 0x1102 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1b6e:	80 91 65 00 	lds	r24, 0x0065
    1b72:	90 91 66 00 	lds	r25, 0x0066
    1b76:	c8 17       	cp	r28, r24
    1b78:	d9 07       	cpc	r29, r25
    1b7a:	20 f4       	brcc	.+8      	; 0x1b84 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    1b7c:	d0 93 66 00 	sts	0x0066, r29
    1b80:	c0 93 65 00 	sts	0x0065, r28
		}
	}
}
    1b84:	df 91       	pop	r29
    1b86:	cf 91       	pop	r28
    1b88:	08 95       	ret

00001b8a <xTaskGenericCreate>:
#endif

/*lint +e956 */

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    1b8a:	4f 92       	push	r4
    1b8c:	5f 92       	push	r5
    1b8e:	6f 92       	push	r6
    1b90:	7f 92       	push	r7
    1b92:	8f 92       	push	r8
    1b94:	9f 92       	push	r9
    1b96:	bf 92       	push	r11
    1b98:	cf 92       	push	r12
    1b9a:	df 92       	push	r13
    1b9c:	ef 92       	push	r14
    1b9e:	ff 92       	push	r15
    1ba0:	0f 93       	push	r16
    1ba2:	1f 93       	push	r17
    1ba4:	cf 93       	push	r28
    1ba6:	df 93       	push	r29
    1ba8:	2c 01       	movw	r4, r24
    1baa:	4b 01       	movw	r8, r22
    1bac:	ea 01       	movw	r28, r20
    1bae:	39 01       	movw	r6, r18
    1bb0:	b0 2e       	mov	r11, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    1bb2:	88 e2       	ldi	r24, 0x28	; 40
    1bb4:	90 e0       	ldi	r25, 0x00	; 0
    1bb6:	0e 94 01 08 	call	0x1002	; 0x1002 <pvPortMalloc>
    1bba:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    1bbc:	00 97       	sbiw	r24, 0x00	; 0
    1bbe:	09 f4       	brne	.+2      	; 0x1bc2 <xTaskGenericCreate+0x38>
    1bc0:	e2 c0       	rjmp	.+452    	; 0x1d86 <xTaskGenericCreate+0x1fc>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1bc2:	c1 14       	cp	r12, r1
    1bc4:	d1 04       	cpc	r13, r1
    1bc6:	09 f0       	breq	.+2      	; 0x1bca <xTaskGenericCreate+0x40>
    1bc8:	f3 c0       	rjmp	.+486    	; 0x1db0 <xTaskGenericCreate+0x226>
    1bca:	ce 01       	movw	r24, r28
    1bcc:	0e 94 01 08 	call	0x1002	; 0x1002 <pvPortMalloc>
    1bd0:	6c 01       	movw	r12, r24
    1bd2:	f8 01       	movw	r30, r16
    1bd4:	90 8f       	std	Z+24, r25	; 0x18
    1bd6:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    1bd8:	00 97       	sbiw	r24, 0x00	; 0
    1bda:	29 f4       	brne	.+10     	; 0x1be6 <xTaskGenericCreate+0x5c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1bdc:	c8 01       	movw	r24, r16
    1bde:	0e 94 37 08 	call	0x106e	; 0x106e <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1be2:	8f ef       	ldi	r24, 0xFF	; 255
    1be4:	d5 c0       	rjmp	.+426    	; 0x1d90 <xTaskGenericCreate+0x206>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    1be6:	c6 01       	movw	r24, r12
    1be8:	65 ea       	ldi	r22, 0xA5	; 165
    1bea:	70 e0       	ldi	r23, 0x00	; 0
    1bec:	ae 01       	movw	r20, r28
    1bee:	0e 94 77 17 	call	0x2eee	; 0x2eee <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    1bf2:	9e 01       	movw	r18, r28
    1bf4:	21 50       	subi	r18, 0x01	; 1
    1bf6:	30 40       	sbci	r19, 0x00	; 0
    1bf8:	f8 01       	movw	r30, r16
    1bfa:	87 89       	ldd	r24, Z+23	; 0x17
    1bfc:	90 8d       	ldd	r25, Z+24	; 0x18
    1bfe:	6c 01       	movw	r12, r24
    1c00:	c2 0e       	add	r12, r18
    1c02:	d3 1e       	adc	r13, r19
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    1c04:	c8 01       	movw	r24, r16
    1c06:	49 96       	adiw	r24, 0x19	; 25
    1c08:	b4 01       	movw	r22, r8
    1c0a:	4f e0       	ldi	r20, 0x0F	; 15
    1c0c:	50 e0       	ldi	r21, 0x00	; 0
    1c0e:	0e 94 7e 17 	call	0x2efc	; 0x2efc <strncpy>
	}
	#endif /* configMAX_TASK_NAME_LEN */
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    1c12:	f8 01       	movw	r30, r16
    1c14:	17 a2       	lds	r17, 0x97
    1c16:	cb 2d       	mov	r28, r11
    1c18:	f3 e0       	ldi	r31, 0x03	; 3
    1c1a:	fb 15       	cp	r31, r11
    1c1c:	08 f4       	brcc	.+2      	; 0x1c20 <xTaskGenericCreate+0x96>
    1c1e:	c3 e0       	ldi	r28, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    1c20:	f8 01       	movw	r30, r16
    1c22:	c6 8b       	std	Z+22, r28	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    1c24:	88 24       	eor	r8, r8
    1c26:	99 24       	eor	r9, r9
    1c28:	68 94       	set
    1c2a:	81 f8       	bld	r8, 1
    1c2c:	80 0e       	add	r8, r16
    1c2e:	91 1e       	adc	r9, r17
    1c30:	c4 01       	movw	r24, r8
    1c32:	0e 94 54 08 	call	0x10a8	; 0x10a8 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    1c36:	c8 01       	movw	r24, r16
    1c38:	0c 96       	adiw	r24, 0x0c	; 12
    1c3a:	0e 94 54 08 	call	0x10a8	; 0x10a8 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1c3e:	f8 01       	movw	r30, r16
    1c40:	11 87       	std	Z+9, r17	; 0x09
    1c42:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( uint16_t ) uxPriority );
    1c44:	84 e0       	ldi	r24, 0x04	; 4
    1c46:	90 e0       	ldi	r25, 0x00	; 0
    1c48:	8c 1b       	sub	r24, r28
    1c4a:	91 09       	sbc	r25, r1
    1c4c:	95 87       	std	Z+13, r25	; 0x0d
    1c4e:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1c50:	13 8b       	std	Z+19, r17	; 0x13
    1c52:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    1c54:	c6 01       	movw	r24, r12
    1c56:	b2 01       	movw	r22, r4
    1c58:	a3 01       	movw	r20, r6
    1c5a:	0e 94 f2 08 	call	0x11e4	; 0x11e4 <pxPortInitialiseStack>
    1c5e:	f8 01       	movw	r30, r16
    1c60:	91 83       	std	Z+1, r25	; 0x01
    1c62:	80 83       	st	Z, r24
		#endif /* portUSING_MPU_WRAPPERS */

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    1c64:	e1 14       	cp	r14, r1
    1c66:	f1 04       	cpc	r15, r1
    1c68:	19 f0       	breq	.+6      	; 0x1c70 <xTaskGenericCreate+0xe6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1c6a:	f7 01       	movw	r30, r14
    1c6c:	11 83       	std	Z+1, r17	; 0x01
    1c6e:	00 83       	st	Z, r16
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1c70:	0f b6       	in	r0, 0x3f	; 63
    1c72:	f8 94       	cli
    1c74:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    1c76:	80 91 dc 05 	lds	r24, 0x05DC
    1c7a:	8f 5f       	subi	r24, 0xFF	; 255
    1c7c:	80 93 dc 05 	sts	0x05DC, r24
			if( pxCurrentTCB == NULL )
    1c80:	80 91 d2 05 	lds	r24, 0x05D2
    1c84:	90 91 d3 05 	lds	r25, 0x05D3
    1c88:	00 97       	sbiw	r24, 0x00	; 0
    1c8a:	d9 f5       	brne	.+118    	; 0x1d02 <xTaskGenericCreate+0x178>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    1c8c:	10 93 d3 05 	sts	0x05D3, r17
    1c90:	00 93 d2 05 	sts	0x05D2, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    1c94:	80 91 dc 05 	lds	r24, 0x05DC
    1c98:	81 30       	cpi	r24, 0x01	; 1
    1c9a:	09 f0       	breq	.+2      	; 0x1c9e <xTaskGenericCreate+0x114>
    1c9c:	41 c0       	rjmp	.+130    	; 0x1d20 <xTaskGenericCreate+0x196>
    1c9e:	c0 e0       	ldi	r28, 0x00	; 0
    1ca0:	d0 e0       	ldi	r29, 0x00	; 0
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    1ca2:	ce 01       	movw	r24, r28
    1ca4:	88 0f       	add	r24, r24
    1ca6:	99 1f       	adc	r25, r25
    1ca8:	88 0f       	add	r24, r24
    1caa:	99 1f       	adc	r25, r25
    1cac:	88 0f       	add	r24, r24
    1cae:	99 1f       	adc	r25, r25
    1cb0:	8c 0f       	add	r24, r28
    1cb2:	9d 1f       	adc	r25, r29
    1cb4:	8c 51       	subi	r24, 0x1C	; 28
    1cb6:	9a 4f       	sbci	r25, 0xFA	; 250
    1cb8:	0e 94 46 08 	call	0x108c	; 0x108c <vListInitialise>
    1cbc:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    1cbe:	c4 30       	cpi	r28, 0x04	; 4
    1cc0:	d1 05       	cpc	r29, r1
    1cc2:	79 f7       	brne	.-34     	; 0x1ca2 <xTaskGenericCreate+0x118>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    1cc4:	c8 e0       	ldi	r28, 0x08	; 8
    1cc6:	d6 e0       	ldi	r29, 0x06	; 6
    1cc8:	ce 01       	movw	r24, r28
    1cca:	0e 94 46 08 	call	0x108c	; 0x108c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    1cce:	0f 2e       	mov	r0, r31
    1cd0:	f1 e1       	ldi	r31, 0x11	; 17
    1cd2:	ef 2e       	mov	r14, r31
    1cd4:	f6 e0       	ldi	r31, 0x06	; 6
    1cd6:	ff 2e       	mov	r15, r31
    1cd8:	f0 2d       	mov	r31, r0
    1cda:	c7 01       	movw	r24, r14
    1cdc:	0e 94 46 08 	call	0x108c	; 0x108c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    1ce0:	8a e1       	ldi	r24, 0x1A	; 26
    1ce2:	96 e0       	ldi	r25, 0x06	; 6
    1ce4:	0e 94 46 08 	call	0x108c	; 0x108c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    1ce8:	83 e2       	ldi	r24, 0x23	; 35
    1cea:	96 e0       	ldi	r25, 0x06	; 6
    1cec:	0e 94 46 08 	call	0x108c	; 0x108c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1cf0:	d0 93 e1 05 	sts	0x05E1, r29
    1cf4:	c0 93 e0 05 	sts	0x05E0, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1cf8:	f0 92 df 05 	sts	0x05DF, r15
    1cfc:	e0 92 de 05 	sts	0x05DE, r14
    1d00:	0f c0       	rjmp	.+30     	; 0x1d20 <xTaskGenericCreate+0x196>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    1d02:	80 91 d8 05 	lds	r24, 0x05D8
    1d06:	88 23       	and	r24, r24
    1d08:	59 f4       	brne	.+22     	; 0x1d20 <xTaskGenericCreate+0x196>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1d0a:	e0 91 d2 05 	lds	r30, 0x05D2
    1d0e:	f0 91 d3 05 	lds	r31, 0x05D3
    1d12:	86 89       	ldd	r24, Z+22	; 0x16
    1d14:	b8 16       	cp	r11, r24
    1d16:	20 f0       	brcs	.+8      	; 0x1d20 <xTaskGenericCreate+0x196>
					{
						pxCurrentTCB = pxNewTCB;
    1d18:	10 93 d3 05 	sts	0x05D3, r17
    1d1c:	00 93 d2 05 	sts	0x05D2, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1d20:	f8 01       	movw	r30, r16
    1d22:	86 89       	ldd	r24, Z+22	; 0x16
    1d24:	90 91 e2 05 	lds	r25, 0x05E2
    1d28:	98 17       	cp	r25, r24
    1d2a:	10 f4       	brcc	.+4      	; 0x1d30 <xTaskGenericCreate+0x1a6>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1d2c:	80 93 e2 05 	sts	0x05E2, r24
			}

			uxTaskNumber++;
    1d30:	90 91 e3 05 	lds	r25, 0x05E3
    1d34:	9f 5f       	subi	r25, 0xFF	; 255
    1d36:	90 93 e3 05 	sts	0x05E3, r25
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyQueue( pxNewTCB );
    1d3a:	90 91 d9 05 	lds	r25, 0x05D9
    1d3e:	98 17       	cp	r25, r24
    1d40:	10 f4       	brcc	.+4      	; 0x1d46 <xTaskGenericCreate+0x1bc>
    1d42:	80 93 d9 05 	sts	0x05D9, r24
    1d46:	90 e0       	ldi	r25, 0x00	; 0
    1d48:	9c 01       	movw	r18, r24
    1d4a:	22 0f       	add	r18, r18
    1d4c:	33 1f       	adc	r19, r19
    1d4e:	22 0f       	add	r18, r18
    1d50:	33 1f       	adc	r19, r19
    1d52:	22 0f       	add	r18, r18
    1d54:	33 1f       	adc	r19, r19
    1d56:	82 0f       	add	r24, r18
    1d58:	93 1f       	adc	r25, r19
    1d5a:	8c 51       	subi	r24, 0x1C	; 28
    1d5c:	9a 4f       	sbci	r25, 0xFA	; 250
    1d5e:	b4 01       	movw	r22, r8
    1d60:	0e 94 58 08 	call	0x10b0	; 0x10b0 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1d64:	0f 90       	pop	r0
    1d66:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1d68:	80 91 d8 05 	lds	r24, 0x05D8
    1d6c:	88 23       	and	r24, r24
    1d6e:	69 f0       	breq	.+26     	; 0x1d8a <xTaskGenericCreate+0x200>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1d70:	e0 91 d2 05 	lds	r30, 0x05D2
    1d74:	f0 91 d3 05 	lds	r31, 0x05D3
    1d78:	86 89       	ldd	r24, Z+22	; 0x16
    1d7a:	8b 15       	cp	r24, r11
    1d7c:	40 f4       	brcc	.+16     	; 0x1d8e <xTaskGenericCreate+0x204>
			{
				portYIELD_WITHIN_API();
    1d7e:	0e 94 b7 09 	call	0x136e	; 0x136e <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1d82:	81 e0       	ldi	r24, 0x01	; 1
    1d84:	05 c0       	rjmp	.+10     	; 0x1d90 <xTaskGenericCreate+0x206>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1d86:	8f ef       	ldi	r24, 0xFF	; 255
    1d88:	03 c0       	rjmp	.+6      	; 0x1d90 <xTaskGenericCreate+0x206>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    1d8a:	81 e0       	ldi	r24, 0x01	; 1
    1d8c:	01 c0       	rjmp	.+2      	; 0x1d90 <xTaskGenericCreate+0x206>
    1d8e:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    1d90:	df 91       	pop	r29
    1d92:	cf 91       	pop	r28
    1d94:	1f 91       	pop	r17
    1d96:	0f 91       	pop	r16
    1d98:	ff 90       	pop	r15
    1d9a:	ef 90       	pop	r14
    1d9c:	df 90       	pop	r13
    1d9e:	cf 90       	pop	r12
    1da0:	bf 90       	pop	r11
    1da2:	9f 90       	pop	r9
    1da4:	8f 90       	pop	r8
    1da6:	7f 90       	pop	r7
    1da8:	6f 90       	pop	r6
    1daa:	5f 90       	pop	r5
    1dac:	4f 90       	pop	r4
    1dae:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    1db0:	fc 01       	movw	r30, r24
    1db2:	d0 8e       	std	Z+24, r13	; 0x18
    1db4:	c7 8a       	std	Z+23, r12	; 0x17
    1db6:	17 cf       	rjmp	.-466    	; 0x1be6 <xTaskGenericCreate+0x5c>

00001db8 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle xTaskToDelete )
	{
    1db8:	ef 92       	push	r14
    1dba:	ff 92       	push	r15
    1dbc:	0f 93       	push	r16
    1dbe:	1f 93       	push	r17
    1dc0:	cf 93       	push	r28
    1dc2:	df 93       	push	r29
    1dc4:	7c 01       	movw	r14, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    1dc6:	0f b6       	in	r0, 0x3f	; 63
    1dc8:	f8 94       	cli
    1dca:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( xTaskToDelete == pxCurrentTCB )
    1dcc:	80 91 d2 05 	lds	r24, 0x05D2
    1dd0:	90 91 d3 05 	lds	r25, 0x05D3
    1dd4:	e8 16       	cp	r14, r24
    1dd6:	f9 06       	cpc	r15, r25
    1dd8:	21 f0       	breq	.+8      	; 0x1de2 <vTaskDelete+0x2a>
			{
				xTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    1dda:	e1 14       	cp	r14, r1
    1ddc:	f1 04       	cpc	r15, r1
    1dde:	41 f4       	brne	.+16     	; 0x1df0 <vTaskDelete+0x38>
    1de0:	02 c0       	rjmp	.+4      	; 0x1de6 <vTaskDelete+0x2e>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( xTaskToDelete == pxCurrentTCB )
			{
				xTaskToDelete = NULL;
    1de2:	ee 24       	eor	r14, r14
    1de4:	ff 24       	eor	r15, r15
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    1de6:	c0 91 d2 05 	lds	r28, 0x05D2
    1dea:	d0 91 d3 05 	lds	r29, 0x05D3
    1dee:	01 c0       	rjmp	.+2      	; 0x1df2 <vTaskDelete+0x3a>
    1df0:	e7 01       	movw	r28, r14

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    1df2:	8e 01       	movw	r16, r28
    1df4:	0e 5f       	subi	r16, 0xFE	; 254
    1df6:	1f 4f       	sbci	r17, 0xFF	; 255
    1df8:	c8 01       	movw	r24, r16
    1dfa:	0e 94 cb 08 	call	0x1196	; 0x1196 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1dfe:	8c 89       	ldd	r24, Y+20	; 0x14
    1e00:	9d 89       	ldd	r25, Y+21	; 0x15
    1e02:	00 97       	sbiw	r24, 0x00	; 0
    1e04:	21 f0       	breq	.+8      	; 0x1e0e <vTaskDelete+0x56>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
    1e06:	ce 01       	movw	r24, r28
    1e08:	0c 96       	adiw	r24, 0x0c	; 12
    1e0a:	0e 94 cb 08 	call	0x1196	; 0x1196 <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1e0e:	83 e2       	ldi	r24, 0x23	; 35
    1e10:	96 e0       	ldi	r25, 0x06	; 6
    1e12:	b8 01       	movw	r22, r16
    1e14:	0e 94 58 08 	call	0x10b0	; 0x10b0 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1e18:	80 91 dd 05 	lds	r24, 0x05DD
    1e1c:	8f 5f       	subi	r24, 0xFF	; 255
    1e1e:	80 93 dd 05 	sts	0x05DD, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    1e22:	80 91 e3 05 	lds	r24, 0x05E3
    1e26:	8f 5f       	subi	r24, 0xFF	; 255
    1e28:	80 93 e3 05 	sts	0x05E3, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1e2c:	0f 90       	pop	r0
    1e2e:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1e30:	80 91 d8 05 	lds	r24, 0x05D8
    1e34:	88 23       	and	r24, r24
    1e36:	29 f0       	breq	.+10     	; 0x1e42 <vTaskDelete+0x8a>
		{
			if( ( void * ) xTaskToDelete == NULL )
    1e38:	e1 14       	cp	r14, r1
    1e3a:	f1 04       	cpc	r15, r1
    1e3c:	11 f4       	brne	.+4      	; 0x1e42 <vTaskDelete+0x8a>
			{
				portYIELD_WITHIN_API();
    1e3e:	0e 94 b7 09 	call	0x136e	; 0x136e <vPortYield>
			}
		}
	}
    1e42:	df 91       	pop	r29
    1e44:	cf 91       	pop	r28
    1e46:	1f 91       	pop	r17
    1e48:	0f 91       	pop	r16
    1e4a:	ff 90       	pop	r15
    1e4c:	ef 90       	pop	r14
    1e4e:	08 95       	ret

00001e50 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    1e50:	af 92       	push	r10
    1e52:	bf 92       	push	r11
    1e54:	cf 92       	push	r12
    1e56:	df 92       	push	r13
    1e58:	ef 92       	push	r14
    1e5a:	ff 92       	push	r15
    1e5c:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1e5e:	80 ed       	ldi	r24, 0xD0	; 208
    1e60:	90 e1       	ldi	r25, 0x10	; 16
    1e62:	60 e6       	ldi	r22, 0x60	; 96
    1e64:	70 e0       	ldi	r23, 0x00	; 0
    1e66:	45 e5       	ldi	r20, 0x55	; 85
    1e68:	50 e0       	ldi	r21, 0x00	; 0
    1e6a:	20 e0       	ldi	r18, 0x00	; 0
    1e6c:	30 e0       	ldi	r19, 0x00	; 0
    1e6e:	00 e0       	ldi	r16, 0x00	; 0
    1e70:	ee 24       	eor	r14, r14
    1e72:	ff 24       	eor	r15, r15
    1e74:	cc 24       	eor	r12, r12
    1e76:	dd 24       	eor	r13, r13
    1e78:	aa 24       	eor	r10, r10
    1e7a:	bb 24       	eor	r11, r11
    1e7c:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1e80:	81 30       	cpi	r24, 0x01	; 1
    1e82:	49 f4       	brne	.+18     	; 0x1e96 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1e84:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1e86:	80 93 d8 05 	sts	0x05D8, r24
		xTickCount = ( uint16_t ) 0U;
    1e8a:	10 92 db 05 	sts	0x05DB, r1
    1e8e:	10 92 da 05 	sts	0x05DA, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1e92:	0e 94 82 09 	call	0x1304	; 0x1304 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    1e96:	0f 91       	pop	r16
    1e98:	ff 90       	pop	r15
    1e9a:	ef 90       	pop	r14
    1e9c:	df 90       	pop	r13
    1e9e:	cf 90       	pop	r12
    1ea0:	bf 90       	pop	r11
    1ea2:	af 90       	pop	r10
    1ea4:	08 95       	ret

00001ea6 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    1ea6:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    1ea8:	10 92 d8 05 	sts	0x05D8, r1
	vPortEndScheduler();
    1eac:	0e 94 b6 09 	call	0x136c	; 0x136c <vPortEndScheduler>
}
    1eb0:	08 95       	ret

00001eb2 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    1eb2:	80 91 d7 05 	lds	r24, 0x05D7
    1eb6:	8f 5f       	subi	r24, 0xFF	; 255
    1eb8:	80 93 d7 05 	sts	0x05D7, r24
}
    1ebc:	08 95       	ret

00001ebe <xTaskGetTickCount>:
uint16_t xTaskGetTickCount( void )
{
uint16_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    1ebe:	0f b6       	in	r0, 0x3f	; 63
    1ec0:	f8 94       	cli
    1ec2:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    1ec4:	80 91 da 05 	lds	r24, 0x05DA
    1ec8:	90 91 db 05 	lds	r25, 0x05DB
	}
	taskEXIT_CRITICAL();
    1ecc:	0f 90       	pop	r0
    1ece:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    1ed0:	08 95       	ret

00001ed2 <xTaskGetTickCountFromISR>:
{
uint16_t xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    1ed2:	80 91 da 05 	lds	r24, 0x05DA
    1ed6:	90 91 db 05 	lds	r25, 0x05DB
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1eda:	08 95       	ret

00001edc <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1edc:	80 91 dc 05 	lds	r24, 0x05DC
}
    1ee0:	08 95       	ret

00001ee2 <vTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    1ee2:	0f 93       	push	r16
    1ee4:	1f 93       	push	r17
    1ee6:	cf 93       	push	r28
    1ee8:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1eea:	80 91 d7 05 	lds	r24, 0x05D7
    1eee:	88 23       	and	r24, r24
    1ef0:	09 f0       	breq	.+2      	; 0x1ef4 <vTaskIncrementTick+0x12>
    1ef2:	bc c0       	rjmp	.+376    	; 0x206c <vTaskIncrementTick+0x18a>
	{
		++xTickCount;
    1ef4:	80 91 da 05 	lds	r24, 0x05DA
    1ef8:	90 91 db 05 	lds	r25, 0x05DB
    1efc:	01 96       	adiw	r24, 0x01	; 1
    1efe:	90 93 db 05 	sts	0x05DB, r25
    1f02:	80 93 da 05 	sts	0x05DA, r24
        
if( xTickCount==65535 )
    1f06:	80 91 da 05 	lds	r24, 0x05DA
    1f0a:	90 91 db 05 	lds	r25, 0x05DB
    1f0e:	2f ef       	ldi	r18, 0xFF	; 255
    1f10:	8f 3f       	cpi	r24, 0xFF	; 255
    1f12:	92 07       	cpc	r25, r18
    1f14:	09 f4       	brne	.+2      	; 0x1f18 <vTaskIncrementTick+0x36>
{
    asm("nop");
    1f16:	00 00       	nop
}
        
		if( xTickCount == ( uint16_t ) 0U )
    1f18:	80 91 da 05 	lds	r24, 0x05DA
    1f1c:	90 91 db 05 	lds	r25, 0x05DB
    1f20:	00 97       	sbiw	r24, 0x00	; 0
    1f22:	99 f5       	brne	.+102    	; 0x1f8a <vTaskIncrementTick+0xa8>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
    1f24:	80 91 e0 05 	lds	r24, 0x05E0
    1f28:	90 91 e1 05 	lds	r25, 0x05E1
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1f2c:	20 91 de 05 	lds	r18, 0x05DE
    1f30:	30 91 df 05 	lds	r19, 0x05DF
    1f34:	30 93 e1 05 	sts	0x05E1, r19
    1f38:	20 93 e0 05 	sts	0x05E0, r18
			pxOverflowDelayedTaskList = pxTemp;
    1f3c:	90 93 df 05 	sts	0x05DF, r25
    1f40:	80 93 de 05 	sts	0x05DE, r24
			xNumOfOverflows++;
    1f44:	80 91 d4 05 	lds	r24, 0x05D4
    1f48:	8f 5f       	subi	r24, 0xFF	; 255
    1f4a:	80 93 d4 05 	sts	0x05D4, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1f4e:	e0 91 e0 05 	lds	r30, 0x05E0
    1f52:	f0 91 e1 05 	lds	r31, 0x05E1
    1f56:	80 81       	ld	r24, Z
    1f58:	88 23       	and	r24, r24
    1f5a:	39 f4       	brne	.+14     	; 0x1f6a <vTaskIncrementTick+0x88>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1f5c:	8f ef       	ldi	r24, 0xFF	; 255
    1f5e:	9f ef       	ldi	r25, 0xFF	; 255
    1f60:	90 93 66 00 	sts	0x0066, r25
    1f64:	80 93 65 00 	sts	0x0065, r24
    1f68:	10 c0       	rjmp	.+32     	; 0x1f8a <vTaskIncrementTick+0xa8>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1f6a:	e0 91 e0 05 	lds	r30, 0x05E0
    1f6e:	f0 91 e1 05 	lds	r31, 0x05E1
    1f72:	05 80       	ldd	r0, Z+5	; 0x05
    1f74:	f6 81       	ldd	r31, Z+6	; 0x06
    1f76:	e0 2d       	mov	r30, r0
    1f78:	06 80       	ldd	r0, Z+6	; 0x06
    1f7a:	f7 81       	ldd	r31, Z+7	; 0x07
    1f7c:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    1f7e:	82 81       	ldd	r24, Z+2	; 0x02
    1f80:	93 81       	ldd	r25, Z+3	; 0x03
    1f82:	90 93 66 00 	sts	0x0066, r25
    1f86:	80 93 65 00 	sts	0x0065, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    1f8a:	20 91 da 05 	lds	r18, 0x05DA
    1f8e:	30 91 db 05 	lds	r19, 0x05DB
    1f92:	80 91 65 00 	lds	r24, 0x0065
    1f96:	90 91 66 00 	lds	r25, 0x0066
    1f9a:	28 17       	cp	r18, r24
    1f9c:	39 07       	cpc	r19, r25
    1f9e:	08 f4       	brcc	.+2      	; 0x1fa2 <vTaskIncrementTick+0xc0>
    1fa0:	6a c0       	rjmp	.+212    	; 0x2076 <vTaskIncrementTick+0x194>
    1fa2:	e0 91 e0 05 	lds	r30, 0x05E0
    1fa6:	f0 91 e1 05 	lds	r31, 0x05E1
    1faa:	80 81       	ld	r24, Z
    1fac:	88 23       	and	r24, r24
    1fae:	99 f0       	breq	.+38     	; 0x1fd6 <vTaskIncrementTick+0xf4>
    1fb0:	e0 91 e0 05 	lds	r30, 0x05E0
    1fb4:	f0 91 e1 05 	lds	r31, 0x05E1
    1fb8:	05 80       	ldd	r0, Z+5	; 0x05
    1fba:	f6 81       	ldd	r31, Z+6	; 0x06
    1fbc:	e0 2d       	mov	r30, r0
    1fbe:	c6 81       	ldd	r28, Z+6	; 0x06
    1fc0:	d7 81       	ldd	r29, Z+7	; 0x07
    1fc2:	8a 81       	ldd	r24, Y+2	; 0x02
    1fc4:	9b 81       	ldd	r25, Y+3	; 0x03
    1fc6:	20 91 da 05 	lds	r18, 0x05DA
    1fca:	30 91 db 05 	lds	r19, 0x05DB
    1fce:	28 17       	cp	r18, r24
    1fd0:	39 07       	cpc	r19, r25
    1fd2:	f8 f4       	brcc	.+62     	; 0x2012 <vTaskIncrementTick+0x130>
    1fd4:	19 c0       	rjmp	.+50     	; 0x2008 <vTaskIncrementTick+0x126>
    1fd6:	8f ef       	ldi	r24, 0xFF	; 255
    1fd8:	9f ef       	ldi	r25, 0xFF	; 255
    1fda:	90 93 66 00 	sts	0x0066, r25
    1fde:	80 93 65 00 	sts	0x0065, r24
    1fe2:	49 c0       	rjmp	.+146    	; 0x2076 <vTaskIncrementTick+0x194>
    1fe4:	e0 91 e0 05 	lds	r30, 0x05E0
    1fe8:	f0 91 e1 05 	lds	r31, 0x05E1
    1fec:	05 80       	ldd	r0, Z+5	; 0x05
    1fee:	f6 81       	ldd	r31, Z+6	; 0x06
    1ff0:	e0 2d       	mov	r30, r0
    1ff2:	c6 81       	ldd	r28, Z+6	; 0x06
    1ff4:	d7 81       	ldd	r29, Z+7	; 0x07
    1ff6:	8a 81       	ldd	r24, Y+2	; 0x02
    1ff8:	9b 81       	ldd	r25, Y+3	; 0x03
    1ffa:	20 91 da 05 	lds	r18, 0x05DA
    1ffe:	30 91 db 05 	lds	r19, 0x05DB
    2002:	28 17       	cp	r18, r24
    2004:	39 07       	cpc	r19, r25
    2006:	28 f4       	brcc	.+10     	; 0x2012 <vTaskIncrementTick+0x130>
    2008:	90 93 66 00 	sts	0x0066, r25
    200c:	80 93 65 00 	sts	0x0065, r24
    2010:	32 c0       	rjmp	.+100    	; 0x2076 <vTaskIncrementTick+0x194>
    2012:	8e 01       	movw	r16, r28
    2014:	0e 5f       	subi	r16, 0xFE	; 254
    2016:	1f 4f       	sbci	r17, 0xFF	; 255
    2018:	c8 01       	movw	r24, r16
    201a:	0e 94 cb 08 	call	0x1196	; 0x1196 <uxListRemove>
    201e:	8c 89       	ldd	r24, Y+20	; 0x14
    2020:	9d 89       	ldd	r25, Y+21	; 0x15
    2022:	00 97       	sbiw	r24, 0x00	; 0
    2024:	21 f0       	breq	.+8      	; 0x202e <vTaskIncrementTick+0x14c>
    2026:	ce 01       	movw	r24, r28
    2028:	0c 96       	adiw	r24, 0x0c	; 12
    202a:	0e 94 cb 08 	call	0x1196	; 0x1196 <uxListRemove>
    202e:	8e 89       	ldd	r24, Y+22	; 0x16
    2030:	90 91 d9 05 	lds	r25, 0x05D9
    2034:	98 17       	cp	r25, r24
    2036:	10 f4       	brcc	.+4      	; 0x203c <vTaskIncrementTick+0x15a>
    2038:	80 93 d9 05 	sts	0x05D9, r24
    203c:	90 e0       	ldi	r25, 0x00	; 0
    203e:	9c 01       	movw	r18, r24
    2040:	22 0f       	add	r18, r18
    2042:	33 1f       	adc	r19, r19
    2044:	22 0f       	add	r18, r18
    2046:	33 1f       	adc	r19, r19
    2048:	22 0f       	add	r18, r18
    204a:	33 1f       	adc	r19, r19
    204c:	82 0f       	add	r24, r18
    204e:	93 1f       	adc	r25, r19
    2050:	8c 51       	subi	r24, 0x1C	; 28
    2052:	9a 4f       	sbci	r25, 0xFA	; 250
    2054:	b8 01       	movw	r22, r16
    2056:	0e 94 58 08 	call	0x10b0	; 0x10b0 <vListInsertEnd>
    205a:	e0 91 e0 05 	lds	r30, 0x05E0
    205e:	f0 91 e1 05 	lds	r31, 0x05E1
    2062:	80 81       	ld	r24, Z
    2064:	88 23       	and	r24, r24
    2066:	09 f0       	breq	.+2      	; 0x206a <vTaskIncrementTick+0x188>
    2068:	bd cf       	rjmp	.-134    	; 0x1fe4 <vTaskIncrementTick+0x102>
    206a:	b5 cf       	rjmp	.-150    	; 0x1fd6 <vTaskIncrementTick+0xf4>
	}
	else
	{
		++uxMissedTicks;
    206c:	80 91 d6 05 	lds	r24, 0x05D6
    2070:	8f 5f       	subi	r24, 0xFF	; 255
    2072:	80 93 d6 05 	sts	0x05D6, r24
		{
			vApplicationTickHook();
		}
	}
	#endif /* configUSE_TICK_HOOK */
}
    2076:	df 91       	pop	r29
    2078:	cf 91       	pop	r28
    207a:	1f 91       	pop	r17
    207c:	0f 91       	pop	r16
    207e:	08 95       	ret

00002080 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2080:	af 92       	push	r10
    2082:	bf 92       	push	r11
    2084:	cf 92       	push	r12
    2086:	df 92       	push	r13
    2088:	ef 92       	push	r14
    208a:	ff 92       	push	r15
    208c:	0f 93       	push	r16
    208e:	1f 93       	push	r17
    2090:	cf 93       	push	r28
    2092:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2094:	0f b6       	in	r0, 0x3f	; 63
    2096:	f8 94       	cli
    2098:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    209a:	80 91 d7 05 	lds	r24, 0x05D7
    209e:	81 50       	subi	r24, 0x01	; 1
    20a0:	80 93 d7 05 	sts	0x05D7, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    20a4:	80 91 d7 05 	lds	r24, 0x05D7
    20a8:	88 23       	and	r24, r24
    20aa:	09 f0       	breq	.+2      	; 0x20ae <xTaskResumeAll+0x2e>
    20ac:	69 c0       	rjmp	.+210    	; 0x2180 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    20ae:	80 91 dc 05 	lds	r24, 0x05DC
    20b2:	88 23       	and	r24, r24
    20b4:	81 f5       	brne	.+96     	; 0x2116 <xTaskResumeAll+0x96>
    20b6:	67 c0       	rjmp	.+206    	; 0x2186 <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    20b8:	d6 01       	movw	r26, r12
    20ba:	ed 91       	ld	r30, X+
    20bc:	fc 91       	ld	r31, X
    20be:	c6 81       	ldd	r28, Z+6	; 0x06
    20c0:	d7 81       	ldd	r29, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
    20c2:	ce 01       	movw	r24, r28
    20c4:	0c 96       	adiw	r24, 0x0c	; 12
    20c6:	0e 94 cb 08 	call	0x1196	; 0x1196 <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
    20ca:	8e 01       	movw	r16, r28
    20cc:	0e 5f       	subi	r16, 0xFE	; 254
    20ce:	1f 4f       	sbci	r17, 0xFF	; 255
    20d0:	c8 01       	movw	r24, r16
    20d2:	0e 94 cb 08 	call	0x1196	; 0x1196 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    20d6:	8e 89       	ldd	r24, Y+22	; 0x16
    20d8:	90 91 d9 05 	lds	r25, 0x05D9
    20dc:	98 17       	cp	r25, r24
    20de:	10 f4       	brcc	.+4      	; 0x20e4 <xTaskResumeAll+0x64>
    20e0:	80 93 d9 05 	sts	0x05D9, r24
    20e4:	90 e0       	ldi	r25, 0x00	; 0
    20e6:	9c 01       	movw	r18, r24
    20e8:	22 0f       	add	r18, r18
    20ea:	33 1f       	adc	r19, r19
    20ec:	22 0f       	add	r18, r18
    20ee:	33 1f       	adc	r19, r19
    20f0:	22 0f       	add	r18, r18
    20f2:	33 1f       	adc	r19, r19
    20f4:	82 0f       	add	r24, r18
    20f6:	93 1f       	adc	r25, r19
    20f8:	8c 51       	subi	r24, 0x1C	; 28
    20fa:	9a 4f       	sbci	r25, 0xFA	; 250
    20fc:	b8 01       	movw	r22, r16
    20fe:	0e 94 58 08 	call	0x10b0	; 0x10b0 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2102:	e0 91 d2 05 	lds	r30, 0x05D2
    2106:	f0 91 d3 05 	lds	r31, 0x05D3
    210a:	9e 89       	ldd	r25, Y+22	; 0x16
    210c:	86 89       	ldd	r24, Z+22	; 0x16
    210e:	98 17       	cp	r25, r24
    2110:	88 f0       	brcs	.+34     	; 0x2134 <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    2112:	ba 2c       	mov	r11, r10
    2114:	0f c0       	rjmp	.+30     	; 0x2134 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2116:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2118:	0f 2e       	mov	r0, r31
    211a:	fa e1       	ldi	r31, 0x1A	; 26
    211c:	ef 2e       	mov	r14, r31
    211e:	f6 e0       	ldi	r31, 0x06	; 6
    2120:	ff 2e       	mov	r15, r31
    2122:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2124:	0f 2e       	mov	r0, r31
    2126:	ff e1       	ldi	r31, 0x1F	; 31
    2128:	cf 2e       	mov	r12, r31
    212a:	f6 e0       	ldi	r31, 0x06	; 6
    212c:	df 2e       	mov	r13, r31
    212e:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    2130:	aa 24       	eor	r10, r10
    2132:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2134:	f7 01       	movw	r30, r14
    2136:	80 81       	ld	r24, Z
    2138:	88 23       	and	r24, r24
    213a:	09 f0       	breq	.+2      	; 0x213e <xTaskResumeAll+0xbe>
    213c:	bd cf       	rjmp	.-134    	; 0x20b8 <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    213e:	80 91 d6 05 	lds	r24, 0x05D6
    2142:	88 23       	and	r24, r24
    2144:	81 f0       	breq	.+32     	; 0x2166 <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2146:	80 91 d6 05 	lds	r24, 0x05D6
    214a:	88 23       	and	r24, r24
    214c:	99 f0       	breq	.+38     	; 0x2174 <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    214e:	0e 94 71 0f 	call	0x1ee2	; 0x1ee2 <vTaskIncrementTick>
						--uxMissedTicks;
    2152:	80 91 d6 05 	lds	r24, 0x05D6
    2156:	81 50       	subi	r24, 0x01	; 1
    2158:	80 93 d6 05 	sts	0x05D6, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    215c:	80 91 d6 05 	lds	r24, 0x05D6
    2160:	88 23       	and	r24, r24
    2162:	a9 f7       	brne	.-22     	; 0x214e <xTaskResumeAll+0xce>
    2164:	07 c0       	rjmp	.+14     	; 0x2174 <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2166:	f1 e0       	ldi	r31, 0x01	; 1
    2168:	bf 16       	cp	r11, r31
    216a:	21 f0       	breq	.+8      	; 0x2174 <xTaskResumeAll+0xf4>
    216c:	80 91 d5 05 	lds	r24, 0x05D5
    2170:	81 30       	cpi	r24, 0x01	; 1
    2172:	41 f4       	brne	.+16     	; 0x2184 <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    2174:	10 92 d5 05 	sts	0x05D5, r1
					portYIELD_WITHIN_API();
    2178:	0e 94 b7 09 	call	0x136e	; 0x136e <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    217c:	81 e0       	ldi	r24, 0x01	; 1
    217e:	03 c0       	rjmp	.+6      	; 0x2186 <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2180:	80 e0       	ldi	r24, 0x00	; 0
    2182:	01 c0       	rjmp	.+2      	; 0x2186 <xTaskResumeAll+0x106>
    2184:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2186:	0f 90       	pop	r0
    2188:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    218a:	df 91       	pop	r29
    218c:	cf 91       	pop	r28
    218e:	1f 91       	pop	r17
    2190:	0f 91       	pop	r16
    2192:	ff 90       	pop	r15
    2194:	ef 90       	pop	r14
    2196:	df 90       	pop	r13
    2198:	cf 90       	pop	r12
    219a:	bf 90       	pop	r11
    219c:	af 90       	pop	r10
    219e:	08 95       	ret

000021a0 <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    21a0:	03 e2       	ldi	r16, 0x23	; 35
    21a2:	16 e0       	ldi	r17, 0x06	; 6
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    21a4:	0f 2e       	mov	r0, r31
    21a6:	f8 e2       	ldi	r31, 0x28	; 40
    21a8:	ef 2e       	mov	r14, r31
    21aa:	f6 e0       	ldi	r31, 0x06	; 6
    21ac:	ff 2e       	mov	r15, r31
    21ae:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    21b0:	0f 2e       	mov	r0, r31
    21b2:	f4 ee       	ldi	r31, 0xE4	; 228
    21b4:	cf 2e       	mov	r12, r31
    21b6:	f5 e0       	ldi	r31, 0x05	; 5
    21b8:	df 2e       	mov	r13, r31
    21ba:	f0 2d       	mov	r31, r0
    21bc:	27 c0       	rjmp	.+78     	; 0x220c <prvIdleTask+0x6c>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
    21be:	0e 94 59 0f 	call	0x1eb2	; 0x1eb2 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    21c2:	d8 01       	movw	r26, r16
    21c4:	cc 91       	ld	r28, X
			xTaskResumeAll();
    21c6:	0e 94 40 10 	call	0x2080	; 0x2080 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    21ca:	cc 23       	and	r28, r28
    21cc:	f9 f0       	breq	.+62     	; 0x220c <prvIdleTask+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    21ce:	0f b6       	in	r0, 0x3f	; 63
    21d0:	f8 94       	cli
    21d2:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    21d4:	d7 01       	movw	r26, r14
    21d6:	ed 91       	ld	r30, X+
    21d8:	fc 91       	ld	r31, X
    21da:	c6 81       	ldd	r28, Z+6	; 0x06
    21dc:	d7 81       	ldd	r29, Z+7	; 0x07
					uxListRemove( &( pxTCB->xGenericListItem ) );
    21de:	ce 01       	movw	r24, r28
    21e0:	02 96       	adiw	r24, 0x02	; 2
    21e2:	0e 94 cb 08 	call	0x1196	; 0x1196 <uxListRemove>
					--uxCurrentNumberOfTasks;
    21e6:	80 91 dc 05 	lds	r24, 0x05DC
    21ea:	81 50       	subi	r24, 0x01	; 1
    21ec:	80 93 dc 05 	sts	0x05DC, r24
					--uxTasksDeleted;
    21f0:	80 91 dd 05 	lds	r24, 0x05DD
    21f4:	81 50       	subi	r24, 0x01	; 1
    21f6:	80 93 dd 05 	sts	0x05DD, r24
				}
				taskEXIT_CRITICAL();
    21fa:	0f 90       	pop	r0
    21fc:	0f be       	out	0x3f, r0	; 63
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    21fe:	8f 89       	ldd	r24, Y+23	; 0x17
    2200:	98 8d       	ldd	r25, Y+24	; 0x18
    2202:	0e 94 37 08 	call	0x106e	; 0x106e <vPortFree>
		vPortFree( pxTCB );
    2206:	ce 01       	movw	r24, r28
    2208:	0e 94 37 08 	call	0x106e	; 0x106e <vPortFree>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    220c:	80 91 dd 05 	lds	r24, 0x05DD
    2210:	88 23       	and	r24, r24
    2212:	a9 f6       	brne	.-86     	; 0x21be <prvIdleTask+0x1e>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    2214:	f6 01       	movw	r30, r12
    2216:	80 81       	ld	r24, Z
    2218:	82 30       	cpi	r24, 0x02	; 2
    221a:	c0 f3       	brcs	.-16     	; 0x220c <prvIdleTask+0x6c>
			{
				taskYIELD();
    221c:	0e 94 b7 09 	call	0x136e	; 0x136e <vPortYield>
    2220:	f5 cf       	rjmp	.-22     	; 0x220c <prvIdleTask+0x6c>

00002222 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( uint16_t xTicksToDelay )
	{
    2222:	cf 93       	push	r28
    2224:	df 93       	push	r29
    2226:	ec 01       	movw	r28, r24
	uint16_t xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( uint16_t ) 0U )
    2228:	00 97       	sbiw	r24, 0x00	; 0
    222a:	b1 f0       	breq	.+44     	; 0x2258 <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    222c:	0e 94 59 0f 	call	0x1eb2	; 0x1eb2 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2230:	80 91 da 05 	lds	r24, 0x05DA
    2234:	90 91 db 05 	lds	r25, 0x05DB
    2238:	c8 0f       	add	r28, r24
    223a:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    223c:	80 91 d2 05 	lds	r24, 0x05D2
    2240:	90 91 d3 05 	lds	r25, 0x05D3
    2244:	02 96       	adiw	r24, 0x02	; 2
    2246:	0e 94 cb 08 	call	0x1196	; 0x1196 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    224a:	ce 01       	movw	r24, r28
    224c:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2250:	0e 94 40 10 	call	0x2080	; 0x2080 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2254:	88 23       	and	r24, r24
    2256:	11 f4       	brne	.+4      	; 0x225c <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    2258:	0e 94 b7 09 	call	0x136e	; 0x136e <vPortYield>
		}
	}
    225c:	df 91       	pop	r29
    225e:	cf 91       	pop	r28
    2260:	08 95       	ret

00002262 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( uint16_t * const pxPreviousWakeTime, uint16_t xTimeIncrement )
	{
    2262:	0f 93       	push	r16
    2264:	1f 93       	push	r17
    2266:	cf 93       	push	r28
    2268:	df 93       	push	r29
    226a:	8c 01       	movw	r16, r24
    226c:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

if( *pxPreviousWakeTime!=xTickCount )
    226e:	80 91 da 05 	lds	r24, 0x05DA
    2272:	90 91 db 05 	lds	r25, 0x05DB
    2276:	f8 01       	movw	r30, r16
    2278:	20 81       	ld	r18, Z
    227a:	31 81       	ldd	r19, Z+1	; 0x01
    227c:	28 17       	cp	r18, r24
    227e:	39 07       	cpc	r19, r25
    2280:	09 f0       	breq	.+2      	; 0x2284 <vTaskDelayUntil+0x22>
{
    asm ("nop");
    2282:	00 00       	nop
    
}

		vTaskSuspendAll();
    2284:	0e 94 59 0f 	call	0x1eb2	; 0x1eb2 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2288:	f8 01       	movw	r30, r16
    228a:	80 81       	ld	r24, Z
    228c:	91 81       	ldd	r25, Z+1	; 0x01
    228e:	c8 0f       	add	r28, r24
    2290:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    2292:	20 91 da 05 	lds	r18, 0x05DA
    2296:	30 91 db 05 	lds	r19, 0x05DB
    229a:	28 17       	cp	r18, r24
    229c:	39 07       	cpc	r19, r25
    229e:	68 f4       	brcc	.+26     	; 0x22ba <vTaskDelayUntil+0x58>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    22a0:	c8 17       	cp	r28, r24
    22a2:	d9 07       	cpc	r29, r25
    22a4:	50 f5       	brcc	.+84     	; 0x22fa <vTaskDelayUntil+0x98>
    22a6:	80 91 da 05 	lds	r24, 0x05DA
    22aa:	90 91 db 05 	lds	r25, 0x05DB
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    22ae:	d1 83       	std	Z+1, r29	; 0x01
    22b0:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    22b2:	8c 17       	cp	r24, r28
    22b4:	9d 07       	cpc	r25, r29
    22b6:	b0 f4       	brcc	.+44     	; 0x22e4 <vTaskDelayUntil+0x82>
    22b8:	0b c0       	rjmp	.+22     	; 0x22d0 <vTaskDelayUntil+0x6e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    22ba:	c8 17       	cp	r28, r24
    22bc:	d9 07       	cpc	r29, r25
    22be:	c8 f0       	brcs	.+50     	; 0x22f2 <vTaskDelayUntil+0x90>
    22c0:	80 91 da 05 	lds	r24, 0x05DA
    22c4:	90 91 db 05 	lds	r25, 0x05DB
    22c8:	8c 17       	cp	r24, r28
    22ca:	9d 07       	cpc	r25, r29
    22cc:	90 f0       	brcs	.+36     	; 0x22f2 <vTaskDelayUntil+0x90>
    22ce:	15 c0       	rjmp	.+42     	; 0x22fa <vTaskDelayUntil+0x98>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    22d0:	80 91 d2 05 	lds	r24, 0x05D2
    22d4:	90 91 d3 05 	lds	r25, 0x05D3
    22d8:	02 96       	adiw	r24, 0x02	; 2
    22da:	0e 94 cb 08 	call	0x1196	; 0x1196 <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    22de:	ce 01       	movw	r24, r28
    22e0:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    22e4:	0e 94 40 10 	call	0x2080	; 0x2080 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    22e8:	88 23       	and	r24, r24
    22ea:	59 f4       	brne	.+22     	; 0x2302 <vTaskDelayUntil+0xa0>
		{
			portYIELD_WITHIN_API();
    22ec:	0e 94 b7 09 	call	0x136e	; 0x136e <vPortYield>
    22f0:	08 c0       	rjmp	.+16     	; 0x2302 <vTaskDelayUntil+0xa0>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    22f2:	f8 01       	movw	r30, r16
    22f4:	d1 83       	std	Z+1, r29	; 0x01
    22f6:	c0 83       	st	Z, r28
    22f8:	eb cf       	rjmp	.-42     	; 0x22d0 <vTaskDelayUntil+0x6e>
    22fa:	f8 01       	movw	r30, r16
    22fc:	d1 83       	std	Z+1, r29	; 0x01
    22fe:	c0 83       	st	Z, r28
    2300:	f1 cf       	rjmp	.-30     	; 0x22e4 <vTaskDelayUntil+0x82>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    2302:	df 91       	pop	r29
    2304:	cf 91       	pop	r28
    2306:	1f 91       	pop	r17
    2308:	0f 91       	pop	r16
    230a:	08 95       	ret

0000230c <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    230c:	80 91 d7 05 	lds	r24, 0x05D7
    2310:	88 23       	and	r24, r24
    2312:	99 f4       	brne	.+38     	; 0x233a <vTaskSwitchContext+0x2e>
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    2314:	80 91 d9 05 	lds	r24, 0x05D9
    2318:	90 e0       	ldi	r25, 0x00	; 0
    231a:	fc 01       	movw	r30, r24
    231c:	ee 0f       	add	r30, r30
    231e:	ff 1f       	adc	r31, r31
    2320:	ee 0f       	add	r30, r30
    2322:	ff 1f       	adc	r31, r31
    2324:	ee 0f       	add	r30, r30
    2326:	ff 1f       	adc	r31, r31
    2328:	8e 0f       	add	r24, r30
    232a:	9f 1f       	adc	r25, r31
    232c:	fc 01       	movw	r30, r24
    232e:	ec 51       	subi	r30, 0x1C	; 28
    2330:	fa 4f       	sbci	r31, 0xFA	; 250
    2332:	80 81       	ld	r24, Z
    2334:	88 23       	and	r24, r24
    2336:	29 f0       	breq	.+10     	; 0x2342 <vTaskSwitchContext+0x36>
    2338:	1b c0       	rjmp	.+54     	; 0x2370 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    233a:	81 e0       	ldi	r24, 0x01	; 1
    233c:	80 93 d5 05 	sts	0x05D5, r24
    2340:	08 95       	ret
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    2342:	80 91 d9 05 	lds	r24, 0x05D9
    2346:	81 50       	subi	r24, 0x01	; 1
    2348:	80 93 d9 05 	sts	0x05D9, r24
    234c:	80 91 d9 05 	lds	r24, 0x05D9
    2350:	90 e0       	ldi	r25, 0x00	; 0
    2352:	fc 01       	movw	r30, r24
    2354:	ee 0f       	add	r30, r30
    2356:	ff 1f       	adc	r31, r31
    2358:	ee 0f       	add	r30, r30
    235a:	ff 1f       	adc	r31, r31
    235c:	ee 0f       	add	r30, r30
    235e:	ff 1f       	adc	r31, r31
    2360:	8e 0f       	add	r24, r30
    2362:	9f 1f       	adc	r25, r31
    2364:	fc 01       	movw	r30, r24
    2366:	ec 51       	subi	r30, 0x1C	; 28
    2368:	fa 4f       	sbci	r31, 0xFA	; 250
    236a:	80 81       	ld	r24, Z
    236c:	88 23       	and	r24, r24
    236e:	49 f3       	breq	.-46     	; 0x2342 <vTaskSwitchContext+0x36>
    2370:	80 91 d9 05 	lds	r24, 0x05D9
    2374:	90 e0       	ldi	r25, 0x00	; 0
    2376:	fc 01       	movw	r30, r24
    2378:	ee 0f       	add	r30, r30
    237a:	ff 1f       	adc	r31, r31
    237c:	ee 0f       	add	r30, r30
    237e:	ff 1f       	adc	r31, r31
    2380:	ee 0f       	add	r30, r30
    2382:	ff 1f       	adc	r31, r31
    2384:	e8 0f       	add	r30, r24
    2386:	f9 1f       	adc	r31, r25
    2388:	ec 51       	subi	r30, 0x1C	; 28
    238a:	fa 4f       	sbci	r31, 0xFA	; 250
    238c:	a1 81       	ldd	r26, Z+1	; 0x01
    238e:	b2 81       	ldd	r27, Z+2	; 0x02
    2390:	12 96       	adiw	r26, 0x02	; 2
    2392:	0d 90       	ld	r0, X+
    2394:	bc 91       	ld	r27, X
    2396:	a0 2d       	mov	r26, r0
    2398:	b2 83       	std	Z+2, r27	; 0x02
    239a:	a1 83       	std	Z+1, r26	; 0x01
    239c:	cf 01       	movw	r24, r30
    239e:	03 96       	adiw	r24, 0x03	; 3
    23a0:	a8 17       	cp	r26, r24
    23a2:	b9 07       	cpc	r27, r25
    23a4:	31 f4       	brne	.+12     	; 0x23b2 <vTaskSwitchContext+0xa6>
    23a6:	12 96       	adiw	r26, 0x02	; 2
    23a8:	8d 91       	ld	r24, X+
    23aa:	9c 91       	ld	r25, X
    23ac:	13 97       	sbiw	r26, 0x03	; 3
    23ae:	92 83       	std	Z+2, r25	; 0x02
    23b0:	81 83       	std	Z+1, r24	; 0x01
    23b2:	01 80       	ldd	r0, Z+1	; 0x01
    23b4:	f2 81       	ldd	r31, Z+2	; 0x02
    23b6:	e0 2d       	mov	r30, r0
    23b8:	86 81       	ldd	r24, Z+6	; 0x06
    23ba:	97 81       	ldd	r25, Z+7	; 0x07
    23bc:	90 93 d3 05 	sts	0x05D3, r25
    23c0:	80 93 d2 05 	sts	0x05D2, r24
    23c4:	08 95       	ret

000023c6 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, uint16_t xTicksToWait )
{
    23c6:	cf 93       	push	r28
    23c8:	df 93       	push	r29
    23ca:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    23cc:	60 91 d2 05 	lds	r22, 0x05D2
    23d0:	70 91 d3 05 	lds	r23, 0x05D3
    23d4:	64 5f       	subi	r22, 0xF4	; 244
    23d6:	7f 4f       	sbci	r23, 0xFF	; 255
    23d8:	0e 94 81 08 	call	0x1102	; 0x1102 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    23dc:	80 91 d2 05 	lds	r24, 0x05D2
    23e0:	90 91 d3 05 	lds	r25, 0x05D3
    23e4:	02 96       	adiw	r24, 0x02	; 2
    23e6:	0e 94 cb 08 	call	0x1196	; 0x1196 <uxListRemove>
	}
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    23ea:	80 91 da 05 	lds	r24, 0x05DA
    23ee:	90 91 db 05 	lds	r25, 0x05DB
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    23f2:	8c 0f       	add	r24, r28
    23f4:	9d 1f       	adc	r25, r29
    23f6:	0e 94 8e 0d 	call	0x1b1c	; 0x1b1c <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    23fa:	df 91       	pop	r29
    23fc:	cf 91       	pop	r28
    23fe:	08 95       	ret

00002400 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    2400:	0f 93       	push	r16
    2402:	1f 93       	push	r17
    2404:	cf 93       	push	r28
    2406:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2408:	dc 01       	movw	r26, r24
    240a:	15 96       	adiw	r26, 0x05	; 5
    240c:	ed 91       	ld	r30, X+
    240e:	fc 91       	ld	r31, X
    2410:	16 97       	sbiw	r26, 0x06	; 6
    2412:	06 81       	ldd	r16, Z+6	; 0x06
    2414:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    2416:	e8 01       	movw	r28, r16
    2418:	2c 96       	adiw	r28, 0x0c	; 12
    241a:	ce 01       	movw	r24, r28
    241c:	0e 94 cb 08 	call	0x1196	; 0x1196 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2420:	80 91 d7 05 	lds	r24, 0x05D7
    2424:	88 23       	and	r24, r24
    2426:	e9 f4       	brne	.+58     	; 0x2462 <xTaskRemoveFromEventList+0x62>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    2428:	e8 01       	movw	r28, r16
    242a:	22 96       	adiw	r28, 0x02	; 2
    242c:	ce 01       	movw	r24, r28
    242e:	0e 94 cb 08 	call	0x1196	; 0x1196 <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2432:	f8 01       	movw	r30, r16
    2434:	86 89       	ldd	r24, Z+22	; 0x16
    2436:	90 91 d9 05 	lds	r25, 0x05D9
    243a:	98 17       	cp	r25, r24
    243c:	10 f4       	brcc	.+4      	; 0x2442 <xTaskRemoveFromEventList+0x42>
    243e:	80 93 d9 05 	sts	0x05D9, r24
    2442:	90 e0       	ldi	r25, 0x00	; 0
    2444:	9c 01       	movw	r18, r24
    2446:	22 0f       	add	r18, r18
    2448:	33 1f       	adc	r19, r19
    244a:	22 0f       	add	r18, r18
    244c:	33 1f       	adc	r19, r19
    244e:	22 0f       	add	r18, r18
    2450:	33 1f       	adc	r19, r19
    2452:	82 0f       	add	r24, r18
    2454:	93 1f       	adc	r25, r19
    2456:	8c 51       	subi	r24, 0x1C	; 28
    2458:	9a 4f       	sbci	r25, 0xFA	; 250
    245a:	be 01       	movw	r22, r28
    245c:	0e 94 58 08 	call	0x10b0	; 0x10b0 <vListInsertEnd>
    2460:	05 c0       	rjmp	.+10     	; 0x246c <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2462:	8a e1       	ldi	r24, 0x1A	; 26
    2464:	96 e0       	ldi	r25, 0x06	; 6
    2466:	be 01       	movw	r22, r28
    2468:	0e 94 58 08 	call	0x10b0	; 0x10b0 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    246c:	e0 91 d2 05 	lds	r30, 0x05D2
    2470:	f0 91 d3 05 	lds	r31, 0x05D3
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2474:	81 e0       	ldi	r24, 0x01	; 1
    2476:	d8 01       	movw	r26, r16
    2478:	56 96       	adiw	r26, 0x16	; 22
    247a:	2c 91       	ld	r18, X
    247c:	56 97       	sbiw	r26, 0x16	; 22
    247e:	96 89       	ldd	r25, Z+22	; 0x16
    2480:	29 17       	cp	r18, r25
    2482:	08 f4       	brcc	.+2      	; 0x2486 <xTaskRemoveFromEventList+0x86>
    2484:	80 e0       	ldi	r24, 0x00	; 0
}
    2486:	df 91       	pop	r29
    2488:	cf 91       	pop	r28
    248a:	1f 91       	pop	r17
    248c:	0f 91       	pop	r16
    248e:	08 95       	ret

00002490 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2490:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2492:	80 91 d4 05 	lds	r24, 0x05D4
    2496:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2498:	40 91 da 05 	lds	r20, 0x05DA
    249c:	50 91 db 05 	lds	r21, 0x05DB
    24a0:	60 e0       	ldi	r22, 0x00	; 0
    24a2:	70 e0       	ldi	r23, 0x00	; 0
    24a4:	41 83       	std	Z+1, r20	; 0x01
    24a6:	52 83       	std	Z+2, r21	; 0x02
    24a8:	63 83       	std	Z+3, r22	; 0x03
    24aa:	74 83       	std	Z+4, r23	; 0x04
}
    24ac:	08 95       	ret

000024ae <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, uint16_t * const pxTicksToWait )
{
    24ae:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    24b0:	0f b6       	in	r0, 0x3f	; 63
    24b2:	f8 94       	cli
    24b4:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( uint16_t ) xTickCount >= ( uint16_t ) pxTimeOut->xTimeOnEntering ) )
    24b6:	80 91 d4 05 	lds	r24, 0x05D4
    24ba:	90 81       	ld	r25, Z
    24bc:	98 17       	cp	r25, r24
    24be:	49 f0       	breq	.+18     	; 0x24d2 <xTaskCheckForTimeOut+0x24>
    24c0:	80 91 da 05 	lds	r24, 0x05DA
    24c4:	90 91 db 05 	lds	r25, 0x05DB
    24c8:	21 81       	ldd	r18, Z+1	; 0x01
    24ca:	32 81       	ldd	r19, Z+2	; 0x02
    24cc:	82 17       	cp	r24, r18
    24ce:	93 07       	cpc	r25, r19
    24d0:	f0 f4       	brcc	.+60     	; 0x250e <xTaskCheckForTimeOut+0x60>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( uint16_t ) ( ( uint16_t ) xTickCount - ( uint16_t ) pxTimeOut->xTimeOnEntering ) ) < ( uint16_t ) *pxTicksToWait )
    24d2:	80 91 da 05 	lds	r24, 0x05DA
    24d6:	90 91 db 05 	lds	r25, 0x05DB
    24da:	21 81       	ldd	r18, Z+1	; 0x01
    24dc:	32 81       	ldd	r19, Z+2	; 0x02
    24de:	db 01       	movw	r26, r22
    24e0:	4d 91       	ld	r20, X+
    24e2:	5c 91       	ld	r21, X
    24e4:	11 97       	sbiw	r26, 0x01	; 1
    24e6:	82 1b       	sub	r24, r18
    24e8:	93 0b       	sbc	r25, r19
    24ea:	84 17       	cp	r24, r20
    24ec:	95 07       	cpc	r25, r21
    24ee:	88 f4       	brcc	.+34     	; 0x2512 <xTaskCheckForTimeOut+0x64>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( uint16_t ) xTickCount - ( uint16_t ) pxTimeOut->xTimeOnEntering );
    24f0:	80 91 da 05 	lds	r24, 0x05DA
    24f4:	90 91 db 05 	lds	r25, 0x05DB
    24f8:	28 1b       	sub	r18, r24
    24fa:	39 0b       	sbc	r19, r25
    24fc:	24 0f       	add	r18, r20
    24fe:	35 1f       	adc	r19, r21
    2500:	2d 93       	st	X+, r18
    2502:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    2504:	cf 01       	movw	r24, r30
    2506:	0e 94 48 12 	call	0x2490	; 0x2490 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    250a:	80 e0       	ldi	r24, 0x00	; 0
    250c:	03 c0       	rjmp	.+6      	; 0x2514 <xTaskCheckForTimeOut+0x66>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    250e:	81 e0       	ldi	r24, 0x01	; 1
    2510:	01 c0       	rjmp	.+2      	; 0x2514 <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2512:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2514:	0f 90       	pop	r0
    2516:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2518:	08 95       	ret

0000251a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    251a:	81 e0       	ldi	r24, 0x01	; 1
    251c:	80 93 d5 05 	sts	0x05D5, r24
}
    2520:	08 95       	ret

00002522 <executeCommunicationTask>:
    xTaskCreate( executeCommunicationTask, ( signed char * ) "commTask", sysCommunicationTaskSTACK_SIZE,  ( void * ) taskParams , uxPriority, ( xTaskHandle * ) NULL );
}


static portTASK_FUNCTION( executeCommunicationTask, pvParameters )
{
    2522:	cf 93       	push	r28
    2524:	df 93       	push	r29
    2526:	00 d0       	rcall	.+0      	; 0x2528 <executeCommunicationTask+0x6>
    2528:	00 d0       	rcall	.+0      	; 0x252a <executeCommunicationTask+0x8>
    252a:	cd b7       	in	r28, 0x3d	; 61
    252c:	de b7       	in	r29, 0x3e	; 62
    uint8_t successFlag=0;
    
    taskParams = ( communicationTaskParameters * ) pvParameters;
        
    //Initialize the wake up time with the current time
    xLastWakeUpTime = xTaskGetTickCount();    
    252e:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <xTaskGetTickCount>
    2532:	a0 e0       	ldi	r26, 0x00	; 0
    2534:	b0 e0       	ldi	r27, 0x00	; 0
    2536:	89 83       	std	Y+1, r24	; 0x01
    2538:	9a 83       	std	Y+2, r25	; 0x02
    253a:	ab 83       	std	Y+3, r26	; 0x03
    253c:	bc 83       	std	Y+4, r27	; 0x04
    
    for(;;)
    {
        vTaskDelayUntil( &xLastWakeUpTime, COMMUNICATION_TASK_CYCLE );
    253e:	ce 01       	movw	r24, r28
    2540:	01 96       	adiw	r24, 0x01	; 1
    2542:	64 ef       	ldi	r22, 0xF4	; 244
    2544:	71 e0       	ldi	r23, 0x01	; 1
    2546:	0e 94 31 11 	call	0x2262	; 0x2262 <vTaskDelayUntil>
    254a:	f9 cf       	rjmp	.-14     	; 0x253e <executeCommunicationTask+0x1c>

0000254c <startCommunicationTask>:
*/
static portBASE_TYPE xCommunicationTaskStatus = pdPASS;


void startCommunicationTask( unsigned portBASE_TYPE uxPriority, xQueueHandle* measQueue )
{  
    254c:	af 92       	push	r10
    254e:	bf 92       	push	r11
    2550:	cf 92       	push	r12
    2552:	df 92       	push	r13
    2554:	ef 92       	push	r14
    2556:	ff 92       	push	r15
    2558:	0f 93       	push	r16
    255a:	cf 93       	push	r28
    255c:	df 93       	push	r29
    255e:	08 2f       	mov	r16, r24
    2560:	eb 01       	movw	r28, r22
    adcInit();
    2562:	0e 94 a0 04 	call	0x940	; 0x940 <adcInit>
        
    //Set high side driver pins to outputs
    DDRC |= ( (1<<PC6) | (1<<PC7) );    
    2566:	84 b3       	in	r24, 0x14	; 20
    2568:	80 6c       	ori	r24, 0xC0	; 192
    256a:	84 bb       	out	0x14, r24	; 20
    //switch on high side driver
    PORTC |=  ( (1<<PC6) | (1<<PC7) );       
    256c:	85 b3       	in	r24, 0x15	; 21
    256e:	80 6c       	ori	r24, 0xC0	; 192
    2570:	85 bb       	out	0x15, r24	; 21
        
    //create task parameter
    communicationTaskParameters *taskParams;
    taskParams = ( communicationTaskParameters * ) pvPortMalloc( sizeof( communicationTaskParameters ) );
    2572:	82 e0       	ldi	r24, 0x02	; 2
    2574:	90 e0       	ldi	r25, 0x00	; 0
    2576:	0e 94 01 08 	call	0x1002	; 0x1002 <pvPortMalloc>
    257a:	9c 01       	movw	r18, r24
    taskParams->measurementQueue = *measQueue;
    257c:	88 81       	ld	r24, Y
    257e:	99 81       	ldd	r25, Y+1	; 0x01
    2580:	f9 01       	movw	r30, r18
    2582:	91 83       	std	Z+1, r25	; 0x01
    2584:	80 83       	st	Z, r24
    //taskParams->statusQueue = *statQueue;
    
    xTaskCreate( executeCommunicationTask, ( signed char * ) "commTask", sysCommunicationTaskSTACK_SIZE,  ( void * ) taskParams , uxPriority, ( xTaskHandle * ) NULL );
    2586:	81 e9       	ldi	r24, 0x91	; 145
    2588:	92 e1       	ldi	r25, 0x12	; 18
    258a:	67 e6       	ldi	r22, 0x67	; 103
    258c:	70 e0       	ldi	r23, 0x00	; 0
    258e:	45 e5       	ldi	r20, 0x55	; 85
    2590:	50 e0       	ldi	r21, 0x00	; 0
    2592:	ee 24       	eor	r14, r14
    2594:	ff 24       	eor	r15, r15
    2596:	cc 24       	eor	r12, r12
    2598:	dd 24       	eor	r13, r13
    259a:	aa 24       	eor	r10, r10
    259c:	bb 24       	eor	r11, r11
    259e:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <xTaskGenericCreate>
}
    25a2:	df 91       	pop	r29
    25a4:	cf 91       	pop	r28
    25a6:	0f 91       	pop	r16
    25a8:	ff 90       	pop	r15
    25aa:	ef 90       	pop	r14
    25ac:	df 90       	pop	r13
    25ae:	cf 90       	pop	r12
    25b0:	bf 90       	pop	r11
    25b2:	af 90       	pop	r10
    25b4:	08 95       	ret

000025b6 <xIsCommunicationTaskStillRunning>:
	{
		xReturn = pdPASS;
	}

	return xReturn;
    25b6:	81 e0       	ldi	r24, 0x01	; 1
    25b8:	08 95       	ret

000025ba <executeNavigatorTask>:
    xTaskCreate( executeNavigatorTask, ( signed char * ) "NavTask", sysNavigatorTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
}


static portTASK_FUNCTION( executeNavigatorTask, pvParameters )
{
    25ba:	cf 93       	push	r28
    25bc:	df 93       	push	r29
    25be:	00 d0       	rcall	.+0      	; 0x25c0 <executeNavigatorTask+0x6>
    25c0:	00 d0       	rcall	.+0      	; 0x25c2 <executeNavigatorTask+0x8>
    25c2:	cd b7       	in	r28, 0x3d	; 61
    25c4:	de b7       	in	r29, 0x3e	; 62
    uint32_t xLastWakeUpTime;

    //Initialize the wake up time with the current time
    xLastWakeUpTime = xTaskGetTickCount();
    25c6:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <xTaskGetTickCount>
    25ca:	a0 e0       	ldi	r26, 0x00	; 0
    25cc:	b0 e0       	ldi	r27, 0x00	; 0
    25ce:	89 83       	std	Y+1, r24	; 0x01
    25d0:	9a 83       	std	Y+2, r25	; 0x02
    25d2:	ab 83       	std	Y+3, r26	; 0x03
    25d4:	bc 83       	std	Y+4, r27	; 0x04

    for(;;)
    {
        //Execute this task each 50ms
        vTaskDelayUntil( &xLastWakeUpTime, NAVIGATOR_TASK_CYCLE );
    25d6:	ce 01       	movw	r24, r28
    25d8:	01 96       	adiw	r24, 0x01	; 1
    25da:	64 e6       	ldi	r22, 0x64	; 100
    25dc:	70 e0       	ldi	r23, 0x00	; 0
    25de:	0e 94 31 11 	call	0x2262	; 0x2262 <vTaskDelayUntil>
    25e2:	f9 cf       	rjmp	.-14     	; 0x25d6 <executeNavigatorTask+0x1c>

000025e4 <startNavigatorTask>:
   Used to signal an error condition inside this task
*/
static portBASE_TYPE xNavigatorTaskStatus = pdPASS;

void startNavigatorTask( unsigned portBASE_TYPE uxPriority, xQueueHandle *statQueue )
{
    25e4:	af 92       	push	r10
    25e6:	bf 92       	push	r11
    25e8:	cf 92       	push	r12
    25ea:	df 92       	push	r13
    25ec:	ef 92       	push	r14
    25ee:	ff 92       	push	r15
    25f0:	0f 93       	push	r16
    25f2:	cf 93       	push	r28
    25f4:	df 93       	push	r29
    25f6:	08 2f       	mov	r16, r24
    25f8:	eb 01       	movw	r28, r22
    //set pins PB0 (green LED) & PB1 (red LED) to outputs
    DDRB |= ( (1<<PB0) | (1<<PB1) );
    25fa:	87 b3       	in	r24, 0x17	; 23
    25fc:	83 60       	ori	r24, 0x03	; 3
    25fe:	87 bb       	out	0x17, r24	; 23
    
    navigatorTaskParameters *taskParams;
    taskParams = ( navigatorTaskParameters * ) pvPortMalloc( sizeof( navigatorTaskParameters ) );
    2600:	82 e0       	ldi	r24, 0x02	; 2
    2602:	90 e0       	ldi	r25, 0x00	; 0
    2604:	0e 94 01 08 	call	0x1002	; 0x1002 <pvPortMalloc>
    2608:	9c 01       	movw	r18, r24
    taskParams->statusQueue = *statQueue;
    260a:	88 81       	ld	r24, Y
    260c:	99 81       	ldd	r25, Y+1	; 0x01
    260e:	f9 01       	movw	r30, r18
    2610:	91 83       	std	Z+1, r25	; 0x01
    2612:	80 83       	st	Z, r24

    xTaskCreate( executeNavigatorTask, ( signed char * ) "NavTask", sysNavigatorTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
    2614:	8d ed       	ldi	r24, 0xDD	; 221
    2616:	92 e1       	ldi	r25, 0x12	; 18
    2618:	60 e7       	ldi	r22, 0x70	; 112
    261a:	70 e0       	ldi	r23, 0x00	; 0
    261c:	45 e5       	ldi	r20, 0x55	; 85
    261e:	50 e0       	ldi	r21, 0x00	; 0
    2620:	ee 24       	eor	r14, r14
    2622:	ff 24       	eor	r15, r15
    2624:	cc 24       	eor	r12, r12
    2626:	dd 24       	eor	r13, r13
    2628:	aa 24       	eor	r10, r10
    262a:	bb 24       	eor	r11, r11
    262c:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <xTaskGenericCreate>
}
    2630:	df 91       	pop	r29
    2632:	cf 91       	pop	r28
    2634:	0f 91       	pop	r16
    2636:	ff 90       	pop	r15
    2638:	ef 90       	pop	r14
    263a:	df 90       	pop	r13
    263c:	cf 90       	pop	r12
    263e:	bf 90       	pop	r11
    2640:	af 90       	pop	r10
    2642:	08 95       	ret

00002644 <xIsNavigatorTaskStillRunning>:
    {
        xReturn = pdPASS;
    }

    return xReturn;
    2644:	81 e0       	ldi	r24, 0x01	; 1
    2646:	08 95       	ret

00002648 <executeSensorTask>:
    xTaskCreate( executeSensorTask, ( signed char * ) "SensorTask", sysSensorTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
}


static portTASK_FUNCTION( executeSensorTask, pvParameters )
{
    2648:	cf 93       	push	r28
    264a:	df 93       	push	r29
    264c:	00 d0       	rcall	.+0      	; 0x264e <executeSensorTask+0x6>
    264e:	00 d0       	rcall	.+0      	; 0x2650 <executeSensorTask+0x8>
    2650:	cd b7       	in	r28, 0x3d	; 61
    2652:	de b7       	in	r29, 0x3e	; 62
    uint32_t xLastWakeUpTime;
    uint16_t ledCycleCounter = 0;
    
    //Initialize the wake up time with the current time
    xLastWakeUpTime = xTaskGetTickCount();
    2654:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <xTaskGetTickCount>
    2658:	a0 e0       	ldi	r26, 0x00	; 0
    265a:	b0 e0       	ldi	r27, 0x00	; 0
    265c:	89 83       	std	Y+1, r24	; 0x01
    265e:	9a 83       	std	Y+2, r25	; 0x02
    2660:	ab 83       	std	Y+3, r26	; 0x03
    2662:	bc 83       	std	Y+4, r27	; 0x04


static portTASK_FUNCTION( executeSensorTask, pvParameters )
{
    uint32_t xLastWakeUpTime;
    uint16_t ledCycleCounter = 0;
    2664:	00 e0       	ldi	r16, 0x00	; 0
    2666:	10 e0       	ldi	r17, 0x00	; 0
{
    static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xIsCommunicationTaskStillRunning() != pdTRUE )
	{
		xErrorHasOccurred = pdTRUE;
    2668:	ff 24       	eor	r15, r15
    266a:	f3 94       	inc	r15
        {
            //signal error condition
        }

        //toogle the green led each 500ms
        if( ledCycleCounter % GREEN_LED_TOGGLE_CYCLE == 0 )
    266c:	0f 2e       	mov	r0, r31
    266e:	f4 ef       	ldi	r31, 0xF4	; 244
    2670:	cf 2e       	mov	r12, r31
    2672:	f1 e0       	ldi	r31, 0x01	; 1
    2674:	df 2e       	mov	r13, r31
    2676:	f0 2d       	mov	r31, r0
            PORTA ^= (1<<PA7);
        }
        
        if( ledCycleCounter > 65000 )
        {
            ledCycleCounter = 0;
    2678:	aa 24       	eor	r10, r10
    267a:	bb 24       	eor	r11, r11
    267c:	01 c0       	rjmp	.+2      	; 0x2680 <executeSensorTask+0x38>
    267e:	85 01       	movw	r16, r10
    xLastWakeUpTime = xTaskGetTickCount();

    for(;;)
    {
        //Execute this task each 50ms
        vTaskDelayUntil( &xLastWakeUpTime, SENSOR_TASK_CYCLE );
    2680:	ce 01       	movw	r24, r28
    2682:	01 96       	adiw	r24, 0x01	; 1
    2684:	64 e6       	ldi	r22, 0x64	; 100
    2686:	70 e0       	ldi	r23, 0x00	; 0
    2688:	0e 94 31 11 	call	0x2262	; 0x2262 <vTaskDelayUntil>

        ledCycleCounter += 50;
    268c:	0e 5c       	subi	r16, 0xCE	; 206
    268e:	1f 4f       	sbci	r17, 0xFF	; 255
 */
static portBASE_TYPE prvCheckOtherTasksAreStillRunning( void )
{
    static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xIsCommunicationTaskStillRunning() != pdTRUE )
    2690:	0e 94 db 12 	call	0x25b6	; 0x25b6 <xIsCommunicationTaskStillRunning>
    2694:	81 30       	cpi	r24, 0x01	; 1
    2696:	11 f0       	breq	.+4      	; 0x269c <executeSensorTask+0x54>
	{
		xErrorHasOccurred = pdTRUE;
    2698:	f0 92 2c 06 	sts	0x062C, r15
	}

	if( xIsOperatorTaskStillRunning() != pdTRUE )
    269c:	0e 94 d9 13 	call	0x27b2	; 0x27b2 <xIsOperatorTaskStillRunning>
    26a0:	81 30       	cpi	r24, 0x01	; 1
    26a2:	11 f0       	breq	.+4      	; 0x26a8 <executeSensorTask+0x60>
	{
		xErrorHasOccurred = pdTRUE;
    26a4:	f0 92 2c 06 	sts	0x062C, r15
	}

	if( xIsNavigatorTaskStillRunning() != pdTRUE )
    26a8:	0e 94 22 13 	call	0x2644	; 0x2644 <xIsNavigatorTaskStillRunning>
    26ac:	81 30       	cpi	r24, 0x01	; 1
    26ae:	91 05       	cpc	r25, r1
    26b0:	11 f0       	breq	.+4      	; 0x26b6 <executeSensorTask+0x6e>
	{
    	xErrorHasOccurred = pdTRUE;
    26b2:	f0 92 2c 06 	sts	0x062C, r15
        {
            //signal error condition
        }

        //toogle the green led each 500ms
        if( ledCycleCounter % GREEN_LED_TOGGLE_CYCLE == 0 )
    26b6:	c8 01       	movw	r24, r16
    26b8:	b6 01       	movw	r22, r12
    26ba:	0e 94 1d 17 	call	0x2e3a	; 0x2e3a <__udivmodhi4>
    26be:	00 97       	sbiw	r24, 0x00	; 0
    26c0:	19 f4       	brne	.+6      	; 0x26c8 <executeSensorTask+0x80>
        {
            PORTA ^= (1<<PA7);
    26c2:	8b b3       	in	r24, 0x1b	; 27
    26c4:	80 58       	subi	r24, 0x80	; 128
    26c6:	8b bb       	out	0x1b, r24	; 27
        }
        
        if( ledCycleCounter > 65000 )
    26c8:	8d ef       	ldi	r24, 0xFD	; 253
    26ca:	09 3e       	cpi	r16, 0xE9	; 233
    26cc:	18 07       	cpc	r17, r24
    26ce:	b8 f6       	brcc	.-82     	; 0x267e <executeSensorTask+0x36>
    26d0:	d7 cf       	rjmp	.-82     	; 0x2680 <executeSensorTask+0x38>

000026d2 <startSensorTask>:

static portBASE_TYPE prvCheckOtherTasksAreStillRunning( void );


void startSensorTask( unsigned portBASE_TYPE uxPriority, xQueueHandle *statQueue )
{
    26d2:	af 92       	push	r10
    26d4:	bf 92       	push	r11
    26d6:	cf 92       	push	r12
    26d8:	df 92       	push	r13
    26da:	ef 92       	push	r14
    26dc:	ff 92       	push	r15
    26de:	0f 93       	push	r16
    26e0:	cf 93       	push	r28
    26e2:	df 93       	push	r29
    26e4:	08 2f       	mov	r16, r24
    26e6:	eb 01       	movw	r28, r22
    //set pin PA7 (green LED) to be an output
    DDRA |= (1<<PA7);
    26e8:	d7 9a       	sbi	0x1a, 7	; 26
    
    sensorTaskParameters *taskParams;
    taskParams = ( sensorTaskParameters * ) pvPortMalloc( sizeof( sensorTaskParameters ) );
    26ea:	82 e0       	ldi	r24, 0x02	; 2
    26ec:	90 e0       	ldi	r25, 0x00	; 0
    26ee:	0e 94 01 08 	call	0x1002	; 0x1002 <pvPortMalloc>
    26f2:	9c 01       	movw	r18, r24
    taskParams->statusQueue = *statQueue;
    26f4:	88 81       	ld	r24, Y
    26f6:	99 81       	ldd	r25, Y+1	; 0x01
    26f8:	f9 01       	movw	r30, r18
    26fa:	91 83       	std	Z+1, r25	; 0x01
    26fc:	80 83       	st	Z, r24

    xTaskCreate( executeSensorTask, ( signed char * ) "SensorTask", sysSensorTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
    26fe:	84 e2       	ldi	r24, 0x24	; 36
    2700:	93 e1       	ldi	r25, 0x13	; 19
    2702:	68 e7       	ldi	r22, 0x78	; 120
    2704:	70 e0       	ldi	r23, 0x00	; 0
    2706:	45 e5       	ldi	r20, 0x55	; 85
    2708:	50 e0       	ldi	r21, 0x00	; 0
    270a:	ee 24       	eor	r14, r14
    270c:	ff 24       	eor	r15, r15
    270e:	cc 24       	eor	r12, r12
    2710:	dd 24       	eor	r13, r13
    2712:	aa 24       	eor	r10, r10
    2714:	bb 24       	eor	r11, r11
    2716:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <xTaskGenericCreate>
}
    271a:	df 91       	pop	r29
    271c:	cf 91       	pop	r28
    271e:	0f 91       	pop	r16
    2720:	ff 90       	pop	r15
    2722:	ef 90       	pop	r14
    2724:	df 90       	pop	r13
    2726:	cf 90       	pop	r12
    2728:	bf 90       	pop	r11
    272a:	af 90       	pop	r10
    272c:	08 95       	ret

0000272e <executeOperatorTask>:
    xTaskCreate( executeOperatorTask, ( signed char * ) "opTask", sysOperatorTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
}


static portTASK_FUNCTION( executeOperatorTask, pvParameters )
{
    272e:	cf 93       	push	r28
    2730:	df 93       	push	r29
    2732:	00 d0       	rcall	.+0      	; 0x2734 <executeOperatorTask+0x6>
    2734:	00 d0       	rcall	.+0      	; 0x2736 <executeOperatorTask+0x8>
    2736:	cd b7       	in	r28, 0x3d	; 61
    2738:	de b7       	in	r29, 0x3e	; 62
    operatorTaskParameters *taskParams;
    
    taskParams = ( operatorTaskParameters * ) pvParameters;
    
    //Initialize the wake up time with the current time
    xLastWakeUpTime = xTaskGetTickCount();
    273a:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <xTaskGetTickCount>
    273e:	a0 e0       	ldi	r26, 0x00	; 0
    2740:	b0 e0       	ldi	r27, 0x00	; 0
    2742:	89 83       	std	Y+1, r24	; 0x01
    2744:	9a 83       	std	Y+2, r25	; 0x02
    2746:	ab 83       	std	Y+3, r26	; 0x03
    2748:	bc 83       	std	Y+4, r27	; 0x04
    
    for(;;)
    {
        
        //Execute this task each 15ms
        vTaskDelayUntil( &xLastWakeUpTime, OPERATOR_TASK_CYCLE );
    274a:	ce 01       	movw	r24, r28
    274c:	01 96       	adiw	r24, 0x01	; 1
    274e:	6f e0       	ldi	r22, 0x0F	; 15
    2750:	70 e0       	ldi	r23, 0x00	; 0
    2752:	0e 94 31 11 	call	0x2262	; 0x2262 <vTaskDelayUntil>
    2756:	f9 cf       	rjmp	.-14     	; 0x274a <executeOperatorTask+0x1c>

00002758 <startOperatorTask>:
   Used to signal an error condition inside this task
*/
static portBASE_TYPE xOperatorTaskStatus = pdPASS;

void startOperatorTask( unsigned portBASE_TYPE uxPriority, xQueueHandle *measQueue )
{
    2758:	af 92       	push	r10
    275a:	bf 92       	push	r11
    275c:	cf 92       	push	r12
    275e:	df 92       	push	r13
    2760:	ef 92       	push	r14
    2762:	ff 92       	push	r15
    2764:	0f 93       	push	r16
    2766:	cf 93       	push	r28
    2768:	df 93       	push	r29
    276a:	08 2f       	mov	r16, r24
    276c:	eb 01       	movw	r28, r22
    operatorTaskParameters *taskParams;
    taskParams = ( operatorTaskParameters * ) pvPortMalloc( sizeof( operatorTaskParameters ) );
    276e:	82 e0       	ldi	r24, 0x02	; 2
    2770:	90 e0       	ldi	r25, 0x00	; 0
    2772:	0e 94 01 08 	call	0x1002	; 0x1002 <pvPortMalloc>
    2776:	9c 01       	movw	r18, r24
    taskParams->measurementQueue = *measQueue;
    2778:	88 81       	ld	r24, Y
    277a:	99 81       	ldd	r25, Y+1	; 0x01
    277c:	f9 01       	movw	r30, r18
    277e:	91 83       	std	Z+1, r25	; 0x01
    2780:	80 83       	st	Z, r24
    
    xTaskCreate( executeOperatorTask, ( signed char * ) "opTask", sysOperatorTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
    2782:	87 e9       	ldi	r24, 0x97	; 151
    2784:	93 e1       	ldi	r25, 0x13	; 19
    2786:	63 e8       	ldi	r22, 0x83	; 131
    2788:	70 e0       	ldi	r23, 0x00	; 0
    278a:	45 e5       	ldi	r20, 0x55	; 85
    278c:	50 e0       	ldi	r21, 0x00	; 0
    278e:	ee 24       	eor	r14, r14
    2790:	ff 24       	eor	r15, r15
    2792:	cc 24       	eor	r12, r12
    2794:	dd 24       	eor	r13, r13
    2796:	aa 24       	eor	r10, r10
    2798:	bb 24       	eor	r11, r11
    279a:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <xTaskGenericCreate>
}
    279e:	df 91       	pop	r29
    27a0:	cf 91       	pop	r28
    27a2:	0f 91       	pop	r16
    27a4:	ff 90       	pop	r15
    27a6:	ef 90       	pop	r14
    27a8:	df 90       	pop	r13
    27aa:	cf 90       	pop	r12
    27ac:	bf 90       	pop	r11
    27ae:	af 90       	pop	r10
    27b0:	08 95       	ret

000027b2 <xIsOperatorTaskStillRunning>:
    {
        xReturn = pdPASS;
    }

    return xReturn;
    27b2:	81 e0       	ldi	r24, 0x01	; 1
    27b4:	08 95       	ret

000027b6 <__subsf3>:
    27b6:	50 58       	subi	r21, 0x80	; 128

000027b8 <__addsf3>:
    27b8:	bb 27       	eor	r27, r27
    27ba:	aa 27       	eor	r26, r26
    27bc:	0e d0       	rcall	.+28     	; 0x27da <__addsf3x>
    27be:	1c c1       	rjmp	.+568    	; 0x29f8 <__fp_round>
    27c0:	0d d1       	rcall	.+538    	; 0x29dc <__fp_pscA>
    27c2:	30 f0       	brcs	.+12     	; 0x27d0 <__addsf3+0x18>
    27c4:	12 d1       	rcall	.+548    	; 0x29ea <__fp_pscB>
    27c6:	20 f0       	brcs	.+8      	; 0x27d0 <__addsf3+0x18>
    27c8:	31 f4       	brne	.+12     	; 0x27d6 <__addsf3+0x1e>
    27ca:	9f 3f       	cpi	r25, 0xFF	; 255
    27cc:	11 f4       	brne	.+4      	; 0x27d2 <__addsf3+0x1a>
    27ce:	1e f4       	brtc	.+6      	; 0x27d6 <__addsf3+0x1e>
    27d0:	02 c1       	rjmp	.+516    	; 0x29d6 <__fp_nan>
    27d2:	0e f4       	brtc	.+2      	; 0x27d6 <__addsf3+0x1e>
    27d4:	e0 95       	com	r30
    27d6:	e7 fb       	bst	r30, 7
    27d8:	f8 c0       	rjmp	.+496    	; 0x29ca <__fp_inf>

000027da <__addsf3x>:
    27da:	e9 2f       	mov	r30, r25
    27dc:	1e d1       	rcall	.+572    	; 0x2a1a <__fp_split3>
    27de:	80 f3       	brcs	.-32     	; 0x27c0 <__addsf3+0x8>
    27e0:	ba 17       	cp	r27, r26
    27e2:	62 07       	cpc	r22, r18
    27e4:	73 07       	cpc	r23, r19
    27e6:	84 07       	cpc	r24, r20
    27e8:	95 07       	cpc	r25, r21
    27ea:	18 f0       	brcs	.+6      	; 0x27f2 <__addsf3x+0x18>
    27ec:	71 f4       	brne	.+28     	; 0x280a <__addsf3x+0x30>
    27ee:	9e f5       	brtc	.+102    	; 0x2856 <__addsf3x+0x7c>
    27f0:	36 c1       	rjmp	.+620    	; 0x2a5e <__fp_zero>
    27f2:	0e f4       	brtc	.+2      	; 0x27f6 <__addsf3x+0x1c>
    27f4:	e0 95       	com	r30
    27f6:	0b 2e       	mov	r0, r27
    27f8:	ba 2f       	mov	r27, r26
    27fa:	a0 2d       	mov	r26, r0
    27fc:	0b 01       	movw	r0, r22
    27fe:	b9 01       	movw	r22, r18
    2800:	90 01       	movw	r18, r0
    2802:	0c 01       	movw	r0, r24
    2804:	ca 01       	movw	r24, r20
    2806:	a0 01       	movw	r20, r0
    2808:	11 24       	eor	r1, r1
    280a:	ff 27       	eor	r31, r31
    280c:	59 1b       	sub	r21, r25
    280e:	99 f0       	breq	.+38     	; 0x2836 <__addsf3x+0x5c>
    2810:	59 3f       	cpi	r21, 0xF9	; 249
    2812:	50 f4       	brcc	.+20     	; 0x2828 <__addsf3x+0x4e>
    2814:	50 3e       	cpi	r21, 0xE0	; 224
    2816:	68 f1       	brcs	.+90     	; 0x2872 <__addsf3x+0x98>
    2818:	1a 16       	cp	r1, r26
    281a:	f0 40       	sbci	r31, 0x00	; 0
    281c:	a2 2f       	mov	r26, r18
    281e:	23 2f       	mov	r18, r19
    2820:	34 2f       	mov	r19, r20
    2822:	44 27       	eor	r20, r20
    2824:	58 5f       	subi	r21, 0xF8	; 248
    2826:	f3 cf       	rjmp	.-26     	; 0x280e <__addsf3x+0x34>
    2828:	46 95       	lsr	r20
    282a:	37 95       	ror	r19
    282c:	27 95       	ror	r18
    282e:	a7 95       	ror	r26
    2830:	f0 40       	sbci	r31, 0x00	; 0
    2832:	53 95       	inc	r21
    2834:	c9 f7       	brne	.-14     	; 0x2828 <__addsf3x+0x4e>
    2836:	7e f4       	brtc	.+30     	; 0x2856 <__addsf3x+0x7c>
    2838:	1f 16       	cp	r1, r31
    283a:	ba 0b       	sbc	r27, r26
    283c:	62 0b       	sbc	r22, r18
    283e:	73 0b       	sbc	r23, r19
    2840:	84 0b       	sbc	r24, r20
    2842:	ba f0       	brmi	.+46     	; 0x2872 <__addsf3x+0x98>
    2844:	91 50       	subi	r25, 0x01	; 1
    2846:	a1 f0       	breq	.+40     	; 0x2870 <__addsf3x+0x96>
    2848:	ff 0f       	add	r31, r31
    284a:	bb 1f       	adc	r27, r27
    284c:	66 1f       	adc	r22, r22
    284e:	77 1f       	adc	r23, r23
    2850:	88 1f       	adc	r24, r24
    2852:	c2 f7       	brpl	.-16     	; 0x2844 <__addsf3x+0x6a>
    2854:	0e c0       	rjmp	.+28     	; 0x2872 <__addsf3x+0x98>
    2856:	ba 0f       	add	r27, r26
    2858:	62 1f       	adc	r22, r18
    285a:	73 1f       	adc	r23, r19
    285c:	84 1f       	adc	r24, r20
    285e:	48 f4       	brcc	.+18     	; 0x2872 <__addsf3x+0x98>
    2860:	87 95       	ror	r24
    2862:	77 95       	ror	r23
    2864:	67 95       	ror	r22
    2866:	b7 95       	ror	r27
    2868:	f7 95       	ror	r31
    286a:	9e 3f       	cpi	r25, 0xFE	; 254
    286c:	08 f0       	brcs	.+2      	; 0x2870 <__addsf3x+0x96>
    286e:	b3 cf       	rjmp	.-154    	; 0x27d6 <__addsf3+0x1e>
    2870:	93 95       	inc	r25
    2872:	88 0f       	add	r24, r24
    2874:	08 f0       	brcs	.+2      	; 0x2878 <__addsf3x+0x9e>
    2876:	99 27       	eor	r25, r25
    2878:	ee 0f       	add	r30, r30
    287a:	97 95       	ror	r25
    287c:	87 95       	ror	r24
    287e:	08 95       	ret

00002880 <__divsf3>:
    2880:	0c d0       	rcall	.+24     	; 0x289a <__divsf3x>
    2882:	ba c0       	rjmp	.+372    	; 0x29f8 <__fp_round>
    2884:	b2 d0       	rcall	.+356    	; 0x29ea <__fp_pscB>
    2886:	40 f0       	brcs	.+16     	; 0x2898 <__divsf3+0x18>
    2888:	a9 d0       	rcall	.+338    	; 0x29dc <__fp_pscA>
    288a:	30 f0       	brcs	.+12     	; 0x2898 <__divsf3+0x18>
    288c:	21 f4       	brne	.+8      	; 0x2896 <__divsf3+0x16>
    288e:	5f 3f       	cpi	r21, 0xFF	; 255
    2890:	19 f0       	breq	.+6      	; 0x2898 <__divsf3+0x18>
    2892:	9b c0       	rjmp	.+310    	; 0x29ca <__fp_inf>
    2894:	51 11       	cpse	r21, r1
    2896:	e4 c0       	rjmp	.+456    	; 0x2a60 <__fp_szero>
    2898:	9e c0       	rjmp	.+316    	; 0x29d6 <__fp_nan>

0000289a <__divsf3x>:
    289a:	bf d0       	rcall	.+382    	; 0x2a1a <__fp_split3>
    289c:	98 f3       	brcs	.-26     	; 0x2884 <__divsf3+0x4>

0000289e <__divsf3_pse>:
    289e:	99 23       	and	r25, r25
    28a0:	c9 f3       	breq	.-14     	; 0x2894 <__divsf3+0x14>
    28a2:	55 23       	and	r21, r21
    28a4:	b1 f3       	breq	.-20     	; 0x2892 <__divsf3+0x12>
    28a6:	95 1b       	sub	r25, r21
    28a8:	55 0b       	sbc	r21, r21
    28aa:	bb 27       	eor	r27, r27
    28ac:	aa 27       	eor	r26, r26
    28ae:	62 17       	cp	r22, r18
    28b0:	73 07       	cpc	r23, r19
    28b2:	84 07       	cpc	r24, r20
    28b4:	38 f0       	brcs	.+14     	; 0x28c4 <__divsf3_pse+0x26>
    28b6:	9f 5f       	subi	r25, 0xFF	; 255
    28b8:	5f 4f       	sbci	r21, 0xFF	; 255
    28ba:	22 0f       	add	r18, r18
    28bc:	33 1f       	adc	r19, r19
    28be:	44 1f       	adc	r20, r20
    28c0:	aa 1f       	adc	r26, r26
    28c2:	a9 f3       	breq	.-22     	; 0x28ae <__divsf3_pse+0x10>
    28c4:	33 d0       	rcall	.+102    	; 0x292c <__divsf3_pse+0x8e>
    28c6:	0e 2e       	mov	r0, r30
    28c8:	3a f0       	brmi	.+14     	; 0x28d8 <__divsf3_pse+0x3a>
    28ca:	e0 e8       	ldi	r30, 0x80	; 128
    28cc:	30 d0       	rcall	.+96     	; 0x292e <__divsf3_pse+0x90>
    28ce:	91 50       	subi	r25, 0x01	; 1
    28d0:	50 40       	sbci	r21, 0x00	; 0
    28d2:	e6 95       	lsr	r30
    28d4:	00 1c       	adc	r0, r0
    28d6:	ca f7       	brpl	.-14     	; 0x28ca <__divsf3_pse+0x2c>
    28d8:	29 d0       	rcall	.+82     	; 0x292c <__divsf3_pse+0x8e>
    28da:	fe 2f       	mov	r31, r30
    28dc:	27 d0       	rcall	.+78     	; 0x292c <__divsf3_pse+0x8e>
    28de:	66 0f       	add	r22, r22
    28e0:	77 1f       	adc	r23, r23
    28e2:	88 1f       	adc	r24, r24
    28e4:	bb 1f       	adc	r27, r27
    28e6:	26 17       	cp	r18, r22
    28e8:	37 07       	cpc	r19, r23
    28ea:	48 07       	cpc	r20, r24
    28ec:	ab 07       	cpc	r26, r27
    28ee:	b0 e8       	ldi	r27, 0x80	; 128
    28f0:	09 f0       	breq	.+2      	; 0x28f4 <__divsf3_pse+0x56>
    28f2:	bb 0b       	sbc	r27, r27
    28f4:	80 2d       	mov	r24, r0
    28f6:	bf 01       	movw	r22, r30
    28f8:	ff 27       	eor	r31, r31
    28fa:	93 58       	subi	r25, 0x83	; 131
    28fc:	5f 4f       	sbci	r21, 0xFF	; 255
    28fe:	2a f0       	brmi	.+10     	; 0x290a <__divsf3_pse+0x6c>
    2900:	9e 3f       	cpi	r25, 0xFE	; 254
    2902:	51 05       	cpc	r21, r1
    2904:	68 f0       	brcs	.+26     	; 0x2920 <__divsf3_pse+0x82>
    2906:	61 c0       	rjmp	.+194    	; 0x29ca <__fp_inf>
    2908:	ab c0       	rjmp	.+342    	; 0x2a60 <__fp_szero>
    290a:	5f 3f       	cpi	r21, 0xFF	; 255
    290c:	ec f3       	brlt	.-6      	; 0x2908 <__divsf3_pse+0x6a>
    290e:	98 3e       	cpi	r25, 0xE8	; 232
    2910:	dc f3       	brlt	.-10     	; 0x2908 <__divsf3_pse+0x6a>
    2912:	86 95       	lsr	r24
    2914:	77 95       	ror	r23
    2916:	67 95       	ror	r22
    2918:	b7 95       	ror	r27
    291a:	f7 95       	ror	r31
    291c:	9f 5f       	subi	r25, 0xFF	; 255
    291e:	c9 f7       	brne	.-14     	; 0x2912 <__divsf3_pse+0x74>
    2920:	88 0f       	add	r24, r24
    2922:	91 1d       	adc	r25, r1
    2924:	96 95       	lsr	r25
    2926:	87 95       	ror	r24
    2928:	97 f9       	bld	r25, 7
    292a:	08 95       	ret
    292c:	e1 e0       	ldi	r30, 0x01	; 1
    292e:	66 0f       	add	r22, r22
    2930:	77 1f       	adc	r23, r23
    2932:	88 1f       	adc	r24, r24
    2934:	bb 1f       	adc	r27, r27
    2936:	62 17       	cp	r22, r18
    2938:	73 07       	cpc	r23, r19
    293a:	84 07       	cpc	r24, r20
    293c:	ba 07       	cpc	r27, r26
    293e:	20 f0       	brcs	.+8      	; 0x2948 <__divsf3_pse+0xaa>
    2940:	62 1b       	sub	r22, r18
    2942:	73 0b       	sbc	r23, r19
    2944:	84 0b       	sbc	r24, r20
    2946:	ba 0b       	sbc	r27, r26
    2948:	ee 1f       	adc	r30, r30
    294a:	88 f7       	brcc	.-30     	; 0x292e <__divsf3_pse+0x90>
    294c:	e0 95       	com	r30
    294e:	08 95       	ret

00002950 <__floatunsisf>:
    2950:	e8 94       	clt
    2952:	09 c0       	rjmp	.+18     	; 0x2966 <__floatsisf+0x12>

00002954 <__floatsisf>:
    2954:	97 fb       	bst	r25, 7
    2956:	3e f4       	brtc	.+14     	; 0x2966 <__floatsisf+0x12>
    2958:	90 95       	com	r25
    295a:	80 95       	com	r24
    295c:	70 95       	com	r23
    295e:	61 95       	neg	r22
    2960:	7f 4f       	sbci	r23, 0xFF	; 255
    2962:	8f 4f       	sbci	r24, 0xFF	; 255
    2964:	9f 4f       	sbci	r25, 0xFF	; 255
    2966:	99 23       	and	r25, r25
    2968:	a9 f0       	breq	.+42     	; 0x2994 <__floatsisf+0x40>
    296a:	f9 2f       	mov	r31, r25
    296c:	96 e9       	ldi	r25, 0x96	; 150
    296e:	bb 27       	eor	r27, r27
    2970:	93 95       	inc	r25
    2972:	f6 95       	lsr	r31
    2974:	87 95       	ror	r24
    2976:	77 95       	ror	r23
    2978:	67 95       	ror	r22
    297a:	b7 95       	ror	r27
    297c:	f1 11       	cpse	r31, r1
    297e:	f8 cf       	rjmp	.-16     	; 0x2970 <__floatsisf+0x1c>
    2980:	fa f4       	brpl	.+62     	; 0x29c0 <__floatsisf+0x6c>
    2982:	bb 0f       	add	r27, r27
    2984:	11 f4       	brne	.+4      	; 0x298a <__floatsisf+0x36>
    2986:	60 ff       	sbrs	r22, 0
    2988:	1b c0       	rjmp	.+54     	; 0x29c0 <__floatsisf+0x6c>
    298a:	6f 5f       	subi	r22, 0xFF	; 255
    298c:	7f 4f       	sbci	r23, 0xFF	; 255
    298e:	8f 4f       	sbci	r24, 0xFF	; 255
    2990:	9f 4f       	sbci	r25, 0xFF	; 255
    2992:	16 c0       	rjmp	.+44     	; 0x29c0 <__floatsisf+0x6c>
    2994:	88 23       	and	r24, r24
    2996:	11 f0       	breq	.+4      	; 0x299c <__floatsisf+0x48>
    2998:	96 e9       	ldi	r25, 0x96	; 150
    299a:	11 c0       	rjmp	.+34     	; 0x29be <__floatsisf+0x6a>
    299c:	77 23       	and	r23, r23
    299e:	21 f0       	breq	.+8      	; 0x29a8 <__floatsisf+0x54>
    29a0:	9e e8       	ldi	r25, 0x8E	; 142
    29a2:	87 2f       	mov	r24, r23
    29a4:	76 2f       	mov	r23, r22
    29a6:	05 c0       	rjmp	.+10     	; 0x29b2 <__floatsisf+0x5e>
    29a8:	66 23       	and	r22, r22
    29aa:	71 f0       	breq	.+28     	; 0x29c8 <__floatsisf+0x74>
    29ac:	96 e8       	ldi	r25, 0x86	; 134
    29ae:	86 2f       	mov	r24, r22
    29b0:	70 e0       	ldi	r23, 0x00	; 0
    29b2:	60 e0       	ldi	r22, 0x00	; 0
    29b4:	2a f0       	brmi	.+10     	; 0x29c0 <__floatsisf+0x6c>
    29b6:	9a 95       	dec	r25
    29b8:	66 0f       	add	r22, r22
    29ba:	77 1f       	adc	r23, r23
    29bc:	88 1f       	adc	r24, r24
    29be:	da f7       	brpl	.-10     	; 0x29b6 <__floatsisf+0x62>
    29c0:	88 0f       	add	r24, r24
    29c2:	96 95       	lsr	r25
    29c4:	87 95       	ror	r24
    29c6:	97 f9       	bld	r25, 7
    29c8:	08 95       	ret

000029ca <__fp_inf>:
    29ca:	97 f9       	bld	r25, 7
    29cc:	9f 67       	ori	r25, 0x7F	; 127
    29ce:	80 e8       	ldi	r24, 0x80	; 128
    29d0:	70 e0       	ldi	r23, 0x00	; 0
    29d2:	60 e0       	ldi	r22, 0x00	; 0
    29d4:	08 95       	ret

000029d6 <__fp_nan>:
    29d6:	9f ef       	ldi	r25, 0xFF	; 255
    29d8:	80 ec       	ldi	r24, 0xC0	; 192
    29da:	08 95       	ret

000029dc <__fp_pscA>:
    29dc:	00 24       	eor	r0, r0
    29de:	0a 94       	dec	r0
    29e0:	16 16       	cp	r1, r22
    29e2:	17 06       	cpc	r1, r23
    29e4:	18 06       	cpc	r1, r24
    29e6:	09 06       	cpc	r0, r25
    29e8:	08 95       	ret

000029ea <__fp_pscB>:
    29ea:	00 24       	eor	r0, r0
    29ec:	0a 94       	dec	r0
    29ee:	12 16       	cp	r1, r18
    29f0:	13 06       	cpc	r1, r19
    29f2:	14 06       	cpc	r1, r20
    29f4:	05 06       	cpc	r0, r21
    29f6:	08 95       	ret

000029f8 <__fp_round>:
    29f8:	09 2e       	mov	r0, r25
    29fa:	03 94       	inc	r0
    29fc:	00 0c       	add	r0, r0
    29fe:	11 f4       	brne	.+4      	; 0x2a04 <__fp_round+0xc>
    2a00:	88 23       	and	r24, r24
    2a02:	52 f0       	brmi	.+20     	; 0x2a18 <__fp_round+0x20>
    2a04:	bb 0f       	add	r27, r27
    2a06:	40 f4       	brcc	.+16     	; 0x2a18 <__fp_round+0x20>
    2a08:	bf 2b       	or	r27, r31
    2a0a:	11 f4       	brne	.+4      	; 0x2a10 <__fp_round+0x18>
    2a0c:	60 ff       	sbrs	r22, 0
    2a0e:	04 c0       	rjmp	.+8      	; 0x2a18 <__fp_round+0x20>
    2a10:	6f 5f       	subi	r22, 0xFF	; 255
    2a12:	7f 4f       	sbci	r23, 0xFF	; 255
    2a14:	8f 4f       	sbci	r24, 0xFF	; 255
    2a16:	9f 4f       	sbci	r25, 0xFF	; 255
    2a18:	08 95       	ret

00002a1a <__fp_split3>:
    2a1a:	57 fd       	sbrc	r21, 7
    2a1c:	90 58       	subi	r25, 0x80	; 128
    2a1e:	44 0f       	add	r20, r20
    2a20:	55 1f       	adc	r21, r21
    2a22:	59 f0       	breq	.+22     	; 0x2a3a <__fp_splitA+0x10>
    2a24:	5f 3f       	cpi	r21, 0xFF	; 255
    2a26:	71 f0       	breq	.+28     	; 0x2a44 <__fp_splitA+0x1a>
    2a28:	47 95       	ror	r20

00002a2a <__fp_splitA>:
    2a2a:	88 0f       	add	r24, r24
    2a2c:	97 fb       	bst	r25, 7
    2a2e:	99 1f       	adc	r25, r25
    2a30:	61 f0       	breq	.+24     	; 0x2a4a <__fp_splitA+0x20>
    2a32:	9f 3f       	cpi	r25, 0xFF	; 255
    2a34:	79 f0       	breq	.+30     	; 0x2a54 <__fp_splitA+0x2a>
    2a36:	87 95       	ror	r24
    2a38:	08 95       	ret
    2a3a:	12 16       	cp	r1, r18
    2a3c:	13 06       	cpc	r1, r19
    2a3e:	14 06       	cpc	r1, r20
    2a40:	55 1f       	adc	r21, r21
    2a42:	f2 cf       	rjmp	.-28     	; 0x2a28 <__fp_split3+0xe>
    2a44:	46 95       	lsr	r20
    2a46:	f1 df       	rcall	.-30     	; 0x2a2a <__fp_splitA>
    2a48:	08 c0       	rjmp	.+16     	; 0x2a5a <__fp_splitA+0x30>
    2a4a:	16 16       	cp	r1, r22
    2a4c:	17 06       	cpc	r1, r23
    2a4e:	18 06       	cpc	r1, r24
    2a50:	99 1f       	adc	r25, r25
    2a52:	f1 cf       	rjmp	.-30     	; 0x2a36 <__fp_splitA+0xc>
    2a54:	86 95       	lsr	r24
    2a56:	71 05       	cpc	r23, r1
    2a58:	61 05       	cpc	r22, r1
    2a5a:	08 94       	sec
    2a5c:	08 95       	ret

00002a5e <__fp_zero>:
    2a5e:	e8 94       	clt

00002a60 <__fp_szero>:
    2a60:	bb 27       	eor	r27, r27
    2a62:	66 27       	eor	r22, r22
    2a64:	77 27       	eor	r23, r23
    2a66:	cb 01       	movw	r24, r22
    2a68:	97 f9       	bld	r25, 7
    2a6a:	08 95       	ret

00002a6c <pow>:
    2a6c:	fa 01       	movw	r30, r20
    2a6e:	ee 0f       	add	r30, r30
    2a70:	ff 1f       	adc	r31, r31
    2a72:	30 96       	adiw	r30, 0x00	; 0
    2a74:	21 05       	cpc	r18, r1
    2a76:	31 05       	cpc	r19, r1
    2a78:	99 f1       	breq	.+102    	; 0x2ae0 <pow+0x74>
    2a7a:	61 15       	cp	r22, r1
    2a7c:	71 05       	cpc	r23, r1
    2a7e:	61 f4       	brne	.+24     	; 0x2a98 <pow+0x2c>
    2a80:	80 38       	cpi	r24, 0x80	; 128
    2a82:	bf e3       	ldi	r27, 0x3F	; 63
    2a84:	9b 07       	cpc	r25, r27
    2a86:	49 f1       	breq	.+82     	; 0x2ada <pow+0x6e>
    2a88:	68 94       	set
    2a8a:	90 38       	cpi	r25, 0x80	; 128
    2a8c:	81 05       	cpc	r24, r1
    2a8e:	61 f0       	breq	.+24     	; 0x2aa8 <pow+0x3c>
    2a90:	80 38       	cpi	r24, 0x80	; 128
    2a92:	bf ef       	ldi	r27, 0xFF	; 255
    2a94:	9b 07       	cpc	r25, r27
    2a96:	41 f0       	breq	.+16     	; 0x2aa8 <pow+0x3c>
    2a98:	99 23       	and	r25, r25
    2a9a:	42 f5       	brpl	.+80     	; 0x2aec <pow+0x80>
    2a9c:	ff 3f       	cpi	r31, 0xFF	; 255
    2a9e:	e1 05       	cpc	r30, r1
    2aa0:	31 05       	cpc	r19, r1
    2aa2:	21 05       	cpc	r18, r1
    2aa4:	11 f1       	breq	.+68     	; 0x2aea <pow+0x7e>
    2aa6:	e8 94       	clt
    2aa8:	08 94       	sec
    2aaa:	e7 95       	ror	r30
    2aac:	d9 01       	movw	r26, r18
    2aae:	aa 23       	and	r26, r26
    2ab0:	29 f4       	brne	.+10     	; 0x2abc <pow+0x50>
    2ab2:	ab 2f       	mov	r26, r27
    2ab4:	be 2f       	mov	r27, r30
    2ab6:	f8 5f       	subi	r31, 0xF8	; 248
    2ab8:	d0 f3       	brcs	.-12     	; 0x2aae <pow+0x42>
    2aba:	10 c0       	rjmp	.+32     	; 0x2adc <pow+0x70>
    2abc:	ff 5f       	subi	r31, 0xFF	; 255
    2abe:	70 f4       	brcc	.+28     	; 0x2adc <pow+0x70>
    2ac0:	a6 95       	lsr	r26
    2ac2:	e0 f7       	brcc	.-8      	; 0x2abc <pow+0x50>
    2ac4:	f7 39       	cpi	r31, 0x97	; 151
    2ac6:	50 f0       	brcs	.+20     	; 0x2adc <pow+0x70>
    2ac8:	19 f0       	breq	.+6      	; 0x2ad0 <pow+0x64>
    2aca:	ff 3a       	cpi	r31, 0xAF	; 175
    2acc:	38 f4       	brcc	.+14     	; 0x2adc <pow+0x70>
    2ace:	9f 77       	andi	r25, 0x7F	; 127
    2ad0:	9f 93       	push	r25
    2ad2:	0c d0       	rcall	.+24     	; 0x2aec <pow+0x80>
    2ad4:	0f 90       	pop	r0
    2ad6:	07 fc       	sbrc	r0, 7
    2ad8:	90 58       	subi	r25, 0x80	; 128
    2ada:	08 95       	ret
    2adc:	3e f0       	brts	.+14     	; 0x2aec <pow+0x80>
    2ade:	7b cf       	rjmp	.-266    	; 0x29d6 <__fp_nan>
    2ae0:	60 e0       	ldi	r22, 0x00	; 0
    2ae2:	70 e0       	ldi	r23, 0x00	; 0
    2ae4:	80 e8       	ldi	r24, 0x80	; 128
    2ae6:	9f e3       	ldi	r25, 0x3F	; 63
    2ae8:	08 95       	ret
    2aea:	4f e7       	ldi	r20, 0x7F	; 127
    2aec:	9f 77       	andi	r25, 0x7F	; 127
    2aee:	5f 93       	push	r21
    2af0:	4f 93       	push	r20
    2af2:	3f 93       	push	r19
    2af4:	2f 93       	push	r18
    2af6:	9e d0       	rcall	.+316    	; 0x2c34 <log>
    2af8:	2f 91       	pop	r18
    2afa:	3f 91       	pop	r19
    2afc:	4f 91       	pop	r20
    2afe:	5f 91       	pop	r21
    2b00:	0c d1       	rcall	.+536    	; 0x2d1a <__mulsf3>
    2b02:	05 c0       	rjmp	.+10     	; 0x2b0e <exp>
    2b04:	19 f4       	brne	.+6      	; 0x2b0c <pow+0xa0>
    2b06:	0e f0       	brts	.+2      	; 0x2b0a <pow+0x9e>
    2b08:	60 cf       	rjmp	.-320    	; 0x29ca <__fp_inf>
    2b0a:	a9 cf       	rjmp	.-174    	; 0x2a5e <__fp_zero>
    2b0c:	64 cf       	rjmp	.-312    	; 0x29d6 <__fp_nan>

00002b0e <exp>:
    2b0e:	8d df       	rcall	.-230    	; 0x2a2a <__fp_splitA>
    2b10:	c8 f3       	brcs	.-14     	; 0x2b04 <pow+0x98>
    2b12:	96 38       	cpi	r25, 0x86	; 134
    2b14:	c0 f7       	brcc	.-16     	; 0x2b06 <pow+0x9a>
    2b16:	07 f8       	bld	r0, 7
    2b18:	0f 92       	push	r0
    2b1a:	e8 94       	clt
    2b1c:	2b e3       	ldi	r18, 0x3B	; 59
    2b1e:	3a ea       	ldi	r19, 0xAA	; 170
    2b20:	48 eb       	ldi	r20, 0xB8	; 184
    2b22:	5f e7       	ldi	r21, 0x7F	; 127
    2b24:	08 d1       	rcall	.+528    	; 0x2d36 <__mulsf3_pse>
    2b26:	0f 92       	push	r0
    2b28:	0f 92       	push	r0
    2b2a:	0f 92       	push	r0
    2b2c:	4d b7       	in	r20, 0x3d	; 61
    2b2e:	5e b7       	in	r21, 0x3e	; 62
    2b30:	0f 92       	push	r0
    2b32:	c0 d0       	rcall	.+384    	; 0x2cb4 <modf>
    2b34:	e4 e5       	ldi	r30, 0x54	; 84
    2b36:	f0 e0       	ldi	r31, 0x00	; 0
    2b38:	16 d0       	rcall	.+44     	; 0x2b66 <__fp_powser>
    2b3a:	4f 91       	pop	r20
    2b3c:	5f 91       	pop	r21
    2b3e:	ef 91       	pop	r30
    2b40:	ff 91       	pop	r31
    2b42:	e5 95       	asr	r30
    2b44:	ee 1f       	adc	r30, r30
    2b46:	ff 1f       	adc	r31, r31
    2b48:	49 f0       	breq	.+18     	; 0x2b5c <exp+0x4e>
    2b4a:	fe 57       	subi	r31, 0x7E	; 126
    2b4c:	e0 68       	ori	r30, 0x80	; 128
    2b4e:	44 27       	eor	r20, r20
    2b50:	ee 0f       	add	r30, r30
    2b52:	44 1f       	adc	r20, r20
    2b54:	fa 95       	dec	r31
    2b56:	e1 f7       	brne	.-8      	; 0x2b50 <exp+0x42>
    2b58:	41 95       	neg	r20
    2b5a:	55 0b       	sbc	r21, r21
    2b5c:	32 d0       	rcall	.+100    	; 0x2bc2 <ldexp>
    2b5e:	0f 90       	pop	r0
    2b60:	07 fe       	sbrs	r0, 7
    2b62:	26 c0       	rjmp	.+76     	; 0x2bb0 <inverse>
    2b64:	08 95       	ret

00002b66 <__fp_powser>:
    2b66:	df 93       	push	r29
    2b68:	cf 93       	push	r28
    2b6a:	1f 93       	push	r17
    2b6c:	0f 93       	push	r16
    2b6e:	ff 92       	push	r15
    2b70:	ef 92       	push	r14
    2b72:	df 92       	push	r13
    2b74:	7b 01       	movw	r14, r22
    2b76:	8c 01       	movw	r16, r24
    2b78:	68 94       	set
    2b7a:	05 c0       	rjmp	.+10     	; 0x2b86 <__fp_powser+0x20>
    2b7c:	da 2e       	mov	r13, r26
    2b7e:	ef 01       	movw	r28, r30
    2b80:	d8 d0       	rcall	.+432    	; 0x2d32 <__mulsf3x>
    2b82:	fe 01       	movw	r30, r28
    2b84:	e8 94       	clt
    2b86:	a5 91       	lpm	r26, Z+
    2b88:	25 91       	lpm	r18, Z+
    2b8a:	35 91       	lpm	r19, Z+
    2b8c:	45 91       	lpm	r20, Z+
    2b8e:	55 91       	lpm	r21, Z+
    2b90:	ae f3       	brts	.-22     	; 0x2b7c <__fp_powser+0x16>
    2b92:	ef 01       	movw	r28, r30
    2b94:	22 de       	rcall	.-956    	; 0x27da <__addsf3x>
    2b96:	fe 01       	movw	r30, r28
    2b98:	97 01       	movw	r18, r14
    2b9a:	a8 01       	movw	r20, r16
    2b9c:	da 94       	dec	r13
    2b9e:	79 f7       	brne	.-34     	; 0x2b7e <__fp_powser+0x18>
    2ba0:	df 90       	pop	r13
    2ba2:	ef 90       	pop	r14
    2ba4:	ff 90       	pop	r15
    2ba6:	0f 91       	pop	r16
    2ba8:	1f 91       	pop	r17
    2baa:	cf 91       	pop	r28
    2bac:	df 91       	pop	r29
    2bae:	08 95       	ret

00002bb0 <inverse>:
    2bb0:	9b 01       	movw	r18, r22
    2bb2:	ac 01       	movw	r20, r24
    2bb4:	60 e0       	ldi	r22, 0x00	; 0
    2bb6:	70 e0       	ldi	r23, 0x00	; 0
    2bb8:	80 e8       	ldi	r24, 0x80	; 128
    2bba:	9f e3       	ldi	r25, 0x3F	; 63
    2bbc:	61 ce       	rjmp	.-830    	; 0x2880 <__divsf3>
    2bbe:	05 cf       	rjmp	.-502    	; 0x29ca <__fp_inf>
    2bc0:	0f c1       	rjmp	.+542    	; 0x2de0 <__fp_mpack>

00002bc2 <ldexp>:
    2bc2:	33 df       	rcall	.-410    	; 0x2a2a <__fp_splitA>
    2bc4:	e8 f3       	brcs	.-6      	; 0x2bc0 <inverse+0x10>
    2bc6:	99 23       	and	r25, r25
    2bc8:	d9 f3       	breq	.-10     	; 0x2bc0 <inverse+0x10>
    2bca:	94 0f       	add	r25, r20
    2bcc:	51 1d       	adc	r21, r1
    2bce:	bb f3       	brvs	.-18     	; 0x2bbe <inverse+0xe>
    2bd0:	91 50       	subi	r25, 0x01	; 1
    2bd2:	50 40       	sbci	r21, 0x00	; 0
    2bd4:	94 f0       	brlt	.+36     	; 0x2bfa <ldexp+0x38>
    2bd6:	59 f0       	breq	.+22     	; 0x2bee <ldexp+0x2c>
    2bd8:	88 23       	and	r24, r24
    2bda:	32 f0       	brmi	.+12     	; 0x2be8 <ldexp+0x26>
    2bdc:	66 0f       	add	r22, r22
    2bde:	77 1f       	adc	r23, r23
    2be0:	88 1f       	adc	r24, r24
    2be2:	91 50       	subi	r25, 0x01	; 1
    2be4:	50 40       	sbci	r21, 0x00	; 0
    2be6:	c1 f7       	brne	.-16     	; 0x2bd8 <ldexp+0x16>
    2be8:	9e 3f       	cpi	r25, 0xFE	; 254
    2bea:	51 05       	cpc	r21, r1
    2bec:	44 f7       	brge	.-48     	; 0x2bbe <inverse+0xe>
    2bee:	88 0f       	add	r24, r24
    2bf0:	91 1d       	adc	r25, r1
    2bf2:	96 95       	lsr	r25
    2bf4:	87 95       	ror	r24
    2bf6:	97 f9       	bld	r25, 7
    2bf8:	08 95       	ret
    2bfa:	5f 3f       	cpi	r21, 0xFF	; 255
    2bfc:	ac f0       	brlt	.+42     	; 0x2c28 <ldexp+0x66>
    2bfe:	98 3e       	cpi	r25, 0xE8	; 232
    2c00:	9c f0       	brlt	.+38     	; 0x2c28 <ldexp+0x66>
    2c02:	bb 27       	eor	r27, r27
    2c04:	86 95       	lsr	r24
    2c06:	77 95       	ror	r23
    2c08:	67 95       	ror	r22
    2c0a:	b7 95       	ror	r27
    2c0c:	08 f4       	brcc	.+2      	; 0x2c10 <ldexp+0x4e>
    2c0e:	b1 60       	ori	r27, 0x01	; 1
    2c10:	93 95       	inc	r25
    2c12:	c1 f7       	brne	.-16     	; 0x2c04 <ldexp+0x42>
    2c14:	bb 0f       	add	r27, r27
    2c16:	58 f7       	brcc	.-42     	; 0x2bee <ldexp+0x2c>
    2c18:	11 f4       	brne	.+4      	; 0x2c1e <ldexp+0x5c>
    2c1a:	60 ff       	sbrs	r22, 0
    2c1c:	e8 cf       	rjmp	.-48     	; 0x2bee <ldexp+0x2c>
    2c1e:	6f 5f       	subi	r22, 0xFF	; 255
    2c20:	7f 4f       	sbci	r23, 0xFF	; 255
    2c22:	8f 4f       	sbci	r24, 0xFF	; 255
    2c24:	9f 4f       	sbci	r25, 0xFF	; 255
    2c26:	e3 cf       	rjmp	.-58     	; 0x2bee <ldexp+0x2c>
    2c28:	1b cf       	rjmp	.-458    	; 0x2a60 <__fp_szero>
    2c2a:	0e f0       	brts	.+2      	; 0x2c2e <ldexp+0x6c>
    2c2c:	d9 c0       	rjmp	.+434    	; 0x2de0 <__fp_mpack>
    2c2e:	d3 ce       	rjmp	.-602    	; 0x29d6 <__fp_nan>
    2c30:	68 94       	set
    2c32:	cb ce       	rjmp	.-618    	; 0x29ca <__fp_inf>

00002c34 <log>:
    2c34:	fa de       	rcall	.-524    	; 0x2a2a <__fp_splitA>
    2c36:	c8 f3       	brcs	.-14     	; 0x2c2a <ldexp+0x68>
    2c38:	99 23       	and	r25, r25
    2c3a:	d1 f3       	breq	.-12     	; 0x2c30 <ldexp+0x6e>
    2c3c:	c6 f3       	brts	.-16     	; 0x2c2e <ldexp+0x6c>
    2c3e:	df 93       	push	r29
    2c40:	cf 93       	push	r28
    2c42:	1f 93       	push	r17
    2c44:	0f 93       	push	r16
    2c46:	ff 92       	push	r15
    2c48:	c9 2f       	mov	r28, r25
    2c4a:	dd 27       	eor	r29, r29
    2c4c:	88 23       	and	r24, r24
    2c4e:	2a f0       	brmi	.+10     	; 0x2c5a <log+0x26>
    2c50:	21 97       	sbiw	r28, 0x01	; 1
    2c52:	66 0f       	add	r22, r22
    2c54:	77 1f       	adc	r23, r23
    2c56:	88 1f       	adc	r24, r24
    2c58:	da f7       	brpl	.-10     	; 0x2c50 <log+0x1c>
    2c5a:	20 e0       	ldi	r18, 0x00	; 0
    2c5c:	30 e0       	ldi	r19, 0x00	; 0
    2c5e:	40 e8       	ldi	r20, 0x80	; 128
    2c60:	5f eb       	ldi	r21, 0xBF	; 191
    2c62:	9f e3       	ldi	r25, 0x3F	; 63
    2c64:	88 39       	cpi	r24, 0x98	; 152
    2c66:	20 f0       	brcs	.+8      	; 0x2c70 <log+0x3c>
    2c68:	80 3e       	cpi	r24, 0xE0	; 224
    2c6a:	30 f0       	brcs	.+12     	; 0x2c78 <log+0x44>
    2c6c:	21 96       	adiw	r28, 0x01	; 1
    2c6e:	8f 77       	andi	r24, 0x7F	; 127
    2c70:	a3 dd       	rcall	.-1210   	; 0x27b8 <__addsf3>
    2c72:	ec e7       	ldi	r30, 0x7C	; 124
    2c74:	f0 e0       	ldi	r31, 0x00	; 0
    2c76:	03 c0       	rjmp	.+6      	; 0x2c7e <log+0x4a>
    2c78:	9f dd       	rcall	.-1218   	; 0x27b8 <__addsf3>
    2c7a:	e9 ea       	ldi	r30, 0xA9	; 169
    2c7c:	f0 e0       	ldi	r31, 0x00	; 0
    2c7e:	73 df       	rcall	.-282    	; 0x2b66 <__fp_powser>
    2c80:	8b 01       	movw	r16, r22
    2c82:	be 01       	movw	r22, r28
    2c84:	ec 01       	movw	r28, r24
    2c86:	fb 2e       	mov	r15, r27
    2c88:	6f 57       	subi	r22, 0x7F	; 127
    2c8a:	71 09       	sbc	r23, r1
    2c8c:	75 95       	asr	r23
    2c8e:	77 1f       	adc	r23, r23
    2c90:	88 0b       	sbc	r24, r24
    2c92:	99 0b       	sbc	r25, r25
    2c94:	5f de       	rcall	.-834    	; 0x2954 <__floatsisf>
    2c96:	28 e1       	ldi	r18, 0x18	; 24
    2c98:	32 e7       	ldi	r19, 0x72	; 114
    2c9a:	41 e3       	ldi	r20, 0x31	; 49
    2c9c:	5f e3       	ldi	r21, 0x3F	; 63
    2c9e:	49 d0       	rcall	.+146    	; 0x2d32 <__mulsf3x>
    2ca0:	af 2d       	mov	r26, r15
    2ca2:	98 01       	movw	r18, r16
    2ca4:	ae 01       	movw	r20, r28
    2ca6:	ff 90       	pop	r15
    2ca8:	0f 91       	pop	r16
    2caa:	1f 91       	pop	r17
    2cac:	cf 91       	pop	r28
    2cae:	df 91       	pop	r29
    2cb0:	94 dd       	rcall	.-1240   	; 0x27da <__addsf3x>
    2cb2:	a2 ce       	rjmp	.-700    	; 0x29f8 <__fp_round>

00002cb4 <modf>:
    2cb4:	fa 01       	movw	r30, r20
    2cb6:	dc 01       	movw	r26, r24
    2cb8:	aa 0f       	add	r26, r26
    2cba:	bb 1f       	adc	r27, r27
    2cbc:	9b 01       	movw	r18, r22
    2cbe:	ac 01       	movw	r20, r24
    2cc0:	bf 57       	subi	r27, 0x7F	; 127
    2cc2:	28 f4       	brcc	.+10     	; 0x2cce <modf+0x1a>
    2cc4:	22 27       	eor	r18, r18
    2cc6:	33 27       	eor	r19, r19
    2cc8:	44 27       	eor	r20, r20
    2cca:	50 78       	andi	r21, 0x80	; 128
    2ccc:	1f c0       	rjmp	.+62     	; 0x2d0c <modf+0x58>
    2cce:	b7 51       	subi	r27, 0x17	; 23
    2cd0:	88 f4       	brcc	.+34     	; 0x2cf4 <modf+0x40>
    2cd2:	ab 2f       	mov	r26, r27
    2cd4:	00 24       	eor	r0, r0
    2cd6:	46 95       	lsr	r20
    2cd8:	37 95       	ror	r19
    2cda:	27 95       	ror	r18
    2cdc:	01 1c       	adc	r0, r1
    2cde:	a3 95       	inc	r26
    2ce0:	d2 f3       	brmi	.-12     	; 0x2cd6 <modf+0x22>
    2ce2:	00 20       	and	r0, r0
    2ce4:	69 f0       	breq	.+26     	; 0x2d00 <modf+0x4c>
    2ce6:	22 0f       	add	r18, r18
    2ce8:	33 1f       	adc	r19, r19
    2cea:	44 1f       	adc	r20, r20
    2cec:	b3 95       	inc	r27
    2cee:	da f3       	brmi	.-10     	; 0x2ce6 <modf+0x32>
    2cf0:	0d d0       	rcall	.+26     	; 0x2d0c <modf+0x58>
    2cf2:	61 cd       	rjmp	.-1342   	; 0x27b6 <__subsf3>
    2cf4:	61 30       	cpi	r22, 0x01	; 1
    2cf6:	71 05       	cpc	r23, r1
    2cf8:	a0 e8       	ldi	r26, 0x80	; 128
    2cfa:	8a 07       	cpc	r24, r26
    2cfc:	b9 46       	sbci	r27, 0x69	; 105
    2cfe:	30 f4       	brcc	.+12     	; 0x2d0c <modf+0x58>
    2d00:	9b 01       	movw	r18, r22
    2d02:	ac 01       	movw	r20, r24
    2d04:	66 27       	eor	r22, r22
    2d06:	77 27       	eor	r23, r23
    2d08:	88 27       	eor	r24, r24
    2d0a:	90 78       	andi	r25, 0x80	; 128
    2d0c:	30 96       	adiw	r30, 0x00	; 0
    2d0e:	21 f0       	breq	.+8      	; 0x2d18 <modf+0x64>
    2d10:	20 83       	st	Z, r18
    2d12:	31 83       	std	Z+1, r19	; 0x01
    2d14:	42 83       	std	Z+2, r20	; 0x02
    2d16:	53 83       	std	Z+3, r21	; 0x03
    2d18:	08 95       	ret

00002d1a <__mulsf3>:
    2d1a:	0b d0       	rcall	.+22     	; 0x2d32 <__mulsf3x>
    2d1c:	6d ce       	rjmp	.-806    	; 0x29f8 <__fp_round>
    2d1e:	5e de       	rcall	.-836    	; 0x29dc <__fp_pscA>
    2d20:	28 f0       	brcs	.+10     	; 0x2d2c <__mulsf3+0x12>
    2d22:	63 de       	rcall	.-826    	; 0x29ea <__fp_pscB>
    2d24:	18 f0       	brcs	.+6      	; 0x2d2c <__mulsf3+0x12>
    2d26:	95 23       	and	r25, r21
    2d28:	09 f0       	breq	.+2      	; 0x2d2c <__mulsf3+0x12>
    2d2a:	4f ce       	rjmp	.-866    	; 0x29ca <__fp_inf>
    2d2c:	54 ce       	rjmp	.-856    	; 0x29d6 <__fp_nan>
    2d2e:	11 24       	eor	r1, r1
    2d30:	97 ce       	rjmp	.-722    	; 0x2a60 <__fp_szero>

00002d32 <__mulsf3x>:
    2d32:	73 de       	rcall	.-794    	; 0x2a1a <__fp_split3>
    2d34:	a0 f3       	brcs	.-24     	; 0x2d1e <__mulsf3+0x4>

00002d36 <__mulsf3_pse>:
    2d36:	95 9f       	mul	r25, r21
    2d38:	d1 f3       	breq	.-12     	; 0x2d2e <__mulsf3+0x14>
    2d3a:	95 0f       	add	r25, r21
    2d3c:	50 e0       	ldi	r21, 0x00	; 0
    2d3e:	55 1f       	adc	r21, r21
    2d40:	62 9f       	mul	r22, r18
    2d42:	f0 01       	movw	r30, r0
    2d44:	72 9f       	mul	r23, r18
    2d46:	bb 27       	eor	r27, r27
    2d48:	f0 0d       	add	r31, r0
    2d4a:	b1 1d       	adc	r27, r1
    2d4c:	63 9f       	mul	r22, r19
    2d4e:	aa 27       	eor	r26, r26
    2d50:	f0 0d       	add	r31, r0
    2d52:	b1 1d       	adc	r27, r1
    2d54:	aa 1f       	adc	r26, r26
    2d56:	64 9f       	mul	r22, r20
    2d58:	66 27       	eor	r22, r22
    2d5a:	b0 0d       	add	r27, r0
    2d5c:	a1 1d       	adc	r26, r1
    2d5e:	66 1f       	adc	r22, r22
    2d60:	82 9f       	mul	r24, r18
    2d62:	22 27       	eor	r18, r18
    2d64:	b0 0d       	add	r27, r0
    2d66:	a1 1d       	adc	r26, r1
    2d68:	62 1f       	adc	r22, r18
    2d6a:	73 9f       	mul	r23, r19
    2d6c:	b0 0d       	add	r27, r0
    2d6e:	a1 1d       	adc	r26, r1
    2d70:	62 1f       	adc	r22, r18
    2d72:	83 9f       	mul	r24, r19
    2d74:	a0 0d       	add	r26, r0
    2d76:	61 1d       	adc	r22, r1
    2d78:	22 1f       	adc	r18, r18
    2d7a:	74 9f       	mul	r23, r20
    2d7c:	33 27       	eor	r19, r19
    2d7e:	a0 0d       	add	r26, r0
    2d80:	61 1d       	adc	r22, r1
    2d82:	23 1f       	adc	r18, r19
    2d84:	84 9f       	mul	r24, r20
    2d86:	60 0d       	add	r22, r0
    2d88:	21 1d       	adc	r18, r1
    2d8a:	82 2f       	mov	r24, r18
    2d8c:	76 2f       	mov	r23, r22
    2d8e:	6a 2f       	mov	r22, r26
    2d90:	11 24       	eor	r1, r1
    2d92:	9f 57       	subi	r25, 0x7F	; 127
    2d94:	50 40       	sbci	r21, 0x00	; 0
    2d96:	8a f0       	brmi	.+34     	; 0x2dba <__mulsf3_pse+0x84>
    2d98:	e1 f0       	breq	.+56     	; 0x2dd2 <__mulsf3_pse+0x9c>
    2d9a:	88 23       	and	r24, r24
    2d9c:	4a f0       	brmi	.+18     	; 0x2db0 <__mulsf3_pse+0x7a>
    2d9e:	ee 0f       	add	r30, r30
    2da0:	ff 1f       	adc	r31, r31
    2da2:	bb 1f       	adc	r27, r27
    2da4:	66 1f       	adc	r22, r22
    2da6:	77 1f       	adc	r23, r23
    2da8:	88 1f       	adc	r24, r24
    2daa:	91 50       	subi	r25, 0x01	; 1
    2dac:	50 40       	sbci	r21, 0x00	; 0
    2dae:	a9 f7       	brne	.-22     	; 0x2d9a <__mulsf3_pse+0x64>
    2db0:	9e 3f       	cpi	r25, 0xFE	; 254
    2db2:	51 05       	cpc	r21, r1
    2db4:	70 f0       	brcs	.+28     	; 0x2dd2 <__mulsf3_pse+0x9c>
    2db6:	09 ce       	rjmp	.-1006   	; 0x29ca <__fp_inf>
    2db8:	53 ce       	rjmp	.-858    	; 0x2a60 <__fp_szero>
    2dba:	5f 3f       	cpi	r21, 0xFF	; 255
    2dbc:	ec f3       	brlt	.-6      	; 0x2db8 <__mulsf3_pse+0x82>
    2dbe:	98 3e       	cpi	r25, 0xE8	; 232
    2dc0:	dc f3       	brlt	.-10     	; 0x2db8 <__mulsf3_pse+0x82>
    2dc2:	86 95       	lsr	r24
    2dc4:	77 95       	ror	r23
    2dc6:	67 95       	ror	r22
    2dc8:	b7 95       	ror	r27
    2dca:	f7 95       	ror	r31
    2dcc:	e7 95       	ror	r30
    2dce:	9f 5f       	subi	r25, 0xFF	; 255
    2dd0:	c1 f7       	brne	.-16     	; 0x2dc2 <__mulsf3_pse+0x8c>
    2dd2:	fe 2b       	or	r31, r30
    2dd4:	88 0f       	add	r24, r24
    2dd6:	91 1d       	adc	r25, r1
    2dd8:	96 95       	lsr	r25
    2dda:	87 95       	ror	r24
    2ddc:	97 f9       	bld	r25, 7
    2dde:	08 95       	ret

00002de0 <__fp_mpack>:
    2de0:	9f 3f       	cpi	r25, 0xFF	; 255
    2de2:	31 f0       	breq	.+12     	; 0x2df0 <__fp_mpack_finite+0xc>

00002de4 <__fp_mpack_finite>:
    2de4:	91 50       	subi	r25, 0x01	; 1
    2de6:	20 f4       	brcc	.+8      	; 0x2df0 <__fp_mpack_finite+0xc>
    2de8:	87 95       	ror	r24
    2dea:	77 95       	ror	r23
    2dec:	67 95       	ror	r22
    2dee:	b7 95       	ror	r27
    2df0:	88 0f       	add	r24, r24
    2df2:	91 1d       	adc	r25, r1
    2df4:	96 95       	lsr	r25
    2df6:	87 95       	ror	r24
    2df8:	97 f9       	bld	r25, 7
    2dfa:	08 95       	ret

00002dfc <__mulsi3>:
    2dfc:	62 9f       	mul	r22, r18
    2dfe:	d0 01       	movw	r26, r0
    2e00:	73 9f       	mul	r23, r19
    2e02:	f0 01       	movw	r30, r0
    2e04:	82 9f       	mul	r24, r18
    2e06:	e0 0d       	add	r30, r0
    2e08:	f1 1d       	adc	r31, r1
    2e0a:	64 9f       	mul	r22, r20
    2e0c:	e0 0d       	add	r30, r0
    2e0e:	f1 1d       	adc	r31, r1
    2e10:	92 9f       	mul	r25, r18
    2e12:	f0 0d       	add	r31, r0
    2e14:	83 9f       	mul	r24, r19
    2e16:	f0 0d       	add	r31, r0
    2e18:	74 9f       	mul	r23, r20
    2e1a:	f0 0d       	add	r31, r0
    2e1c:	65 9f       	mul	r22, r21
    2e1e:	f0 0d       	add	r31, r0
    2e20:	99 27       	eor	r25, r25
    2e22:	72 9f       	mul	r23, r18
    2e24:	b0 0d       	add	r27, r0
    2e26:	e1 1d       	adc	r30, r1
    2e28:	f9 1f       	adc	r31, r25
    2e2a:	63 9f       	mul	r22, r19
    2e2c:	b0 0d       	add	r27, r0
    2e2e:	e1 1d       	adc	r30, r1
    2e30:	f9 1f       	adc	r31, r25
    2e32:	bd 01       	movw	r22, r26
    2e34:	cf 01       	movw	r24, r30
    2e36:	11 24       	eor	r1, r1
    2e38:	08 95       	ret

00002e3a <__udivmodhi4>:
    2e3a:	aa 1b       	sub	r26, r26
    2e3c:	bb 1b       	sub	r27, r27
    2e3e:	51 e1       	ldi	r21, 0x11	; 17
    2e40:	07 c0       	rjmp	.+14     	; 0x2e50 <__udivmodhi4_ep>

00002e42 <__udivmodhi4_loop>:
    2e42:	aa 1f       	adc	r26, r26
    2e44:	bb 1f       	adc	r27, r27
    2e46:	a6 17       	cp	r26, r22
    2e48:	b7 07       	cpc	r27, r23
    2e4a:	10 f0       	brcs	.+4      	; 0x2e50 <__udivmodhi4_ep>
    2e4c:	a6 1b       	sub	r26, r22
    2e4e:	b7 0b       	sbc	r27, r23

00002e50 <__udivmodhi4_ep>:
    2e50:	88 1f       	adc	r24, r24
    2e52:	99 1f       	adc	r25, r25
    2e54:	5a 95       	dec	r21
    2e56:	a9 f7       	brne	.-22     	; 0x2e42 <__udivmodhi4_loop>
    2e58:	80 95       	com	r24
    2e5a:	90 95       	com	r25
    2e5c:	bc 01       	movw	r22, r24
    2e5e:	cd 01       	movw	r24, r26
    2e60:	08 95       	ret

00002e62 <__udivmodsi4>:
    2e62:	a1 e2       	ldi	r26, 0x21	; 33
    2e64:	1a 2e       	mov	r1, r26
    2e66:	aa 1b       	sub	r26, r26
    2e68:	bb 1b       	sub	r27, r27
    2e6a:	fd 01       	movw	r30, r26
    2e6c:	0d c0       	rjmp	.+26     	; 0x2e88 <__udivmodsi4_ep>

00002e6e <__udivmodsi4_loop>:
    2e6e:	aa 1f       	adc	r26, r26
    2e70:	bb 1f       	adc	r27, r27
    2e72:	ee 1f       	adc	r30, r30
    2e74:	ff 1f       	adc	r31, r31
    2e76:	a2 17       	cp	r26, r18
    2e78:	b3 07       	cpc	r27, r19
    2e7a:	e4 07       	cpc	r30, r20
    2e7c:	f5 07       	cpc	r31, r21
    2e7e:	20 f0       	brcs	.+8      	; 0x2e88 <__udivmodsi4_ep>
    2e80:	a2 1b       	sub	r26, r18
    2e82:	b3 0b       	sbc	r27, r19
    2e84:	e4 0b       	sbc	r30, r20
    2e86:	f5 0b       	sbc	r31, r21

00002e88 <__udivmodsi4_ep>:
    2e88:	66 1f       	adc	r22, r22
    2e8a:	77 1f       	adc	r23, r23
    2e8c:	88 1f       	adc	r24, r24
    2e8e:	99 1f       	adc	r25, r25
    2e90:	1a 94       	dec	r1
    2e92:	69 f7       	brne	.-38     	; 0x2e6e <__udivmodsi4_loop>
    2e94:	60 95       	com	r22
    2e96:	70 95       	com	r23
    2e98:	80 95       	com	r24
    2e9a:	90 95       	com	r25
    2e9c:	9b 01       	movw	r18, r22
    2e9e:	ac 01       	movw	r20, r24
    2ea0:	bd 01       	movw	r22, r26
    2ea2:	cf 01       	movw	r24, r30
    2ea4:	08 95       	ret

00002ea6 <__divmodsi4>:
    2ea6:	97 fb       	bst	r25, 7
    2ea8:	09 2e       	mov	r0, r25
    2eaa:	05 26       	eor	r0, r21
    2eac:	0e d0       	rcall	.+28     	; 0x2eca <__divmodsi4_neg1>
    2eae:	57 fd       	sbrc	r21, 7
    2eb0:	04 d0       	rcall	.+8      	; 0x2eba <__divmodsi4_neg2>
    2eb2:	d7 df       	rcall	.-82     	; 0x2e62 <__udivmodsi4>
    2eb4:	0a d0       	rcall	.+20     	; 0x2eca <__divmodsi4_neg1>
    2eb6:	00 1c       	adc	r0, r0
    2eb8:	38 f4       	brcc	.+14     	; 0x2ec8 <__divmodsi4_exit>

00002eba <__divmodsi4_neg2>:
    2eba:	50 95       	com	r21
    2ebc:	40 95       	com	r20
    2ebe:	30 95       	com	r19
    2ec0:	21 95       	neg	r18
    2ec2:	3f 4f       	sbci	r19, 0xFF	; 255
    2ec4:	4f 4f       	sbci	r20, 0xFF	; 255
    2ec6:	5f 4f       	sbci	r21, 0xFF	; 255

00002ec8 <__divmodsi4_exit>:
    2ec8:	08 95       	ret

00002eca <__divmodsi4_neg1>:
    2eca:	f6 f7       	brtc	.-4      	; 0x2ec8 <__divmodsi4_exit>
    2ecc:	90 95       	com	r25
    2ece:	80 95       	com	r24
    2ed0:	70 95       	com	r23
    2ed2:	61 95       	neg	r22
    2ed4:	7f 4f       	sbci	r23, 0xFF	; 255
    2ed6:	8f 4f       	sbci	r24, 0xFF	; 255
    2ed8:	9f 4f       	sbci	r25, 0xFF	; 255
    2eda:	08 95       	ret

00002edc <memcpy>:
    2edc:	fb 01       	movw	r30, r22
    2ede:	dc 01       	movw	r26, r24
    2ee0:	02 c0       	rjmp	.+4      	; 0x2ee6 <memcpy+0xa>
    2ee2:	01 90       	ld	r0, Z+
    2ee4:	0d 92       	st	X+, r0
    2ee6:	41 50       	subi	r20, 0x01	; 1
    2ee8:	50 40       	sbci	r21, 0x00	; 0
    2eea:	d8 f7       	brcc	.-10     	; 0x2ee2 <memcpy+0x6>
    2eec:	08 95       	ret

00002eee <memset>:
    2eee:	dc 01       	movw	r26, r24
    2ef0:	01 c0       	rjmp	.+2      	; 0x2ef4 <memset+0x6>
    2ef2:	6d 93       	st	X+, r22
    2ef4:	41 50       	subi	r20, 0x01	; 1
    2ef6:	50 40       	sbci	r21, 0x00	; 0
    2ef8:	e0 f7       	brcc	.-8      	; 0x2ef2 <memset+0x4>
    2efa:	08 95       	ret

00002efc <strncpy>:
    2efc:	fb 01       	movw	r30, r22
    2efe:	dc 01       	movw	r26, r24
    2f00:	41 50       	subi	r20, 0x01	; 1
    2f02:	50 40       	sbci	r21, 0x00	; 0
    2f04:	48 f0       	brcs	.+18     	; 0x2f18 <strncpy+0x1c>
    2f06:	01 90       	ld	r0, Z+
    2f08:	0d 92       	st	X+, r0
    2f0a:	00 20       	and	r0, r0
    2f0c:	c9 f7       	brne	.-14     	; 0x2f00 <strncpy+0x4>
    2f0e:	01 c0       	rjmp	.+2      	; 0x2f12 <strncpy+0x16>
    2f10:	1d 92       	st	X+, r1
    2f12:	41 50       	subi	r20, 0x01	; 1
    2f14:	50 40       	sbci	r21, 0x00	; 0
    2f16:	e0 f7       	brcc	.-8      	; 0x2f10 <strncpy+0x14>
    2f18:	08 95       	ret

00002f1a <_exit>:
    2f1a:	f8 94       	cli

00002f1c <__stop_program>:
    2f1c:	ff cf       	rjmp	.-2      	; 0x2f1c <__stop_program>
