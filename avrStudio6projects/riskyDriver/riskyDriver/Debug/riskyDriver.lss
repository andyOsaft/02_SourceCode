
riskyDriver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001f3e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000002a  00800060  00001f3e  00001fd2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000054f  0080008a  0080008a  00001ffc  2**0
                  ALLOC
  3 .stab         00000888  00000000  00000000  00001ffc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000001ac  00000000  00000000  00002884  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000240  00000000  00000000  00002a30  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002e26  00000000  00000000  00002c70  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000f0f  00000000  00000000  00005a96  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001b05  00000000  00000000  000069a5  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000920  00000000  00000000  000084ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000012e9  00000000  00000000  00008dcc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000025ff  00000000  00000000  0000a0b5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000f0  00000000  00000000  0000c6b4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 7f 05 	jmp	0xafe	; 0xafe <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e3       	ldi	r30, 0x3E	; 62
      68:	ff e1       	ldi	r31, 0x1F	; 31
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	aa 38       	cpi	r26, 0x8A	; 138
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	15 e0       	ldi	r17, 0x05	; 5
      78:	aa e8       	ldi	r26, 0x8A	; 138
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a9 3d       	cpi	r26, 0xD9	; 217
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 73 00 	call	0xe6	; 0xe6 <main>
      8a:	0c 94 9d 0f 	jmp	0x1f3a	; 0x1f3a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <adcInit>:
        CPU Frequenz: 8MHz
        -> Prescaler 64 -> ADC Frequenz 125kHz
            
    */
    
    ADCSRA |= (1<<ADEN);
      92:	37 9a       	sbi	0x06, 7	; 6
    
    //Differential Test:
    // * negative input -> ADC1
    // * positive input -> ADC0
    ADMUX |= ( 1<<MUX4 );  
      94:	3c 9a       	sbi	0x07, 4	; 7
   
 
    
    ADCSRA |= ((1<<ADPS2) | (1<<ADPS1) | (1<<ADSC));
      96:	86 b1       	in	r24, 0x06	; 6
      98:	86 64       	ori	r24, 0x46	; 70
      9a:	86 b9       	out	0x06, r24	; 6

    /* Auf Abschluss der Konvertierung warten
       Das Register ADCSRA wird mit "1<<ADSC" maskiert. Da ADSC den Wert 6 hat, wartet das while 
       also solange, bis das Bit6 von ADCSRA == 0 wird.
    */
    while (ADCSRA & (1<<ADSC) ) {}
      9c:	36 99       	sbic	0x06, 6	; 6
      9e:	fe cf       	rjmp	.-4      	; 0x9c <adcInit+0xa>
    //ADCSRA |= (1<<ADIE);				
  
    /* ADCW muss einmal gelesen werden, sonst wird Ergebnis der n‰chsten
        Wandlung nicht ¸bernommen. 
    */
    result = ADCW;		 
      a0:	84 b1       	in	r24, 0x04	; 4
      a2:	95 b1       	in	r25, 0x05	; 5
   
}
      a4:	08 95       	ret

000000a6 <adcRead>:
  
  
    //Single Ended
    //ADMUX:            00101
    //Absolute Input:   ADC5
    ADMUX = 0x05;
      a6:	85 e0       	ldi	r24, 0x05	; 5
      a8:	87 b9       	out	0x07, r24	; 7

   
	/* Single Konvertierung anstoﬂen */
  	ADCSRA |= (1<<ADSC);	
      aa:	36 9a       	sbi	0x06, 6	; 6
    

  	/* Auf Abschluss der Konvertierung warten */
 	while (ADCSRA & (1<<ADSC) ) {}
      ac:	36 99       	sbic	0x06, 6	; 6
      ae:	fe cf       	rjmp	.-4      	; 0xac <adcRead+0x6>
	

	/* Ergebnis als Bitwert */
	result = (uint32_t) ADCW;
      b0:	64 b1       	in	r22, 0x04	; 4
      b2:	75 b1       	in	r23, 0x05	; 5
      b4:	80 e0       	ldi	r24, 0x00	; 0
      b6:	90 e0       	ldi	r25, 0x00	; 0

	/* Wandlungsergebnis in die Realspannung umrechnen 
        -> + 512 -> Korrekte Rundung durch Addition des halben Divisors    
    */
    result = ( (18696 * result ) + 512 ) / 1023; 
      b8:	28 e0       	ldi	r18, 0x08	; 8
      ba:	39 e4       	ldi	r19, 0x49	; 73
      bc:	40 e0       	ldi	r20, 0x00	; 0
      be:	50 e0       	ldi	r21, 0x00	; 0
      c0:	0e 94 29 0f 	call	0x1e52	; 0x1e52 <__mulsi3>
      c4:	60 50       	subi	r22, 0x00	; 0
      c6:	7e 4f       	sbci	r23, 0xFE	; 254
      c8:	8f 4f       	sbci	r24, 0xFF	; 255
      ca:	9f 4f       	sbci	r25, 0xFF	; 255
      cc:	2f ef       	ldi	r18, 0xFF	; 255
      ce:	33 e0       	ldi	r19, 0x03	; 3
      d0:	40 e0       	ldi	r20, 0x00	; 0
      d2:	50 e0       	ldi	r21, 0x00	; 0
      d4:	0e 94 5c 0f 	call	0x1eb8	; 0x1eb8 <__udivmodsi4>
      
         
	return (uint16_t) result;
}
      d8:	82 2f       	mov	r24, r18
      da:	93 2f       	mov	r25, r19
      dc:	08 95       	ret

000000de <measureBattVoltage>:


uint16_t measureBattVoltage()
{
    return( adcRead( BATTERY_VOLTAGE ) );    
      de:	80 e0       	ldi	r24, 0x00	; 0
      e0:	0e 94 53 00 	call	0xa6	; 0xa6 <adcRead>
}
      e4:	08 95       	ret

000000e6 <main>:
void vApplicationIdleHook( void );

/*-----------------------------------------------------------*/

int main( void )
{  
      e6:	cf 93       	push	r28
      e8:	df 93       	push	r29
      ea:	00 d0       	rcall	.+0      	; 0xec <main+0x6>
      ec:	cd b7       	in	r28, 0x3d	; 61
      ee:	de b7       	in	r29, 0x3e	; 62
    
    xQueueHandle measurementQueue;
    //xQueueHandle statusQueue;
    
    //configure time measurment pin as output
    DDRD |= (1<<PB7);
      f0:	8f 9a       	sbi	0x11, 7	; 17

	//prvIncrementResetCount();
    
    //create queues for intertask communication
    measurementQueue = xQueueCreate( measurementQueueLength, ( unsigned portBASE_TYPE ) sizeof( measurementQueueMsg * ) );
      f2:	85 e0       	ldi	r24, 0x05	; 5
      f4:	62 e0       	ldi	r22, 0x02	; 2
      f6:	40 e0       	ldi	r20, 0x00	; 0
      f8:	0e 94 86 06 	call	0xd0c	; 0xd0c <xQueueGenericCreate>
      fc:	9a 83       	std	Y+2, r25	; 0x02
      fe:	89 83       	std	Y+1, r24	; 0x01
    //statusQueue = xQueueCreate( statusQueueLength, ( unsigned portBASE_TYPE ) sizeof( statusQueueMsg * ) );
        
	/* Create the tasks. */
    startCommunicationTask( mainCOMMUNICATION_TASK_PRIORITY, &measurementQueue );
     100:	81 e0       	ldi	r24, 0x01	; 1
     102:	be 01       	movw	r22, r28
     104:	6f 5f       	subi	r22, 0xFF	; 255
     106:	7f 4f       	sbci	r23, 0xFF	; 255
     108:	0e 94 d2 0d 	call	0x1ba4	; 0x1ba4 <startCommunicationTask>
    startNavigatorTask( mainNAVIGATOR_TASK_PRIORITY, &measurementQueue );
     10c:	82 e0       	ldi	r24, 0x02	; 2
     10e:	be 01       	movw	r22, r28
     110:	6f 5f       	subi	r22, 0xFF	; 255
     112:	7f 4f       	sbci	r23, 0xFF	; 255
     114:	0e 94 1e 0e 	call	0x1c3c	; 0x1c3c <startNavigatorTask>
    startOperatorTask( mainOPERATOR_TASK_PRIORITY, &measurementQueue );
     118:	83 e0       	ldi	r24, 0x03	; 3
     11a:	be 01       	movw	r22, r28
     11c:	6f 5f       	subi	r22, 0xFF	; 255
     11e:	7f 4f       	sbci	r23, 0xFF	; 255
     120:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <startOperatorTask>
	startSensorTask( mainSENSOR_TASK_PRIORITY, &measurementQueue);
     124:	83 e0       	ldi	r24, 0x03	; 3
     126:	be 01       	movw	r22, r28
     128:	6f 5f       	subi	r22, 0xFF	; 255
     12a:	7f 4f       	sbci	r23, 0xFF	; 255
     12c:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <startSensorTask>
	
	/* In this port, to use preemptive scheduler define configUSE_PREEMPTION 
	as 1 in portmacro.h.  To use the cooperative scheduler define 
	configUSE_PREEMPTION as 0. */
	vTaskStartScheduler();
     130:	0e 94 3c 0a 	call	0x1478	; 0x1478 <vTaskStartScheduler>

	return 0;
}
     134:	80 e0       	ldi	r24, 0x00	; 0
     136:	90 e0       	ldi	r25, 0x00	; 0
     138:	0f 90       	pop	r0
     13a:	0f 90       	pop	r0
     13c:	df 91       	pop	r29
     13e:	cf 91       	pop	r28
     140:	08 95       	ret

00000142 <vApplicationIdleHook>:
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
	//vCoRoutineSchedule();
}
     142:	08 95       	ret

00000144 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     144:	af 92       	push	r10
     146:	bf 92       	push	r11
     148:	cf 92       	push	r12
     14a:	df 92       	push	r13
     14c:	ef 92       	push	r14
     14e:	ff 92       	push	r15
     150:	0f 93       	push	r16
     152:	1f 93       	push	r17
     154:	cf 93       	push	r28
     156:	df 93       	push	r29
     158:	6c 01       	movw	r12, r24
     15a:	e6 2e       	mov	r14, r22
     15c:	f4 2e       	mov	r15, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     15e:	8a e1       	ldi	r24, 0x1A	; 26
     160:	90 e0       	ldi	r25, 0x00	; 0
     162:	0e 94 15 03 	call	0x62a	; 0x62a <pvPortMalloc>
     166:	8c 01       	movw	r16, r24
	if( pxCoRoutine )
     168:	00 97       	sbiw	r24, 0x00	; 0
     16a:	09 f4       	brne	.+2      	; 0x16e <xCoRoutineCreate+0x2a>
     16c:	62 c0       	rjmp	.+196    	; 0x232 <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     16e:	80 91 8a 00 	lds	r24, 0x008A
     172:	90 91 8b 00 	lds	r25, 0x008B
     176:	00 97       	sbiw	r24, 0x00	; 0
     178:	39 f5       	brne	.+78     	; 0x1c8 <xCoRoutineCreate+0x84>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     17a:	10 93 8b 00 	sts	0x008B, r17
     17e:	00 93 8a 00 	sts	0x008A, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
     182:	cd e8       	ldi	r28, 0x8D	; 141
     184:	d0 e0       	ldi	r29, 0x00	; 0
     186:	ce 01       	movw	r24, r28
     188:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialise>
     18c:	ce 01       	movw	r24, r28
     18e:	09 96       	adiw	r24, 0x09	; 9
     190:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
     194:	cf e9       	ldi	r28, 0x9F	; 159
     196:	d0 e0       	ldi	r29, 0x00	; 0
     198:	ce 01       	movw	r24, r28
     19a:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
     19e:	0f 2e       	mov	r0, r31
     1a0:	f8 ea       	ldi	r31, 0xA8	; 168
     1a2:	af 2e       	mov	r10, r31
     1a4:	f0 e0       	ldi	r31, 0x00	; 0
     1a6:	bf 2e       	mov	r11, r31
     1a8:	f0 2d       	mov	r31, r0
     1aa:	c5 01       	movw	r24, r10
     1ac:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
     1b0:	81 eb       	ldi	r24, 0xB1	; 177
     1b2:	90 e0       	ldi	r25, 0x00	; 0
     1b4:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
     1b8:	d0 93 bb 00 	sts	0x00BB, r29
     1bc:	c0 93 ba 00 	sts	0x00BA, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
     1c0:	b0 92 bd 00 	sts	0x00BD, r11
     1c4:	a0 92 bc 00 	sts	0x00BC, r10
     1c8:	ce 2d       	mov	r28, r14
     1ca:	e1 10       	cpse	r14, r1
     1cc:	c1 e0       	ldi	r28, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     1ce:	f8 01       	movw	r30, r16
     1d0:	11 8e       	std	Z+25, r1	; 0x19
     1d2:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     1d4:	c6 8b       	std	Z+22, r28	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     1d6:	f7 8a       	std	Z+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     1d8:	c1 92       	st	Z+, r12
     1da:	d1 92       	st	Z+, r13
     1dc:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     1de:	cf 01       	movw	r24, r30
     1e0:	0e 94 68 03 	call	0x6d0	; 0x6d0 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     1e4:	c8 01       	movw	r24, r16
     1e6:	0c 96       	adiw	r24, 0x0c	; 12
     1e8:	0e 94 68 03 	call	0x6d0	; 0x6d0 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     1ec:	f8 01       	movw	r30, r16
     1ee:	11 87       	std	Z+9, r17	; 0x09
     1f0:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     1f2:	13 8b       	std	Z+19, r17	; 0x13
     1f4:	02 8b       	std	Z+18, r16	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( uint32_t ) uxPriority );
     1f6:	84 e0       	ldi	r24, 0x04	; 4
     1f8:	90 e0       	ldi	r25, 0x00	; 0
     1fa:	8c 1b       	sub	r24, r28
     1fc:	91 09       	sbc	r25, r1
     1fe:	95 87       	std	Z+13, r25	; 0x0d
     200:	84 87       	std	Z+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     202:	86 89       	ldd	r24, Z+22	; 0x16
     204:	90 91 8c 00 	lds	r25, 0x008C
     208:	98 17       	cp	r25, r24
     20a:	10 f4       	brcc	.+4      	; 0x210 <xCoRoutineCreate+0xcc>
     20c:	80 93 8c 00 	sts	0x008C, r24
     210:	90 e0       	ldi	r25, 0x00	; 0
     212:	9c 01       	movw	r18, r24
     214:	22 0f       	add	r18, r18
     216:	33 1f       	adc	r19, r19
     218:	22 0f       	add	r18, r18
     21a:	33 1f       	adc	r19, r19
     21c:	22 0f       	add	r18, r18
     21e:	33 1f       	adc	r19, r19
     220:	82 0f       	add	r24, r18
     222:	93 1f       	adc	r25, r19
     224:	83 57       	subi	r24, 0x73	; 115
     226:	9f 4f       	sbci	r25, 0xFF	; 255
     228:	b7 01       	movw	r22, r14
     22a:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInsertEnd>

		xReturn = pdPASS;
     22e:	81 e0       	ldi	r24, 0x01	; 1
     230:	01 c0       	rjmp	.+2      	; 0x234 <xCoRoutineCreate+0xf0>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     232:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
     234:	df 91       	pop	r29
     236:	cf 91       	pop	r28
     238:	1f 91       	pop	r17
     23a:	0f 91       	pop	r16
     23c:	ff 90       	pop	r15
     23e:	ef 90       	pop	r14
     240:	df 90       	pop	r13
     242:	cf 90       	pop	r12
     244:	bf 90       	pop	r11
     246:	af 90       	pop	r10
     248:	08 95       	ret

0000024a <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( uint32_t xTicksToDelay, xList *pxEventList )
{
     24a:	cf 92       	push	r12
     24c:	df 92       	push	r13
     24e:	ef 92       	push	r14
     250:	ff 92       	push	r15
     252:	cf 93       	push	r28
     254:	df 93       	push	r29
     256:	dc 01       	movw	r26, r24
     258:	cb 01       	movw	r24, r22
     25a:	ea 01       	movw	r28, r20
uint32_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     25c:	c0 90 be 00 	lds	r12, 0x00BE
     260:	d0 90 bf 00 	lds	r13, 0x00BF
     264:	e0 90 c0 00 	lds	r14, 0x00C0
     268:	f0 90 c1 00 	lds	r15, 0x00C1
     26c:	c8 0e       	add	r12, r24
     26e:	d9 1e       	adc	r13, r25
     270:	ea 1e       	adc	r14, r26
     272:	fb 1e       	adc	r15, r27

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     274:	80 91 8a 00 	lds	r24, 0x008A
     278:	90 91 8b 00 	lds	r25, 0x008B
     27c:	02 96       	adiw	r24, 0x02	; 2
     27e:	0e 94 df 03 	call	0x7be	; 0x7be <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     282:	e0 91 8a 00 	lds	r30, 0x008A
     286:	f0 91 8b 00 	lds	r31, 0x008B
     28a:	d3 82       	std	Z+3, r13	; 0x03
     28c:	c2 82       	std	Z+2, r12	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     28e:	80 91 be 00 	lds	r24, 0x00BE
     292:	90 91 bf 00 	lds	r25, 0x00BF
     296:	a0 91 c0 00 	lds	r26, 0x00C0
     29a:	b0 91 c1 00 	lds	r27, 0x00C1
     29e:	c8 16       	cp	r12, r24
     2a0:	d9 06       	cpc	r13, r25
     2a2:	ea 06       	cpc	r14, r26
     2a4:	fb 06       	cpc	r15, r27
     2a6:	50 f4       	brcc	.+20     	; 0x2bc <vCoRoutineAddToDelayedList+0x72>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2a8:	bf 01       	movw	r22, r30
     2aa:	6e 5f       	subi	r22, 0xFE	; 254
     2ac:	7f 4f       	sbci	r23, 0xFF	; 255
     2ae:	80 91 bc 00 	lds	r24, 0x00BC
     2b2:	90 91 bd 00 	lds	r25, 0x00BD
     2b6:	0e 94 95 03 	call	0x72a	; 0x72a <vListInsert>
     2ba:	09 c0       	rjmp	.+18     	; 0x2ce <vCoRoutineAddToDelayedList+0x84>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     2bc:	bf 01       	movw	r22, r30
     2be:	6e 5f       	subi	r22, 0xFE	; 254
     2c0:	7f 4f       	sbci	r23, 0xFF	; 255
     2c2:	80 91 ba 00 	lds	r24, 0x00BA
     2c6:	90 91 bb 00 	lds	r25, 0x00BB
     2ca:	0e 94 95 03 	call	0x72a	; 0x72a <vListInsert>
	}

	if( pxEventList )
     2ce:	20 97       	sbiw	r28, 0x00	; 0
     2d0:	49 f0       	breq	.+18     	; 0x2e4 <vCoRoutineAddToDelayedList+0x9a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     2d2:	60 91 8a 00 	lds	r22, 0x008A
     2d6:	70 91 8b 00 	lds	r23, 0x008B
     2da:	64 5f       	subi	r22, 0xF4	; 244
     2dc:	7f 4f       	sbci	r23, 0xFF	; 255
     2de:	ce 01       	movw	r24, r28
     2e0:	0e 94 95 03 	call	0x72a	; 0x72a <vListInsert>
	}
}
     2e4:	df 91       	pop	r29
     2e6:	cf 91       	pop	r28
     2e8:	ff 90       	pop	r15
     2ea:	ef 90       	pop	r14
     2ec:	df 90       	pop	r13
     2ee:	cf 90       	pop	r12
     2f0:	08 95       	ret

000002f2 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
     2f2:	cf 92       	push	r12
     2f4:	df 92       	push	r13
     2f6:	ef 92       	push	r14
     2f8:	ff 92       	push	r15
     2fa:	0f 93       	push	r16
     2fc:	1f 93       	push	r17
     2fe:	cf 93       	push	r28
     300:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     302:	80 91 b1 00 	lds	r24, 0x00B1
     306:	88 23       	and	r24, r24
     308:	b9 f1       	breq	.+110    	; 0x378 <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     30a:	0f 2e       	mov	r0, r31
     30c:	f6 eb       	ldi	r31, 0xB6	; 182
     30e:	ef 2e       	mov	r14, r31
     310:	f0 e0       	ldi	r31, 0x00	; 0
     312:	ff 2e       	mov	r15, r31
     314:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     316:	0f 2e       	mov	r0, r31
     318:	f1 eb       	ldi	r31, 0xB1	; 177
     31a:	cf 2e       	mov	r12, r31
     31c:	f0 e0       	ldi	r31, 0x00	; 0
     31e:	df 2e       	mov	r13, r31
     320:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
     322:	f8 94       	cli
		{
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
     324:	d7 01       	movw	r26, r14
     326:	ed 91       	ld	r30, X+
     328:	fc 91       	ld	r31, X
     32a:	c6 81       	ldd	r28, Z+6	; 0x06
     32c:	d7 81       	ldd	r29, Z+7	; 0x07
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     32e:	ce 01       	movw	r24, r28
     330:	0c 96       	adiw	r24, 0x0c	; 12
     332:	0e 94 df 03 	call	0x7be	; 0x7be <uxListRemove>
		}
		portENABLE_INTERRUPTS();
     336:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
     338:	8e 01       	movw	r16, r28
     33a:	0e 5f       	subi	r16, 0xFE	; 254
     33c:	1f 4f       	sbci	r17, 0xFF	; 255
     33e:	c8 01       	movw	r24, r16
     340:	0e 94 df 03 	call	0x7be	; 0x7be <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
     344:	8e 89       	ldd	r24, Y+22	; 0x16
     346:	90 91 8c 00 	lds	r25, 0x008C
     34a:	98 17       	cp	r25, r24
     34c:	10 f4       	brcc	.+4      	; 0x352 <vCoRoutineSchedule+0x60>
     34e:	80 93 8c 00 	sts	0x008C, r24
     352:	90 e0       	ldi	r25, 0x00	; 0
     354:	9c 01       	movw	r18, r24
     356:	22 0f       	add	r18, r18
     358:	33 1f       	adc	r19, r19
     35a:	22 0f       	add	r18, r18
     35c:	33 1f       	adc	r19, r19
     35e:	22 0f       	add	r18, r18
     360:	33 1f       	adc	r19, r19
     362:	82 0f       	add	r24, r18
     364:	93 1f       	adc	r25, r19
     366:	83 57       	subi	r24, 0x73	; 115
     368:	9f 4f       	sbci	r25, 0xFF	; 255
     36a:	b8 01       	movw	r22, r16
     36c:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
     370:	f6 01       	movw	r30, r12
     372:	80 81       	ld	r24, Z
     374:	88 23       	and	r24, r24
     376:	a9 f6       	brne	.-86     	; 0x322 <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
     378:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <xTaskGetTickCount>
     37c:	a0 e0       	ldi	r26, 0x00	; 0
     37e:	b0 e0       	ldi	r27, 0x00	; 0
     380:	40 91 c2 00 	lds	r20, 0x00C2
     384:	50 91 c3 00 	lds	r21, 0x00C3
     388:	60 91 c4 00 	lds	r22, 0x00C4
     38c:	70 91 c5 00 	lds	r23, 0x00C5
     390:	84 1b       	sub	r24, r20
     392:	95 0b       	sbc	r25, r21
     394:	a6 0b       	sbc	r26, r22
     396:	b7 0b       	sbc	r27, r23
     398:	80 93 c6 00 	sts	0x00C6, r24
     39c:	90 93 c7 00 	sts	0x00C7, r25
     3a0:	a0 93 c8 00 	sts	0x00C8, r26
     3a4:	b0 93 c9 00 	sts	0x00C9, r27
     3a8:	97 c0       	rjmp	.+302    	; 0x4d8 <vCoRoutineSchedule+0x1e6>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
     3aa:	40 91 be 00 	lds	r20, 0x00BE
     3ae:	50 91 bf 00 	lds	r21, 0x00BF
     3b2:	60 91 c0 00 	lds	r22, 0x00C0
     3b6:	70 91 c1 00 	lds	r23, 0x00C1
     3ba:	4f 5f       	subi	r20, 0xFF	; 255
     3bc:	5f 4f       	sbci	r21, 0xFF	; 255
     3be:	6f 4f       	sbci	r22, 0xFF	; 255
     3c0:	7f 4f       	sbci	r23, 0xFF	; 255
     3c2:	40 93 be 00 	sts	0x00BE, r20
     3c6:	50 93 bf 00 	sts	0x00BF, r21
     3ca:	60 93 c0 00 	sts	0x00C0, r22
     3ce:	70 93 c1 00 	sts	0x00C1, r23
		xPassedTicks--;
     3d2:	01 97       	sbiw	r24, 0x01	; 1
     3d4:	a1 09       	sbc	r26, r1
     3d6:	b1 09       	sbc	r27, r1
     3d8:	80 93 c6 00 	sts	0x00C6, r24
     3dc:	90 93 c7 00 	sts	0x00C7, r25
     3e0:	a0 93 c8 00 	sts	0x00C8, r26
     3e4:	b0 93 c9 00 	sts	0x00C9, r27

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
     3e8:	41 15       	cp	r20, r1
     3ea:	51 05       	cpc	r21, r1
     3ec:	61 05       	cpc	r22, r1
     3ee:	71 05       	cpc	r23, r1
     3f0:	81 f4       	brne	.+32     	; 0x412 <vCoRoutineSchedule+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
     3f2:	80 91 ba 00 	lds	r24, 0x00BA
     3f6:	90 91 bb 00 	lds	r25, 0x00BB
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
     3fa:	20 91 bc 00 	lds	r18, 0x00BC
     3fe:	30 91 bd 00 	lds	r19, 0x00BD
     402:	30 93 bb 00 	sts	0x00BB, r19
     406:	20 93 ba 00 	sts	0x00BA, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
     40a:	90 93 bd 00 	sts	0x00BD, r25
     40e:	80 93 bc 00 	sts	0x00BC, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     412:	e0 91 ba 00 	lds	r30, 0x00BA
     416:	f0 91 bb 00 	lds	r31, 0x00BB
     41a:	80 81       	ld	r24, Z
     41c:	88 23       	and	r24, r24
     41e:	09 f4       	brne	.+2      	; 0x422 <vCoRoutineSchedule+0x130>
     420:	5b c0       	rjmp	.+182    	; 0x4d8 <vCoRoutineSchedule+0x1e6>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     422:	05 80       	ldd	r0, Z+5	; 0x05
     424:	f6 81       	ldd	r31, Z+6	; 0x06
     426:	e0 2d       	mov	r30, r0
     428:	c6 81       	ldd	r28, Z+6	; 0x06
     42a:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     42c:	4a 81       	ldd	r20, Y+2	; 0x02
     42e:	5b 81       	ldd	r21, Y+3	; 0x03
     430:	60 e0       	ldi	r22, 0x00	; 0
     432:	70 e0       	ldi	r23, 0x00	; 0
     434:	80 91 be 00 	lds	r24, 0x00BE
     438:	90 91 bf 00 	lds	r25, 0x00BF
     43c:	a0 91 c0 00 	lds	r26, 0x00C0
     440:	b0 91 c1 00 	lds	r27, 0x00C1
     444:	84 17       	cp	r24, r20
     446:	95 07       	cpc	r25, r21
     448:	a6 07       	cpc	r26, r22
     44a:	b7 07       	cpc	r27, r23
     44c:	b8 f4       	brcc	.+46     	; 0x47c <vCoRoutineSchedule+0x18a>
     44e:	44 c0       	rjmp	.+136    	; 0x4d8 <vCoRoutineSchedule+0x1e6>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
     450:	05 80       	ldd	r0, Z+5	; 0x05
     452:	f6 81       	ldd	r31, Z+6	; 0x06
     454:	e0 2d       	mov	r30, r0
     456:	c6 81       	ldd	r28, Z+6	; 0x06
     458:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
     45a:	4a 81       	ldd	r20, Y+2	; 0x02
     45c:	5b 81       	ldd	r21, Y+3	; 0x03
     45e:	60 e0       	ldi	r22, 0x00	; 0
     460:	70 e0       	ldi	r23, 0x00	; 0
     462:	80 91 be 00 	lds	r24, 0x00BE
     466:	90 91 bf 00 	lds	r25, 0x00BF
     46a:	a0 91 c0 00 	lds	r26, 0x00C0
     46e:	b0 91 c1 00 	lds	r27, 0x00C1
     472:	84 17       	cp	r24, r20
     474:	95 07       	cpc	r25, r21
     476:	a6 07       	cpc	r26, r22
     478:	b7 07       	cpc	r27, r23
     47a:	70 f1       	brcs	.+92     	; 0x4d8 <vCoRoutineSchedule+0x1e6>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
     47c:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );
     47e:	8e 01       	movw	r16, r28
     480:	0e 5f       	subi	r16, 0xFE	; 254
     482:	1f 4f       	sbci	r17, 0xFF	; 255
     484:	c8 01       	movw	r24, r16
     486:	0e 94 df 03 	call	0x7be	; 0x7be <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
     48a:	8c 89       	ldd	r24, Y+20	; 0x14
     48c:	9d 89       	ldd	r25, Y+21	; 0x15
     48e:	00 97       	sbiw	r24, 0x00	; 0
     490:	21 f0       	breq	.+8      	; 0x49a <vCoRoutineSchedule+0x1a8>
				{
					uxListRemove( &( pxCRCB->xEventListItem ) );
     492:	ce 01       	movw	r24, r28
     494:	0c 96       	adiw	r24, 0x0c	; 12
     496:	0e 94 df 03 	call	0x7be	; 0x7be <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
     49a:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
     49c:	8e 89       	ldd	r24, Y+22	; 0x16
     49e:	90 91 8c 00 	lds	r25, 0x008C
     4a2:	98 17       	cp	r25, r24
     4a4:	10 f4       	brcc	.+4      	; 0x4aa <vCoRoutineSchedule+0x1b8>
     4a6:	80 93 8c 00 	sts	0x008C, r24
     4aa:	90 e0       	ldi	r25, 0x00	; 0
     4ac:	9c 01       	movw	r18, r24
     4ae:	22 0f       	add	r18, r18
     4b0:	33 1f       	adc	r19, r19
     4b2:	22 0f       	add	r18, r18
     4b4:	33 1f       	adc	r19, r19
     4b6:	22 0f       	add	r18, r18
     4b8:	33 1f       	adc	r19, r19
     4ba:	82 0f       	add	r24, r18
     4bc:	93 1f       	adc	r25, r19
     4be:	83 57       	subi	r24, 0x73	; 115
     4c0:	9f 4f       	sbci	r25, 0xFF	; 255
     4c2:	b8 01       	movw	r22, r16
     4c4:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
     4c8:	e0 91 ba 00 	lds	r30, 0x00BA
     4cc:	f0 91 bb 00 	lds	r31, 0x00BB
     4d0:	80 81       	ld	r24, Z
     4d2:	88 23       	and	r24, r24
     4d4:	09 f0       	breq	.+2      	; 0x4d8 <vCoRoutineSchedule+0x1e6>
     4d6:	bc cf       	rjmp	.-136    	; 0x450 <vCoRoutineSchedule+0x15e>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
     4d8:	80 91 c6 00 	lds	r24, 0x00C6
     4dc:	90 91 c7 00 	lds	r25, 0x00C7
     4e0:	a0 91 c8 00 	lds	r26, 0x00C8
     4e4:	b0 91 c9 00 	lds	r27, 0x00C9
     4e8:	00 97       	sbiw	r24, 0x00	; 0
     4ea:	a1 05       	cpc	r26, r1
     4ec:	b1 05       	cpc	r27, r1
     4ee:	09 f0       	breq	.+2      	; 0x4f2 <vCoRoutineSchedule+0x200>
     4f0:	5c cf       	rjmp	.-328    	; 0x3aa <vCoRoutineSchedule+0xb8>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
     4f2:	80 91 be 00 	lds	r24, 0x00BE
     4f6:	90 91 bf 00 	lds	r25, 0x00BF
     4fa:	a0 91 c0 00 	lds	r26, 0x00C0
     4fe:	b0 91 c1 00 	lds	r27, 0x00C1
     502:	80 93 c2 00 	sts	0x00C2, r24
     506:	90 93 c3 00 	sts	0x00C3, r25
     50a:	a0 93 c4 00 	sts	0x00C4, r26
     50e:	b0 93 c5 00 	sts	0x00C5, r27

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     512:	20 91 8c 00 	lds	r18, 0x008C
     516:	82 2f       	mov	r24, r18
     518:	90 e0       	ldi	r25, 0x00	; 0
     51a:	fc 01       	movw	r30, r24
     51c:	ee 0f       	add	r30, r30
     51e:	ff 1f       	adc	r31, r31
     520:	ee 0f       	add	r30, r30
     522:	ff 1f       	adc	r31, r31
     524:	ee 0f       	add	r30, r30
     526:	ff 1f       	adc	r31, r31
     528:	e8 0f       	add	r30, r24
     52a:	f9 1f       	adc	r31, r25
     52c:	e3 57       	subi	r30, 0x73	; 115
     52e:	ff 4f       	sbci	r31, 0xFF	; 255
     530:	30 81       	ld	r19, Z
     532:	33 23       	and	r19, r19
     534:	d9 f4       	brne	.+54     	; 0x56c <vCoRoutineSchedule+0x27a>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
     536:	22 23       	and	r18, r18
     538:	31 f4       	brne	.+12     	; 0x546 <vCoRoutineSchedule+0x254>
     53a:	47 c0       	rjmp	.+142    	; 0x5ca <vCoRoutineSchedule+0x2d8>
     53c:	22 23       	and	r18, r18
     53e:	19 f4       	brne	.+6      	; 0x546 <vCoRoutineSchedule+0x254>
     540:	20 93 8c 00 	sts	0x008C, r18
     544:	42 c0       	rjmp	.+132    	; 0x5ca <vCoRoutineSchedule+0x2d8>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
     546:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
     548:	82 2f       	mov	r24, r18
     54a:	90 e0       	ldi	r25, 0x00	; 0
     54c:	fc 01       	movw	r30, r24
     54e:	ee 0f       	add	r30, r30
     550:	ff 1f       	adc	r31, r31
     552:	ee 0f       	add	r30, r30
     554:	ff 1f       	adc	r31, r31
     556:	ee 0f       	add	r30, r30
     558:	ff 1f       	adc	r31, r31
     55a:	e8 0f       	add	r30, r24
     55c:	f9 1f       	adc	r31, r25
     55e:	e3 57       	subi	r30, 0x73	; 115
     560:	ff 4f       	sbci	r31, 0xFF	; 255
     562:	30 81       	ld	r19, Z
     564:	33 23       	and	r19, r19
     566:	51 f3       	breq	.-44     	; 0x53c <vCoRoutineSchedule+0x24a>
     568:	20 93 8c 00 	sts	0x008C, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
     56c:	fc 01       	movw	r30, r24
     56e:	ee 0f       	add	r30, r30
     570:	ff 1f       	adc	r31, r31
     572:	ee 0f       	add	r30, r30
     574:	ff 1f       	adc	r31, r31
     576:	ee 0f       	add	r30, r30
     578:	ff 1f       	adc	r31, r31
     57a:	8e 0f       	add	r24, r30
     57c:	9f 1f       	adc	r25, r31
     57e:	fc 01       	movw	r30, r24
     580:	e3 57       	subi	r30, 0x73	; 115
     582:	ff 4f       	sbci	r31, 0xFF	; 255
     584:	a1 81       	ldd	r26, Z+1	; 0x01
     586:	b2 81       	ldd	r27, Z+2	; 0x02
     588:	12 96       	adiw	r26, 0x02	; 2
     58a:	0d 90       	ld	r0, X+
     58c:	bc 91       	ld	r27, X
     58e:	a0 2d       	mov	r26, r0
     590:	b2 83       	std	Z+2, r27	; 0x02
     592:	a1 83       	std	Z+1, r26	; 0x01
     594:	cf 01       	movw	r24, r30
     596:	03 96       	adiw	r24, 0x03	; 3
     598:	a8 17       	cp	r26, r24
     59a:	b9 07       	cpc	r27, r25
     59c:	31 f4       	brne	.+12     	; 0x5aa <vCoRoutineSchedule+0x2b8>
     59e:	12 96       	adiw	r26, 0x02	; 2
     5a0:	8d 91       	ld	r24, X+
     5a2:	9c 91       	ld	r25, X
     5a4:	13 97       	sbiw	r26, 0x03	; 3
     5a6:	92 83       	std	Z+2, r25	; 0x02
     5a8:	81 83       	std	Z+1, r24	; 0x01
     5aa:	01 80       	ldd	r0, Z+1	; 0x01
     5ac:	f2 81       	ldd	r31, Z+2	; 0x02
     5ae:	e0 2d       	mov	r30, r0
     5b0:	a6 81       	ldd	r26, Z+6	; 0x06
     5b2:	b7 81       	ldd	r27, Z+7	; 0x07
     5b4:	b0 93 8b 00 	sts	0x008B, r27
     5b8:	a0 93 8a 00 	sts	0x008A, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
     5bc:	ed 91       	ld	r30, X+
     5be:	fc 91       	ld	r31, X
     5c0:	11 97       	sbiw	r26, 0x01	; 1
     5c2:	cd 01       	movw	r24, r26
     5c4:	57 96       	adiw	r26, 0x17	; 23
     5c6:	6c 91       	ld	r22, X
     5c8:	09 95       	icall

	return;
}
     5ca:	df 91       	pop	r29
     5cc:	cf 91       	pop	r28
     5ce:	1f 91       	pop	r17
     5d0:	0f 91       	pop	r16
     5d2:	ff 90       	pop	r15
     5d4:	ef 90       	pop	r14
     5d6:	df 90       	pop	r13
     5d8:	cf 90       	pop	r12
     5da:	08 95       	ret

000005dc <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
     5dc:	0f 93       	push	r16
     5de:	1f 93       	push	r17
     5e0:	cf 93       	push	r28
     5e2:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     5e4:	dc 01       	movw	r26, r24
     5e6:	15 96       	adiw	r26, 0x05	; 5
     5e8:	ed 91       	ld	r30, X+
     5ea:	fc 91       	ld	r31, X
     5ec:	16 97       	sbiw	r26, 0x06	; 6
     5ee:	06 81       	ldd	r16, Z+6	; 0x06
     5f0:	17 81       	ldd	r17, Z+7	; 0x07
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
     5f2:	e8 01       	movw	r28, r16
     5f4:	2c 96       	adiw	r28, 0x0c	; 12
     5f6:	ce 01       	movw	r24, r28
     5f8:	0e 94 df 03 	call	0x7be	; 0x7be <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
     5fc:	81 eb       	ldi	r24, 0xB1	; 177
     5fe:	90 e0       	ldi	r25, 0x00	; 0
     600:	be 01       	movw	r22, r28
     602:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
     606:	e0 91 8a 00 	lds	r30, 0x008A
     60a:	f0 91 8b 00 	lds	r31, 0x008B
	{
		xReturn = pdTRUE;
     60e:	81 e0       	ldi	r24, 0x01	; 1
     610:	d8 01       	movw	r26, r16
     612:	56 96       	adiw	r26, 0x16	; 22
     614:	2c 91       	ld	r18, X
     616:	56 97       	sbiw	r26, 0x16	; 22
     618:	96 89       	ldd	r25, Z+22	; 0x16
     61a:	29 17       	cp	r18, r25
     61c:	08 f4       	brcc	.+2      	; 0x620 <xCoRoutineRemoveFromEventList+0x44>
     61e:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     620:	df 91       	pop	r29
     622:	cf 91       	pop	r28
     624:	1f 91       	pop	r17
     626:	0f 91       	pop	r16
     628:	08 95       	ret

0000062a <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     62a:	cf 93       	push	r28
     62c:	df 93       	push	r29
     62e:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     630:	0e 94 6d 0a 	call	0x14da	; 0x14da <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     634:	80 91 ca 00 	lds	r24, 0x00CA
     638:	90 91 cb 00 	lds	r25, 0x00CB
     63c:	00 97       	sbiw	r24, 0x00	; 0
     63e:	31 f4       	brne	.+12     	; 0x64c <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
     640:	8d ec       	ldi	r24, 0xCD	; 205
     642:	90 e0       	ldi	r25, 0x00	; 0
     644:	90 93 cb 00 	sts	0x00CB, r25
     648:	80 93 ca 00 	sts	0x00CA, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     64c:	20 91 7c 05 	lds	r18, 0x057C
     650:	30 91 7d 05 	lds	r19, 0x057D
     654:	ce 01       	movw	r24, r28
     656:	82 0f       	add	r24, r18
     658:	93 1f       	adc	r25, r19
     65a:	44 e0       	ldi	r20, 0x04	; 4
     65c:	8f 3a       	cpi	r24, 0xAF	; 175
     65e:	94 07       	cpc	r25, r20
     660:	70 f4       	brcc	.+28     	; 0x67e <pvPortMalloc+0x54>
     662:	28 17       	cp	r18, r24
     664:	39 07       	cpc	r19, r25
     666:	70 f4       	brcc	.+28     	; 0x684 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     668:	c0 91 ca 00 	lds	r28, 0x00CA
     66c:	d0 91 cb 00 	lds	r29, 0x00CB
     670:	c2 0f       	add	r28, r18
     672:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
     674:	90 93 7d 05 	sts	0x057D, r25
     678:	80 93 7c 05 	sts	0x057C, r24
     67c:	05 c0       	rjmp	.+10     	; 0x688 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     67e:	c0 e0       	ldi	r28, 0x00	; 0
     680:	d0 e0       	ldi	r29, 0x00	; 0
     682:	02 c0       	rjmp	.+4      	; 0x688 <pvPortMalloc+0x5e>
     684:	c0 e0       	ldi	r28, 0x00	; 0
     686:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
			xNextFreeByte += xWantedSize;
		}
	}
	xTaskResumeAll();
     688:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     68c:	8c 2f       	mov	r24, r28
     68e:	9d 2f       	mov	r25, r29
     690:	df 91       	pop	r29
     692:	cf 91       	pop	r28
     694:	08 95       	ret

00000696 <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
     696:	08 95       	ret

00000698 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
     698:	10 92 7d 05 	sts	0x057D, r1
     69c:	10 92 7c 05 	sts	0x057C, r1
}
     6a0:	08 95       	ret

000006a2 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
     6a2:	20 91 7c 05 	lds	r18, 0x057C
     6a6:	30 91 7d 05 	lds	r19, 0x057D
     6aa:	8f ea       	ldi	r24, 0xAF	; 175
     6ac:	94 e0       	ldi	r25, 0x04	; 4
     6ae:	82 1b       	sub	r24, r18
     6b0:	93 0b       	sbc	r25, r19
}
     6b2:	08 95       	ret

000006b4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     6b4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     6b6:	03 96       	adiw	r24, 0x03	; 3
     6b8:	92 83       	std	Z+2, r25	; 0x02
     6ba:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     6bc:	2f ef       	ldi	r18, 0xFF	; 255
     6be:	3f ef       	ldi	r19, 0xFF	; 255
     6c0:	34 83       	std	Z+4, r19	; 0x04
     6c2:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     6c4:	96 83       	std	Z+6, r25	; 0x06
     6c6:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     6c8:	90 87       	std	Z+8, r25	; 0x08
     6ca:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     6cc:	10 82       	st	Z, r1
}
     6ce:	08 95       	ret

000006d0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     6d0:	fc 01       	movw	r30, r24
     6d2:	11 86       	std	Z+9, r1	; 0x09
     6d4:	10 86       	std	Z+8, r1	; 0x08
}
     6d6:	08 95       	ret

000006d8 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     6d8:	cf 93       	push	r28
     6da:	df 93       	push	r29
     6dc:	ec 01       	movw	r28, r24
     6de:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     6e0:	89 81       	ldd	r24, Y+1	; 0x01
     6e2:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     6e4:	dc 01       	movw	r26, r24
     6e6:	12 96       	adiw	r26, 0x02	; 2
     6e8:	2d 91       	ld	r18, X+
     6ea:	3c 91       	ld	r19, X
     6ec:	13 97       	sbiw	r26, 0x03	; 3
     6ee:	33 83       	std	Z+3, r19	; 0x03
     6f0:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
     6f2:	29 81       	ldd	r18, Y+1	; 0x01
     6f4:	3a 81       	ldd	r19, Y+2	; 0x02
     6f6:	35 83       	std	Z+5, r19	; 0x05
     6f8:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     6fa:	12 96       	adiw	r26, 0x02	; 2
     6fc:	2d 91       	ld	r18, X+
     6fe:	3c 91       	ld	r19, X
     700:	13 97       	sbiw	r26, 0x03	; 3
     702:	d9 01       	movw	r26, r18
     704:	15 96       	adiw	r26, 0x05	; 5
     706:	7c 93       	st	X, r23
     708:	6e 93       	st	-X, r22
     70a:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     70c:	dc 01       	movw	r26, r24
     70e:	13 96       	adiw	r26, 0x03	; 3
     710:	7c 93       	st	X, r23
     712:	6e 93       	st	-X, r22
     714:	12 97       	sbiw	r26, 0x02	; 2
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     716:	7a 83       	std	Y+2, r23	; 0x02
     718:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     71a:	d1 87       	std	Z+9, r29	; 0x09
     71c:	c0 87       	std	Z+8, r28	; 0x08

	( pxList->uxNumberOfItems )++;
     71e:	88 81       	ld	r24, Y
     720:	8f 5f       	subi	r24, 0xFF	; 255
     722:	88 83       	st	Y, r24
}
     724:	df 91       	pop	r29
     726:	cf 91       	pop	r28
     728:	08 95       	ret

0000072a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     72a:	cf 93       	push	r28
     72c:	df 93       	push	r29
     72e:	9c 01       	movw	r18, r24
     730:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
uint32_t xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     732:	48 81       	ld	r20, Y
     734:	59 81       	ldd	r21, Y+1	; 0x01
     736:	60 e0       	ldi	r22, 0x00	; 0
     738:	70 e0       	ldi	r23, 0x00	; 0
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     73a:	4f 3f       	cpi	r20, 0xFF	; 255
     73c:	8f ef       	ldi	r24, 0xFF	; 255
     73e:	58 07       	cpc	r21, r24
     740:	80 e0       	ldi	r24, 0x00	; 0
     742:	68 07       	cpc	r22, r24
     744:	80 e0       	ldi	r24, 0x00	; 0
     746:	78 07       	cpc	r23, r24
     748:	31 f4       	brne	.+12     	; 0x756 <vListInsert+0x2c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     74a:	d9 01       	movw	r26, r18
     74c:	17 96       	adiw	r26, 0x07	; 7
     74e:	ed 91       	ld	r30, X+
     750:	fc 91       	ld	r31, X
     752:	18 97       	sbiw	r26, 0x08	; 8
     754:	1f c0       	rjmp	.+62     	; 0x794 <vListInsert+0x6a>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     756:	f9 01       	movw	r30, r18
     758:	33 96       	adiw	r30, 0x03	; 3
     75a:	d9 01       	movw	r26, r18
     75c:	15 96       	adiw	r26, 0x05	; 5
     75e:	8d 91       	ld	r24, X+
     760:	9c 91       	ld	r25, X
     762:	16 97       	sbiw	r26, 0x06	; 6
     764:	dc 01       	movw	r26, r24
     766:	8d 91       	ld	r24, X+
     768:	9c 91       	ld	r25, X
     76a:	a0 e0       	ldi	r26, 0x00	; 0
     76c:	b0 e0       	ldi	r27, 0x00	; 0
     76e:	48 17       	cp	r20, r24
     770:	59 07       	cpc	r21, r25
     772:	6a 07       	cpc	r22, r26
     774:	7b 07       	cpc	r23, r27
     776:	70 f0       	brcs	.+28     	; 0x794 <vListInsert+0x6a>
     778:	02 80       	ldd	r0, Z+2	; 0x02
     77a:	f3 81       	ldd	r31, Z+3	; 0x03
     77c:	e0 2d       	mov	r30, r0
     77e:	a2 81       	ldd	r26, Z+2	; 0x02
     780:	b3 81       	ldd	r27, Z+3	; 0x03
     782:	8d 91       	ld	r24, X+
     784:	9c 91       	ld	r25, X
     786:	a0 e0       	ldi	r26, 0x00	; 0
     788:	b0 e0       	ldi	r27, 0x00	; 0
     78a:	48 17       	cp	r20, r24
     78c:	59 07       	cpc	r21, r25
     78e:	6a 07       	cpc	r22, r26
     790:	7b 07       	cpc	r23, r27
     792:	90 f7       	brcc	.-28     	; 0x778 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     794:	a2 81       	ldd	r26, Z+2	; 0x02
     796:	b3 81       	ldd	r27, Z+3	; 0x03
     798:	bb 83       	std	Y+3, r27	; 0x03
     79a:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     79c:	15 96       	adiw	r26, 0x05	; 5
     79e:	dc 93       	st	X, r29
     7a0:	ce 93       	st	-X, r28
     7a2:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     7a4:	fd 83       	std	Y+5, r31	; 0x05
     7a6:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     7a8:	d3 83       	std	Z+3, r29	; 0x03
     7aa:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     7ac:	39 87       	std	Y+9, r19	; 0x09
     7ae:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     7b0:	f9 01       	movw	r30, r18
     7b2:	80 81       	ld	r24, Z
     7b4:	8f 5f       	subi	r24, 0xFF	; 255
     7b6:	80 83       	st	Z, r24
}
     7b8:	df 91       	pop	r29
     7ba:	cf 91       	pop	r28
     7bc:	08 95       	ret

000007be <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
     7be:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     7c0:	a2 81       	ldd	r26, Z+2	; 0x02
     7c2:	b3 81       	ldd	r27, Z+3	; 0x03
     7c4:	84 81       	ldd	r24, Z+4	; 0x04
     7c6:	95 81       	ldd	r25, Z+5	; 0x05
     7c8:	15 96       	adiw	r26, 0x05	; 5
     7ca:	9c 93       	st	X, r25
     7cc:	8e 93       	st	-X, r24
     7ce:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     7d0:	a4 81       	ldd	r26, Z+4	; 0x04
     7d2:	b5 81       	ldd	r27, Z+5	; 0x05
     7d4:	82 81       	ldd	r24, Z+2	; 0x02
     7d6:	93 81       	ldd	r25, Z+3	; 0x03
     7d8:	13 96       	adiw	r26, 0x03	; 3
     7da:	9c 93       	st	X, r25
     7dc:	8e 93       	st	-X, r24
     7de:	12 97       	sbiw	r26, 0x02	; 2

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     7e0:	a0 85       	ldd	r26, Z+8	; 0x08
     7e2:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     7e4:	11 96       	adiw	r26, 0x01	; 1
     7e6:	8d 91       	ld	r24, X+
     7e8:	9c 91       	ld	r25, X
     7ea:	12 97       	sbiw	r26, 0x02	; 2
     7ec:	8e 17       	cp	r24, r30
     7ee:	9f 07       	cpc	r25, r31
     7f0:	31 f4       	brne	.+12     	; 0x7fe <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     7f2:	84 81       	ldd	r24, Z+4	; 0x04
     7f4:	95 81       	ldd	r25, Z+5	; 0x05
     7f6:	12 96       	adiw	r26, 0x02	; 2
     7f8:	9c 93       	st	X, r25
     7fa:	8e 93       	st	-X, r24
     7fc:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     7fe:	11 86       	std	Z+9, r1	; 0x09
     800:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     802:	8c 91       	ld	r24, X
     804:	81 50       	subi	r24, 0x01	; 1
     806:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
     808:	8c 91       	ld	r24, X
}
     80a:	08 95       	ret

0000080c <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     80c:	21 e1       	ldi	r18, 0x11	; 17
     80e:	fc 01       	movw	r30, r24
     810:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     812:	31 97       	sbiw	r30, 0x01	; 1
     814:	32 e2       	ldi	r19, 0x22	; 34
     816:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     818:	fc 01       	movw	r30, r24
     81a:	32 97       	sbiw	r30, 0x02	; 2
     81c:	a3 e3       	ldi	r26, 0x33	; 51
     81e:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     820:	fc 01       	movw	r30, r24
     822:	33 97       	sbiw	r30, 0x03	; 3
     824:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     826:	fc 01       	movw	r30, r24
     828:	34 97       	sbiw	r30, 0x04	; 4
     82a:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
     82c:	fc 01       	movw	r30, r24
     82e:	35 97       	sbiw	r30, 0x05	; 5
     830:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     832:	fc 01       	movw	r30, r24
     834:	36 97       	sbiw	r30, 0x06	; 6
     836:	60 e8       	ldi	r22, 0x80	; 128
     838:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
     83a:	fc 01       	movw	r30, r24
     83c:	37 97       	sbiw	r30, 0x07	; 7
     83e:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
     840:	fc 01       	movw	r30, r24
     842:	38 97       	sbiw	r30, 0x08	; 8
     844:	62 e0       	ldi	r22, 0x02	; 2
     846:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
     848:	fc 01       	movw	r30, r24
     84a:	39 97       	sbiw	r30, 0x09	; 9
     84c:	63 e0       	ldi	r22, 0x03	; 3
     84e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
     850:	fc 01       	movw	r30, r24
     852:	3a 97       	sbiw	r30, 0x0a	; 10
     854:	64 e0       	ldi	r22, 0x04	; 4
     856:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
     858:	fc 01       	movw	r30, r24
     85a:	3b 97       	sbiw	r30, 0x0b	; 11
     85c:	65 e0       	ldi	r22, 0x05	; 5
     85e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
     860:	fc 01       	movw	r30, r24
     862:	3c 97       	sbiw	r30, 0x0c	; 12
     864:	66 e0       	ldi	r22, 0x06	; 6
     866:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
     868:	fc 01       	movw	r30, r24
     86a:	3d 97       	sbiw	r30, 0x0d	; 13
     86c:	67 e0       	ldi	r22, 0x07	; 7
     86e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
     870:	fc 01       	movw	r30, r24
     872:	3e 97       	sbiw	r30, 0x0e	; 14
     874:	68 e0       	ldi	r22, 0x08	; 8
     876:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
     878:	fc 01       	movw	r30, r24
     87a:	3f 97       	sbiw	r30, 0x0f	; 15
     87c:	69 e0       	ldi	r22, 0x09	; 9
     87e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
     880:	fc 01       	movw	r30, r24
     882:	70 97       	sbiw	r30, 0x10	; 16
     884:	60 e1       	ldi	r22, 0x10	; 16
     886:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
     888:	fc 01       	movw	r30, r24
     88a:	71 97       	sbiw	r30, 0x11	; 17
     88c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
     88e:	fc 01       	movw	r30, r24
     890:	72 97       	sbiw	r30, 0x12	; 18
     892:	22 e1       	ldi	r18, 0x12	; 18
     894:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
     896:	fc 01       	movw	r30, r24
     898:	73 97       	sbiw	r30, 0x13	; 19
     89a:	23 e1       	ldi	r18, 0x13	; 19
     89c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
     89e:	fc 01       	movw	r30, r24
     8a0:	74 97       	sbiw	r30, 0x14	; 20
     8a2:	24 e1       	ldi	r18, 0x14	; 20
     8a4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
     8a6:	fc 01       	movw	r30, r24
     8a8:	75 97       	sbiw	r30, 0x15	; 21
     8aa:	25 e1       	ldi	r18, 0x15	; 21
     8ac:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
     8ae:	fc 01       	movw	r30, r24
     8b0:	76 97       	sbiw	r30, 0x16	; 22
     8b2:	26 e1       	ldi	r18, 0x16	; 22
     8b4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
     8b6:	fc 01       	movw	r30, r24
     8b8:	77 97       	sbiw	r30, 0x17	; 23
     8ba:	27 e1       	ldi	r18, 0x17	; 23
     8bc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
     8be:	fc 01       	movw	r30, r24
     8c0:	78 97       	sbiw	r30, 0x18	; 24
     8c2:	28 e1       	ldi	r18, 0x18	; 24
     8c4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
     8c6:	fc 01       	movw	r30, r24
     8c8:	79 97       	sbiw	r30, 0x19	; 25
     8ca:	29 e1       	ldi	r18, 0x19	; 25
     8cc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
     8ce:	fc 01       	movw	r30, r24
     8d0:	7a 97       	sbiw	r30, 0x1a	; 26
     8d2:	20 e2       	ldi	r18, 0x20	; 32
     8d4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
     8d6:	fc 01       	movw	r30, r24
     8d8:	7b 97       	sbiw	r30, 0x1b	; 27
     8da:	21 e2       	ldi	r18, 0x21	; 33
     8dc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
     8de:	fc 01       	movw	r30, r24
     8e0:	7c 97       	sbiw	r30, 0x1c	; 28
     8e2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
     8e4:	fc 01       	movw	r30, r24
     8e6:	7d 97       	sbiw	r30, 0x1d	; 29
     8e8:	23 e2       	ldi	r18, 0x23	; 35
     8ea:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     8ec:	fc 01       	movw	r30, r24
     8ee:	7e 97       	sbiw	r30, 0x1e	; 30
     8f0:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
     8f2:	fc 01       	movw	r30, r24
     8f4:	7f 97       	sbiw	r30, 0x1f	; 31
     8f6:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
     8f8:	fc 01       	movw	r30, r24
     8fa:	b0 97       	sbiw	r30, 0x20	; 32
     8fc:	26 e2       	ldi	r18, 0x26	; 38
     8fe:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
     900:	fc 01       	movw	r30, r24
     902:	b1 97       	sbiw	r30, 0x21	; 33
     904:	27 e2       	ldi	r18, 0x27	; 39
     906:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
     908:	fc 01       	movw	r30, r24
     90a:	b2 97       	sbiw	r30, 0x22	; 34
     90c:	28 e2       	ldi	r18, 0x28	; 40
     90e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
     910:	fc 01       	movw	r30, r24
     912:	b3 97       	sbiw	r30, 0x23	; 35
     914:	29 e2       	ldi	r18, 0x29	; 41
     916:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
     918:	fc 01       	movw	r30, r24
     91a:	b4 97       	sbiw	r30, 0x24	; 36
     91c:	20 e3       	ldi	r18, 0x30	; 48
     91e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
     920:	fc 01       	movw	r30, r24
     922:	b5 97       	sbiw	r30, 0x25	; 37
     924:	21 e3       	ldi	r18, 0x31	; 49
     926:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
     928:	86 97       	sbiw	r24, 0x26	; 38
}
     92a:	08 95       	ret

0000092c <xPortStartScheduler>:
	//ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	//ulCompareMatch >>= 8;
	//ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	//OCR1AH = ucHighByte;
	//OCR1AL = ucLowByte;
    OCR0 = ulCompareMatch; 
     92c:	8a ef       	ldi	r24, 0xFA	; 250
     92e:	8c bf       	out	0x3c, r24	; 60
	/* Setup clock source and compare match behaviour. */
	//MOD: atmega32A
	//ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	//TCCR1B = ucLowByte;
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR0 = ucLowByte;
     930:	8b e0       	ldi	r24, 0x0B	; 11
     932:	83 bf       	out	0x33, r24	; 51
	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	//MOD: atmega32A
	//ucLowByte = TIMSK;
	//-> enable Timer1 Output Compare A
	ucLowByte = TIMSK;
     934:	89 b7       	in	r24, 0x39	; 57
	
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     936:	82 60       	ori	r24, 0x02	; 2
	
	//MOD: atmega1284p
	//TIMSK = ucLowByte;
	TIMSK = ucLowByte;
     938:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     93a:	a0 91 7e 05 	lds	r26, 0x057E
     93e:	b0 91 7f 05 	lds	r27, 0x057F
     942:	cd 91       	ld	r28, X+
     944:	cd bf       	out	0x3d, r28	; 61
     946:	dd 91       	ld	r29, X+
     948:	de bf       	out	0x3e, r29	; 62
     94a:	ff 91       	pop	r31
     94c:	ef 91       	pop	r30
     94e:	df 91       	pop	r29
     950:	cf 91       	pop	r28
     952:	bf 91       	pop	r27
     954:	af 91       	pop	r26
     956:	9f 91       	pop	r25
     958:	8f 91       	pop	r24
     95a:	7f 91       	pop	r23
     95c:	6f 91       	pop	r22
     95e:	5f 91       	pop	r21
     960:	4f 91       	pop	r20
     962:	3f 91       	pop	r19
     964:	2f 91       	pop	r18
     966:	1f 91       	pop	r17
     968:	0f 91       	pop	r16
     96a:	ff 90       	pop	r15
     96c:	ef 90       	pop	r14
     96e:	df 90       	pop	r13
     970:	cf 90       	pop	r12
     972:	bf 90       	pop	r11
     974:	af 90       	pop	r10
     976:	9f 90       	pop	r9
     978:	8f 90       	pop	r8
     97a:	7f 90       	pop	r7
     97c:	6f 90       	pop	r6
     97e:	5f 90       	pop	r5
     980:	4f 90       	pop	r4
     982:	3f 90       	pop	r3
     984:	2f 90       	pop	r2
     986:	1f 90       	pop	r1
     988:	0f 90       	pop	r0
     98a:	0f be       	out	0x3f, r0	; 63
     98c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     98e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     990:	81 e0       	ldi	r24, 0x01	; 1
     992:	08 95       	ret

00000994 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
     994:	08 95       	ret

00000996 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     996:	0f 92       	push	r0
     998:	0f b6       	in	r0, 0x3f	; 63
     99a:	f8 94       	cli
     99c:	0f 92       	push	r0
     99e:	1f 92       	push	r1
     9a0:	11 24       	eor	r1, r1
     9a2:	2f 92       	push	r2
     9a4:	3f 92       	push	r3
     9a6:	4f 92       	push	r4
     9a8:	5f 92       	push	r5
     9aa:	6f 92       	push	r6
     9ac:	7f 92       	push	r7
     9ae:	8f 92       	push	r8
     9b0:	9f 92       	push	r9
     9b2:	af 92       	push	r10
     9b4:	bf 92       	push	r11
     9b6:	cf 92       	push	r12
     9b8:	df 92       	push	r13
     9ba:	ef 92       	push	r14
     9bc:	ff 92       	push	r15
     9be:	0f 93       	push	r16
     9c0:	1f 93       	push	r17
     9c2:	2f 93       	push	r18
     9c4:	3f 93       	push	r19
     9c6:	4f 93       	push	r20
     9c8:	5f 93       	push	r21
     9ca:	6f 93       	push	r22
     9cc:	7f 93       	push	r23
     9ce:	8f 93       	push	r24
     9d0:	9f 93       	push	r25
     9d2:	af 93       	push	r26
     9d4:	bf 93       	push	r27
     9d6:	cf 93       	push	r28
     9d8:	df 93       	push	r29
     9da:	ef 93       	push	r30
     9dc:	ff 93       	push	r31
     9de:	a0 91 7e 05 	lds	r26, 0x057E
     9e2:	b0 91 7f 05 	lds	r27, 0x057F
     9e6:	0d b6       	in	r0, 0x3d	; 61
     9e8:	0d 92       	st	X+, r0
     9ea:	0e b6       	in	r0, 0x3e	; 62
     9ec:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     9ee:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     9f2:	a0 91 7e 05 	lds	r26, 0x057E
     9f6:	b0 91 7f 05 	lds	r27, 0x057F
     9fa:	cd 91       	ld	r28, X+
     9fc:	cd bf       	out	0x3d, r28	; 61
     9fe:	dd 91       	ld	r29, X+
     a00:	de bf       	out	0x3e, r29	; 62
     a02:	ff 91       	pop	r31
     a04:	ef 91       	pop	r30
     a06:	df 91       	pop	r29
     a08:	cf 91       	pop	r28
     a0a:	bf 91       	pop	r27
     a0c:	af 91       	pop	r26
     a0e:	9f 91       	pop	r25
     a10:	8f 91       	pop	r24
     a12:	7f 91       	pop	r23
     a14:	6f 91       	pop	r22
     a16:	5f 91       	pop	r21
     a18:	4f 91       	pop	r20
     a1a:	3f 91       	pop	r19
     a1c:	2f 91       	pop	r18
     a1e:	1f 91       	pop	r17
     a20:	0f 91       	pop	r16
     a22:	ff 90       	pop	r15
     a24:	ef 90       	pop	r14
     a26:	df 90       	pop	r13
     a28:	cf 90       	pop	r12
     a2a:	bf 90       	pop	r11
     a2c:	af 90       	pop	r10
     a2e:	9f 90       	pop	r9
     a30:	8f 90       	pop	r8
     a32:	7f 90       	pop	r7
     a34:	6f 90       	pop	r6
     a36:	5f 90       	pop	r5
     a38:	4f 90       	pop	r4
     a3a:	3f 90       	pop	r3
     a3c:	2f 90       	pop	r2
     a3e:	1f 90       	pop	r1
     a40:	0f 90       	pop	r0
     a42:	0f be       	out	0x3f, r0	; 63
     a44:	0f 90       	pop	r0

	asm volatile ( "ret" );
     a46:	08 95       	ret

00000a48 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     a48:	0f 92       	push	r0
     a4a:	0f b6       	in	r0, 0x3f	; 63
     a4c:	f8 94       	cli
     a4e:	0f 92       	push	r0
     a50:	1f 92       	push	r1
     a52:	11 24       	eor	r1, r1
     a54:	2f 92       	push	r2
     a56:	3f 92       	push	r3
     a58:	4f 92       	push	r4
     a5a:	5f 92       	push	r5
     a5c:	6f 92       	push	r6
     a5e:	7f 92       	push	r7
     a60:	8f 92       	push	r8
     a62:	9f 92       	push	r9
     a64:	af 92       	push	r10
     a66:	bf 92       	push	r11
     a68:	cf 92       	push	r12
     a6a:	df 92       	push	r13
     a6c:	ef 92       	push	r14
     a6e:	ff 92       	push	r15
     a70:	0f 93       	push	r16
     a72:	1f 93       	push	r17
     a74:	2f 93       	push	r18
     a76:	3f 93       	push	r19
     a78:	4f 93       	push	r20
     a7a:	5f 93       	push	r21
     a7c:	6f 93       	push	r22
     a7e:	7f 93       	push	r23
     a80:	8f 93       	push	r24
     a82:	9f 93       	push	r25
     a84:	af 93       	push	r26
     a86:	bf 93       	push	r27
     a88:	cf 93       	push	r28
     a8a:	df 93       	push	r29
     a8c:	ef 93       	push	r30
     a8e:	ff 93       	push	r31
     a90:	a0 91 7e 05 	lds	r26, 0x057E
     a94:	b0 91 7f 05 	lds	r27, 0x057F
     a98:	0d b6       	in	r0, 0x3d	; 61
     a9a:	0d 92       	st	X+, r0
     a9c:	0e b6       	in	r0, 0x3e	; 62
     a9e:	0d 92       	st	X+, r0
	vTaskIncrementTick();
     aa0:	0e 94 85 0a 	call	0x150a	; 0x150a <vTaskIncrementTick>
	vTaskSwitchContext();
     aa4:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     aa8:	a0 91 7e 05 	lds	r26, 0x057E
     aac:	b0 91 7f 05 	lds	r27, 0x057F
     ab0:	cd 91       	ld	r28, X+
     ab2:	cd bf       	out	0x3d, r28	; 61
     ab4:	dd 91       	ld	r29, X+
     ab6:	de bf       	out	0x3e, r29	; 62
     ab8:	ff 91       	pop	r31
     aba:	ef 91       	pop	r30
     abc:	df 91       	pop	r29
     abe:	cf 91       	pop	r28
     ac0:	bf 91       	pop	r27
     ac2:	af 91       	pop	r26
     ac4:	9f 91       	pop	r25
     ac6:	8f 91       	pop	r24
     ac8:	7f 91       	pop	r23
     aca:	6f 91       	pop	r22
     acc:	5f 91       	pop	r21
     ace:	4f 91       	pop	r20
     ad0:	3f 91       	pop	r19
     ad2:	2f 91       	pop	r18
     ad4:	1f 91       	pop	r17
     ad6:	0f 91       	pop	r16
     ad8:	ff 90       	pop	r15
     ada:	ef 90       	pop	r14
     adc:	df 90       	pop	r13
     ade:	cf 90       	pop	r12
     ae0:	bf 90       	pop	r11
     ae2:	af 90       	pop	r10
     ae4:	9f 90       	pop	r9
     ae6:	8f 90       	pop	r8
     ae8:	7f 90       	pop	r7
     aea:	6f 90       	pop	r6
     aec:	5f 90       	pop	r5
     aee:	4f 90       	pop	r4
     af0:	3f 90       	pop	r3
     af2:	2f 90       	pop	r2
     af4:	1f 90       	pop	r1
     af6:	0f 90       	pop	r0
     af8:	0f be       	out	0x3f, r0	; 63
     afa:	0f 90       	pop	r0

	asm volatile ( "ret" );
     afc:	08 95       	ret

00000afe <__vector_7>:
	 */
	ISR (TIMER1_COMPA_vect) __attribute__ ( ( signal, naked ) );
	ISR (TIMER1_COMPA_vect)
	{
        //PORTB ^= (1<<PB0);
		vPortYieldFromTick();
     afe:	0e 94 24 05 	call	0xa48	; 0xa48 <vPortYieldFromTick>
		asm volatile ( "reti" );
     b02:	18 95       	reti

00000b04 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
     b04:	cf 93       	push	r28
     b06:	df 93       	push	r29
     b08:	dc 01       	movw	r26, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
     b0a:	cd 91       	ld	r28, X+
     b0c:	dc 91       	ld	r29, X
     b0e:	11 97       	sbiw	r26, 0x01	; 1
     b10:	20 97       	sbiw	r28, 0x00	; 0
     b12:	21 f1       	breq	.+72     	; 0xb5c <prvCopyDataFromQueue+0x58>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
     b14:	5c 96       	adiw	r26, 0x1c	; 28
     b16:	4c 91       	ld	r20, X
     b18:	5c 97       	sbiw	r26, 0x1c	; 28
     b1a:	16 96       	adiw	r26, 0x06	; 6
     b1c:	2d 91       	ld	r18, X+
     b1e:	3c 91       	ld	r19, X
     b20:	17 97       	sbiw	r26, 0x07	; 7
     b22:	24 0f       	add	r18, r20
     b24:	31 1d       	adc	r19, r1
     b26:	17 96       	adiw	r26, 0x07	; 7
     b28:	3c 93       	st	X, r19
     b2a:	2e 93       	st	-X, r18
     b2c:	16 97       	sbiw	r26, 0x06	; 6
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
     b2e:	12 96       	adiw	r26, 0x02	; 2
     b30:	ed 91       	ld	r30, X+
     b32:	fc 91       	ld	r31, X
     b34:	13 97       	sbiw	r26, 0x03	; 3
     b36:	2e 17       	cp	r18, r30
     b38:	3f 07       	cpc	r19, r31
     b3a:	20 f0       	brcs	.+8      	; 0xb44 <prvCopyDataFromQueue+0x40>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
     b3c:	17 96       	adiw	r26, 0x07	; 7
     b3e:	dc 93       	st	X, r29
     b40:	ce 93       	st	-X, r28
     b42:	16 97       	sbiw	r26, 0x06	; 6
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
     b44:	16 96       	adiw	r26, 0x06	; 6
     b46:	3c 91       	ld	r19, X
     b48:	16 97       	sbiw	r26, 0x06	; 6
     b4a:	17 96       	adiw	r26, 0x07	; 7
     b4c:	2c 91       	ld	r18, X
     b4e:	86 2f       	mov	r24, r22
     b50:	97 2f       	mov	r25, r23
     b52:	63 2f       	mov	r22, r19
     b54:	72 2f       	mov	r23, r18
     b56:	50 e0       	ldi	r21, 0x00	; 0
     b58:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <memcpy>
	}
}
     b5c:	df 91       	pop	r29
     b5e:	cf 91       	pop	r28
     b60:	08 95       	ret

00000b62 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
     b62:	cf 93       	push	r28
     b64:	df 93       	push	r29
     b66:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
     b68:	2c 8d       	ldd	r18, Y+28	; 0x1c
     b6a:	22 23       	and	r18, r18
     b6c:	a9 f1       	breq	.+106    	; 0xbd8 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
     b6e:	44 23       	and	r20, r20
     b70:	b9 f4       	brne	.+46     	; 0xba0 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     b72:	8c 81       	ldd	r24, Y+4	; 0x04
     b74:	9d 81       	ldd	r25, Y+5	; 0x05
     b76:	42 2f       	mov	r20, r18
     b78:	50 e0       	ldi	r21, 0x00	; 0
     b7a:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     b7e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     b80:	8c 81       	ldd	r24, Y+4	; 0x04
     b82:	9d 81       	ldd	r25, Y+5	; 0x05
     b84:	82 0f       	add	r24, r18
     b86:	91 1d       	adc	r25, r1
     b88:	9d 83       	std	Y+5, r25	; 0x05
     b8a:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
     b8c:	2a 81       	ldd	r18, Y+2	; 0x02
     b8e:	3b 81       	ldd	r19, Y+3	; 0x03
     b90:	82 17       	cp	r24, r18
     b92:	93 07       	cpc	r25, r19
     b94:	08 f1       	brcs	.+66     	; 0xbd8 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     b96:	88 81       	ld	r24, Y
     b98:	99 81       	ldd	r25, Y+1	; 0x01
     b9a:	9d 83       	std	Y+5, r25	; 0x05
     b9c:	8c 83       	std	Y+4, r24	; 0x04
     b9e:	1c c0       	rjmp	.+56     	; 0xbd8 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
     ba0:	8e 81       	ldd	r24, Y+6	; 0x06
     ba2:	9f 81       	ldd	r25, Y+7	; 0x07
     ba4:	42 2f       	mov	r20, r18
     ba6:	50 e0       	ldi	r21, 0x00	; 0
     ba8:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
     bac:	4c 8d       	ldd	r20, Y+28	; 0x1c
     bae:	50 e0       	ldi	r21, 0x00	; 0
     bb0:	50 95       	com	r21
     bb2:	41 95       	neg	r20
     bb4:	5f 4f       	sbci	r21, 0xFF	; 255
     bb6:	8e 81       	ldd	r24, Y+6	; 0x06
     bb8:	9f 81       	ldd	r25, Y+7	; 0x07
     bba:	84 0f       	add	r24, r20
     bbc:	95 1f       	adc	r25, r21
     bbe:	9f 83       	std	Y+7, r25	; 0x07
     bc0:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
     bc2:	28 81       	ld	r18, Y
     bc4:	39 81       	ldd	r19, Y+1	; 0x01
     bc6:	82 17       	cp	r24, r18
     bc8:	93 07       	cpc	r25, r19
     bca:	30 f4       	brcc	.+12     	; 0xbd8 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     bcc:	8a 81       	ldd	r24, Y+2	; 0x02
     bce:	9b 81       	ldd	r25, Y+3	; 0x03
     bd0:	48 0f       	add	r20, r24
     bd2:	59 1f       	adc	r21, r25
     bd4:	5f 83       	std	Y+7, r21	; 0x07
     bd6:	4e 83       	std	Y+6, r20	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
     bd8:	8a 8d       	ldd	r24, Y+26	; 0x1a
     bda:	8f 5f       	subi	r24, 0xFF	; 255
     bdc:	8a 8f       	std	Y+26, r24	; 0x1a
}
     bde:	df 91       	pop	r29
     be0:	cf 91       	pop	r28
     be2:	08 95       	ret

00000be4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQUEUE *pxQueue )
{
     be4:	0f 93       	push	r16
     be6:	1f 93       	push	r17
     be8:	cf 93       	push	r28
     bea:	df 93       	push	r29
     bec:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     bee:	0f b6       	in	r0, 0x3f	; 63
     bf0:	f8 94       	cli
     bf2:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     bf4:	8e 8d       	ldd	r24, Y+30	; 0x1e
     bf6:	18 16       	cp	r1, r24
     bf8:	c4 f4       	brge	.+48     	; 0xc2a <prvUnlockQueue+0x46>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     bfa:	89 89       	ldd	r24, Y+17	; 0x11
     bfc:	88 23       	and	r24, r24
     bfe:	29 f4       	brne	.+10     	; 0xc0a <prvUnlockQueue+0x26>
     c00:	14 c0       	rjmp	.+40     	; 0xc2a <prvUnlockQueue+0x46>
     c02:	89 89       	ldd	r24, Y+17	; 0x11
     c04:	88 23       	and	r24, r24
     c06:	21 f4       	brne	.+8      	; 0xc10 <prvUnlockQueue+0x2c>
     c08:	10 c0       	rjmp	.+32     	; 0xc2a <prvUnlockQueue+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c0a:	8e 01       	movw	r16, r28
     c0c:	0f 5e       	subi	r16, 0xEF	; 239
     c0e:	1f 4f       	sbci	r17, 0xFF	; 255
     c10:	c8 01       	movw	r24, r16
     c12:	0e 94 14 0d 	call	0x1a28	; 0x1a28 <xTaskRemoveFromEventList>
     c16:	88 23       	and	r24, r24
     c18:	11 f0       	breq	.+4      	; 0xc1e <prvUnlockQueue+0x3a>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
     c1a:	0e 94 a1 0d 	call	0x1b42	; 0x1b42 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
     c1e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     c20:	81 50       	subi	r24, 0x01	; 1
     c22:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     c24:	8e 8d       	ldd	r24, Y+30	; 0x1e
     c26:	18 16       	cp	r1, r24
     c28:	64 f3       	brlt	.-40     	; 0xc02 <prvUnlockQueue+0x1e>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
     c2a:	8f ef       	ldi	r24, 0xFF	; 255
     c2c:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     c2e:	0f 90       	pop	r0
     c30:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     c32:	0f b6       	in	r0, 0x3f	; 63
     c34:	f8 94       	cli
     c36:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     c38:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c3a:	18 16       	cp	r1, r24
     c3c:	c4 f4       	brge	.+48     	; 0xc6e <prvUnlockQueue+0x8a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     c3e:	88 85       	ldd	r24, Y+8	; 0x08
     c40:	88 23       	and	r24, r24
     c42:	29 f4       	brne	.+10     	; 0xc4e <prvUnlockQueue+0x6a>
     c44:	14 c0       	rjmp	.+40     	; 0xc6e <prvUnlockQueue+0x8a>
     c46:	88 85       	ldd	r24, Y+8	; 0x08
     c48:	88 23       	and	r24, r24
     c4a:	21 f4       	brne	.+8      	; 0xc54 <prvUnlockQueue+0x70>
     c4c:	10 c0       	rjmp	.+32     	; 0xc6e <prvUnlockQueue+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     c4e:	8e 01       	movw	r16, r28
     c50:	08 5f       	subi	r16, 0xF8	; 248
     c52:	1f 4f       	sbci	r17, 0xFF	; 255
     c54:	c8 01       	movw	r24, r16
     c56:	0e 94 14 0d 	call	0x1a28	; 0x1a28 <xTaskRemoveFromEventList>
     c5a:	88 23       	and	r24, r24
     c5c:	11 f0       	breq	.+4      	; 0xc62 <prvUnlockQueue+0x7e>
				{
					vTaskMissedYield();
     c5e:	0e 94 a1 0d 	call	0x1b42	; 0x1b42 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
     c62:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c64:	81 50       	subi	r24, 0x01	; 1
     c66:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     c68:	8d 8d       	ldd	r24, Y+29	; 0x1d
     c6a:	18 16       	cp	r1, r24
     c6c:	64 f3       	brlt	.-40     	; 0xc46 <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     c6e:	8f ef       	ldi	r24, 0xFF	; 255
     c70:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     c72:	0f 90       	pop	r0
     c74:	0f be       	out	0x3f, r0	; 63
}
     c76:	df 91       	pop	r29
     c78:	cf 91       	pop	r28
     c7a:	1f 91       	pop	r17
     c7c:	0f 91       	pop	r16
     c7e:	08 95       	ret

00000c80 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
     c80:	cf 93       	push	r28
     c82:	df 93       	push	r29
     c84:	ec 01       	movw	r28, r24
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     c86:	0f b6       	in	r0, 0x3f	; 63
     c88:	f8 94       	cli
     c8a:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     c8c:	48 81       	ld	r20, Y
     c8e:	59 81       	ldd	r21, Y+1	; 0x01
     c90:	2b 8d       	ldd	r18, Y+27	; 0x1b
     c92:	30 e0       	ldi	r19, 0x00	; 0
     c94:	ec 8d       	ldd	r30, Y+28	; 0x1c
     c96:	f0 e0       	ldi	r31, 0x00	; 0
     c98:	2e 9f       	mul	r18, r30
     c9a:	c0 01       	movw	r24, r0
     c9c:	2f 9f       	mul	r18, r31
     c9e:	90 0d       	add	r25, r0
     ca0:	3e 9f       	mul	r19, r30
     ca2:	90 0d       	add	r25, r0
     ca4:	11 24       	eor	r1, r1
     ca6:	84 0f       	add	r24, r20
     ca8:	95 1f       	adc	r25, r21
     caa:	9b 83       	std	Y+3, r25	; 0x03
     cac:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
     cae:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     cb0:	5d 83       	std	Y+5, r21	; 0x05
     cb2:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
     cb4:	c9 01       	movw	r24, r18
     cb6:	01 97       	sbiw	r24, 0x01	; 1
     cb8:	e8 9f       	mul	r30, r24
     cba:	90 01       	movw	r18, r0
     cbc:	e9 9f       	mul	r30, r25
     cbe:	30 0d       	add	r19, r0
     cc0:	f8 9f       	mul	r31, r24
     cc2:	30 0d       	add	r19, r0
     cc4:	11 24       	eor	r1, r1
     cc6:	24 0f       	add	r18, r20
     cc8:	35 1f       	adc	r19, r21
     cca:	3f 83       	std	Y+7, r19	; 0x07
     ccc:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     cce:	8f ef       	ldi	r24, 0xFF	; 255
     cd0:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     cd2:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     cd4:	66 23       	and	r22, r22
     cd6:	61 f4       	brne	.+24     	; 0xcf0 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     cd8:	88 85       	ldd	r24, Y+8	; 0x08
     cda:	88 23       	and	r24, r24
     cdc:	89 f0       	breq	.+34     	; 0xd00 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     cde:	ce 01       	movw	r24, r28
     ce0:	08 96       	adiw	r24, 0x08	; 8
     ce2:	0e 94 14 0d 	call	0x1a28	; 0x1a28 <xTaskRemoveFromEventList>
     ce6:	81 30       	cpi	r24, 0x01	; 1
     ce8:	59 f4       	brne	.+22     	; 0xd00 <xQueueGenericReset+0x80>
				{
					portYIELD_WITHIN_API();
     cea:	0e 94 cb 04 	call	0x996	; 0x996 <vPortYield>
     cee:	08 c0       	rjmp	.+16     	; 0xd00 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     cf0:	ce 01       	movw	r24, r28
     cf2:	08 96       	adiw	r24, 0x08	; 8
     cf4:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     cf8:	ce 01       	movw	r24, r28
     cfa:	41 96       	adiw	r24, 0x11	; 17
     cfc:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     d00:	0f 90       	pop	r0
     d02:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     d04:	81 e0       	ldi	r24, 0x01	; 1
     d06:	df 91       	pop	r29
     d08:	cf 91       	pop	r28
     d0a:	08 95       	ret

00000d0c <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
     d0c:	0f 93       	push	r16
     d0e:	1f 93       	push	r17
     d10:	cf 93       	push	r28
     d12:	df 93       	push	r29
     d14:	18 2f       	mov	r17, r24
     d16:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
     d18:	88 23       	and	r24, r24
     d1a:	f9 f0       	breq	.+62     	; 0xd5a <xQueueGenericCreate+0x4e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
     d1c:	8f e1       	ldi	r24, 0x1F	; 31
     d1e:	90 e0       	ldi	r25, 0x00	; 0
     d20:	0e 94 15 03 	call	0x62a	; 0x62a <pvPortMalloc>
     d24:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
     d26:	00 97       	sbiw	r24, 0x00	; 0
     d28:	d9 f0       	breq	.+54     	; 0xd60 <xQueueGenericCreate+0x54>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
     d2a:	01 9f       	mul	r16, r17
     d2c:	c0 01       	movw	r24, r0
     d2e:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
     d30:	01 96       	adiw	r24, 0x01	; 1
     d32:	0e 94 15 03 	call	0x62a	; 0x62a <pvPortMalloc>
     d36:	99 83       	std	Y+1, r25	; 0x01
     d38:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
     d3a:	00 97       	sbiw	r24, 0x00	; 0
     d3c:	41 f0       	breq	.+16     	; 0xd4e <xQueueGenericCreate+0x42>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
     d3e:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
     d40:	0c 8f       	std	Y+28, r16	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
     d42:	ce 01       	movw	r24, r28
     d44:	61 e0       	ldi	r22, 0x01	; 1
     d46:	0e 94 40 06 	call	0xc80	; 0xc80 <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
     d4a:	ce 01       	movw	r24, r28
     d4c:	0b c0       	rjmp	.+22     	; 0xd64 <xQueueGenericCreate+0x58>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
     d4e:	ce 01       	movw	r24, r28
     d50:	0e 94 4b 03 	call	0x696	; 0x696 <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
     d54:	80 e0       	ldi	r24, 0x00	; 0
     d56:	90 e0       	ldi	r25, 0x00	; 0
     d58:	05 c0       	rjmp	.+10     	; 0xd64 <xQueueGenericCreate+0x58>
     d5a:	80 e0       	ldi	r24, 0x00	; 0
     d5c:	90 e0       	ldi	r25, 0x00	; 0
     d5e:	02 c0       	rjmp	.+4      	; 0xd64 <xQueueGenericCreate+0x58>
     d60:	80 e0       	ldi	r24, 0x00	; 0
     d62:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
     d64:	df 91       	pop	r29
     d66:	cf 91       	pop	r28
     d68:	1f 91       	pop	r17
     d6a:	0f 91       	pop	r16
     d6c:	08 95       	ret

00000d6e <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, uint32_t xTicksToWait, portBASE_TYPE xCopyPosition )
{
     d6e:	8f 92       	push	r8
     d70:	9f 92       	push	r9
     d72:	bf 92       	push	r11
     d74:	cf 92       	push	r12
     d76:	df 92       	push	r13
     d78:	ef 92       	push	r14
     d7a:	ff 92       	push	r15
     d7c:	0f 93       	push	r16
     d7e:	1f 93       	push	r17
     d80:	cf 93       	push	r28
     d82:	df 93       	push	r29
     d84:	cd b7       	in	r28, 0x3d	; 61
     d86:	de b7       	in	r29, 0x3e	; 62
     d88:	29 97       	sbiw	r28, 0x09	; 9
     d8a:	0f b6       	in	r0, 0x3f	; 63
     d8c:	f8 94       	cli
     d8e:	de bf       	out	0x3e, r29	; 62
     d90:	0f be       	out	0x3f, r0	; 63
     d92:	cd bf       	out	0x3d, r28	; 61
     d94:	7c 01       	movw	r14, r24
     d96:	4b 01       	movw	r8, r22
     d98:	2e 83       	std	Y+6, r18	; 0x06
     d9a:	3f 83       	std	Y+7, r19	; 0x07
     d9c:	48 87       	std	Y+8, r20	; 0x08
     d9e:	59 87       	std	Y+9, r21	; 0x09
     da0:	b0 2e       	mov	r11, r16
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     da2:	10 e0       	ldi	r17, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     da4:	01 e0       	ldi	r16, 0x01	; 1
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     da6:	cc 24       	eor	r12, r12
     da8:	dd 24       	eor	r13, r13
     daa:	68 94       	set
     dac:	c3 f8       	bld	r12, 3
     dae:	c8 0e       	add	r12, r24
     db0:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     db2:	0f b6       	in	r0, 0x3f	; 63
     db4:	f8 94       	cli
     db6:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     db8:	f7 01       	movw	r30, r14
     dba:	92 8d       	ldd	r25, Z+26	; 0x1a
     dbc:	83 8d       	ldd	r24, Z+27	; 0x1b
     dbe:	98 17       	cp	r25, r24
     dc0:	a8 f4       	brcc	.+42     	; 0xdec <xQueueGenericSend+0x7e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     dc2:	c7 01       	movw	r24, r14
     dc4:	b4 01       	movw	r22, r8
     dc6:	4b 2d       	mov	r20, r11
     dc8:	0e 94 b1 05 	call	0xb62	; 0xb62 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     dcc:	f7 01       	movw	r30, r14
     dce:	81 89       	ldd	r24, Z+17	; 0x11
     dd0:	88 23       	and	r24, r24
     dd2:	41 f0       	breq	.+16     	; 0xde4 <xQueueGenericSend+0x76>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     dd4:	c7 01       	movw	r24, r14
     dd6:	41 96       	adiw	r24, 0x11	; 17
     dd8:	0e 94 14 0d 	call	0x1a28	; 0x1a28 <xTaskRemoveFromEventList>
     ddc:	81 30       	cpi	r24, 0x01	; 1
     dde:	11 f4       	brne	.+4      	; 0xde4 <xQueueGenericSend+0x76>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							portYIELD_WITHIN_API();
     de0:	0e 94 cb 04 	call	0x996	; 0x996 <vPortYield>
						}
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
     de4:	0f 90       	pop	r0
     de6:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
     de8:	81 e0       	ldi	r24, 0x01	; 1
     dea:	56 c0       	rjmp	.+172    	; 0xe98 <xQueueGenericSend+0x12a>
			}
			else
			{
				if( xTicksToWait == ( uint32_t ) 0 )
     dec:	8e 81       	ldd	r24, Y+6	; 0x06
     dee:	9f 81       	ldd	r25, Y+7	; 0x07
     df0:	a8 85       	ldd	r26, Y+8	; 0x08
     df2:	b9 85       	ldd	r27, Y+9	; 0x09
     df4:	00 97       	sbiw	r24, 0x00	; 0
     df6:	a1 05       	cpc	r26, r1
     df8:	b1 05       	cpc	r27, r1
     dfa:	21 f4       	brne	.+8      	; 0xe04 <xQueueGenericSend+0x96>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     dfc:	0f 90       	pop	r0
     dfe:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     e00:	80 e0       	ldi	r24, 0x00	; 0
     e02:	4a c0       	rjmp	.+148    	; 0xe98 <xQueueGenericSend+0x12a>
				}
				else if( xEntryTimeSet == pdFALSE )
     e04:	11 23       	and	r17, r17
     e06:	29 f4       	brne	.+10     	; 0xe12 <xQueueGenericSend+0xa4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     e08:	ce 01       	movw	r24, r28
     e0a:	01 96       	adiw	r24, 0x01	; 1
     e0c:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     e10:	10 2f       	mov	r17, r16
				}
			}
		}
		taskEXIT_CRITICAL();
     e12:	0f 90       	pop	r0
     e14:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     e16:	0e 94 6d 0a 	call	0x14da	; 0x14da <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     e1a:	0f b6       	in	r0, 0x3f	; 63
     e1c:	f8 94       	cli
     e1e:	0f 92       	push	r0
     e20:	f7 01       	movw	r30, r14
     e22:	85 8d       	ldd	r24, Z+29	; 0x1d
     e24:	8f 3f       	cpi	r24, 0xFF	; 255
     e26:	09 f4       	brne	.+2      	; 0xe2a <xQueueGenericSend+0xbc>
     e28:	15 8e       	std	Z+29, r1	; 0x1d
     e2a:	f7 01       	movw	r30, r14
     e2c:	86 8d       	ldd	r24, Z+30	; 0x1e
     e2e:	8f 3f       	cpi	r24, 0xFF	; 255
     e30:	09 f4       	brne	.+2      	; 0xe34 <xQueueGenericSend+0xc6>
     e32:	16 8e       	std	Z+30, r1	; 0x1e
     e34:	0f 90       	pop	r0
     e36:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e38:	ce 01       	movw	r24, r28
     e3a:	01 96       	adiw	r24, 0x01	; 1
     e3c:	be 01       	movw	r22, r28
     e3e:	6a 5f       	subi	r22, 0xFA	; 250
     e40:	7f 4f       	sbci	r23, 0xFF	; 255
     e42:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <xTaskCheckForTimeOut>
     e46:	88 23       	and	r24, r24
     e48:	09 f5       	brne	.+66     	; 0xe8c <xQueueGenericSend+0x11e>

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     e4a:	0f b6       	in	r0, 0x3f	; 63
     e4c:	f8 94       	cli
     e4e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     e50:	f7 01       	movw	r30, r14
     e52:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     e54:	0f 90       	pop	r0
     e56:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     e58:	f7 01       	movw	r30, r14
     e5a:	83 8d       	ldd	r24, Z+27	; 0x1b
     e5c:	98 17       	cp	r25, r24
     e5e:	81 f4       	brne	.+32     	; 0xe80 <xQueueGenericSend+0x112>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     e60:	6e 81       	ldd	r22, Y+6	; 0x06
     e62:	7f 81       	ldd	r23, Y+7	; 0x07
     e64:	c6 01       	movw	r24, r12
     e66:	0e 94 f7 0c 	call	0x19ee	; 0x19ee <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     e6a:	c7 01       	movw	r24, r14
     e6c:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     e70:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <xTaskResumeAll>
     e74:	88 23       	and	r24, r24
     e76:	09 f0       	breq	.+2      	; 0xe7a <xQueueGenericSend+0x10c>
     e78:	9c cf       	rjmp	.-200    	; 0xdb2 <xQueueGenericSend+0x44>
				{
					portYIELD_WITHIN_API();
     e7a:	0e 94 cb 04 	call	0x996	; 0x996 <vPortYield>
     e7e:	99 cf       	rjmp	.-206    	; 0xdb2 <xQueueGenericSend+0x44>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     e80:	c7 01       	movw	r24, r14
     e82:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     e86:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <xTaskResumeAll>
     e8a:	93 cf       	rjmp	.-218    	; 0xdb2 <xQueueGenericSend+0x44>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     e8c:	c7 01       	movw	r24, r14
     e8e:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     e92:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     e96:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     e98:	29 96       	adiw	r28, 0x09	; 9
     e9a:	0f b6       	in	r0, 0x3f	; 63
     e9c:	f8 94       	cli
     e9e:	de bf       	out	0x3e, r29	; 62
     ea0:	0f be       	out	0x3f, r0	; 63
     ea2:	cd bf       	out	0x3d, r28	; 61
     ea4:	df 91       	pop	r29
     ea6:	cf 91       	pop	r28
     ea8:	1f 91       	pop	r17
     eaa:	0f 91       	pop	r16
     eac:	ff 90       	pop	r15
     eae:	ef 90       	pop	r14
     eb0:	df 90       	pop	r13
     eb2:	cf 90       	pop	r12
     eb4:	bf 90       	pop	r11
     eb6:	9f 90       	pop	r9
     eb8:	8f 90       	pop	r8
     eba:	08 95       	ret

00000ebc <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
     ebc:	0f 93       	push	r16
     ebe:	1f 93       	push	r17
     ec0:	cf 93       	push	r28
     ec2:	df 93       	push	r29
     ec4:	ec 01       	movw	r28, r24
     ec6:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     ec8:	9a 8d       	ldd	r25, Y+26	; 0x1a
     eca:	8b 8d       	ldd	r24, Y+27	; 0x1b
     ecc:	98 17       	cp	r25, r24
     ece:	e0 f4       	brcc	.+56     	; 0xf08 <xQueueGenericSendFromISR+0x4c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     ed0:	ce 01       	movw	r24, r28
     ed2:	42 2f       	mov	r20, r18
     ed4:	0e 94 b1 05 	call	0xb62	; 0xb62 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     ed8:	8e 8d       	ldd	r24, Y+30	; 0x1e
     eda:	8f 3f       	cpi	r24, 0xFF	; 255
     edc:	81 f4       	brne	.+32     	; 0xefe <xQueueGenericSendFromISR+0x42>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ede:	89 89       	ldd	r24, Y+17	; 0x11
     ee0:	88 23       	and	r24, r24
     ee2:	a1 f0       	breq	.+40     	; 0xf0c <xQueueGenericSendFromISR+0x50>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     ee4:	ce 01       	movw	r24, r28
     ee6:	41 96       	adiw	r24, 0x11	; 17
     ee8:	0e 94 14 0d 	call	0x1a28	; 0x1a28 <xTaskRemoveFromEventList>
     eec:	88 23       	and	r24, r24
     eee:	81 f0       	breq	.+32     	; 0xf10 <xQueueGenericSendFromISR+0x54>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     ef0:	01 15       	cp	r16, r1
     ef2:	11 05       	cpc	r17, r1
     ef4:	79 f0       	breq	.+30     	; 0xf14 <xQueueGenericSendFromISR+0x58>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     ef6:	81 e0       	ldi	r24, 0x01	; 1
     ef8:	f8 01       	movw	r30, r16
     efa:	80 83       	st	Z, r24
     efc:	0c c0       	rjmp	.+24     	; 0xf16 <xQueueGenericSendFromISR+0x5a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     efe:	8e 8d       	ldd	r24, Y+30	; 0x1e
     f00:	8f 5f       	subi	r24, 0xFF	; 255
     f02:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
     f04:	81 e0       	ldi	r24, 0x01	; 1
     f06:	07 c0       	rjmp	.+14     	; 0xf16 <xQueueGenericSendFromISR+0x5a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     f08:	80 e0       	ldi	r24, 0x00	; 0
     f0a:	05 c0       	rjmp	.+10     	; 0xf16 <xQueueGenericSendFromISR+0x5a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
     f0c:	81 e0       	ldi	r24, 0x01	; 1
     f0e:	03 c0       	rjmp	.+6      	; 0xf16 <xQueueGenericSendFromISR+0x5a>
     f10:	81 e0       	ldi	r24, 0x01	; 1
     f12:	01 c0       	rjmp	.+2      	; 0xf16 <xQueueGenericSendFromISR+0x5a>
     f14:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     f16:	df 91       	pop	r29
     f18:	cf 91       	pop	r28
     f1a:	1f 91       	pop	r17
     f1c:	0f 91       	pop	r16
     f1e:	08 95       	ret

00000f20 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, uint32_t xTicksToWait, portBASE_TYPE xJustPeeking )
{
     f20:	8f 92       	push	r8
     f22:	9f 92       	push	r9
     f24:	bf 92       	push	r11
     f26:	cf 92       	push	r12
     f28:	df 92       	push	r13
     f2a:	ef 92       	push	r14
     f2c:	ff 92       	push	r15
     f2e:	0f 93       	push	r16
     f30:	1f 93       	push	r17
     f32:	cf 93       	push	r28
     f34:	df 93       	push	r29
     f36:	cd b7       	in	r28, 0x3d	; 61
     f38:	de b7       	in	r29, 0x3e	; 62
     f3a:	29 97       	sbiw	r28, 0x09	; 9
     f3c:	0f b6       	in	r0, 0x3f	; 63
     f3e:	f8 94       	cli
     f40:	de bf       	out	0x3e, r29	; 62
     f42:	0f be       	out	0x3f, r0	; 63
     f44:	cd bf       	out	0x3d, r28	; 61
     f46:	7c 01       	movw	r14, r24
     f48:	4b 01       	movw	r8, r22
     f4a:	2e 83       	std	Y+6, r18	; 0x06
     f4c:	3f 83       	std	Y+7, r19	; 0x07
     f4e:	48 87       	std	Y+8, r20	; 0x08
     f50:	59 87       	std	Y+9, r21	; 0x09
     f52:	b0 2e       	mov	r11, r16
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     f54:	10 e0       	ldi	r17, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     f56:	01 e0       	ldi	r16, 0x01	; 1
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     f58:	0f 2e       	mov	r0, r31
     f5a:	f1 e1       	ldi	r31, 0x11	; 17
     f5c:	cf 2e       	mov	r12, r31
     f5e:	dd 24       	eor	r13, r13
     f60:	f0 2d       	mov	r31, r0
     f62:	c8 0e       	add	r12, r24
     f64:	d9 1e       	adc	r13, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     f66:	0f b6       	in	r0, 0x3f	; 63
     f68:	f8 94       	cli
     f6a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     f6c:	f7 01       	movw	r30, r14
     f6e:	82 8d       	ldd	r24, Z+26	; 0x1a
     f70:	88 23       	and	r24, r24
     f72:	51 f1       	breq	.+84     	; 0xfc8 <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     f74:	06 81       	ldd	r16, Z+6	; 0x06
     f76:	17 81       	ldd	r17, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     f78:	c7 01       	movw	r24, r14
     f7a:	b4 01       	movw	r22, r8
     f7c:	0e 94 82 05 	call	0xb04	; 0xb04 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     f80:	bb 20       	and	r11, r11
     f82:	81 f4       	brne	.+32     	; 0xfa4 <xQueueGenericReceive+0x84>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     f84:	f7 01       	movw	r30, r14
     f86:	82 8d       	ldd	r24, Z+26	; 0x1a
     f88:	81 50       	subi	r24, 0x01	; 1
     f8a:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     f8c:	80 85       	ldd	r24, Z+8	; 0x08
     f8e:	88 23       	and	r24, r24
     f90:	b9 f0       	breq	.+46     	; 0xfc0 <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     f92:	c7 01       	movw	r24, r14
     f94:	08 96       	adiw	r24, 0x08	; 8
     f96:	0e 94 14 0d 	call	0x1a28	; 0x1a28 <xTaskRemoveFromEventList>
     f9a:	81 30       	cpi	r24, 0x01	; 1
     f9c:	89 f4       	brne	.+34     	; 0xfc0 <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
     f9e:	0e 94 cb 04 	call	0x996	; 0x996 <vPortYield>
     fa2:	0e c0       	rjmp	.+28     	; 0xfc0 <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     fa4:	f7 01       	movw	r30, r14
     fa6:	17 83       	std	Z+7, r17	; 0x07
     fa8:	06 83       	std	Z+6, r16	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     faa:	81 89       	ldd	r24, Z+17	; 0x11
     fac:	88 23       	and	r24, r24
     fae:	41 f0       	breq	.+16     	; 0xfc0 <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     fb0:	c7 01       	movw	r24, r14
     fb2:	41 96       	adiw	r24, 0x11	; 17
     fb4:	0e 94 14 0d 	call	0x1a28	; 0x1a28 <xTaskRemoveFromEventList>
     fb8:	88 23       	and	r24, r24
     fba:	11 f0       	breq	.+4      	; 0xfc0 <xQueueGenericReceive+0xa0>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     fbc:	0e 94 cb 04 	call	0x996	; 0x996 <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
     fc0:	0f 90       	pop	r0
     fc2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     fc4:	81 e0       	ldi	r24, 0x01	; 1
     fc6:	54 c0       	rjmp	.+168    	; 0x1070 <xQueueGenericReceive+0x150>
			}
			else
			{
				if( xTicksToWait == ( uint32_t ) 0 )
     fc8:	8e 81       	ldd	r24, Y+6	; 0x06
     fca:	9f 81       	ldd	r25, Y+7	; 0x07
     fcc:	a8 85       	ldd	r26, Y+8	; 0x08
     fce:	b9 85       	ldd	r27, Y+9	; 0x09
     fd0:	00 97       	sbiw	r24, 0x00	; 0
     fd2:	a1 05       	cpc	r26, r1
     fd4:	b1 05       	cpc	r27, r1
     fd6:	21 f4       	brne	.+8      	; 0xfe0 <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     fd8:	0f 90       	pop	r0
     fda:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     fdc:	80 e0       	ldi	r24, 0x00	; 0
     fde:	48 c0       	rjmp	.+144    	; 0x1070 <xQueueGenericReceive+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
     fe0:	11 23       	and	r17, r17
     fe2:	29 f4       	brne	.+10     	; 0xfee <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     fe4:	ce 01       	movw	r24, r28
     fe6:	01 96       	adiw	r24, 0x01	; 1
     fe8:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     fec:	10 2f       	mov	r17, r16
				}
			}
		}
		taskEXIT_CRITICAL();
     fee:	0f 90       	pop	r0
     ff0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     ff2:	0e 94 6d 0a 	call	0x14da	; 0x14da <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     ff6:	0f b6       	in	r0, 0x3f	; 63
     ff8:	f8 94       	cli
     ffa:	0f 92       	push	r0
     ffc:	f7 01       	movw	r30, r14
     ffe:	85 8d       	ldd	r24, Z+29	; 0x1d
    1000:	8f 3f       	cpi	r24, 0xFF	; 255
    1002:	09 f4       	brne	.+2      	; 0x1006 <xQueueGenericReceive+0xe6>
    1004:	15 8e       	std	Z+29, r1	; 0x1d
    1006:	f7 01       	movw	r30, r14
    1008:	86 8d       	ldd	r24, Z+30	; 0x1e
    100a:	8f 3f       	cpi	r24, 0xFF	; 255
    100c:	09 f4       	brne	.+2      	; 0x1010 <xQueueGenericReceive+0xf0>
    100e:	16 8e       	std	Z+30, r1	; 0x1e
    1010:	0f 90       	pop	r0
    1012:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1014:	ce 01       	movw	r24, r28
    1016:	01 96       	adiw	r24, 0x01	; 1
    1018:	be 01       	movw	r22, r28
    101a:	6a 5f       	subi	r22, 0xFA	; 250
    101c:	7f 4f       	sbci	r23, 0xFF	; 255
    101e:	0e 94 6b 0d 	call	0x1ad6	; 0x1ad6 <xTaskCheckForTimeOut>
    1022:	88 23       	and	r24, r24
    1024:	f9 f4       	brne	.+62     	; 0x1064 <xQueueGenericReceive+0x144>

static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1026:	0f b6       	in	r0, 0x3f	; 63
    1028:	f8 94       	cli
    102a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == 0 )
    102c:	f7 01       	movw	r30, r14
    102e:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1030:	0f 90       	pop	r0
    1032:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1034:	88 23       	and	r24, r24
    1036:	81 f4       	brne	.+32     	; 0x1058 <xQueueGenericReceive+0x138>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1038:	6e 81       	ldd	r22, Y+6	; 0x06
    103a:	7f 81       	ldd	r23, Y+7	; 0x07
    103c:	c6 01       	movw	r24, r12
    103e:	0e 94 f7 0c 	call	0x19ee	; 0x19ee <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1042:	c7 01       	movw	r24, r14
    1044:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1048:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <xTaskResumeAll>
    104c:	88 23       	and	r24, r24
    104e:	09 f0       	breq	.+2      	; 0x1052 <xQueueGenericReceive+0x132>
    1050:	8a cf       	rjmp	.-236    	; 0xf66 <xQueueGenericReceive+0x46>
				{
					portYIELD_WITHIN_API();
    1052:	0e 94 cb 04 	call	0x996	; 0x996 <vPortYield>
    1056:	87 cf       	rjmp	.-242    	; 0xf66 <xQueueGenericReceive+0x46>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1058:	c7 01       	movw	r24, r14
    105a:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    105e:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <xTaskResumeAll>
    1062:	81 cf       	rjmp	.-254    	; 0xf66 <xQueueGenericReceive+0x46>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    1064:	c7 01       	movw	r24, r14
    1066:	0e 94 f2 05 	call	0xbe4	; 0xbe4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    106a:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    106e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1070:	29 96       	adiw	r28, 0x09	; 9
    1072:	0f b6       	in	r0, 0x3f	; 63
    1074:	f8 94       	cli
    1076:	de bf       	out	0x3e, r29	; 62
    1078:	0f be       	out	0x3f, r0	; 63
    107a:	cd bf       	out	0x3d, r28	; 61
    107c:	df 91       	pop	r29
    107e:	cf 91       	pop	r28
    1080:	1f 91       	pop	r17
    1082:	0f 91       	pop	r16
    1084:	ff 90       	pop	r15
    1086:	ef 90       	pop	r14
    1088:	df 90       	pop	r13
    108a:	cf 90       	pop	r12
    108c:	bf 90       	pop	r11
    108e:	9f 90       	pop	r9
    1090:	8f 90       	pop	r8
    1092:	08 95       	ret

00001094 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    1094:	0f 93       	push	r16
    1096:	1f 93       	push	r17
    1098:	cf 93       	push	r28
    109a:	df 93       	push	r29
    109c:	ec 01       	movw	r28, r24
    109e:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    10a0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10a2:	88 23       	and	r24, r24
    10a4:	f1 f0       	breq	.+60     	; 0x10e2 <xQueueReceiveFromISR+0x4e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    10a6:	ce 01       	movw	r24, r28
    10a8:	0e 94 82 05 	call	0xb04	; 0xb04 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    10ac:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10ae:	81 50       	subi	r24, 0x01	; 1
    10b0:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    10b2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    10b4:	8f 3f       	cpi	r24, 0xFF	; 255
    10b6:	81 f4       	brne	.+32     	; 0x10d8 <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    10b8:	88 85       	ldd	r24, Y+8	; 0x08
    10ba:	88 23       	and	r24, r24
    10bc:	a1 f0       	breq	.+40     	; 0x10e6 <xQueueReceiveFromISR+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    10be:	ce 01       	movw	r24, r28
    10c0:	08 96       	adiw	r24, 0x08	; 8
    10c2:	0e 94 14 0d 	call	0x1a28	; 0x1a28 <xTaskRemoveFromEventList>
    10c6:	88 23       	and	r24, r24
    10c8:	81 f0       	breq	.+32     	; 0x10ea <xQueueReceiveFromISR+0x56>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    10ca:	01 15       	cp	r16, r1
    10cc:	11 05       	cpc	r17, r1
    10ce:	79 f0       	breq	.+30     	; 0x10ee <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    10d0:	81 e0       	ldi	r24, 0x01	; 1
    10d2:	f8 01       	movw	r30, r16
    10d4:	80 83       	st	Z, r24
    10d6:	0c c0       	rjmp	.+24     	; 0x10f0 <xQueueReceiveFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    10d8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    10da:	8f 5f       	subi	r24, 0xFF	; 255
    10dc:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    10de:	81 e0       	ldi	r24, 0x01	; 1
    10e0:	07 c0       	rjmp	.+14     	; 0x10f0 <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			xReturn = pdFAIL;
    10e2:	80 e0       	ldi	r24, 0x00	; 0
    10e4:	05 c0       	rjmp	.+10     	; 0x10f0 <xQueueReceiveFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    10e6:	81 e0       	ldi	r24, 0x01	; 1
    10e8:	03 c0       	rjmp	.+6      	; 0x10f0 <xQueueReceiveFromISR+0x5c>
    10ea:	81 e0       	ldi	r24, 0x01	; 1
    10ec:	01 c0       	rjmp	.+2      	; 0x10f0 <xQueueReceiveFromISR+0x5c>
    10ee:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    10f0:	df 91       	pop	r29
    10f2:	cf 91       	pop	r28
    10f4:	1f 91       	pop	r17
    10f6:	0f 91       	pop	r16
    10f8:	08 95       	ret

000010fa <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    10fa:	0f b6       	in	r0, 0x3f	; 63
    10fc:	f8 94       	cli
    10fe:	0f 92       	push	r0
		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
    1100:	fc 01       	movw	r30, r24
    1102:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1104:	0f 90       	pop	r0
    1106:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1108:	08 95       	ret

0000110a <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
    110a:	fc 01       	movw	r30, r24
    110c:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    110e:	08 95       	ret

00001110 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle xQueue )
{
    1110:	cf 93       	push	r28
    1112:	df 93       	push	r29
    1114:	ec 01       	movw	r28, r24
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		prvQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue->pcHead );
    1116:	88 81       	ld	r24, Y
    1118:	99 81       	ldd	r25, Y+1	; 0x01
    111a:	0e 94 4b 03 	call	0x696	; 0x696 <vPortFree>
	vPortFree( pxQueue );
    111e:	ce 01       	movw	r24, r28
    1120:	0e 94 4b 03 	call	0x696	; 0x696 <vPortFree>
}
    1124:	df 91       	pop	r29
    1126:	cf 91       	pop	r28
    1128:	08 95       	ret

0000112a <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == 0 )
    112a:	fc 01       	movw	r30, r24
    112c:	92 8d       	ldd	r25, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    112e:	81 e0       	ldi	r24, 0x01	; 1
    1130:	91 11       	cpse	r25, r1
    1132:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1134:	08 95       	ret

00001136 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
{
    1136:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
    1138:	22 8d       	ldd	r18, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    113a:	81 e0       	ldi	r24, 0x01	; 1
    113c:	93 8d       	ldd	r25, Z+27	; 0x1b
    113e:	29 13       	cpse	r18, r25
    1140:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1142:	08 95       	ret

00001144 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( uint16_t xTimeToWake )
{
    1144:	cf 93       	push	r28
    1146:	df 93       	push	r29
    1148:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    114a:	e0 91 7e 05 	lds	r30, 0x057E
    114e:	f0 91 7f 05 	lds	r31, 0x057F
    1152:	93 83       	std	Z+3, r25	; 0x03
    1154:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    1156:	80 91 86 05 	lds	r24, 0x0586
    115a:	90 91 87 05 	lds	r25, 0x0587
    115e:	c8 17       	cp	r28, r24
    1160:	d9 07       	cpc	r29, r25
    1162:	68 f4       	brcc	.+26     	; 0x117e <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1164:	80 91 8a 05 	lds	r24, 0x058A
    1168:	90 91 8b 05 	lds	r25, 0x058B
    116c:	60 91 7e 05 	lds	r22, 0x057E
    1170:	70 91 7f 05 	lds	r23, 0x057F
    1174:	6e 5f       	subi	r22, 0xFE	; 254
    1176:	7f 4f       	sbci	r23, 0xFF	; 255
    1178:	0e 94 95 03 	call	0x72a	; 0x72a <vListInsert>
    117c:	17 c0       	rjmp	.+46     	; 0x11ac <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    117e:	80 91 8c 05 	lds	r24, 0x058C
    1182:	90 91 8d 05 	lds	r25, 0x058D
    1186:	60 91 7e 05 	lds	r22, 0x057E
    118a:	70 91 7f 05 	lds	r23, 0x057F
    118e:	6e 5f       	subi	r22, 0xFE	; 254
    1190:	7f 4f       	sbci	r23, 0xFF	; 255
    1192:	0e 94 95 03 	call	0x72a	; 0x72a <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    1196:	80 91 65 00 	lds	r24, 0x0065
    119a:	90 91 66 00 	lds	r25, 0x0066
    119e:	c8 17       	cp	r28, r24
    11a0:	d9 07       	cpc	r29, r25
    11a2:	20 f4       	brcc	.+8      	; 0x11ac <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    11a4:	d0 93 66 00 	sts	0x0066, r29
    11a8:	c0 93 65 00 	sts	0x0065, r28
		}
	}
}
    11ac:	df 91       	pop	r29
    11ae:	cf 91       	pop	r28
    11b0:	08 95       	ret

000011b2 <xTaskGenericCreate>:
#endif

/*lint +e956 */

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    11b2:	4f 92       	push	r4
    11b4:	5f 92       	push	r5
    11b6:	6f 92       	push	r6
    11b8:	7f 92       	push	r7
    11ba:	8f 92       	push	r8
    11bc:	9f 92       	push	r9
    11be:	bf 92       	push	r11
    11c0:	cf 92       	push	r12
    11c2:	df 92       	push	r13
    11c4:	ef 92       	push	r14
    11c6:	ff 92       	push	r15
    11c8:	0f 93       	push	r16
    11ca:	1f 93       	push	r17
    11cc:	cf 93       	push	r28
    11ce:	df 93       	push	r29
    11d0:	2c 01       	movw	r4, r24
    11d2:	4b 01       	movw	r8, r22
    11d4:	ea 01       	movw	r28, r20
    11d6:	39 01       	movw	r6, r18
    11d8:	b0 2e       	mov	r11, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    11da:	88 e2       	ldi	r24, 0x28	; 40
    11dc:	90 e0       	ldi	r25, 0x00	; 0
    11de:	0e 94 15 03 	call	0x62a	; 0x62a <pvPortMalloc>
    11e2:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    11e4:	00 97       	sbiw	r24, 0x00	; 0
    11e6:	09 f4       	brne	.+2      	; 0x11ea <xTaskGenericCreate+0x38>
    11e8:	e2 c0       	rjmp	.+452    	; 0x13ae <xTaskGenericCreate+0x1fc>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    11ea:	c1 14       	cp	r12, r1
    11ec:	d1 04       	cpc	r13, r1
    11ee:	09 f0       	breq	.+2      	; 0x11f2 <xTaskGenericCreate+0x40>
    11f0:	f3 c0       	rjmp	.+486    	; 0x13d8 <xTaskGenericCreate+0x226>
    11f2:	ce 01       	movw	r24, r28
    11f4:	0e 94 15 03 	call	0x62a	; 0x62a <pvPortMalloc>
    11f8:	6c 01       	movw	r12, r24
    11fa:	f8 01       	movw	r30, r16
    11fc:	90 8f       	std	Z+24, r25	; 0x18
    11fe:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    1200:	00 97       	sbiw	r24, 0x00	; 0
    1202:	29 f4       	brne	.+10     	; 0x120e <xTaskGenericCreate+0x5c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    1204:	c8 01       	movw	r24, r16
    1206:	0e 94 4b 03 	call	0x696	; 0x696 <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    120a:	8f ef       	ldi	r24, 0xFF	; 255
    120c:	d5 c0       	rjmp	.+426    	; 0x13b8 <xTaskGenericCreate+0x206>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    120e:	c6 01       	movw	r24, r12
    1210:	65 ea       	ldi	r22, 0xA5	; 165
    1212:	70 e0       	ldi	r23, 0x00	; 0
    1214:	ae 01       	movw	r20, r28
    1216:	0e 94 87 0f 	call	0x1f0e	; 0x1f0e <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    121a:	9e 01       	movw	r18, r28
    121c:	21 50       	subi	r18, 0x01	; 1
    121e:	30 40       	sbci	r19, 0x00	; 0
    1220:	f8 01       	movw	r30, r16
    1222:	87 89       	ldd	r24, Z+23	; 0x17
    1224:	90 8d       	ldd	r25, Z+24	; 0x18
    1226:	6c 01       	movw	r12, r24
    1228:	c2 0e       	add	r12, r18
    122a:	d3 1e       	adc	r13, r19
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    122c:	c8 01       	movw	r24, r16
    122e:	49 96       	adiw	r24, 0x19	; 25
    1230:	b4 01       	movw	r22, r8
    1232:	4f e0       	ldi	r20, 0x0F	; 15
    1234:	50 e0       	ldi	r21, 0x00	; 0
    1236:	0e 94 8e 0f 	call	0x1f1c	; 0x1f1c <strncpy>
	}
	#endif /* configMAX_TASK_NAME_LEN */
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    123a:	f8 01       	movw	r30, r16
    123c:	17 a2       	lds	r17, 0x97
    123e:	cb 2d       	mov	r28, r11
    1240:	f3 e0       	ldi	r31, 0x03	; 3
    1242:	fb 15       	cp	r31, r11
    1244:	08 f4       	brcc	.+2      	; 0x1248 <xTaskGenericCreate+0x96>
    1246:	c3 e0       	ldi	r28, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    1248:	f8 01       	movw	r30, r16
    124a:	c6 8b       	std	Z+22, r28	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    124c:	88 24       	eor	r8, r8
    124e:	99 24       	eor	r9, r9
    1250:	68 94       	set
    1252:	81 f8       	bld	r8, 1
    1254:	80 0e       	add	r8, r16
    1256:	91 1e       	adc	r9, r17
    1258:	c4 01       	movw	r24, r8
    125a:	0e 94 68 03 	call	0x6d0	; 0x6d0 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    125e:	c8 01       	movw	r24, r16
    1260:	0c 96       	adiw	r24, 0x0c	; 12
    1262:	0e 94 68 03 	call	0x6d0	; 0x6d0 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    1266:	f8 01       	movw	r30, r16
    1268:	11 87       	std	Z+9, r17	; 0x09
    126a:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( uint16_t ) uxPriority );
    126c:	84 e0       	ldi	r24, 0x04	; 4
    126e:	90 e0       	ldi	r25, 0x00	; 0
    1270:	8c 1b       	sub	r24, r28
    1272:	91 09       	sbc	r25, r1
    1274:	95 87       	std	Z+13, r25	; 0x0d
    1276:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    1278:	13 8b       	std	Z+19, r17	; 0x13
    127a:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    127c:	c6 01       	movw	r24, r12
    127e:	b2 01       	movw	r22, r4
    1280:	a3 01       	movw	r20, r6
    1282:	0e 94 06 04 	call	0x80c	; 0x80c <pxPortInitialiseStack>
    1286:	f8 01       	movw	r30, r16
    1288:	91 83       	std	Z+1, r25	; 0x01
    128a:	80 83       	st	Z, r24
		#endif /* portUSING_MPU_WRAPPERS */

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    128c:	e1 14       	cp	r14, r1
    128e:	f1 04       	cpc	r15, r1
    1290:	19 f0       	breq	.+6      	; 0x1298 <xTaskGenericCreate+0xe6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    1292:	f7 01       	movw	r30, r14
    1294:	11 83       	std	Z+1, r17	; 0x01
    1296:	00 83       	st	Z, r16
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    1298:	0f b6       	in	r0, 0x3f	; 63
    129a:	f8 94       	cli
    129c:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    129e:	80 91 88 05 	lds	r24, 0x0588
    12a2:	8f 5f       	subi	r24, 0xFF	; 255
    12a4:	80 93 88 05 	sts	0x0588, r24
			if( pxCurrentTCB == NULL )
    12a8:	80 91 7e 05 	lds	r24, 0x057E
    12ac:	90 91 7f 05 	lds	r25, 0x057F
    12b0:	00 97       	sbiw	r24, 0x00	; 0
    12b2:	d9 f5       	brne	.+118    	; 0x132a <xTaskGenericCreate+0x178>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    12b4:	10 93 7f 05 	sts	0x057F, r17
    12b8:	00 93 7e 05 	sts	0x057E, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    12bc:	80 91 88 05 	lds	r24, 0x0588
    12c0:	81 30       	cpi	r24, 0x01	; 1
    12c2:	09 f0       	breq	.+2      	; 0x12c6 <xTaskGenericCreate+0x114>
    12c4:	41 c0       	rjmp	.+130    	; 0x1348 <xTaskGenericCreate+0x196>
    12c6:	c0 e0       	ldi	r28, 0x00	; 0
    12c8:	d0 e0       	ldi	r29, 0x00	; 0
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    12ca:	ce 01       	movw	r24, r28
    12cc:	88 0f       	add	r24, r24
    12ce:	99 1f       	adc	r25, r25
    12d0:	88 0f       	add	r24, r24
    12d2:	99 1f       	adc	r25, r25
    12d4:	88 0f       	add	r24, r24
    12d6:	99 1f       	adc	r25, r25
    12d8:	8c 0f       	add	r24, r28
    12da:	9d 1f       	adc	r25, r29
    12dc:	80 57       	subi	r24, 0x70	; 112
    12de:	9a 4f       	sbci	r25, 0xFA	; 250
    12e0:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialise>
    12e4:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    12e6:	c4 30       	cpi	r28, 0x04	; 4
    12e8:	d1 05       	cpc	r29, r1
    12ea:	79 f7       	brne	.-34     	; 0x12ca <xTaskGenericCreate+0x118>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    12ec:	c4 eb       	ldi	r28, 0xB4	; 180
    12ee:	d5 e0       	ldi	r29, 0x05	; 5
    12f0:	ce 01       	movw	r24, r28
    12f2:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    12f6:	0f 2e       	mov	r0, r31
    12f8:	fd eb       	ldi	r31, 0xBD	; 189
    12fa:	ef 2e       	mov	r14, r31
    12fc:	f5 e0       	ldi	r31, 0x05	; 5
    12fe:	ff 2e       	mov	r15, r31
    1300:	f0 2d       	mov	r31, r0
    1302:	c7 01       	movw	r24, r14
    1304:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    1308:	86 ec       	ldi	r24, 0xC6	; 198
    130a:	95 e0       	ldi	r25, 0x05	; 5
    130c:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    1310:	8f ec       	ldi	r24, 0xCF	; 207
    1312:	95 e0       	ldi	r25, 0x05	; 5
    1314:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    1318:	d0 93 8d 05 	sts	0x058D, r29
    131c:	c0 93 8c 05 	sts	0x058C, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    1320:	f0 92 8b 05 	sts	0x058B, r15
    1324:	e0 92 8a 05 	sts	0x058A, r14
    1328:	0f c0       	rjmp	.+30     	; 0x1348 <xTaskGenericCreate+0x196>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    132a:	80 91 84 05 	lds	r24, 0x0584
    132e:	88 23       	and	r24, r24
    1330:	59 f4       	brne	.+22     	; 0x1348 <xTaskGenericCreate+0x196>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    1332:	e0 91 7e 05 	lds	r30, 0x057E
    1336:	f0 91 7f 05 	lds	r31, 0x057F
    133a:	86 89       	ldd	r24, Z+22	; 0x16
    133c:	b8 16       	cp	r11, r24
    133e:	20 f0       	brcs	.+8      	; 0x1348 <xTaskGenericCreate+0x196>
					{
						pxCurrentTCB = pxNewTCB;
    1340:	10 93 7f 05 	sts	0x057F, r17
    1344:	00 93 7e 05 	sts	0x057E, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    1348:	f8 01       	movw	r30, r16
    134a:	86 89       	ldd	r24, Z+22	; 0x16
    134c:	90 91 8e 05 	lds	r25, 0x058E
    1350:	98 17       	cp	r25, r24
    1352:	10 f4       	brcc	.+4      	; 0x1358 <xTaskGenericCreate+0x1a6>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    1354:	80 93 8e 05 	sts	0x058E, r24
			}

			uxTaskNumber++;
    1358:	90 91 8f 05 	lds	r25, 0x058F
    135c:	9f 5f       	subi	r25, 0xFF	; 255
    135e:	90 93 8f 05 	sts	0x058F, r25
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyQueue( pxNewTCB );
    1362:	90 91 85 05 	lds	r25, 0x0585
    1366:	98 17       	cp	r25, r24
    1368:	10 f4       	brcc	.+4      	; 0x136e <xTaskGenericCreate+0x1bc>
    136a:	80 93 85 05 	sts	0x0585, r24
    136e:	90 e0       	ldi	r25, 0x00	; 0
    1370:	9c 01       	movw	r18, r24
    1372:	22 0f       	add	r18, r18
    1374:	33 1f       	adc	r19, r19
    1376:	22 0f       	add	r18, r18
    1378:	33 1f       	adc	r19, r19
    137a:	22 0f       	add	r18, r18
    137c:	33 1f       	adc	r19, r19
    137e:	82 0f       	add	r24, r18
    1380:	93 1f       	adc	r25, r19
    1382:	80 57       	subi	r24, 0x70	; 112
    1384:	9a 4f       	sbci	r25, 0xFA	; 250
    1386:	b4 01       	movw	r22, r8
    1388:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    138c:	0f 90       	pop	r0
    138e:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1390:	80 91 84 05 	lds	r24, 0x0584
    1394:	88 23       	and	r24, r24
    1396:	69 f0       	breq	.+26     	; 0x13b2 <xTaskGenericCreate+0x200>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    1398:	e0 91 7e 05 	lds	r30, 0x057E
    139c:	f0 91 7f 05 	lds	r31, 0x057F
    13a0:	86 89       	ldd	r24, Z+22	; 0x16
    13a2:	8b 15       	cp	r24, r11
    13a4:	40 f4       	brcc	.+16     	; 0x13b6 <xTaskGenericCreate+0x204>
			{
				portYIELD_WITHIN_API();
    13a6:	0e 94 cb 04 	call	0x996	; 0x996 <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    13aa:	81 e0       	ldi	r24, 0x01	; 1
    13ac:	05 c0       	rjmp	.+10     	; 0x13b8 <xTaskGenericCreate+0x206>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    13ae:	8f ef       	ldi	r24, 0xFF	; 255
    13b0:	03 c0       	rjmp	.+6      	; 0x13b8 <xTaskGenericCreate+0x206>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    13b2:	81 e0       	ldi	r24, 0x01	; 1
    13b4:	01 c0       	rjmp	.+2      	; 0x13b8 <xTaskGenericCreate+0x206>
    13b6:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    13b8:	df 91       	pop	r29
    13ba:	cf 91       	pop	r28
    13bc:	1f 91       	pop	r17
    13be:	0f 91       	pop	r16
    13c0:	ff 90       	pop	r15
    13c2:	ef 90       	pop	r14
    13c4:	df 90       	pop	r13
    13c6:	cf 90       	pop	r12
    13c8:	bf 90       	pop	r11
    13ca:	9f 90       	pop	r9
    13cc:	8f 90       	pop	r8
    13ce:	7f 90       	pop	r7
    13d0:	6f 90       	pop	r6
    13d2:	5f 90       	pop	r5
    13d4:	4f 90       	pop	r4
    13d6:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    13d8:	fc 01       	movw	r30, r24
    13da:	d0 8e       	std	Z+24, r13	; 0x18
    13dc:	c7 8a       	std	Z+23, r12	; 0x17
    13de:	17 cf       	rjmp	.-466    	; 0x120e <xTaskGenericCreate+0x5c>

000013e0 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle xTaskToDelete )
	{
    13e0:	ef 92       	push	r14
    13e2:	ff 92       	push	r15
    13e4:	0f 93       	push	r16
    13e6:	1f 93       	push	r17
    13e8:	cf 93       	push	r28
    13ea:	df 93       	push	r29
    13ec:	7c 01       	movw	r14, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    13ee:	0f b6       	in	r0, 0x3f	; 63
    13f0:	f8 94       	cli
    13f2:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( xTaskToDelete == pxCurrentTCB )
    13f4:	80 91 7e 05 	lds	r24, 0x057E
    13f8:	90 91 7f 05 	lds	r25, 0x057F
    13fc:	e8 16       	cp	r14, r24
    13fe:	f9 06       	cpc	r15, r25
    1400:	21 f0       	breq	.+8      	; 0x140a <vTaskDelete+0x2a>
			{
				xTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    1402:	e1 14       	cp	r14, r1
    1404:	f1 04       	cpc	r15, r1
    1406:	41 f4       	brne	.+16     	; 0x1418 <vTaskDelete+0x38>
    1408:	02 c0       	rjmp	.+4      	; 0x140e <vTaskDelete+0x2e>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( xTaskToDelete == pxCurrentTCB )
			{
				xTaskToDelete = NULL;
    140a:	ee 24       	eor	r14, r14
    140c:	ff 24       	eor	r15, r15
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    140e:	c0 91 7e 05 	lds	r28, 0x057E
    1412:	d0 91 7f 05 	lds	r29, 0x057F
    1416:	01 c0       	rjmp	.+2      	; 0x141a <vTaskDelete+0x3a>
    1418:	e7 01       	movw	r28, r14

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    141a:	8e 01       	movw	r16, r28
    141c:	0e 5f       	subi	r16, 0xFE	; 254
    141e:	1f 4f       	sbci	r17, 0xFF	; 255
    1420:	c8 01       	movw	r24, r16
    1422:	0e 94 df 03 	call	0x7be	; 0x7be <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    1426:	8c 89       	ldd	r24, Y+20	; 0x14
    1428:	9d 89       	ldd	r25, Y+21	; 0x15
    142a:	00 97       	sbiw	r24, 0x00	; 0
    142c:	21 f0       	breq	.+8      	; 0x1436 <vTaskDelete+0x56>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
    142e:	ce 01       	movw	r24, r28
    1430:	0c 96       	adiw	r24, 0x0c	; 12
    1432:	0e 94 df 03 	call	0x7be	; 0x7be <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    1436:	8f ec       	ldi	r24, 0xCF	; 207
    1438:	95 e0       	ldi	r25, 0x05	; 5
    143a:	b8 01       	movw	r22, r16
    143c:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    1440:	80 91 89 05 	lds	r24, 0x0589
    1444:	8f 5f       	subi	r24, 0xFF	; 255
    1446:	80 93 89 05 	sts	0x0589, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    144a:	80 91 8f 05 	lds	r24, 0x058F
    144e:	8f 5f       	subi	r24, 0xFF	; 255
    1450:	80 93 8f 05 	sts	0x058F, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    1454:	0f 90       	pop	r0
    1456:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    1458:	80 91 84 05 	lds	r24, 0x0584
    145c:	88 23       	and	r24, r24
    145e:	29 f0       	breq	.+10     	; 0x146a <vTaskDelete+0x8a>
		{
			if( ( void * ) xTaskToDelete == NULL )
    1460:	e1 14       	cp	r14, r1
    1462:	f1 04       	cpc	r15, r1
    1464:	11 f4       	brne	.+4      	; 0x146a <vTaskDelete+0x8a>
			{
				portYIELD_WITHIN_API();
    1466:	0e 94 cb 04 	call	0x996	; 0x996 <vPortYield>
			}
		}
	}
    146a:	df 91       	pop	r29
    146c:	cf 91       	pop	r28
    146e:	1f 91       	pop	r17
    1470:	0f 91       	pop	r16
    1472:	ff 90       	pop	r15
    1474:	ef 90       	pop	r14
    1476:	08 95       	ret

00001478 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    1478:	af 92       	push	r10
    147a:	bf 92       	push	r11
    147c:	cf 92       	push	r12
    147e:	df 92       	push	r13
    1480:	ef 92       	push	r14
    1482:	ff 92       	push	r15
    1484:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1486:	84 ee       	ldi	r24, 0xE4	; 228
    1488:	9b e0       	ldi	r25, 0x0B	; 11
    148a:	60 e6       	ldi	r22, 0x60	; 96
    148c:	70 e0       	ldi	r23, 0x00	; 0
    148e:	45 e5       	ldi	r20, 0x55	; 85
    1490:	50 e0       	ldi	r21, 0x00	; 0
    1492:	20 e0       	ldi	r18, 0x00	; 0
    1494:	30 e0       	ldi	r19, 0x00	; 0
    1496:	00 e0       	ldi	r16, 0x00	; 0
    1498:	ee 24       	eor	r14, r14
    149a:	ff 24       	eor	r15, r15
    149c:	cc 24       	eor	r12, r12
    149e:	dd 24       	eor	r13, r13
    14a0:	aa 24       	eor	r10, r10
    14a2:	bb 24       	eor	r11, r11
    14a4:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    14a8:	81 30       	cpi	r24, 0x01	; 1
    14aa:	49 f4       	brne	.+18     	; 0x14be <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    14ac:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    14ae:	80 93 84 05 	sts	0x0584, r24
		xTickCount = ( uint16_t ) 0U;
    14b2:	10 92 87 05 	sts	0x0587, r1
    14b6:	10 92 86 05 	sts	0x0586, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    14ba:	0e 94 96 04 	call	0x92c	; 0x92c <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    14be:	0f 91       	pop	r16
    14c0:	ff 90       	pop	r15
    14c2:	ef 90       	pop	r14
    14c4:	df 90       	pop	r13
    14c6:	cf 90       	pop	r12
    14c8:	bf 90       	pop	r11
    14ca:	af 90       	pop	r10
    14cc:	08 95       	ret

000014ce <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    14ce:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    14d0:	10 92 84 05 	sts	0x0584, r1
	vPortEndScheduler();
    14d4:	0e 94 ca 04 	call	0x994	; 0x994 <vPortEndScheduler>
}
    14d8:	08 95       	ret

000014da <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    14da:	80 91 83 05 	lds	r24, 0x0583
    14de:	8f 5f       	subi	r24, 0xFF	; 255
    14e0:	80 93 83 05 	sts	0x0583, r24
}
    14e4:	08 95       	ret

000014e6 <xTaskGetTickCount>:
uint16_t xTaskGetTickCount( void )
{
uint16_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    14e6:	0f b6       	in	r0, 0x3f	; 63
    14e8:	f8 94       	cli
    14ea:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    14ec:	80 91 86 05 	lds	r24, 0x0586
    14f0:	90 91 87 05 	lds	r25, 0x0587
	}
	taskEXIT_CRITICAL();
    14f4:	0f 90       	pop	r0
    14f6:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    14f8:	08 95       	ret

000014fa <xTaskGetTickCountFromISR>:
{
uint16_t xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    14fa:	80 91 86 05 	lds	r24, 0x0586
    14fe:	90 91 87 05 	lds	r25, 0x0587
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1502:	08 95       	ret

00001504 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    1504:	80 91 88 05 	lds	r24, 0x0588
}
    1508:	08 95       	ret

0000150a <vTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    150a:	0f 93       	push	r16
    150c:	1f 93       	push	r17
    150e:	cf 93       	push	r28
    1510:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1512:	80 91 83 05 	lds	r24, 0x0583
    1516:	88 23       	and	r24, r24
    1518:	09 f0       	breq	.+2      	; 0x151c <vTaskIncrementTick+0x12>
    151a:	bc c0       	rjmp	.+376    	; 0x1694 <vTaskIncrementTick+0x18a>
	{
		++xTickCount;
    151c:	80 91 86 05 	lds	r24, 0x0586
    1520:	90 91 87 05 	lds	r25, 0x0587
    1524:	01 96       	adiw	r24, 0x01	; 1
    1526:	90 93 87 05 	sts	0x0587, r25
    152a:	80 93 86 05 	sts	0x0586, r24
        
if( xTickCount==65535 )
    152e:	80 91 86 05 	lds	r24, 0x0586
    1532:	90 91 87 05 	lds	r25, 0x0587
    1536:	2f ef       	ldi	r18, 0xFF	; 255
    1538:	8f 3f       	cpi	r24, 0xFF	; 255
    153a:	92 07       	cpc	r25, r18
    153c:	09 f4       	brne	.+2      	; 0x1540 <vTaskIncrementTick+0x36>
{
    asm("nop");
    153e:	00 00       	nop
}
        
		if( xTickCount == ( uint16_t ) 0U )
    1540:	80 91 86 05 	lds	r24, 0x0586
    1544:	90 91 87 05 	lds	r25, 0x0587
    1548:	00 97       	sbiw	r24, 0x00	; 0
    154a:	99 f5       	brne	.+102    	; 0x15b2 <vTaskIncrementTick+0xa8>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
    154c:	80 91 8c 05 	lds	r24, 0x058C
    1550:	90 91 8d 05 	lds	r25, 0x058D
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    1554:	20 91 8a 05 	lds	r18, 0x058A
    1558:	30 91 8b 05 	lds	r19, 0x058B
    155c:	30 93 8d 05 	sts	0x058D, r19
    1560:	20 93 8c 05 	sts	0x058C, r18
			pxOverflowDelayedTaskList = pxTemp;
    1564:	90 93 8b 05 	sts	0x058B, r25
    1568:	80 93 8a 05 	sts	0x058A, r24
			xNumOfOverflows++;
    156c:	80 91 80 05 	lds	r24, 0x0580
    1570:	8f 5f       	subi	r24, 0xFF	; 255
    1572:	80 93 80 05 	sts	0x0580, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    1576:	e0 91 8c 05 	lds	r30, 0x058C
    157a:	f0 91 8d 05 	lds	r31, 0x058D
    157e:	80 81       	ld	r24, Z
    1580:	88 23       	and	r24, r24
    1582:	39 f4       	brne	.+14     	; 0x1592 <vTaskIncrementTick+0x88>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    1584:	8f ef       	ldi	r24, 0xFF	; 255
    1586:	9f ef       	ldi	r25, 0xFF	; 255
    1588:	90 93 66 00 	sts	0x0066, r25
    158c:	80 93 65 00 	sts	0x0065, r24
    1590:	10 c0       	rjmp	.+32     	; 0x15b2 <vTaskIncrementTick+0xa8>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1592:	e0 91 8c 05 	lds	r30, 0x058C
    1596:	f0 91 8d 05 	lds	r31, 0x058D
    159a:	05 80       	ldd	r0, Z+5	; 0x05
    159c:	f6 81       	ldd	r31, Z+6	; 0x06
    159e:	e0 2d       	mov	r30, r0
    15a0:	06 80       	ldd	r0, Z+6	; 0x06
    15a2:	f7 81       	ldd	r31, Z+7	; 0x07
    15a4:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    15a6:	82 81       	ldd	r24, Z+2	; 0x02
    15a8:	93 81       	ldd	r25, Z+3	; 0x03
    15aa:	90 93 66 00 	sts	0x0066, r25
    15ae:	80 93 65 00 	sts	0x0065, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    15b2:	20 91 86 05 	lds	r18, 0x0586
    15b6:	30 91 87 05 	lds	r19, 0x0587
    15ba:	80 91 65 00 	lds	r24, 0x0065
    15be:	90 91 66 00 	lds	r25, 0x0066
    15c2:	28 17       	cp	r18, r24
    15c4:	39 07       	cpc	r19, r25
    15c6:	08 f4       	brcc	.+2      	; 0x15ca <vTaskIncrementTick+0xc0>
    15c8:	6a c0       	rjmp	.+212    	; 0x169e <vTaskIncrementTick+0x194>
    15ca:	e0 91 8c 05 	lds	r30, 0x058C
    15ce:	f0 91 8d 05 	lds	r31, 0x058D
    15d2:	80 81       	ld	r24, Z
    15d4:	88 23       	and	r24, r24
    15d6:	99 f0       	breq	.+38     	; 0x15fe <vTaskIncrementTick+0xf4>
    15d8:	e0 91 8c 05 	lds	r30, 0x058C
    15dc:	f0 91 8d 05 	lds	r31, 0x058D
    15e0:	05 80       	ldd	r0, Z+5	; 0x05
    15e2:	f6 81       	ldd	r31, Z+6	; 0x06
    15e4:	e0 2d       	mov	r30, r0
    15e6:	c6 81       	ldd	r28, Z+6	; 0x06
    15e8:	d7 81       	ldd	r29, Z+7	; 0x07
    15ea:	8a 81       	ldd	r24, Y+2	; 0x02
    15ec:	9b 81       	ldd	r25, Y+3	; 0x03
    15ee:	20 91 86 05 	lds	r18, 0x0586
    15f2:	30 91 87 05 	lds	r19, 0x0587
    15f6:	28 17       	cp	r18, r24
    15f8:	39 07       	cpc	r19, r25
    15fa:	f8 f4       	brcc	.+62     	; 0x163a <vTaskIncrementTick+0x130>
    15fc:	19 c0       	rjmp	.+50     	; 0x1630 <vTaskIncrementTick+0x126>
    15fe:	8f ef       	ldi	r24, 0xFF	; 255
    1600:	9f ef       	ldi	r25, 0xFF	; 255
    1602:	90 93 66 00 	sts	0x0066, r25
    1606:	80 93 65 00 	sts	0x0065, r24
    160a:	49 c0       	rjmp	.+146    	; 0x169e <vTaskIncrementTick+0x194>
    160c:	e0 91 8c 05 	lds	r30, 0x058C
    1610:	f0 91 8d 05 	lds	r31, 0x058D
    1614:	05 80       	ldd	r0, Z+5	; 0x05
    1616:	f6 81       	ldd	r31, Z+6	; 0x06
    1618:	e0 2d       	mov	r30, r0
    161a:	c6 81       	ldd	r28, Z+6	; 0x06
    161c:	d7 81       	ldd	r29, Z+7	; 0x07
    161e:	8a 81       	ldd	r24, Y+2	; 0x02
    1620:	9b 81       	ldd	r25, Y+3	; 0x03
    1622:	20 91 86 05 	lds	r18, 0x0586
    1626:	30 91 87 05 	lds	r19, 0x0587
    162a:	28 17       	cp	r18, r24
    162c:	39 07       	cpc	r19, r25
    162e:	28 f4       	brcc	.+10     	; 0x163a <vTaskIncrementTick+0x130>
    1630:	90 93 66 00 	sts	0x0066, r25
    1634:	80 93 65 00 	sts	0x0065, r24
    1638:	32 c0       	rjmp	.+100    	; 0x169e <vTaskIncrementTick+0x194>
    163a:	8e 01       	movw	r16, r28
    163c:	0e 5f       	subi	r16, 0xFE	; 254
    163e:	1f 4f       	sbci	r17, 0xFF	; 255
    1640:	c8 01       	movw	r24, r16
    1642:	0e 94 df 03 	call	0x7be	; 0x7be <uxListRemove>
    1646:	8c 89       	ldd	r24, Y+20	; 0x14
    1648:	9d 89       	ldd	r25, Y+21	; 0x15
    164a:	00 97       	sbiw	r24, 0x00	; 0
    164c:	21 f0       	breq	.+8      	; 0x1656 <vTaskIncrementTick+0x14c>
    164e:	ce 01       	movw	r24, r28
    1650:	0c 96       	adiw	r24, 0x0c	; 12
    1652:	0e 94 df 03 	call	0x7be	; 0x7be <uxListRemove>
    1656:	8e 89       	ldd	r24, Y+22	; 0x16
    1658:	90 91 85 05 	lds	r25, 0x0585
    165c:	98 17       	cp	r25, r24
    165e:	10 f4       	brcc	.+4      	; 0x1664 <vTaskIncrementTick+0x15a>
    1660:	80 93 85 05 	sts	0x0585, r24
    1664:	90 e0       	ldi	r25, 0x00	; 0
    1666:	9c 01       	movw	r18, r24
    1668:	22 0f       	add	r18, r18
    166a:	33 1f       	adc	r19, r19
    166c:	22 0f       	add	r18, r18
    166e:	33 1f       	adc	r19, r19
    1670:	22 0f       	add	r18, r18
    1672:	33 1f       	adc	r19, r19
    1674:	82 0f       	add	r24, r18
    1676:	93 1f       	adc	r25, r19
    1678:	80 57       	subi	r24, 0x70	; 112
    167a:	9a 4f       	sbci	r25, 0xFA	; 250
    167c:	b8 01       	movw	r22, r16
    167e:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInsertEnd>
    1682:	e0 91 8c 05 	lds	r30, 0x058C
    1686:	f0 91 8d 05 	lds	r31, 0x058D
    168a:	80 81       	ld	r24, Z
    168c:	88 23       	and	r24, r24
    168e:	09 f0       	breq	.+2      	; 0x1692 <vTaskIncrementTick+0x188>
    1690:	bd cf       	rjmp	.-134    	; 0x160c <vTaskIncrementTick+0x102>
    1692:	b5 cf       	rjmp	.-150    	; 0x15fe <vTaskIncrementTick+0xf4>
	}
	else
	{
		++uxMissedTicks;
    1694:	80 91 82 05 	lds	r24, 0x0582
    1698:	8f 5f       	subi	r24, 0xFF	; 255
    169a:	80 93 82 05 	sts	0x0582, r24
		{
			vApplicationTickHook();
		}
	}
	#endif /* configUSE_TICK_HOOK */
}
    169e:	df 91       	pop	r29
    16a0:	cf 91       	pop	r28
    16a2:	1f 91       	pop	r17
    16a4:	0f 91       	pop	r16
    16a6:	08 95       	ret

000016a8 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    16a8:	af 92       	push	r10
    16aa:	bf 92       	push	r11
    16ac:	cf 92       	push	r12
    16ae:	df 92       	push	r13
    16b0:	ef 92       	push	r14
    16b2:	ff 92       	push	r15
    16b4:	0f 93       	push	r16
    16b6:	1f 93       	push	r17
    16b8:	cf 93       	push	r28
    16ba:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    16bc:	0f b6       	in	r0, 0x3f	; 63
    16be:	f8 94       	cli
    16c0:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    16c2:	80 91 83 05 	lds	r24, 0x0583
    16c6:	81 50       	subi	r24, 0x01	; 1
    16c8:	80 93 83 05 	sts	0x0583, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    16cc:	80 91 83 05 	lds	r24, 0x0583
    16d0:	88 23       	and	r24, r24
    16d2:	09 f0       	breq	.+2      	; 0x16d6 <xTaskResumeAll+0x2e>
    16d4:	69 c0       	rjmp	.+210    	; 0x17a8 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    16d6:	80 91 88 05 	lds	r24, 0x0588
    16da:	88 23       	and	r24, r24
    16dc:	81 f5       	brne	.+96     	; 0x173e <xTaskResumeAll+0x96>
    16de:	67 c0       	rjmp	.+206    	; 0x17ae <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    16e0:	d6 01       	movw	r26, r12
    16e2:	ed 91       	ld	r30, X+
    16e4:	fc 91       	ld	r31, X
    16e6:	c6 81       	ldd	r28, Z+6	; 0x06
    16e8:	d7 81       	ldd	r29, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
    16ea:	ce 01       	movw	r24, r28
    16ec:	0c 96       	adiw	r24, 0x0c	; 12
    16ee:	0e 94 df 03 	call	0x7be	; 0x7be <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
    16f2:	8e 01       	movw	r16, r28
    16f4:	0e 5f       	subi	r16, 0xFE	; 254
    16f6:	1f 4f       	sbci	r17, 0xFF	; 255
    16f8:	c8 01       	movw	r24, r16
    16fa:	0e 94 df 03 	call	0x7be	; 0x7be <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    16fe:	8e 89       	ldd	r24, Y+22	; 0x16
    1700:	90 91 85 05 	lds	r25, 0x0585
    1704:	98 17       	cp	r25, r24
    1706:	10 f4       	brcc	.+4      	; 0x170c <xTaskResumeAll+0x64>
    1708:	80 93 85 05 	sts	0x0585, r24
    170c:	90 e0       	ldi	r25, 0x00	; 0
    170e:	9c 01       	movw	r18, r24
    1710:	22 0f       	add	r18, r18
    1712:	33 1f       	adc	r19, r19
    1714:	22 0f       	add	r18, r18
    1716:	33 1f       	adc	r19, r19
    1718:	22 0f       	add	r18, r18
    171a:	33 1f       	adc	r19, r19
    171c:	82 0f       	add	r24, r18
    171e:	93 1f       	adc	r25, r19
    1720:	80 57       	subi	r24, 0x70	; 112
    1722:	9a 4f       	sbci	r25, 0xFA	; 250
    1724:	b8 01       	movw	r22, r16
    1726:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    172a:	e0 91 7e 05 	lds	r30, 0x057E
    172e:	f0 91 7f 05 	lds	r31, 0x057F
    1732:	9e 89       	ldd	r25, Y+22	; 0x16
    1734:	86 89       	ldd	r24, Z+22	; 0x16
    1736:	98 17       	cp	r25, r24
    1738:	88 f0       	brcs	.+34     	; 0x175c <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    173a:	ba 2c       	mov	r11, r10
    173c:	0f c0       	rjmp	.+30     	; 0x175c <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    173e:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    1740:	0f 2e       	mov	r0, r31
    1742:	f6 ec       	ldi	r31, 0xC6	; 198
    1744:	ef 2e       	mov	r14, r31
    1746:	f5 e0       	ldi	r31, 0x05	; 5
    1748:	ff 2e       	mov	r15, r31
    174a:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    174c:	0f 2e       	mov	r0, r31
    174e:	fb ec       	ldi	r31, 0xCB	; 203
    1750:	cf 2e       	mov	r12, r31
    1752:	f5 e0       	ldi	r31, 0x05	; 5
    1754:	df 2e       	mov	r13, r31
    1756:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    1758:	aa 24       	eor	r10, r10
    175a:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    175c:	f7 01       	movw	r30, r14
    175e:	80 81       	ld	r24, Z
    1760:	88 23       	and	r24, r24
    1762:	09 f0       	breq	.+2      	; 0x1766 <xTaskResumeAll+0xbe>
    1764:	bd cf       	rjmp	.-134    	; 0x16e0 <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1766:	80 91 82 05 	lds	r24, 0x0582
    176a:	88 23       	and	r24, r24
    176c:	81 f0       	breq	.+32     	; 0x178e <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    176e:	80 91 82 05 	lds	r24, 0x0582
    1772:	88 23       	and	r24, r24
    1774:	99 f0       	breq	.+38     	; 0x179c <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    1776:	0e 94 85 0a 	call	0x150a	; 0x150a <vTaskIncrementTick>
						--uxMissedTicks;
    177a:	80 91 82 05 	lds	r24, 0x0582
    177e:	81 50       	subi	r24, 0x01	; 1
    1780:	80 93 82 05 	sts	0x0582, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    1784:	80 91 82 05 	lds	r24, 0x0582
    1788:	88 23       	and	r24, r24
    178a:	a9 f7       	brne	.-22     	; 0x1776 <xTaskResumeAll+0xce>
    178c:	07 c0       	rjmp	.+14     	; 0x179c <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    178e:	f1 e0       	ldi	r31, 0x01	; 1
    1790:	bf 16       	cp	r11, r31
    1792:	21 f0       	breq	.+8      	; 0x179c <xTaskResumeAll+0xf4>
    1794:	80 91 81 05 	lds	r24, 0x0581
    1798:	81 30       	cpi	r24, 0x01	; 1
    179a:	41 f4       	brne	.+16     	; 0x17ac <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    179c:	10 92 81 05 	sts	0x0581, r1
					portYIELD_WITHIN_API();
    17a0:	0e 94 cb 04 	call	0x996	; 0x996 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    17a4:	81 e0       	ldi	r24, 0x01	; 1
    17a6:	03 c0       	rjmp	.+6      	; 0x17ae <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    17a8:	80 e0       	ldi	r24, 0x00	; 0
    17aa:	01 c0       	rjmp	.+2      	; 0x17ae <xTaskResumeAll+0x106>
    17ac:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    17ae:	0f 90       	pop	r0
    17b0:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    17b2:	df 91       	pop	r29
    17b4:	cf 91       	pop	r28
    17b6:	1f 91       	pop	r17
    17b8:	0f 91       	pop	r16
    17ba:	ff 90       	pop	r15
    17bc:	ef 90       	pop	r14
    17be:	df 90       	pop	r13
    17c0:	cf 90       	pop	r12
    17c2:	bf 90       	pop	r11
    17c4:	af 90       	pop	r10
    17c6:	08 95       	ret

000017c8 <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    17c8:	0f ec       	ldi	r16, 0xCF	; 207
    17ca:	15 e0       	ldi	r17, 0x05	; 5
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    17cc:	0f 2e       	mov	r0, r31
    17ce:	f4 ed       	ldi	r31, 0xD4	; 212
    17d0:	ef 2e       	mov	r14, r31
    17d2:	f5 e0       	ldi	r31, 0x05	; 5
    17d4:	ff 2e       	mov	r15, r31
    17d6:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    17d8:	0f 2e       	mov	r0, r31
    17da:	f0 e9       	ldi	r31, 0x90	; 144
    17dc:	cf 2e       	mov	r12, r31
    17de:	f5 e0       	ldi	r31, 0x05	; 5
    17e0:	df 2e       	mov	r13, r31
    17e2:	f0 2d       	mov	r31, r0
    17e4:	27 c0       	rjmp	.+78     	; 0x1834 <prvIdleTask+0x6c>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
    17e6:	0e 94 6d 0a 	call	0x14da	; 0x14da <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    17ea:	d8 01       	movw	r26, r16
    17ec:	cc 91       	ld	r28, X
			xTaskResumeAll();
    17ee:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    17f2:	cc 23       	and	r28, r28
    17f4:	f9 f0       	breq	.+62     	; 0x1834 <prvIdleTask+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    17f6:	0f b6       	in	r0, 0x3f	; 63
    17f8:	f8 94       	cli
    17fa:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    17fc:	d7 01       	movw	r26, r14
    17fe:	ed 91       	ld	r30, X+
    1800:	fc 91       	ld	r31, X
    1802:	c6 81       	ldd	r28, Z+6	; 0x06
    1804:	d7 81       	ldd	r29, Z+7	; 0x07
					uxListRemove( &( pxTCB->xGenericListItem ) );
    1806:	ce 01       	movw	r24, r28
    1808:	02 96       	adiw	r24, 0x02	; 2
    180a:	0e 94 df 03 	call	0x7be	; 0x7be <uxListRemove>
					--uxCurrentNumberOfTasks;
    180e:	80 91 88 05 	lds	r24, 0x0588
    1812:	81 50       	subi	r24, 0x01	; 1
    1814:	80 93 88 05 	sts	0x0588, r24
					--uxTasksDeleted;
    1818:	80 91 89 05 	lds	r24, 0x0589
    181c:	81 50       	subi	r24, 0x01	; 1
    181e:	80 93 89 05 	sts	0x0589, r24
				}
				taskEXIT_CRITICAL();
    1822:	0f 90       	pop	r0
    1824:	0f be       	out	0x3f, r0	; 63
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    1826:	8f 89       	ldd	r24, Y+23	; 0x17
    1828:	98 8d       	ldd	r25, Y+24	; 0x18
    182a:	0e 94 4b 03 	call	0x696	; 0x696 <vPortFree>
		vPortFree( pxTCB );
    182e:	ce 01       	movw	r24, r28
    1830:	0e 94 4b 03 	call	0x696	; 0x696 <vPortFree>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    1834:	80 91 89 05 	lds	r24, 0x0589
    1838:	88 23       	and	r24, r24
    183a:	a9 f6       	brne	.-86     	; 0x17e6 <prvIdleTask+0x1e>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    183c:	f6 01       	movw	r30, r12
    183e:	80 81       	ld	r24, Z
    1840:	82 30       	cpi	r24, 0x02	; 2
    1842:	c0 f3       	brcs	.-16     	; 0x1834 <prvIdleTask+0x6c>
			{
				taskYIELD();
    1844:	0e 94 cb 04 	call	0x996	; 0x996 <vPortYield>
    1848:	f5 cf       	rjmp	.-22     	; 0x1834 <prvIdleTask+0x6c>

0000184a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( uint16_t xTicksToDelay )
	{
    184a:	cf 93       	push	r28
    184c:	df 93       	push	r29
    184e:	ec 01       	movw	r28, r24
	uint16_t xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( uint16_t ) 0U )
    1850:	00 97       	sbiw	r24, 0x00	; 0
    1852:	b1 f0       	breq	.+44     	; 0x1880 <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    1854:	0e 94 6d 0a 	call	0x14da	; 0x14da <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1858:	80 91 86 05 	lds	r24, 0x0586
    185c:	90 91 87 05 	lds	r25, 0x0587
    1860:	c8 0f       	add	r28, r24
    1862:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    1864:	80 91 7e 05 	lds	r24, 0x057E
    1868:	90 91 7f 05 	lds	r25, 0x057F
    186c:	02 96       	adiw	r24, 0x02	; 2
    186e:	0e 94 df 03 	call	0x7be	; 0x7be <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1872:	ce 01       	movw	r24, r28
    1874:	0e 94 a2 08 	call	0x1144	; 0x1144 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1878:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    187c:	88 23       	and	r24, r24
    187e:	11 f4       	brne	.+4      	; 0x1884 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    1880:	0e 94 cb 04 	call	0x996	; 0x996 <vPortYield>
		}
	}
    1884:	df 91       	pop	r29
    1886:	cf 91       	pop	r28
    1888:	08 95       	ret

0000188a <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( uint16_t * const pxPreviousWakeTime, uint16_t xTimeIncrement )
	{
    188a:	0f 93       	push	r16
    188c:	1f 93       	push	r17
    188e:	cf 93       	push	r28
    1890:	df 93       	push	r29
    1892:	8c 01       	movw	r16, r24
    1894:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

if( *pxPreviousWakeTime!=xTickCount )
    1896:	80 91 86 05 	lds	r24, 0x0586
    189a:	90 91 87 05 	lds	r25, 0x0587
    189e:	f8 01       	movw	r30, r16
    18a0:	20 81       	ld	r18, Z
    18a2:	31 81       	ldd	r19, Z+1	; 0x01
    18a4:	28 17       	cp	r18, r24
    18a6:	39 07       	cpc	r19, r25
    18a8:	09 f0       	breq	.+2      	; 0x18ac <vTaskDelayUntil+0x22>
{
    asm ("nop");
    18aa:	00 00       	nop
    
}

		vTaskSuspendAll();
    18ac:	0e 94 6d 0a 	call	0x14da	; 0x14da <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    18b0:	f8 01       	movw	r30, r16
    18b2:	80 81       	ld	r24, Z
    18b4:	91 81       	ldd	r25, Z+1	; 0x01
    18b6:	c8 0f       	add	r28, r24
    18b8:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    18ba:	20 91 86 05 	lds	r18, 0x0586
    18be:	30 91 87 05 	lds	r19, 0x0587
    18c2:	28 17       	cp	r18, r24
    18c4:	39 07       	cpc	r19, r25
    18c6:	68 f4       	brcc	.+26     	; 0x18e2 <vTaskDelayUntil+0x58>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    18c8:	c8 17       	cp	r28, r24
    18ca:	d9 07       	cpc	r29, r25
    18cc:	50 f5       	brcc	.+84     	; 0x1922 <vTaskDelayUntil+0x98>
    18ce:	80 91 86 05 	lds	r24, 0x0586
    18d2:	90 91 87 05 	lds	r25, 0x0587
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    18d6:	d1 83       	std	Z+1, r29	; 0x01
    18d8:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    18da:	8c 17       	cp	r24, r28
    18dc:	9d 07       	cpc	r25, r29
    18de:	b0 f4       	brcc	.+44     	; 0x190c <vTaskDelayUntil+0x82>
    18e0:	0b c0       	rjmp	.+22     	; 0x18f8 <vTaskDelayUntil+0x6e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    18e2:	c8 17       	cp	r28, r24
    18e4:	d9 07       	cpc	r29, r25
    18e6:	c8 f0       	brcs	.+50     	; 0x191a <vTaskDelayUntil+0x90>
    18e8:	80 91 86 05 	lds	r24, 0x0586
    18ec:	90 91 87 05 	lds	r25, 0x0587
    18f0:	8c 17       	cp	r24, r28
    18f2:	9d 07       	cpc	r25, r29
    18f4:	90 f0       	brcs	.+36     	; 0x191a <vTaskDelayUntil+0x90>
    18f6:	15 c0       	rjmp	.+42     	; 0x1922 <vTaskDelayUntil+0x98>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    18f8:	80 91 7e 05 	lds	r24, 0x057E
    18fc:	90 91 7f 05 	lds	r25, 0x057F
    1900:	02 96       	adiw	r24, 0x02	; 2
    1902:	0e 94 df 03 	call	0x7be	; 0x7be <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1906:	ce 01       	movw	r24, r28
    1908:	0e 94 a2 08 	call	0x1144	; 0x1144 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    190c:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1910:	88 23       	and	r24, r24
    1912:	59 f4       	brne	.+22     	; 0x192a <vTaskDelayUntil+0xa0>
		{
			portYIELD_WITHIN_API();
    1914:	0e 94 cb 04 	call	0x996	; 0x996 <vPortYield>
    1918:	08 c0       	rjmp	.+16     	; 0x192a <vTaskDelayUntil+0xa0>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    191a:	f8 01       	movw	r30, r16
    191c:	d1 83       	std	Z+1, r29	; 0x01
    191e:	c0 83       	st	Z, r28
    1920:	eb cf       	rjmp	.-42     	; 0x18f8 <vTaskDelayUntil+0x6e>
    1922:	f8 01       	movw	r30, r16
    1924:	d1 83       	std	Z+1, r29	; 0x01
    1926:	c0 83       	st	Z, r28
    1928:	f1 cf       	rjmp	.-30     	; 0x190c <vTaskDelayUntil+0x82>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    192a:	df 91       	pop	r29
    192c:	cf 91       	pop	r28
    192e:	1f 91       	pop	r17
    1930:	0f 91       	pop	r16
    1932:	08 95       	ret

00001934 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1934:	80 91 83 05 	lds	r24, 0x0583
    1938:	88 23       	and	r24, r24
    193a:	99 f4       	brne	.+38     	; 0x1962 <vTaskSwitchContext+0x2e>
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    193c:	80 91 85 05 	lds	r24, 0x0585
    1940:	90 e0       	ldi	r25, 0x00	; 0
    1942:	fc 01       	movw	r30, r24
    1944:	ee 0f       	add	r30, r30
    1946:	ff 1f       	adc	r31, r31
    1948:	ee 0f       	add	r30, r30
    194a:	ff 1f       	adc	r31, r31
    194c:	ee 0f       	add	r30, r30
    194e:	ff 1f       	adc	r31, r31
    1950:	8e 0f       	add	r24, r30
    1952:	9f 1f       	adc	r25, r31
    1954:	fc 01       	movw	r30, r24
    1956:	e0 57       	subi	r30, 0x70	; 112
    1958:	fa 4f       	sbci	r31, 0xFA	; 250
    195a:	80 81       	ld	r24, Z
    195c:	88 23       	and	r24, r24
    195e:	29 f0       	breq	.+10     	; 0x196a <vTaskSwitchContext+0x36>
    1960:	1b c0       	rjmp	.+54     	; 0x1998 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1962:	81 e0       	ldi	r24, 0x01	; 1
    1964:	80 93 81 05 	sts	0x0581, r24
    1968:	08 95       	ret
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    196a:	80 91 85 05 	lds	r24, 0x0585
    196e:	81 50       	subi	r24, 0x01	; 1
    1970:	80 93 85 05 	sts	0x0585, r24
    1974:	80 91 85 05 	lds	r24, 0x0585
    1978:	90 e0       	ldi	r25, 0x00	; 0
    197a:	fc 01       	movw	r30, r24
    197c:	ee 0f       	add	r30, r30
    197e:	ff 1f       	adc	r31, r31
    1980:	ee 0f       	add	r30, r30
    1982:	ff 1f       	adc	r31, r31
    1984:	ee 0f       	add	r30, r30
    1986:	ff 1f       	adc	r31, r31
    1988:	8e 0f       	add	r24, r30
    198a:	9f 1f       	adc	r25, r31
    198c:	fc 01       	movw	r30, r24
    198e:	e0 57       	subi	r30, 0x70	; 112
    1990:	fa 4f       	sbci	r31, 0xFA	; 250
    1992:	80 81       	ld	r24, Z
    1994:	88 23       	and	r24, r24
    1996:	49 f3       	breq	.-46     	; 0x196a <vTaskSwitchContext+0x36>
    1998:	80 91 85 05 	lds	r24, 0x0585
    199c:	90 e0       	ldi	r25, 0x00	; 0
    199e:	fc 01       	movw	r30, r24
    19a0:	ee 0f       	add	r30, r30
    19a2:	ff 1f       	adc	r31, r31
    19a4:	ee 0f       	add	r30, r30
    19a6:	ff 1f       	adc	r31, r31
    19a8:	ee 0f       	add	r30, r30
    19aa:	ff 1f       	adc	r31, r31
    19ac:	e8 0f       	add	r30, r24
    19ae:	f9 1f       	adc	r31, r25
    19b0:	e0 57       	subi	r30, 0x70	; 112
    19b2:	fa 4f       	sbci	r31, 0xFA	; 250
    19b4:	a1 81       	ldd	r26, Z+1	; 0x01
    19b6:	b2 81       	ldd	r27, Z+2	; 0x02
    19b8:	12 96       	adiw	r26, 0x02	; 2
    19ba:	0d 90       	ld	r0, X+
    19bc:	bc 91       	ld	r27, X
    19be:	a0 2d       	mov	r26, r0
    19c0:	b2 83       	std	Z+2, r27	; 0x02
    19c2:	a1 83       	std	Z+1, r26	; 0x01
    19c4:	cf 01       	movw	r24, r30
    19c6:	03 96       	adiw	r24, 0x03	; 3
    19c8:	a8 17       	cp	r26, r24
    19ca:	b9 07       	cpc	r27, r25
    19cc:	31 f4       	brne	.+12     	; 0x19da <vTaskSwitchContext+0xa6>
    19ce:	12 96       	adiw	r26, 0x02	; 2
    19d0:	8d 91       	ld	r24, X+
    19d2:	9c 91       	ld	r25, X
    19d4:	13 97       	sbiw	r26, 0x03	; 3
    19d6:	92 83       	std	Z+2, r25	; 0x02
    19d8:	81 83       	std	Z+1, r24	; 0x01
    19da:	01 80       	ldd	r0, Z+1	; 0x01
    19dc:	f2 81       	ldd	r31, Z+2	; 0x02
    19de:	e0 2d       	mov	r30, r0
    19e0:	86 81       	ldd	r24, Z+6	; 0x06
    19e2:	97 81       	ldd	r25, Z+7	; 0x07
    19e4:	90 93 7f 05 	sts	0x057F, r25
    19e8:	80 93 7e 05 	sts	0x057E, r24
    19ec:	08 95       	ret

000019ee <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, uint16_t xTicksToWait )
{
    19ee:	cf 93       	push	r28
    19f0:	df 93       	push	r29
    19f2:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    19f4:	60 91 7e 05 	lds	r22, 0x057E
    19f8:	70 91 7f 05 	lds	r23, 0x057F
    19fc:	64 5f       	subi	r22, 0xF4	; 244
    19fe:	7f 4f       	sbci	r23, 0xFF	; 255
    1a00:	0e 94 95 03 	call	0x72a	; 0x72a <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    1a04:	80 91 7e 05 	lds	r24, 0x057E
    1a08:	90 91 7f 05 	lds	r25, 0x057F
    1a0c:	02 96       	adiw	r24, 0x02	; 2
    1a0e:	0e 94 df 03 	call	0x7be	; 0x7be <uxListRemove>
	}
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    1a12:	80 91 86 05 	lds	r24, 0x0586
    1a16:	90 91 87 05 	lds	r25, 0x0587
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1a1a:	8c 0f       	add	r24, r28
    1a1c:	9d 1f       	adc	r25, r29
    1a1e:	0e 94 a2 08 	call	0x1144	; 0x1144 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1a22:	df 91       	pop	r29
    1a24:	cf 91       	pop	r28
    1a26:	08 95       	ret

00001a28 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    1a28:	0f 93       	push	r16
    1a2a:	1f 93       	push	r17
    1a2c:	cf 93       	push	r28
    1a2e:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1a30:	dc 01       	movw	r26, r24
    1a32:	15 96       	adiw	r26, 0x05	; 5
    1a34:	ed 91       	ld	r30, X+
    1a36:	fc 91       	ld	r31, X
    1a38:	16 97       	sbiw	r26, 0x06	; 6
    1a3a:	06 81       	ldd	r16, Z+6	; 0x06
    1a3c:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1a3e:	e8 01       	movw	r28, r16
    1a40:	2c 96       	adiw	r28, 0x0c	; 12
    1a42:	ce 01       	movw	r24, r28
    1a44:	0e 94 df 03 	call	0x7be	; 0x7be <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    1a48:	80 91 83 05 	lds	r24, 0x0583
    1a4c:	88 23       	and	r24, r24
    1a4e:	e9 f4       	brne	.+58     	; 0x1a8a <xTaskRemoveFromEventList+0x62>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1a50:	e8 01       	movw	r28, r16
    1a52:	22 96       	adiw	r28, 0x02	; 2
    1a54:	ce 01       	movw	r24, r28
    1a56:	0e 94 df 03 	call	0x7be	; 0x7be <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    1a5a:	f8 01       	movw	r30, r16
    1a5c:	86 89       	ldd	r24, Z+22	; 0x16
    1a5e:	90 91 85 05 	lds	r25, 0x0585
    1a62:	98 17       	cp	r25, r24
    1a64:	10 f4       	brcc	.+4      	; 0x1a6a <xTaskRemoveFromEventList+0x42>
    1a66:	80 93 85 05 	sts	0x0585, r24
    1a6a:	90 e0       	ldi	r25, 0x00	; 0
    1a6c:	9c 01       	movw	r18, r24
    1a6e:	22 0f       	add	r18, r18
    1a70:	33 1f       	adc	r19, r19
    1a72:	22 0f       	add	r18, r18
    1a74:	33 1f       	adc	r19, r19
    1a76:	22 0f       	add	r18, r18
    1a78:	33 1f       	adc	r19, r19
    1a7a:	82 0f       	add	r24, r18
    1a7c:	93 1f       	adc	r25, r19
    1a7e:	80 57       	subi	r24, 0x70	; 112
    1a80:	9a 4f       	sbci	r25, 0xFA	; 250
    1a82:	be 01       	movw	r22, r28
    1a84:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInsertEnd>
    1a88:	05 c0       	rjmp	.+10     	; 0x1a94 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1a8a:	86 ec       	ldi	r24, 0xC6	; 198
    1a8c:	95 e0       	ldi	r25, 0x05	; 5
    1a8e:	be 01       	movw	r22, r28
    1a90:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1a94:	e0 91 7e 05 	lds	r30, 0x057E
    1a98:	f0 91 7f 05 	lds	r31, 0x057F
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    1a9c:	81 e0       	ldi	r24, 0x01	; 1
    1a9e:	d8 01       	movw	r26, r16
    1aa0:	56 96       	adiw	r26, 0x16	; 22
    1aa2:	2c 91       	ld	r18, X
    1aa4:	56 97       	sbiw	r26, 0x16	; 22
    1aa6:	96 89       	ldd	r25, Z+22	; 0x16
    1aa8:	29 17       	cp	r18, r25
    1aaa:	08 f4       	brcc	.+2      	; 0x1aae <xTaskRemoveFromEventList+0x86>
    1aac:	80 e0       	ldi	r24, 0x00	; 0
}
    1aae:	df 91       	pop	r29
    1ab0:	cf 91       	pop	r28
    1ab2:	1f 91       	pop	r17
    1ab4:	0f 91       	pop	r16
    1ab6:	08 95       	ret

00001ab8 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    1ab8:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1aba:	80 91 80 05 	lds	r24, 0x0580
    1abe:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    1ac0:	40 91 86 05 	lds	r20, 0x0586
    1ac4:	50 91 87 05 	lds	r21, 0x0587
    1ac8:	60 e0       	ldi	r22, 0x00	; 0
    1aca:	70 e0       	ldi	r23, 0x00	; 0
    1acc:	41 83       	std	Z+1, r20	; 0x01
    1ace:	52 83       	std	Z+2, r21	; 0x02
    1ad0:	63 83       	std	Z+3, r22	; 0x03
    1ad2:	74 83       	std	Z+4, r23	; 0x04
}
    1ad4:	08 95       	ret

00001ad6 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, uint16_t * const pxTicksToWait )
{
    1ad6:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1ad8:	0f b6       	in	r0, 0x3f	; 63
    1ada:	f8 94       	cli
    1adc:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( uint16_t ) xTickCount >= ( uint16_t ) pxTimeOut->xTimeOnEntering ) )
    1ade:	80 91 80 05 	lds	r24, 0x0580
    1ae2:	90 81       	ld	r25, Z
    1ae4:	98 17       	cp	r25, r24
    1ae6:	49 f0       	breq	.+18     	; 0x1afa <xTaskCheckForTimeOut+0x24>
    1ae8:	80 91 86 05 	lds	r24, 0x0586
    1aec:	90 91 87 05 	lds	r25, 0x0587
    1af0:	21 81       	ldd	r18, Z+1	; 0x01
    1af2:	32 81       	ldd	r19, Z+2	; 0x02
    1af4:	82 17       	cp	r24, r18
    1af6:	93 07       	cpc	r25, r19
    1af8:	f0 f4       	brcc	.+60     	; 0x1b36 <xTaskCheckForTimeOut+0x60>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( uint16_t ) ( ( uint16_t ) xTickCount - ( uint16_t ) pxTimeOut->xTimeOnEntering ) ) < ( uint16_t ) *pxTicksToWait )
    1afa:	80 91 86 05 	lds	r24, 0x0586
    1afe:	90 91 87 05 	lds	r25, 0x0587
    1b02:	21 81       	ldd	r18, Z+1	; 0x01
    1b04:	32 81       	ldd	r19, Z+2	; 0x02
    1b06:	db 01       	movw	r26, r22
    1b08:	4d 91       	ld	r20, X+
    1b0a:	5c 91       	ld	r21, X
    1b0c:	11 97       	sbiw	r26, 0x01	; 1
    1b0e:	82 1b       	sub	r24, r18
    1b10:	93 0b       	sbc	r25, r19
    1b12:	84 17       	cp	r24, r20
    1b14:	95 07       	cpc	r25, r21
    1b16:	88 f4       	brcc	.+34     	; 0x1b3a <xTaskCheckForTimeOut+0x64>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( uint16_t ) xTickCount - ( uint16_t ) pxTimeOut->xTimeOnEntering );
    1b18:	80 91 86 05 	lds	r24, 0x0586
    1b1c:	90 91 87 05 	lds	r25, 0x0587
    1b20:	28 1b       	sub	r18, r24
    1b22:	39 0b       	sbc	r19, r25
    1b24:	24 0f       	add	r18, r20
    1b26:	35 1f       	adc	r19, r21
    1b28:	2d 93       	st	X+, r18
    1b2a:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    1b2c:	cf 01       	movw	r24, r30
    1b2e:	0e 94 5c 0d 	call	0x1ab8	; 0x1ab8 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1b32:	80 e0       	ldi	r24, 0x00	; 0
    1b34:	03 c0       	rjmp	.+6      	; 0x1b3c <xTaskCheckForTimeOut+0x66>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    1b36:	81 e0       	ldi	r24, 0x01	; 1
    1b38:	01 c0       	rjmp	.+2      	; 0x1b3c <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1b3a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1b3c:	0f 90       	pop	r0
    1b3e:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1b40:	08 95       	ret

00001b42 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1b42:	81 e0       	ldi	r24, 0x01	; 1
    1b44:	80 93 81 05 	sts	0x0581, r24
}
    1b48:	08 95       	ret

00001b4a <executeCommunicationTask>:
    xTaskCreate( executeCommunicationTask, ( signed char * ) "commTask", sysCommunicationTaskSTACK_SIZE,  ( void * ) taskParams , uxPriority, ( xTaskHandle * ) NULL );
}


static portTASK_FUNCTION( executeCommunicationTask, pvParameters )
{
    1b4a:	cf 93       	push	r28
    1b4c:	df 93       	push	r29
    1b4e:	00 d0       	rcall	.+0      	; 0x1b50 <executeCommunicationTask+0x6>
    1b50:	00 d0       	rcall	.+0      	; 0x1b52 <executeCommunicationTask+0x8>
    1b52:	00 d0       	rcall	.+0      	; 0x1b54 <executeCommunicationTask+0xa>
    1b54:	cd b7       	in	r28, 0x3d	; 61
    1b56:	de b7       	in	r29, 0x3e	; 62
    1b58:	7c 01       	movw	r14, r24
    uint8_t successFlag=0;
    
    taskParams = ( communicationTaskParameters * ) pvParameters;
        
    //Initialize the wake up time with the current time
    xLastWakeUpTime = xTaskGetTickCount();    
    1b5a:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <xTaskGetTickCount>
    1b5e:	a0 e0       	ldi	r26, 0x00	; 0
    1b60:	b0 e0       	ldi	r27, 0x00	; 0
    1b62:	89 83       	std	Y+1, r24	; 0x01
    1b64:	9a 83       	std	Y+2, r25	; 0x02
    1b66:	ab 83       	std	Y+3, r26	; 0x03
    1b68:	bc 83       	std	Y+4, r27	; 0x04
    
    for(;;)
    {
        vTaskDelayUntil( &xLastWakeUpTime, COMMUNICATION_TASK_CYCLE );
    1b6a:	ce 01       	movw	r24, r28
    1b6c:	01 96       	adiw	r24, 0x01	; 1
    1b6e:	64 ef       	ldi	r22, 0xF4	; 244
    1b70:	71 e0       	ldi	r23, 0x01	; 1
    1b72:	0e 94 45 0c 	call	0x188a	; 0x188a <vTaskDelayUntil>
                
        //Execute this task each 50ms
        batteryVoltage_mVolt = measureBattVoltage();
    1b76:	0e 94 6f 00 	call	0xde	; 0xde <measureBattVoltage>
        //consumerCurrent_mAmps = measureConsumerCurrent();
        //!!measure also solar voltage!!!
        
        //send new battery voltage value via measurement queue
        //first: prepare message
        measurementMsg->valueId = ID_BATTERY_VOLTAGE;
    1b7a:	ed 81       	ldd	r30, Y+5	; 0x05
    1b7c:	fe 81       	ldd	r31, Y+6	; 0x06
    1b7e:	10 82       	st	Z, r1
        measurementMsg->value = batteryVoltage_mVolt;
    1b80:	ed 81       	ldd	r30, Y+5	; 0x05
    1b82:	fe 81       	ldd	r31, Y+6	; 0x06
    1b84:	92 83       	std	Z+2, r25	; 0x02
    1b86:	81 83       	std	Z+1, r24	; 0x01
           
        //second: send queue
        successFlag = xQueueSend( taskParams->measurementQueue, &measurementMsg, ( portTickType ) 10  ) ;
    1b88:	f7 01       	movw	r30, r14
    1b8a:	80 81       	ld	r24, Z
    1b8c:	91 81       	ldd	r25, Z+1	; 0x01
    1b8e:	be 01       	movw	r22, r28
    1b90:	6b 5f       	subi	r22, 0xFB	; 251
    1b92:	7f 4f       	sbci	r23, 0xFF	; 255
    1b94:	2a e0       	ldi	r18, 0x0A	; 10
    1b96:	30 e0       	ldi	r19, 0x00	; 0
    1b98:	40 e0       	ldi	r20, 0x00	; 0
    1b9a:	50 e0       	ldi	r21, 0x00	; 0
    1b9c:	00 e0       	ldi	r16, 0x00	; 0
    1b9e:	0e 94 b7 06 	call	0xd6e	; 0xd6e <xQueueGenericSend>
    1ba2:	e3 cf       	rjmp	.-58     	; 0x1b6a <executeCommunicationTask+0x20>

00001ba4 <startCommunicationTask>:
*/
static portBASE_TYPE xCommunicationTaskStatus = pdPASS;


void startCommunicationTask( unsigned portBASE_TYPE uxPriority, xQueueHandle* measQueue )
{  
    1ba4:	af 92       	push	r10
    1ba6:	bf 92       	push	r11
    1ba8:	cf 92       	push	r12
    1baa:	df 92       	push	r13
    1bac:	ef 92       	push	r14
    1bae:	ff 92       	push	r15
    1bb0:	0f 93       	push	r16
    1bb2:	cf 93       	push	r28
    1bb4:	df 93       	push	r29
    1bb6:	08 2f       	mov	r16, r24
    1bb8:	eb 01       	movw	r28, r22
    adcInit();
    1bba:	0e 94 49 00 	call	0x92	; 0x92 <adcInit>
        
    //Set high side driver pins to outputs
    DDRC |= ( (1<<PC6) | (1<<PC7) );    
    1bbe:	84 b3       	in	r24, 0x14	; 20
    1bc0:	80 6c       	ori	r24, 0xC0	; 192
    1bc2:	84 bb       	out	0x14, r24	; 20
    //switch on high side driver
    PORTC |=  ( (1<<PC6) | (1<<PC7) );       
    1bc4:	85 b3       	in	r24, 0x15	; 21
    1bc6:	80 6c       	ori	r24, 0xC0	; 192
    1bc8:	85 bb       	out	0x15, r24	; 21
        
    //create task parameter
    communicationTaskParameters *taskParams;
    taskParams = ( communicationTaskParameters * ) pvPortMalloc( sizeof( communicationTaskParameters ) );
    1bca:	82 e0       	ldi	r24, 0x02	; 2
    1bcc:	90 e0       	ldi	r25, 0x00	; 0
    1bce:	0e 94 15 03 	call	0x62a	; 0x62a <pvPortMalloc>
    1bd2:	9c 01       	movw	r18, r24
    taskParams->measurementQueue = *measQueue;
    1bd4:	88 81       	ld	r24, Y
    1bd6:	99 81       	ldd	r25, Y+1	; 0x01
    1bd8:	f9 01       	movw	r30, r18
    1bda:	91 83       	std	Z+1, r25	; 0x01
    1bdc:	80 83       	st	Z, r24
    //taskParams->statusQueue = *statQueue;
    
    xTaskCreate( executeCommunicationTask, ( signed char * ) "commTask", sysCommunicationTaskSTACK_SIZE,  ( void * ) taskParams , uxPriority, ( xTaskHandle * ) NULL );
    1bde:	85 ea       	ldi	r24, 0xA5	; 165
    1be0:	9d e0       	ldi	r25, 0x0D	; 13
    1be2:	67 e6       	ldi	r22, 0x67	; 103
    1be4:	70 e0       	ldi	r23, 0x00	; 0
    1be6:	45 e5       	ldi	r20, 0x55	; 85
    1be8:	50 e0       	ldi	r21, 0x00	; 0
    1bea:	ee 24       	eor	r14, r14
    1bec:	ff 24       	eor	r15, r15
    1bee:	cc 24       	eor	r12, r12
    1bf0:	dd 24       	eor	r13, r13
    1bf2:	aa 24       	eor	r10, r10
    1bf4:	bb 24       	eor	r11, r11
    1bf6:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <xTaskGenericCreate>
}
    1bfa:	df 91       	pop	r29
    1bfc:	cf 91       	pop	r28
    1bfe:	0f 91       	pop	r16
    1c00:	ff 90       	pop	r15
    1c02:	ef 90       	pop	r14
    1c04:	df 90       	pop	r13
    1c06:	cf 90       	pop	r12
    1c08:	bf 90       	pop	r11
    1c0a:	af 90       	pop	r10
    1c0c:	08 95       	ret

00001c0e <xIsCommunicationTaskStillRunning>:
	{
		xReturn = pdPASS;
	}

	return xReturn;
    1c0e:	81 e0       	ldi	r24, 0x01	; 1
    1c10:	08 95       	ret

00001c12 <executeNavigatorTask>:
    xTaskCreate( executeNavigatorTask, ( signed char * ) "NavTask", sysNavigatorTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
}


static portTASK_FUNCTION( executeNavigatorTask, pvParameters )
{
    1c12:	cf 93       	push	r28
    1c14:	df 93       	push	r29
    1c16:	00 d0       	rcall	.+0      	; 0x1c18 <executeNavigatorTask+0x6>
    1c18:	00 d0       	rcall	.+0      	; 0x1c1a <executeNavigatorTask+0x8>
    1c1a:	cd b7       	in	r28, 0x3d	; 61
    1c1c:	de b7       	in	r29, 0x3e	; 62
    uint32_t xLastWakeUpTime;

    //Initialize the wake up time with the current time
    xLastWakeUpTime = xTaskGetTickCount();
    1c1e:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <xTaskGetTickCount>
    1c22:	a0 e0       	ldi	r26, 0x00	; 0
    1c24:	b0 e0       	ldi	r27, 0x00	; 0
    1c26:	89 83       	std	Y+1, r24	; 0x01
    1c28:	9a 83       	std	Y+2, r25	; 0x02
    1c2a:	ab 83       	std	Y+3, r26	; 0x03
    1c2c:	bc 83       	std	Y+4, r27	; 0x04

    for(;;)
    {
        //Execute this task each 50ms
        vTaskDelayUntil( &xLastWakeUpTime, NAVIGATOR_TASK_CYCLE );
    1c2e:	ce 01       	movw	r24, r28
    1c30:	01 96       	adiw	r24, 0x01	; 1
    1c32:	64 e6       	ldi	r22, 0x64	; 100
    1c34:	70 e0       	ldi	r23, 0x00	; 0
    1c36:	0e 94 45 0c 	call	0x188a	; 0x188a <vTaskDelayUntil>
    1c3a:	f9 cf       	rjmp	.-14     	; 0x1c2e <executeNavigatorTask+0x1c>

00001c3c <startNavigatorTask>:
   Used to signal an error condition inside this task
*/
static portBASE_TYPE xNavigatorTaskStatus = pdPASS;

void startNavigatorTask( unsigned portBASE_TYPE uxPriority, xQueueHandle *statQueue )
{
    1c3c:	af 92       	push	r10
    1c3e:	bf 92       	push	r11
    1c40:	cf 92       	push	r12
    1c42:	df 92       	push	r13
    1c44:	ef 92       	push	r14
    1c46:	ff 92       	push	r15
    1c48:	0f 93       	push	r16
    1c4a:	cf 93       	push	r28
    1c4c:	df 93       	push	r29
    1c4e:	08 2f       	mov	r16, r24
    1c50:	eb 01       	movw	r28, r22
    //set pins PB0 (green LED) & PB1 (red LED) to outputs
    DDRB |= ( (1<<PB0) | (1<<PB1) );
    1c52:	87 b3       	in	r24, 0x17	; 23
    1c54:	83 60       	ori	r24, 0x03	; 3
    1c56:	87 bb       	out	0x17, r24	; 23
    
    navigatorTaskParameters *taskParams;
    taskParams = ( navigatorTaskParameters * ) pvPortMalloc( sizeof( navigatorTaskParameters ) );
    1c58:	82 e0       	ldi	r24, 0x02	; 2
    1c5a:	90 e0       	ldi	r25, 0x00	; 0
    1c5c:	0e 94 15 03 	call	0x62a	; 0x62a <pvPortMalloc>
    1c60:	9c 01       	movw	r18, r24
    taskParams->statusQueue = *statQueue;
    1c62:	88 81       	ld	r24, Y
    1c64:	99 81       	ldd	r25, Y+1	; 0x01
    1c66:	f9 01       	movw	r30, r18
    1c68:	91 83       	std	Z+1, r25	; 0x01
    1c6a:	80 83       	st	Z, r24

    xTaskCreate( executeNavigatorTask, ( signed char * ) "NavTask", sysNavigatorTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
    1c6c:	89 e0       	ldi	r24, 0x09	; 9
    1c6e:	9e e0       	ldi	r25, 0x0E	; 14
    1c70:	60 e7       	ldi	r22, 0x70	; 112
    1c72:	70 e0       	ldi	r23, 0x00	; 0
    1c74:	45 e5       	ldi	r20, 0x55	; 85
    1c76:	50 e0       	ldi	r21, 0x00	; 0
    1c78:	ee 24       	eor	r14, r14
    1c7a:	ff 24       	eor	r15, r15
    1c7c:	cc 24       	eor	r12, r12
    1c7e:	dd 24       	eor	r13, r13
    1c80:	aa 24       	eor	r10, r10
    1c82:	bb 24       	eor	r11, r11
    1c84:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <xTaskGenericCreate>
}
    1c88:	df 91       	pop	r29
    1c8a:	cf 91       	pop	r28
    1c8c:	0f 91       	pop	r16
    1c8e:	ff 90       	pop	r15
    1c90:	ef 90       	pop	r14
    1c92:	df 90       	pop	r13
    1c94:	cf 90       	pop	r12
    1c96:	bf 90       	pop	r11
    1c98:	af 90       	pop	r10
    1c9a:	08 95       	ret

00001c9c <xIsNavigatorTaskStillRunning>:
    {
        xReturn = pdPASS;
    }

    return xReturn;
    1c9c:	81 e0       	ldi	r24, 0x01	; 1
    1c9e:	08 95       	ret

00001ca0 <executeSensorTask>:
    xTaskCreate( executeSensorTask, ( signed char * ) "SensorTask", sysSensorTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
}


static portTASK_FUNCTION( executeSensorTask, pvParameters )
{
    1ca0:	cf 93       	push	r28
    1ca2:	df 93       	push	r29
    1ca4:	00 d0       	rcall	.+0      	; 0x1ca6 <executeSensorTask+0x6>
    1ca6:	00 d0       	rcall	.+0      	; 0x1ca8 <executeSensorTask+0x8>
    1ca8:	cd b7       	in	r28, 0x3d	; 61
    1caa:	de b7       	in	r29, 0x3e	; 62
    uint32_t xLastWakeUpTime;
    uint16_t ledCycleCounter = 0;
    
    //Initialize the wake up time with the current time
    xLastWakeUpTime = xTaskGetTickCount();
    1cac:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <xTaskGetTickCount>
    1cb0:	a0 e0       	ldi	r26, 0x00	; 0
    1cb2:	b0 e0       	ldi	r27, 0x00	; 0
    1cb4:	89 83       	std	Y+1, r24	; 0x01
    1cb6:	9a 83       	std	Y+2, r25	; 0x02
    1cb8:	ab 83       	std	Y+3, r26	; 0x03
    1cba:	bc 83       	std	Y+4, r27	; 0x04


static portTASK_FUNCTION( executeSensorTask, pvParameters )
{
    uint32_t xLastWakeUpTime;
    uint16_t ledCycleCounter = 0;
    1cbc:	00 e0       	ldi	r16, 0x00	; 0
    1cbe:	10 e0       	ldi	r17, 0x00	; 0
{
    static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xIsCommunicationTaskStillRunning() != pdTRUE )
	{
		xErrorHasOccurred = pdTRUE;
    1cc0:	ff 24       	eor	r15, r15
    1cc2:	f3 94       	inc	r15
        {
            //signal error condition
        }

        //toogle the green led each 500ms
        if( ledCycleCounter % GREEN_LED_TOGGLE_CYCLE == 0 )
    1cc4:	0f 2e       	mov	r0, r31
    1cc6:	f4 ef       	ldi	r31, 0xF4	; 244
    1cc8:	cf 2e       	mov	r12, r31
    1cca:	f1 e0       	ldi	r31, 0x01	; 1
    1ccc:	df 2e       	mov	r13, r31
    1cce:	f0 2d       	mov	r31, r0
        {
            PORTB ^= (1<<PB0);
        }
        
        //toogle the red led each 200ms
        if( ledCycleCounter % RED_LED_TOGGLE_CYCLE == 0 )
    1cd0:	0f 2e       	mov	r0, r31
    1cd2:	f8 ec       	ldi	r31, 0xC8	; 200
    1cd4:	af 2e       	mov	r10, r31
    1cd6:	bb 24       	eor	r11, r11
    1cd8:	f0 2d       	mov	r31, r0
        {
            PORTB ^= (1<<PB1);
    1cda:	ee 24       	eor	r14, r14
    1cdc:	68 94       	set
    1cde:	e1 f8       	bld	r14, 1
        }
        
        
        if( ledCycleCounter > 65000 )
        {
            ledCycleCounter = 0;
    1ce0:	88 24       	eor	r8, r8
    1ce2:	99 24       	eor	r9, r9
    1ce4:	01 c0       	rjmp	.+2      	; 0x1ce8 <executeSensorTask+0x48>
    1ce6:	84 01       	movw	r16, r8
    xLastWakeUpTime = xTaskGetTickCount();

    for(;;)
    {
        //Execute this task each 50ms
        vTaskDelayUntil( &xLastWakeUpTime, SENSOR_TASK_CYCLE );
    1ce8:	ce 01       	movw	r24, r28
    1cea:	01 96       	adiw	r24, 0x01	; 1
    1cec:	64 e6       	ldi	r22, 0x64	; 100
    1cee:	70 e0       	ldi	r23, 0x00	; 0
    1cf0:	0e 94 45 0c 	call	0x188a	; 0x188a <vTaskDelayUntil>

        ledCycleCounter += 50;
    1cf4:	0e 5c       	subi	r16, 0xCE	; 206
    1cf6:	1f 4f       	sbci	r17, 0xFF	; 255
 */
static portBASE_TYPE prvCheckOtherTasksAreStillRunning( void )
{
    static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xIsCommunicationTaskStillRunning() != pdTRUE )
    1cf8:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <xIsCommunicationTaskStillRunning>
    1cfc:	81 30       	cpi	r24, 0x01	; 1
    1cfe:	11 f0       	breq	.+4      	; 0x1d04 <executeSensorTask+0x64>
	{
		xErrorHasOccurred = pdTRUE;
    1d00:	f0 92 d8 05 	sts	0x05D8, r15
	}

	if( xIsOperatorTaskStillRunning() != pdTRUE )
    1d04:	0e 94 27 0f 	call	0x1e4e	; 0x1e4e <xIsOperatorTaskStillRunning>
    1d08:	81 30       	cpi	r24, 0x01	; 1
    1d0a:	11 f0       	breq	.+4      	; 0x1d10 <executeSensorTask+0x70>
	{
		xErrorHasOccurred = pdTRUE;
    1d0c:	f0 92 d8 05 	sts	0x05D8, r15
	}

	if( xIsNavigatorTaskStillRunning() != pdTRUE )
    1d10:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <xIsNavigatorTaskStillRunning>
    1d14:	81 30       	cpi	r24, 0x01	; 1
    1d16:	91 05       	cpc	r25, r1
    1d18:	11 f0       	breq	.+4      	; 0x1d1e <executeSensorTask+0x7e>
	{
    	xErrorHasOccurred = pdTRUE;
    1d1a:	f0 92 d8 05 	sts	0x05D8, r15
        {
            //signal error condition
        }

        //toogle the green led each 500ms
        if( ledCycleCounter % GREEN_LED_TOGGLE_CYCLE == 0 )
    1d1e:	c8 01       	movw	r24, r16
    1d20:	b6 01       	movw	r22, r12
    1d22:	0e 94 48 0f 	call	0x1e90	; 0x1e90 <__udivmodhi4>
    1d26:	00 97       	sbiw	r24, 0x00	; 0
    1d28:	19 f4       	brne	.+6      	; 0x1d30 <executeSensorTask+0x90>
        {
            PORTB ^= (1<<PB0);
    1d2a:	88 b3       	in	r24, 0x18	; 24
    1d2c:	8f 25       	eor	r24, r15
    1d2e:	88 bb       	out	0x18, r24	; 24
        }
        
        //toogle the red led each 200ms
        if( ledCycleCounter % RED_LED_TOGGLE_CYCLE == 0 )
    1d30:	c8 01       	movw	r24, r16
    1d32:	b5 01       	movw	r22, r10
    1d34:	0e 94 48 0f 	call	0x1e90	; 0x1e90 <__udivmodhi4>
    1d38:	00 97       	sbiw	r24, 0x00	; 0
    1d3a:	19 f4       	brne	.+6      	; 0x1d42 <executeSensorTask+0xa2>
        {
            PORTB ^= (1<<PB1);
    1d3c:	88 b3       	in	r24, 0x18	; 24
    1d3e:	8e 25       	eor	r24, r14
    1d40:	88 bb       	out	0x18, r24	; 24
        }
        
        
        if( ledCycleCounter > 65000 )
    1d42:	8d ef       	ldi	r24, 0xFD	; 253
    1d44:	09 3e       	cpi	r16, 0xE9	; 233
    1d46:	18 07       	cpc	r17, r24
    1d48:	70 f6       	brcc	.-100    	; 0x1ce6 <executeSensorTask+0x46>
    1d4a:	ce cf       	rjmp	.-100    	; 0x1ce8 <executeSensorTask+0x48>

00001d4c <startSensorTask>:

static portBASE_TYPE prvCheckOtherTasksAreStillRunning( void );


void startSensorTask( unsigned portBASE_TYPE uxPriority, xQueueHandle *statQueue )
{
    1d4c:	af 92       	push	r10
    1d4e:	bf 92       	push	r11
    1d50:	cf 92       	push	r12
    1d52:	df 92       	push	r13
    1d54:	ef 92       	push	r14
    1d56:	ff 92       	push	r15
    1d58:	0f 93       	push	r16
    1d5a:	cf 93       	push	r28
    1d5c:	df 93       	push	r29
    1d5e:	08 2f       	mov	r16, r24
    1d60:	eb 01       	movw	r28, r22
    //set pins PB0 (green LED) & PB1 (red LED) to outputs
    DDRB |= ( (1<<PB0) | (1<<PB1) );
    1d62:	87 b3       	in	r24, 0x17	; 23
    1d64:	83 60       	ori	r24, 0x03	; 3
    1d66:	87 bb       	out	0x17, r24	; 23
    
    sensorTaskParameters *taskParams;
    taskParams = ( sensorTaskParameters * ) pvPortMalloc( sizeof( sensorTaskParameters ) );
    1d68:	82 e0       	ldi	r24, 0x02	; 2
    1d6a:	90 e0       	ldi	r25, 0x00	; 0
    1d6c:	0e 94 15 03 	call	0x62a	; 0x62a <pvPortMalloc>
    1d70:	9c 01       	movw	r18, r24
    taskParams->statusQueue = *statQueue;
    1d72:	88 81       	ld	r24, Y
    1d74:	99 81       	ldd	r25, Y+1	; 0x01
    1d76:	f9 01       	movw	r30, r18
    1d78:	91 83       	std	Z+1, r25	; 0x01
    1d7a:	80 83       	st	Z, r24

    xTaskCreate( executeSensorTask, ( signed char * ) "SensorTask", sysSensorTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
    1d7c:	80 e5       	ldi	r24, 0x50	; 80
    1d7e:	9e e0       	ldi	r25, 0x0E	; 14
    1d80:	68 e7       	ldi	r22, 0x78	; 120
    1d82:	70 e0       	ldi	r23, 0x00	; 0
    1d84:	45 e5       	ldi	r20, 0x55	; 85
    1d86:	50 e0       	ldi	r21, 0x00	; 0
    1d88:	ee 24       	eor	r14, r14
    1d8a:	ff 24       	eor	r15, r15
    1d8c:	cc 24       	eor	r12, r12
    1d8e:	dd 24       	eor	r13, r13
    1d90:	aa 24       	eor	r10, r10
    1d92:	bb 24       	eor	r11, r11
    1d94:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <xTaskGenericCreate>
}
    1d98:	df 91       	pop	r29
    1d9a:	cf 91       	pop	r28
    1d9c:	0f 91       	pop	r16
    1d9e:	ff 90       	pop	r15
    1da0:	ef 90       	pop	r14
    1da2:	df 90       	pop	r13
    1da4:	cf 90       	pop	r12
    1da6:	bf 90       	pop	r11
    1da8:	af 90       	pop	r10
    1daa:	08 95       	ret

00001dac <executeOperatorTask>:
    xTaskCreate( executeOperatorTask, ( signed char * ) "opTask", sysOperatorTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
}


static portTASK_FUNCTION( executeOperatorTask, pvParameters )
{
    1dac:	cf 93       	push	r28
    1dae:	df 93       	push	r29
    1db0:	00 d0       	rcall	.+0      	; 0x1db2 <executeOperatorTask+0x6>
    1db2:	00 d0       	rcall	.+0      	; 0x1db4 <executeOperatorTask+0x8>
    1db4:	00 d0       	rcall	.+0      	; 0x1db6 <executeOperatorTask+0xa>
    1db6:	cd b7       	in	r28, 0x3d	; 61
    1db8:	de b7       	in	r29, 0x3e	; 62
    1dba:	7c 01       	movw	r14, r24
    operatorTaskParameters *taskParams;
    
    taskParams = ( operatorTaskParameters * ) pvParameters;
    
    //Initialize the wake up time with the current time
    xLastWakeUpTime = xTaskGetTickCount();
    1dbc:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <xTaskGetTickCount>
    1dc0:	a0 e0       	ldi	r26, 0x00	; 0
    1dc2:	b0 e0       	ldi	r27, 0x00	; 0
    1dc4:	89 83       	std	Y+1, r24	; 0x01
    1dc6:	9a 83       	std	Y+2, r25	; 0x02
    1dc8:	ab 83       	std	Y+3, r26	; 0x03
    1dca:	bc 83       	std	Y+4, r27	; 0x04
    
    for(;;)
    {
        
        //Execute this task each 15ms
        vTaskDelayUntil( &xLastWakeUpTime, OPERATOR_TASK_CYCLE );
    1dcc:	ce 01       	movw	r24, r28
    1dce:	01 96       	adiw	r24, 0x01	; 1
    1dd0:	6f e0       	ldi	r22, 0x0F	; 15
    1dd2:	70 e0       	ldi	r23, 0x00	; 0
    1dd4:	0e 94 45 0c 	call	0x188a	; 0x188a <vTaskDelayUntil>
                
        //check if there are new items to read in the measurement value queue
        receivedNewMessage = xQueueReceive( taskParams->measurementQueue, &( measurementMsg ), ( portTickType ) 10 );
    1dd8:	f7 01       	movw	r30, r14
    1dda:	80 81       	ld	r24, Z
    1ddc:	91 81       	ldd	r25, Z+1	; 0x01
    1dde:	be 01       	movw	r22, r28
    1de0:	6b 5f       	subi	r22, 0xFB	; 251
    1de2:	7f 4f       	sbci	r23, 0xFF	; 255
    1de4:	2a e0       	ldi	r18, 0x0A	; 10
    1de6:	30 e0       	ldi	r19, 0x00	; 0
    1de8:	40 e0       	ldi	r20, 0x00	; 0
    1dea:	50 e0       	ldi	r21, 0x00	; 0
    1dec:	00 e0       	ldi	r16, 0x00	; 0
    1dee:	0e 94 90 07 	call	0xf20	; 0xf20 <xQueueGenericReceive>
    1df2:	ec cf       	rjmp	.-40     	; 0x1dcc <executeOperatorTask+0x20>

00001df4 <startOperatorTask>:
   Used to signal an error condition inside this task
*/
static portBASE_TYPE xOperatorTaskStatus = pdPASS;

void startOperatorTask( unsigned portBASE_TYPE uxPriority, xQueueHandle *measQueue )
{
    1df4:	af 92       	push	r10
    1df6:	bf 92       	push	r11
    1df8:	cf 92       	push	r12
    1dfa:	df 92       	push	r13
    1dfc:	ef 92       	push	r14
    1dfe:	ff 92       	push	r15
    1e00:	0f 93       	push	r16
    1e02:	cf 93       	push	r28
    1e04:	df 93       	push	r29
    1e06:	08 2f       	mov	r16, r24
    1e08:	eb 01       	movw	r28, r22
    operatorTaskParameters *taskParams;
    taskParams = ( operatorTaskParameters * ) pvPortMalloc( sizeof( operatorTaskParameters ) );
    1e0a:	82 e0       	ldi	r24, 0x02	; 2
    1e0c:	90 e0       	ldi	r25, 0x00	; 0
    1e0e:	0e 94 15 03 	call	0x62a	; 0x62a <pvPortMalloc>
    1e12:	9c 01       	movw	r18, r24
    taskParams->measurementQueue = *measQueue;
    1e14:	88 81       	ld	r24, Y
    1e16:	99 81       	ldd	r25, Y+1	; 0x01
    1e18:	f9 01       	movw	r30, r18
    1e1a:	91 83       	std	Z+1, r25	; 0x01
    1e1c:	80 83       	st	Z, r24
    
    xTaskCreate( executeOperatorTask, ( signed char * ) "opTask", sysOperatorTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
    1e1e:	86 ed       	ldi	r24, 0xD6	; 214
    1e20:	9e e0       	ldi	r25, 0x0E	; 14
    1e22:	63 e8       	ldi	r22, 0x83	; 131
    1e24:	70 e0       	ldi	r23, 0x00	; 0
    1e26:	45 e5       	ldi	r20, 0x55	; 85
    1e28:	50 e0       	ldi	r21, 0x00	; 0
    1e2a:	ee 24       	eor	r14, r14
    1e2c:	ff 24       	eor	r15, r15
    1e2e:	cc 24       	eor	r12, r12
    1e30:	dd 24       	eor	r13, r13
    1e32:	aa 24       	eor	r10, r10
    1e34:	bb 24       	eor	r11, r11
    1e36:	0e 94 d9 08 	call	0x11b2	; 0x11b2 <xTaskGenericCreate>
}
    1e3a:	df 91       	pop	r29
    1e3c:	cf 91       	pop	r28
    1e3e:	0f 91       	pop	r16
    1e40:	ff 90       	pop	r15
    1e42:	ef 90       	pop	r14
    1e44:	df 90       	pop	r13
    1e46:	cf 90       	pop	r12
    1e48:	bf 90       	pop	r11
    1e4a:	af 90       	pop	r10
    1e4c:	08 95       	ret

00001e4e <xIsOperatorTaskStillRunning>:
    {
        xReturn = pdPASS;
    }

    return xReturn;
    1e4e:	81 e0       	ldi	r24, 0x01	; 1
    1e50:	08 95       	ret

00001e52 <__mulsi3>:
    1e52:	62 9f       	mul	r22, r18
    1e54:	d0 01       	movw	r26, r0
    1e56:	73 9f       	mul	r23, r19
    1e58:	f0 01       	movw	r30, r0
    1e5a:	82 9f       	mul	r24, r18
    1e5c:	e0 0d       	add	r30, r0
    1e5e:	f1 1d       	adc	r31, r1
    1e60:	64 9f       	mul	r22, r20
    1e62:	e0 0d       	add	r30, r0
    1e64:	f1 1d       	adc	r31, r1
    1e66:	92 9f       	mul	r25, r18
    1e68:	f0 0d       	add	r31, r0
    1e6a:	83 9f       	mul	r24, r19
    1e6c:	f0 0d       	add	r31, r0
    1e6e:	74 9f       	mul	r23, r20
    1e70:	f0 0d       	add	r31, r0
    1e72:	65 9f       	mul	r22, r21
    1e74:	f0 0d       	add	r31, r0
    1e76:	99 27       	eor	r25, r25
    1e78:	72 9f       	mul	r23, r18
    1e7a:	b0 0d       	add	r27, r0
    1e7c:	e1 1d       	adc	r30, r1
    1e7e:	f9 1f       	adc	r31, r25
    1e80:	63 9f       	mul	r22, r19
    1e82:	b0 0d       	add	r27, r0
    1e84:	e1 1d       	adc	r30, r1
    1e86:	f9 1f       	adc	r31, r25
    1e88:	bd 01       	movw	r22, r26
    1e8a:	cf 01       	movw	r24, r30
    1e8c:	11 24       	eor	r1, r1
    1e8e:	08 95       	ret

00001e90 <__udivmodhi4>:
    1e90:	aa 1b       	sub	r26, r26
    1e92:	bb 1b       	sub	r27, r27
    1e94:	51 e1       	ldi	r21, 0x11	; 17
    1e96:	07 c0       	rjmp	.+14     	; 0x1ea6 <__udivmodhi4_ep>

00001e98 <__udivmodhi4_loop>:
    1e98:	aa 1f       	adc	r26, r26
    1e9a:	bb 1f       	adc	r27, r27
    1e9c:	a6 17       	cp	r26, r22
    1e9e:	b7 07       	cpc	r27, r23
    1ea0:	10 f0       	brcs	.+4      	; 0x1ea6 <__udivmodhi4_ep>
    1ea2:	a6 1b       	sub	r26, r22
    1ea4:	b7 0b       	sbc	r27, r23

00001ea6 <__udivmodhi4_ep>:
    1ea6:	88 1f       	adc	r24, r24
    1ea8:	99 1f       	adc	r25, r25
    1eaa:	5a 95       	dec	r21
    1eac:	a9 f7       	brne	.-22     	; 0x1e98 <__udivmodhi4_loop>
    1eae:	80 95       	com	r24
    1eb0:	90 95       	com	r25
    1eb2:	bc 01       	movw	r22, r24
    1eb4:	cd 01       	movw	r24, r26
    1eb6:	08 95       	ret

00001eb8 <__udivmodsi4>:
    1eb8:	a1 e2       	ldi	r26, 0x21	; 33
    1eba:	1a 2e       	mov	r1, r26
    1ebc:	aa 1b       	sub	r26, r26
    1ebe:	bb 1b       	sub	r27, r27
    1ec0:	fd 01       	movw	r30, r26
    1ec2:	0d c0       	rjmp	.+26     	; 0x1ede <__udivmodsi4_ep>

00001ec4 <__udivmodsi4_loop>:
    1ec4:	aa 1f       	adc	r26, r26
    1ec6:	bb 1f       	adc	r27, r27
    1ec8:	ee 1f       	adc	r30, r30
    1eca:	ff 1f       	adc	r31, r31
    1ecc:	a2 17       	cp	r26, r18
    1ece:	b3 07       	cpc	r27, r19
    1ed0:	e4 07       	cpc	r30, r20
    1ed2:	f5 07       	cpc	r31, r21
    1ed4:	20 f0       	brcs	.+8      	; 0x1ede <__udivmodsi4_ep>
    1ed6:	a2 1b       	sub	r26, r18
    1ed8:	b3 0b       	sbc	r27, r19
    1eda:	e4 0b       	sbc	r30, r20
    1edc:	f5 0b       	sbc	r31, r21

00001ede <__udivmodsi4_ep>:
    1ede:	66 1f       	adc	r22, r22
    1ee0:	77 1f       	adc	r23, r23
    1ee2:	88 1f       	adc	r24, r24
    1ee4:	99 1f       	adc	r25, r25
    1ee6:	1a 94       	dec	r1
    1ee8:	69 f7       	brne	.-38     	; 0x1ec4 <__udivmodsi4_loop>
    1eea:	60 95       	com	r22
    1eec:	70 95       	com	r23
    1eee:	80 95       	com	r24
    1ef0:	90 95       	com	r25
    1ef2:	9b 01       	movw	r18, r22
    1ef4:	ac 01       	movw	r20, r24
    1ef6:	bd 01       	movw	r22, r26
    1ef8:	cf 01       	movw	r24, r30
    1efa:	08 95       	ret

00001efc <memcpy>:
    1efc:	fb 01       	movw	r30, r22
    1efe:	dc 01       	movw	r26, r24
    1f00:	02 c0       	rjmp	.+4      	; 0x1f06 <memcpy+0xa>
    1f02:	01 90       	ld	r0, Z+
    1f04:	0d 92       	st	X+, r0
    1f06:	41 50       	subi	r20, 0x01	; 1
    1f08:	50 40       	sbci	r21, 0x00	; 0
    1f0a:	d8 f7       	brcc	.-10     	; 0x1f02 <memcpy+0x6>
    1f0c:	08 95       	ret

00001f0e <memset>:
    1f0e:	dc 01       	movw	r26, r24
    1f10:	01 c0       	rjmp	.+2      	; 0x1f14 <memset+0x6>
    1f12:	6d 93       	st	X+, r22
    1f14:	41 50       	subi	r20, 0x01	; 1
    1f16:	50 40       	sbci	r21, 0x00	; 0
    1f18:	e0 f7       	brcc	.-8      	; 0x1f12 <memset+0x4>
    1f1a:	08 95       	ret

00001f1c <strncpy>:
    1f1c:	fb 01       	movw	r30, r22
    1f1e:	dc 01       	movw	r26, r24
    1f20:	41 50       	subi	r20, 0x01	; 1
    1f22:	50 40       	sbci	r21, 0x00	; 0
    1f24:	48 f0       	brcs	.+18     	; 0x1f38 <strncpy+0x1c>
    1f26:	01 90       	ld	r0, Z+
    1f28:	0d 92       	st	X+, r0
    1f2a:	00 20       	and	r0, r0
    1f2c:	c9 f7       	brne	.-14     	; 0x1f20 <strncpy+0x4>
    1f2e:	01 c0       	rjmp	.+2      	; 0x1f32 <strncpy+0x16>
    1f30:	1d 92       	st	X+, r1
    1f32:	41 50       	subi	r20, 0x01	; 1
    1f34:	50 40       	sbci	r21, 0x00	; 0
    1f36:	e0 f7       	brcc	.-8      	; 0x1f30 <strncpy+0x14>
    1f38:	08 95       	ret

00001f3a <_exit>:
    1f3a:	f8 94       	cli

00001f3c <__stop_program>:
    1f3c:	ff cf       	rjmp	.-2      	; 0x1f3c <__stop_program>
