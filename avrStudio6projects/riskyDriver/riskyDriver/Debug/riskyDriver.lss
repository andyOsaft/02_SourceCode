
riskyDriver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000035c6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000002a  00800060  000035c6  0000365a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000575  0080008a  0080008a  00003684  2**0
                  ALLOC
  3 .stab         000038c4  00000000  00000000  00003684  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000b94  00000000  00000000  00006f48  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000320  00000000  00000000  00007ae0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000041ce  00000000  00000000  00007e00  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001612  00000000  00000000  0000bfce  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002479  00000000  00000000  0000d5e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000d44  00000000  00000000  0000fa5c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000174e  00000000  00000000  000107a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000039fc  00000000  00000000  00011eee  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000f0  00000000  00000000  000158ea  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 6b 00 	jmp	0xd6	; 0xd6 <__ctors_end>
       4:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
       8:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
       c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      10:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      14:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      18:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      1c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      20:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      24:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      28:	0c 94 53 0d 	jmp	0x1aa6	; 0x1aa6 <__vector_10>
      2c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      30:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      34:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      38:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      3c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      40:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      44:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      48:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      4c:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      50:	0c 94 88 00 	jmp	0x110	; 0x110 <__bad_interrupt>
      54:	07 63       	ori	r16, 0x37	; 55
      56:	42 36       	cpi	r20, 0x62	; 98
      58:	b7 9b       	sbis	0x16, 7	; 22
      5a:	d8 a7       	lds	r29, 0x78
      5c:	1a 39       	cpi	r17, 0x9A	; 154
      5e:	68 56       	subi	r22, 0x68	; 104
      60:	18 ae       	sts	0xb8, r17
      62:	ba ab       	sts	0x5a, r27
      64:	55 8c       	ldd	r5, Z+29	; 0x1d
      66:	1d 3c       	cpi	r17, 0xCD	; 205
      68:	b7 cc       	rjmp	.-1682   	; 0xfffff9d8 <__eeprom_end+0xff7ef9d8>
      6a:	57 63       	ori	r21, 0x37	; 55
      6c:	bd 6d       	ori	r27, 0xDD	; 221
      6e:	ed fd       	.word	0xfded	; ????
      70:	75 3e       	cpi	r23, 0xE5	; 229
      72:	f6 17       	cp	r31, r22
      74:	72 31       	cpi	r23, 0x12	; 18
      76:	bf 00       	.word	0x00bf	; ????
      78:	00 00       	nop
      7a:	80 3f       	cpi	r24, 0xF0	; 240
      7c:	08 00       	.word	0x0008	; ????
      7e:	00 00       	nop
      80:	be 92       	st	-X, r11
      82:	24 49       	sbci	r18, 0x94	; 148
      84:	12 3e       	cpi	r17, 0xE2	; 226
      86:	ab aa       	sts	0x9b, r26
      88:	aa 2a       	or	r10, r26
      8a:	be cd       	rjmp	.-1156   	; 0xfffffc08 <__eeprom_end+0xff7efc08>
      8c:	cc cc       	rjmp	.-1640   	; 0xfffffa26 <__eeprom_end+0xff7efa26>
      8e:	4c 3e       	cpi	r20, 0xEC	; 236
      90:	00 00       	nop
      92:	00 80       	ld	r0, Z
      94:	be ab       	sts	0x5e, r27
      96:	aa aa       	sts	0x9a, r26
      98:	aa 3e       	cpi	r26, 0xEA	; 234
      9a:	00 00       	nop
      9c:	00 00       	nop
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	00 00       	nop
      a6:	00 00       	nop
      a8:	00 08       	sbc	r0, r0
      aa:	41 78       	andi	r20, 0x81	; 129
      ac:	d3 bb       	out	0x13, r29	; 19
      ae:	43 87       	std	Z+11, r20	; 0x0b
      b0:	d1 13       	cpse	r29, r17
      b2:	3d 19       	sub	r19, r13
      b4:	0e 3c       	cpi	r16, 0xCE	; 206
      b6:	c3 bd       	out	0x23, r28	; 35
      b8:	42 82       	std	Z+2, r4	; 0x02
      ba:	ad 2b       	or	r26, r29
      bc:	3e 68       	ori	r19, 0x8E	; 142
      be:	ec 82       	std	Y+4, r14	; 0x04
      c0:	76 be       	out	0x36, r7	; 54
      c2:	d9 8f       	std	Y+25, r29	; 0x19
      c4:	e1 a9       	sts	0x41, r30
      c6:	3e 4c       	sbci	r19, 0xCE	; 206
      c8:	80 ef       	ldi	r24, 0xF0	; 240
      ca:	ff be       	out	0x3f, r15	; 63
      cc:	01 c4       	rjmp	.+2050   	; 0x8d0 <BMP085_Calibration+0x14>
      ce:	ff 7f       	andi	r31, 0xFF	; 255
      d0:	3f 00       	.word	0x003f	; ????
      d2:	00 00       	nop
	...

000000d6 <__ctors_end>:
      d6:	11 24       	eor	r1, r1
      d8:	1f be       	out	0x3f, r1	; 63
      da:	cf e5       	ldi	r28, 0x5F	; 95
      dc:	d8 e0       	ldi	r29, 0x08	; 8
      de:	de bf       	out	0x3e, r29	; 62
      e0:	cd bf       	out	0x3d, r28	; 61

000000e2 <__do_copy_data>:
      e2:	10 e0       	ldi	r17, 0x00	; 0
      e4:	a0 e6       	ldi	r26, 0x60	; 96
      e6:	b0 e0       	ldi	r27, 0x00	; 0
      e8:	e6 ec       	ldi	r30, 0xC6	; 198
      ea:	f5 e3       	ldi	r31, 0x35	; 53
      ec:	02 c0       	rjmp	.+4      	; 0xf2 <__do_copy_data+0x10>
      ee:	05 90       	lpm	r0, Z+
      f0:	0d 92       	st	X+, r0
      f2:	aa 38       	cpi	r26, 0x8A	; 138
      f4:	b1 07       	cpc	r27, r17
      f6:	d9 f7       	brne	.-10     	; 0xee <__do_copy_data+0xc>

000000f8 <__do_clear_bss>:
      f8:	15 e0       	ldi	r17, 0x05	; 5
      fa:	aa e8       	ldi	r26, 0x8A	; 138
      fc:	b0 e0       	ldi	r27, 0x00	; 0
      fe:	01 c0       	rjmp	.+2      	; 0x102 <.do_clear_bss_start>

00000100 <.do_clear_bss_loop>:
     100:	1d 92       	st	X+, r1

00000102 <.do_clear_bss_start>:
     102:	af 3f       	cpi	r26, 0xFF	; 255
     104:	b1 07       	cpc	r27, r17
     106:	e1 f7       	brne	.-8      	; 0x100 <.do_clear_bss_loop>
     108:	0e 94 1e 08 	call	0x103c	; 0x103c <main>
     10c:	0c 94 e1 1a 	jmp	0x35c2	; 0x35c2 <_exit>

00000110 <__bad_interrupt>:
     110:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000114 <input_init>:
//----------------------------------------
// 
//----------------------------------------
void input_init()
{
	input_DDR &= ~(1<<BMP085_pin);//Input
     114:	a2 98       	cbi	0x14, 2	; 20
	input_PORT |= (1<<BMP085_pin);//Enable PullUp
     116:	aa 9a       	sbi	0x15, 2	; 21
}
     118:	08 95       	ret

0000011a <bmp085ReadShort>:
//----------------------------------------
// 
//----------------------------------------
uint16_t bmp085ReadShort(uint8_t address, uint8_t* error_code)
{
     11a:	ef 92       	push	r14
     11c:	ff 92       	push	r15
     11e:	0f 93       	push	r16
     120:	1f 93       	push	r17
     122:	cf 93       	push	r28
     124:	df 93       	push	r29
     126:	08 2f       	mov	r16, r24
     128:	eb 01       	movw	r28, r22
	uint16_t msb=0;
	uint16_t lsb=0;
	uint16_t data;
	//Send Start Condition
	i2cSendStart();	
     12a:	0e 94 9a 07 	call	0xf34	; 0xf34 <i2cSendStart>
	*error_code=i2cWaitForComplete();
     12e:	0e 94 be 07 	call	0xf7c	; 0xf7c <i2cWaitForComplete>
     132:	88 83       	st	Y, r24
	if (*error_code==0){
     134:	88 23       	and	r24, r24
     136:	09 f0       	breq	.+2      	; 0x13a <bmp085ReadShort+0x20>
     138:	86 c0       	rjmp	.+268    	; 0x246 <bmp085ReadShort+0x12c>
		*error_code=checki2cReturnCode(TW_START);
     13a:	88 e0       	ldi	r24, 0x08	; 8
     13c:	0e 94 cc 07 	call	0xf98	; 0xf98 <checki2cReturnCode>
     140:	88 83       	st	Y, r24
	}//
	//printf("error code: %d \n",error_code);


	//Tell Slave to go in receive mode
	if (*error_code==0){	
     142:	88 23       	and	r24, r24
     144:	09 f0       	breq	.+2      	; 0x148 <bmp085ReadShort+0x2e>
     146:	82 c0       	rjmp	.+260    	; 0x24c <bmp085ReadShort+0x132>
		i2cSendByte(BMP085_W);	// write 0xEE
     148:	8e ee       	ldi	r24, 0xEE	; 238
     14a:	0e 94 b4 07 	call	0xf68	; 0xf68 <i2cSendByte>
		*error_code=i2cWaitForComplete();
     14e:	0e 94 be 07 	call	0xf7c	; 0xf7c <i2cWaitForComplete>
     152:	88 83       	st	Y, r24
	}
	//ACKS
	if (*error_code==0){	
     154:	88 23       	and	r24, r24
     156:	09 f0       	breq	.+2      	; 0x15a <bmp085ReadShort+0x40>
     158:	7c c0       	rjmp	.+248    	; 0x252 <bmp085ReadShort+0x138>
		*error_code=checki2cReturnCode(TW_MT_SLA_ACK);
     15a:	88 e1       	ldi	r24, 0x18	; 24
     15c:	0e 94 cc 07 	call	0xf98	; 0xf98 <checki2cReturnCode>
     160:	88 83       	st	Y, r24
	}
	//printf("error code: %d \n",error_code);
	
	
	//Send read address to Salve
	if (*error_code==0){	
     162:	88 23       	and	r24, r24
     164:	09 f0       	breq	.+2      	; 0x168 <bmp085ReadShort+0x4e>
     166:	78 c0       	rjmp	.+240    	; 0x258 <bmp085ReadShort+0x13e>
		i2cSendByte(address);	// write register address
     168:	80 2f       	mov	r24, r16
     16a:	0e 94 b4 07 	call	0xf68	; 0xf68 <i2cSendByte>
		*error_code=i2cWaitForComplete();
     16e:	0e 94 be 07 	call	0xf7c	; 0xf7c <i2cWaitForComplete>
     172:	88 83       	st	Y, r24
	}
	//ACKS
	if (*error_code==0){	
     174:	88 23       	and	r24, r24
     176:	09 f0       	breq	.+2      	; 0x17a <bmp085ReadShort+0x60>
     178:	72 c0       	rjmp	.+228    	; 0x25e <bmp085ReadShort+0x144>
		*error_code=checki2cReturnCode(TW_MT_DATA_ACK);
     17a:	88 e2       	ldi	r24, 0x28	; 40
     17c:	0e 94 cc 07 	call	0xf98	; 0xf98 <checki2cReturnCode>
     180:	88 83       	st	Y, r24
	}
	//printf("error code: %d \n",error_code);

	//Send Restart to Slave
	if (*error_code==0){	
     182:	88 23       	and	r24, r24
     184:	09 f0       	breq	.+2      	; 0x188 <bmp085ReadShort+0x6e>
     186:	6e c0       	rjmp	.+220    	; 0x264 <bmp085ReadShort+0x14a>
		i2cSendStart();
     188:	0e 94 9a 07 	call	0xf34	; 0xf34 <i2cSendStart>
		*error_code=i2cWaitForComplete();
     18c:	0e 94 be 07 	call	0xf7c	; 0xf7c <i2cWaitForComplete>
     190:	88 83       	st	Y, r24
	}
	if (*error_code==0){	
     192:	88 23       	and	r24, r24
     194:	09 f0       	breq	.+2      	; 0x198 <bmp085ReadShort+0x7e>
     196:	69 c0       	rjmp	.+210    	; 0x26a <bmp085ReadShort+0x150>
		*error_code=checki2cReturnCode(TW_REP_START);
     198:	80 e1       	ldi	r24, 0x10	; 16
     19a:	0e 94 cc 07 	call	0xf98	; 0xf98 <checki2cReturnCode>
     19e:	88 83       	st	Y, r24
	}
	//printf("error code: %d \n",error_code);


	//Tell Salve go in send mode
	if (*error_code==0){	
     1a0:	88 23       	and	r24, r24
     1a2:	09 f0       	breq	.+2      	; 0x1a6 <bmp085ReadShort+0x8c>
     1a4:	65 c0       	rjmp	.+202    	; 0x270 <bmp085ReadShort+0x156>
		i2cSendByte(BMP085_R);	// read 0xEF
     1a6:	8f ee       	ldi	r24, 0xEF	; 239
     1a8:	0e 94 b4 07 	call	0xf68	; 0xf68 <i2cSendByte>
		*error_code=i2cWaitForComplete();
     1ac:	0e 94 be 07 	call	0xf7c	; 0xf7c <i2cWaitForComplete>
     1b0:	88 83       	st	Y, r24
	}
	//ACKS
	if (*error_code==0){	
     1b2:	88 23       	and	r24, r24
     1b4:	09 f0       	breq	.+2      	; 0x1b8 <bmp085ReadShort+0x9e>
     1b6:	5f c0       	rjmp	.+190    	; 0x276 <bmp085ReadShort+0x15c>
		*error_code=checki2cReturnCode(TW_MR_SLA_ACK);
     1b8:	80 e4       	ldi	r24, 0x40	; 64
     1ba:	0e 94 cc 07 	call	0xf98	; 0xf98 <checki2cReturnCode>
     1be:	88 83       	st	Y, r24
	}
	//printf("error code: %d \n",error_code);


	//Get MSB from Salve
	if (*error_code==0){	
     1c0:	88 23       	and	r24, r24
     1c2:	09 f0       	breq	.+2      	; 0x1c6 <bmp085ReadShort+0xac>
     1c4:	5b c0       	rjmp	.+182    	; 0x27c <bmp085ReadShort+0x162>
		i2cReceiveByteACK();
     1c6:	0e 94 b8 07 	call	0xf70	; 0xf70 <i2cReceiveByteACK>
		*error_code=i2cWaitForComplete();
     1ca:	0e 94 be 07 	call	0xf7c	; 0xf7c <i2cWaitForComplete>
     1ce:	88 83       	st	Y, r24
	}
	//printf("error code: %d \n",error_code);
	if (*error_code==0){	
     1d0:	88 23       	and	r24, r24
     1d2:	09 f0       	breq	.+2      	; 0x1d6 <bmp085ReadShort+0xbc>
     1d4:	56 c0       	rjmp	.+172    	; 0x282 <bmp085ReadShort+0x168>
		msb = i2cGetReceivedByte();	// Get MSB result
     1d6:	0e 94 ca 07 	call	0xf94	; 0xf94 <i2cGetReceivedByte>
     1da:	08 2f       	mov	r16, r24
     1dc:	10 e0       	ldi	r17, 0x00	; 0
		*error_code=i2cWaitForComplete();
     1de:	0e 94 be 07 	call	0xf7c	; 0xf7c <i2cWaitForComplete>
     1e2:	88 83       	st	Y, r24
	}
	//ACKM
	if (*error_code==0){	
     1e4:	88 23       	and	r24, r24
     1e6:	09 f0       	breq	.+2      	; 0x1ea <bmp085ReadShort+0xd0>
     1e8:	4e c0       	rjmp	.+156    	; 0x286 <bmp085ReadShort+0x16c>
		*error_code=checki2cReturnCode(TW_MR_DATA_ACK);
     1ea:	80 e5       	ldi	r24, 0x50	; 80
     1ec:	0e 94 cc 07 	call	0xf98	; 0xf98 <checki2cReturnCode>
     1f0:	88 83       	st	Y, r24
	}
	//printf("error code: %d \n",error_code);

	
	//Get LSB from Slave
	if (*error_code==0){
     1f2:	88 23       	and	r24, r24
     1f4:	09 f0       	breq	.+2      	; 0x1f8 <bmp085ReadShort+0xde>
     1f6:	47 c0       	rjmp	.+142    	; 0x286 <bmp085ReadShort+0x16c>
		i2cReceiveByteNACK();
     1f8:	0e 94 bb 07 	call	0xf76	; 0xf76 <i2cReceiveByteNACK>
		*error_code=i2cWaitForComplete();
     1fc:	0e 94 be 07 	call	0xf7c	; 0xf7c <i2cWaitForComplete>
     200:	88 83       	st	Y, r24
	}
	//printf("error code: %d \n",error_code);
	if (*error_code==0){	
     202:	88 23       	and	r24, r24
     204:	09 f0       	breq	.+2      	; 0x208 <bmp085ReadShort+0xee>
     206:	3f c0       	rjmp	.+126    	; 0x286 <bmp085ReadShort+0x16c>
		lsb = i2cGetReceivedByte();	// Get LSB result
     208:	0e 94 ca 07 	call	0xf94	; 0xf94 <i2cGetReceivedByte>
     20c:	e8 2e       	mov	r14, r24
     20e:	ff 24       	eor	r15, r15
		*error_code=i2cWaitForComplete();
     210:	0e 94 be 07 	call	0xf7c	; 0xf7c <i2cWaitForComplete>
     214:	88 83       	st	Y, r24
	}
	//NACKM
	if (*error_code==0){	
     216:	88 23       	and	r24, r24
     218:	49 f4       	brne	.+18     	; 0x22c <bmp085ReadShort+0x112>
		*error_code=checki2cReturnCode(TW_MR_DATA_NACK);
     21a:	88 e5       	ldi	r24, 0x58	; 88
     21c:	0e 94 cc 07 	call	0xf98	; 0xf98 <checki2cReturnCode>
     220:	88 83       	st	Y, r24
	//printf("error code: %d \n",error_code);
	//printf("TWSR STATUS: %d \n",(TWSR & 0xF8));
	
		
	//Send Stop on the Bus
	if (*error_code==0){
     222:	88 23       	and	r24, r24
     224:	19 f4       	brne	.+6      	; 0x22c <bmp085ReadShort+0x112>
		*error_code=i2cSendStop();
     226:	0e 94 9d 07 	call	0xf3a	; 0xf3a <i2cSendStop>
     22a:	88 83       	st	Y, r24
	}
	//printf("error code: %d \n",error_code);
	
	data = (msb << 8) + lsb;
     22c:	10 2f       	mov	r17, r16
     22e:	00 27       	eor	r16, r16
     230:	e0 0e       	add	r14, r16
     232:	f1 1e       	adc	r15, r17
	return data;
}
     234:	8e 2d       	mov	r24, r14
     236:	9f 2d       	mov	r25, r15
     238:	df 91       	pop	r29
     23a:	cf 91       	pop	r28
     23c:	1f 91       	pop	r17
     23e:	0f 91       	pop	r16
     240:	ff 90       	pop	r15
     242:	ef 90       	pop	r14
     244:	08 95       	ret
	uint16_t lsb=0;
	uint16_t data;
	//Send Start Condition
	i2cSendStart();	
	*error_code=i2cWaitForComplete();
	if (*error_code==0){
     246:	00 e0       	ldi	r16, 0x00	; 0
     248:	10 e0       	ldi	r17, 0x00	; 0
     24a:	1d c0       	rjmp	.+58     	; 0x286 <bmp085ReadShort+0x16c>
	}//
	//printf("error code: %d \n",error_code);


	//Tell Slave to go in receive mode
	if (*error_code==0){	
     24c:	00 e0       	ldi	r16, 0x00	; 0
     24e:	10 e0       	ldi	r17, 0x00	; 0
     250:	1a c0       	rjmp	.+52     	; 0x286 <bmp085ReadShort+0x16c>
		i2cSendByte(BMP085_W);	// write 0xEE
		*error_code=i2cWaitForComplete();
	}
	//ACKS
	if (*error_code==0){	
     252:	00 e0       	ldi	r16, 0x00	; 0
     254:	10 e0       	ldi	r17, 0x00	; 0
     256:	17 c0       	rjmp	.+46     	; 0x286 <bmp085ReadShort+0x16c>
	}
	//printf("error code: %d \n",error_code);
	
	
	//Send read address to Salve
	if (*error_code==0){	
     258:	00 e0       	ldi	r16, 0x00	; 0
     25a:	10 e0       	ldi	r17, 0x00	; 0
     25c:	14 c0       	rjmp	.+40     	; 0x286 <bmp085ReadShort+0x16c>
		i2cSendByte(address);	// write register address
		*error_code=i2cWaitForComplete();
	}
	//ACKS
	if (*error_code==0){	
     25e:	00 e0       	ldi	r16, 0x00	; 0
     260:	10 e0       	ldi	r17, 0x00	; 0
     262:	11 c0       	rjmp	.+34     	; 0x286 <bmp085ReadShort+0x16c>
		*error_code=checki2cReturnCode(TW_MT_DATA_ACK);
	}
	//printf("error code: %d \n",error_code);

	//Send Restart to Slave
	if (*error_code==0){	
     264:	00 e0       	ldi	r16, 0x00	; 0
     266:	10 e0       	ldi	r17, 0x00	; 0
     268:	0e c0       	rjmp	.+28     	; 0x286 <bmp085ReadShort+0x16c>
		i2cSendStart();
		*error_code=i2cWaitForComplete();
	}
	if (*error_code==0){	
     26a:	00 e0       	ldi	r16, 0x00	; 0
     26c:	10 e0       	ldi	r17, 0x00	; 0
     26e:	0b c0       	rjmp	.+22     	; 0x286 <bmp085ReadShort+0x16c>
	}
	//printf("error code: %d \n",error_code);


	//Tell Salve go in send mode
	if (*error_code==0){	
     270:	00 e0       	ldi	r16, 0x00	; 0
     272:	10 e0       	ldi	r17, 0x00	; 0
     274:	08 c0       	rjmp	.+16     	; 0x286 <bmp085ReadShort+0x16c>
		i2cSendByte(BMP085_R);	// read 0xEF
		*error_code=i2cWaitForComplete();
	}
	//ACKS
	if (*error_code==0){	
     276:	00 e0       	ldi	r16, 0x00	; 0
     278:	10 e0       	ldi	r17, 0x00	; 0
     27a:	05 c0       	rjmp	.+10     	; 0x286 <bmp085ReadShort+0x16c>
	}
	//printf("error code: %d \n",error_code);


	//Get MSB from Salve
	if (*error_code==0){	
     27c:	00 e0       	ldi	r16, 0x00	; 0
     27e:	10 e0       	ldi	r17, 0x00	; 0
     280:	02 c0       	rjmp	.+4      	; 0x286 <bmp085ReadShort+0x16c>
		i2cReceiveByteACK();
		*error_code=i2cWaitForComplete();
	}
	//printf("error code: %d \n",error_code);
	if (*error_code==0){	
     282:	00 e0       	ldi	r16, 0x00	; 0
     284:	10 e0       	ldi	r17, 0x00	; 0
	if (*error_code==0){	
		i2cSendByte(BMP085_R);	// read 0xEF
		*error_code=i2cWaitForComplete();
	}
	//ACKS
	if (*error_code==0){	
     286:	ee 24       	eor	r14, r14
     288:	ff 24       	eor	r15, r15
     28a:	d0 cf       	rjmp	.-96     	; 0x22c <bmp085ReadShort+0x112>

0000028c <bmp085ReadTemp>:
}
//----------------------------------------
// 
//----------------------------------------
int32_t bmp085ReadTemp(uint8_t* error_code)
{
     28c:	0f 93       	push	r16
     28e:	1f 93       	push	r17
     290:	cf 93       	push	r28
     292:	df 93       	push	r29
     294:	ec 01       	movw	r28, r24
	
	int32_t temperature = 0;
	//Send Start Condition
	i2cSendStart();	
     296:	0e 94 9a 07 	call	0xf34	; 0xf34 <i2cSendStart>
	*error_code=i2cWaitForComplete();
     29a:	0e 94 be 07 	call	0xf7c	; 0xf7c <i2cWaitForComplete>
     29e:	88 83       	st	Y, r24
	if (*error_code==0){
     2a0:	88 23       	and	r24, r24
     2a2:	99 f5       	brne	.+102    	; 0x30a <bmp085ReadTemp+0x7e>
		*error_code=checki2cReturnCode(TW_START);
     2a4:	88 e0       	ldi	r24, 0x08	; 8
     2a6:	0e 94 cc 07 	call	0xf98	; 0xf98 <checki2cReturnCode>
     2aa:	88 83       	st	Y, r24
	}

	//printf("error code: %d \n",error_code);
	
	//Tell Salve go in receive mode
	if (*error_code==0){	
     2ac:	88 23       	and	r24, r24
     2ae:	69 f5       	brne	.+90     	; 0x30a <bmp085ReadTemp+0x7e>
		i2cSendByte(BMP085_W);	// write 0xEE
     2b0:	8e ee       	ldi	r24, 0xEE	; 238
     2b2:	0e 94 b4 07 	call	0xf68	; 0xf68 <i2cSendByte>
		*error_code=i2cWaitForComplete();
     2b6:	0e 94 be 07 	call	0xf7c	; 0xf7c <i2cWaitForComplete>
     2ba:	88 83       	st	Y, r24
	}
	//ACKS
	if (*error_code==0){	
     2bc:	88 23       	and	r24, r24
     2be:	29 f5       	brne	.+74     	; 0x30a <bmp085ReadTemp+0x7e>
		*error_code=checki2cReturnCode(TW_MT_SLA_ACK);
     2c0:	88 e1       	ldi	r24, 0x18	; 24
     2c2:	0e 94 cc 07 	call	0xf98	; 0xf98 <checki2cReturnCode>
     2c6:	88 83       	st	Y, r24
	}
	//printf("error code: %d \n",error_code);
	
	//Write control register address
	if (*error_code==0){	
     2c8:	88 23       	and	r24, r24
     2ca:	f9 f4       	brne	.+62     	; 0x30a <bmp085ReadTemp+0x7e>
		i2cSendByte(0xF4);	// write 0xF4
     2cc:	84 ef       	ldi	r24, 0xF4	; 244
     2ce:	0e 94 b4 07 	call	0xf68	; 0xf68 <i2cSendByte>
		*error_code=i2cWaitForComplete();
     2d2:	0e 94 be 07 	call	0xf7c	; 0xf7c <i2cWaitForComplete>
     2d6:	88 83       	st	Y, r24
	}
	//ACKS
	if (*error_code==0){	
     2d8:	88 23       	and	r24, r24
     2da:	b9 f4       	brne	.+46     	; 0x30a <bmp085ReadTemp+0x7e>
		*error_code=checki2cReturnCode(TW_MT_DATA_ACK);
     2dc:	88 e2       	ldi	r24, 0x28	; 40
     2de:	0e 94 cc 07 	call	0xf98	; 0xf98 <checki2cReturnCode>
     2e2:	88 83       	st	Y, r24
	}
	//printf("error code: %d \n",error_code);
	//printf("TWSR STATUS: %d \n",(TWSR & 0xF8));

	//Write control register value
	if (*error_code==0){	
     2e4:	88 23       	and	r24, r24
     2e6:	89 f4       	brne	.+34     	; 0x30a <bmp085ReadTemp+0x7e>
		i2cSendByte(0x2E);	// write 0x2E
     2e8:	8e e2       	ldi	r24, 0x2E	; 46
     2ea:	0e 94 b4 07 	call	0xf68	; 0xf68 <i2cSendByte>
		*error_code=i2cWaitForComplete();
     2ee:	0e 94 be 07 	call	0xf7c	; 0xf7c <i2cWaitForComplete>
     2f2:	88 83       	st	Y, r24
	}
	//ACKS
	if (*error_code==0){	
     2f4:	88 23       	and	r24, r24
     2f6:	49 f4       	brne	.+18     	; 0x30a <bmp085ReadTemp+0x7e>
		*error_code=checki2cReturnCode(TW_MT_DATA_ACK);
     2f8:	88 e2       	ldi	r24, 0x28	; 40
     2fa:	0e 94 cc 07 	call	0xf98	; 0xf98 <checki2cReturnCode>
     2fe:	88 83       	st	Y, r24
	}
	//printf("error code: %d \n",error_code);

	
	//Send Stop on the Bus
	if (*error_code==0){
     300:	88 23       	and	r24, r24
     302:	19 f4       	brne	.+6      	; 0x30a <bmp085ReadTemp+0x7e>
		*error_code=i2cSendStop();
     304:	0e 94 9d 07 	call	0xf3a	; 0xf3a <i2cSendStop>
     308:	88 83       	st	Y, r24
	}
	//printf("error code: %d \n",error_code);

		uint16_t i = 0;		//time out variable

	while(!(input_PIN & (1<<BMP085_pin)) && (i < 5000)){
     30a:	9a 99       	sbic	0x13, 2	; 19
     30c:	07 c0       	rjmp	.+14     	; 0x31c <bmp085ReadTemp+0x90>
     30e:	88 e8       	ldi	r24, 0x88	; 136
     310:	93 e1       	ldi	r25, 0x13	; 19
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     312:	00 00       	nop
     314:	9a 99       	sbic	0x13, 2	; 19
     316:	02 c0       	rjmp	.+4      	; 0x31c <bmp085ReadTemp+0x90>
     318:	01 97       	sbiw	r24, 0x01	; 1
     31a:	d9 f7       	brne	.-10     	; 0x312 <bmp085ReadTemp+0x86>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     31c:	83 ec       	ldi	r24, 0xC3	; 195
     31e:	99 e0       	ldi	r25, 0x09	; 9
     320:	01 97       	sbiw	r24, 0x01	; 1
     322:	f1 f7       	brne	.-4      	; 0x320 <bmp085ReadTemp+0x94>
     324:	00 c0       	rjmp	.+0      	; 0x326 <bmp085ReadTemp+0x9a>
     326:	00 00       	nop
		i++;
	};
	
	_delay_ms(10);	// min time is 4.5ms
	
	if (*error_code==0){
     328:	88 81       	ld	r24, Y
     32a:	88 23       	and	r24, r24
     32c:	41 f4       	brne	.+16     	; 0x33e <bmp085ReadTemp+0xb2>
		temperature = bmp085ReadShort(0xF6,error_code);
     32e:	86 ef       	ldi	r24, 0xF6	; 246
     330:	be 01       	movw	r22, r28
     332:	0e 94 8d 00 	call	0x11a	; 0x11a <bmp085ReadShort>
     336:	8c 01       	movw	r16, r24
     338:	20 e0       	ldi	r18, 0x00	; 0
     33a:	30 e0       	ldi	r19, 0x00	; 0
     33c:	03 c0       	rjmp	.+6      	; 0x344 <bmp085ReadTemp+0xb8>
// 
//----------------------------------------
int32_t bmp085ReadTemp(uint8_t* error_code)
{
	
	int32_t temperature = 0;
     33e:	00 e0       	ldi	r16, 0x00	; 0
     340:	10 e0       	ldi	r17, 0x00	; 0
     342:	98 01       	movw	r18, r16
		temperature = bmp085ReadShort(0xF6,error_code);
	}

	
	return temperature;
}
     344:	60 2f       	mov	r22, r16
     346:	71 2f       	mov	r23, r17
     348:	82 2f       	mov	r24, r18
     34a:	93 2f       	mov	r25, r19
     34c:	df 91       	pop	r29
     34e:	cf 91       	pop	r28
     350:	1f 91       	pop	r17
     352:	0f 91       	pop	r16
     354:	08 95       	ret

00000356 <bmp085ReadPressure>:
//----------------------------------------
// 
//----------------------------------------
int32_t bmp085ReadPressure(uint8_t* error_code)
{
     356:	0f 93       	push	r16
     358:	1f 93       	push	r17
     35a:	cf 93       	push	r28
     35c:	df 93       	push	r29
     35e:	ec 01       	movw	r28, r24
	int32_t pressure = 0;
	//Send Start Condition
	i2cSendStart();	
     360:	0e 94 9a 07 	call	0xf34	; 0xf34 <i2cSendStart>
	*error_code=i2cWaitForComplete();
     364:	0e 94 be 07 	call	0xf7c	; 0xf7c <i2cWaitForComplete>
     368:	88 83       	st	Y, r24
	if (*error_code==0){
     36a:	88 23       	and	r24, r24
     36c:	99 f5       	brne	.+102    	; 0x3d4 <bmp085ReadPressure+0x7e>
		*error_code=checki2cReturnCode(TW_START);
     36e:	88 e0       	ldi	r24, 0x08	; 8
     370:	0e 94 cc 07 	call	0xf98	; 0xf98 <checki2cReturnCode>
     374:	88 83       	st	Y, r24
	}

	//printf("error code: %d \n",error_code);
	
	//Tell Salve go in receive mode
	if (*error_code==0){	
     376:	88 23       	and	r24, r24
     378:	69 f5       	brne	.+90     	; 0x3d4 <bmp085ReadPressure+0x7e>
		i2cSendByte(BMP085_W);	// write 0xEE
     37a:	8e ee       	ldi	r24, 0xEE	; 238
     37c:	0e 94 b4 07 	call	0xf68	; 0xf68 <i2cSendByte>
		*error_code=i2cWaitForComplete();
     380:	0e 94 be 07 	call	0xf7c	; 0xf7c <i2cWaitForComplete>
     384:	88 83       	st	Y, r24
	}
	//ACKS
	if (*error_code==0){	
     386:	88 23       	and	r24, r24
     388:	29 f5       	brne	.+74     	; 0x3d4 <bmp085ReadPressure+0x7e>
		*error_code=checki2cReturnCode(TW_MT_SLA_ACK);
     38a:	88 e1       	ldi	r24, 0x18	; 24
     38c:	0e 94 cc 07 	call	0xf98	; 0xf98 <checki2cReturnCode>
     390:	88 83       	st	Y, r24
	}
	//printf("error code: %d \n",error_code);
	
	//Write control register address
	if (*error_code==0){	
     392:	88 23       	and	r24, r24
     394:	f9 f4       	brne	.+62     	; 0x3d4 <bmp085ReadPressure+0x7e>
		i2cSendByte(0xF4);	// write 0xF4
     396:	84 ef       	ldi	r24, 0xF4	; 244
     398:	0e 94 b4 07 	call	0xf68	; 0xf68 <i2cSendByte>
		*error_code=i2cWaitForComplete();
     39c:	0e 94 be 07 	call	0xf7c	; 0xf7c <i2cWaitForComplete>
     3a0:	88 83       	st	Y, r24
	}
	//ACKS
	if (*error_code==0){	
     3a2:	88 23       	and	r24, r24
     3a4:	b9 f4       	brne	.+46     	; 0x3d4 <bmp085ReadPressure+0x7e>
		*error_code=checki2cReturnCode(TW_MT_DATA_ACK);
     3a6:	88 e2       	ldi	r24, 0x28	; 40
     3a8:	0e 94 cc 07 	call	0xf98	; 0xf98 <checki2cReturnCode>
     3ac:	88 83       	st	Y, r24
	}
	//printf("error code: %d \n",error_code);
	//printf("TWSR STATUS: %d \n",(TWSR & 0xF8));

	//Write control register value
	if (*error_code==0){	
     3ae:	88 23       	and	r24, r24
     3b0:	89 f4       	brne	.+34     	; 0x3d4 <bmp085ReadPressure+0x7e>
		i2cSendByte(0x34+(OSS<<6));	// write 0x34+(OSS<<6)
     3b2:	84 e3       	ldi	r24, 0x34	; 52
     3b4:	0e 94 b4 07 	call	0xf68	; 0xf68 <i2cSendByte>
		*error_code=i2cWaitForComplete();
     3b8:	0e 94 be 07 	call	0xf7c	; 0xf7c <i2cWaitForComplete>
     3bc:	88 83       	st	Y, r24
	}
	//ACKS
	if (*error_code==0){	
     3be:	88 23       	and	r24, r24
     3c0:	49 f4       	brne	.+18     	; 0x3d4 <bmp085ReadPressure+0x7e>
		*error_code=checki2cReturnCode(TW_MT_DATA_ACK);
     3c2:	88 e2       	ldi	r24, 0x28	; 40
     3c4:	0e 94 cc 07 	call	0xf98	; 0xf98 <checki2cReturnCode>
     3c8:	88 83       	st	Y, r24
	}
	//printf("error code: %d \n",error_code);

	
	//Send Stop on the Bus
	if (*error_code==0){
     3ca:	88 23       	and	r24, r24
     3cc:	19 f4       	brne	.+6      	; 0x3d4 <bmp085ReadPressure+0x7e>
		*error_code=i2cSendStop();
     3ce:	0e 94 9d 07 	call	0xf3a	; 0xf3a <i2cSendStop>
     3d2:	88 83       	st	Y, r24
	//printf("error code: %d \n",error_code);

	uint16_t i = 0;		//time out variable && (i < 25000)


	while(!(input_PIN & (1<<BMP085_pin)) && (i < 15000)){
     3d4:	9a 99       	sbic	0x13, 2	; 19
     3d6:	07 c0       	rjmp	.+14     	; 0x3e6 <bmp085ReadPressure+0x90>
     3d8:	88 e9       	ldi	r24, 0x98	; 152
     3da:	9a e3       	ldi	r25, 0x3A	; 58
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3dc:	00 00       	nop
     3de:	9a 99       	sbic	0x13, 2	; 19
     3e0:	02 c0       	rjmp	.+4      	; 0x3e6 <bmp085ReadPressure+0x90>
     3e2:	01 97       	sbiw	r24, 0x01	; 1
     3e4:	d9 f7       	brne	.-10     	; 0x3dc <bmp085ReadPressure+0x86>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     3e6:	8f e0       	ldi	r24, 0x0F	; 15
     3e8:	97 e2       	ldi	r25, 0x27	; 39
     3ea:	01 97       	sbiw	r24, 0x01	; 1
     3ec:	f1 f7       	brne	.-4      	; 0x3ea <bmp085ReadPressure+0x94>
     3ee:	00 c0       	rjmp	.+0      	; 0x3f0 <bmp085ReadPressure+0x9a>
     3f0:	00 00       	nop
		i++;
	};
	
	_delay_ms(40);	// min time is 15ms
	
	if (*error_code==0){
     3f2:	88 81       	ld	r24, Y
     3f4:	88 23       	and	r24, r24
     3f6:	41 f4       	brne	.+16     	; 0x408 <bmp085ReadPressure+0xb2>
		pressure = bmp085ReadShort(0xF6,error_code);
     3f8:	86 ef       	ldi	r24, 0xF6	; 246
     3fa:	be 01       	movw	r22, r28
     3fc:	0e 94 8d 00 	call	0x11a	; 0x11a <bmp085ReadShort>
		pressure = pressure << 8;
		pressure = pressure >> (8-OSS);
     400:	8c 01       	movw	r16, r24
     402:	20 e0       	ldi	r18, 0x00	; 0
     404:	30 e0       	ldi	r19, 0x00	; 0
     406:	03 c0       	rjmp	.+6      	; 0x40e <bmp085ReadPressure+0xb8>
//----------------------------------------
// 
//----------------------------------------
int32_t bmp085ReadPressure(uint8_t* error_code)
{
	int32_t pressure = 0;
     408:	00 e0       	ldi	r16, 0x00	; 0
     40a:	10 e0       	ldi	r17, 0x00	; 0
     40c:	98 01       	movw	r18, r16
		pressure = pressure >> (8-OSS);
	}
	
	return pressure;

}
     40e:	60 2f       	mov	r22, r16
     410:	71 2f       	mov	r23, r17
     412:	82 2f       	mov	r24, r18
     414:	93 2f       	mov	r25, r19
     416:	df 91       	pop	r29
     418:	cf 91       	pop	r28
     41a:	1f 91       	pop	r17
     41c:	0f 91       	pop	r16
     41e:	08 95       	ret

00000420 <bmp085Convert>:
//----------------------------------------
// 
//----------------------------------------
void bmp085Convert(int16_t BMP085_calibration_int16_t[],int16_t BMP085_calibration_uint16_t[],int32_t* temperature, int32_t* pressure, uint8_t* error_code)
{
     420:	2f 92       	push	r2
     422:	3f 92       	push	r3
     424:	4f 92       	push	r4
     426:	5f 92       	push	r5
     428:	6f 92       	push	r6
     42a:	7f 92       	push	r7
     42c:	8f 92       	push	r8
     42e:	9f 92       	push	r9
     430:	af 92       	push	r10
     432:	bf 92       	push	r11
     434:	cf 92       	push	r12
     436:	df 92       	push	r13
     438:	ef 92       	push	r14
     43a:	ff 92       	push	r15
     43c:	0f 93       	push	r16
     43e:	1f 93       	push	r17
     440:	cf 93       	push	r28
     442:	df 93       	push	r29
     444:	cd b7       	in	r28, 0x3d	; 61
     446:	de b7       	in	r29, 0x3e	; 62
     448:	60 97       	sbiw	r28, 0x10	; 16
     44a:	0f b6       	in	r0, 0x3f	; 63
     44c:	f8 94       	cli
     44e:	de bf       	out	0x3e, r29	; 62
     450:	0f be       	out	0x3f, r0	; 63
     452:	cd bf       	out	0x3d, r28	; 61
     454:	fc 01       	movw	r30, r24
     456:	6a 01       	movw	r12, r20
     458:	3c 87       	std	Y+12, r19	; 0x0c
     45a:	2b 87       	std	Y+11, r18	; 0x0b
	
	int32_t up=0;
	int32_t x1, x2, b5, b6, x3, b3, p;
	uint32_t b4, b7;
	
	ac1=BMP085_calibration_int16_t[0];
     45c:	80 81       	ld	r24, Z
     45e:	91 81       	ldd	r25, Z+1	; 0x01
     460:	90 93 de 05 	sts	0x05DE, r25
     464:	80 93 dd 05 	sts	0x05DD, r24
	ac2=BMP085_calibration_int16_t[1]; 
     468:	82 81       	ldd	r24, Z+2	; 0x02
     46a:	93 81       	ldd	r25, Z+3	; 0x03
     46c:	90 93 e6 05 	sts	0x05E6, r25
     470:	80 93 e5 05 	sts	0x05E5, r24
	ac3=BMP085_calibration_int16_t[2]; 
     474:	84 81       	ldd	r24, Z+4	; 0x04
     476:	95 81       	ldd	r25, Z+5	; 0x05
     478:	90 93 f2 05 	sts	0x05F2, r25
     47c:	80 93 f1 05 	sts	0x05F1, r24
	ac4=BMP085_calibration_uint16_t[0];
     480:	db 01       	movw	r26, r22
     482:	8d 91       	ld	r24, X+
     484:	9c 91       	ld	r25, X
     486:	11 97       	sbiw	r26, 0x01	; 1
     488:	90 93 ea 05 	sts	0x05EA, r25
     48c:	80 93 e9 05 	sts	0x05E9, r24
	ac5=BMP085_calibration_uint16_t[1];
     490:	12 96       	adiw	r26, 0x02	; 2
     492:	8d 91       	ld	r24, X+
     494:	9c 91       	ld	r25, X
     496:	13 97       	sbiw	r26, 0x03	; 3
     498:	90 93 e4 05 	sts	0x05E4, r25
     49c:	80 93 e3 05 	sts	0x05E3, r24
	ac6=BMP085_calibration_uint16_t[2];
     4a0:	14 96       	adiw	r26, 0x04	; 4
     4a2:	8d 91       	ld	r24, X+
     4a4:	9c 91       	ld	r25, X
     4a6:	15 97       	sbiw	r26, 0x05	; 5
     4a8:	90 93 e2 05 	sts	0x05E2, r25
     4ac:	80 93 e1 05 	sts	0x05E1, r24
	b1=BMP085_calibration_int16_t[3]; 
     4b0:	86 81       	ldd	r24, Z+6	; 0x06
     4b2:	97 81       	ldd	r25, Z+7	; 0x07
     4b4:	90 93 e0 05 	sts	0x05E0, r25
     4b8:	80 93 df 05 	sts	0x05DF, r24
	b2=BMP085_calibration_int16_t[4];
     4bc:	80 85       	ldd	r24, Z+8	; 0x08
     4be:	91 85       	ldd	r25, Z+9	; 0x09
     4c0:	90 93 da 05 	sts	0x05DA, r25
     4c4:	80 93 d9 05 	sts	0x05D9, r24
	mb=BMP085_calibration_int16_t[5];
     4c8:	82 85       	ldd	r24, Z+10	; 0x0a
     4ca:	93 85       	ldd	r25, Z+11	; 0x0b
     4cc:	90 93 dc 05 	sts	0x05DC, r25
     4d0:	80 93 db 05 	sts	0x05DB, r24
	mc=BMP085_calibration_int16_t[6];
     4d4:	84 85       	ldd	r24, Z+12	; 0x0c
     4d6:	95 85       	ldd	r25, Z+13	; 0x0d
     4d8:	90 93 ec 05 	sts	0x05EC, r25
     4dc:	80 93 eb 05 	sts	0x05EB, r24
	md=BMP085_calibration_int16_t[7];
     4e0:	86 85       	ldd	r24, Z+14	; 0x0e
     4e2:	97 85       	ldd	r25, Z+15	; 0x0f
     4e4:	90 93 e8 05 	sts	0x05E8, r25
     4e8:	80 93 e7 05 	sts	0x05E7, r24

	
	if (*error_code==0){
     4ec:	f8 01       	movw	r30, r16
     4ee:	80 81       	ld	r24, Z
     4f0:	88 23       	and	r24, r24
     4f2:	c9 f4       	brne	.+50     	; 0x526 <bmp085Convert+0x106>
		ut = bmp085ReadTemp(error_code);
     4f4:	c8 01       	movw	r24, r16
     4f6:	0e 94 46 01 	call	0x28c	; 0x28c <bmp085ReadTemp>
     4fa:	dc 01       	movw	r26, r24
     4fc:	cb 01       	movw	r24, r22
     4fe:	80 93 ed 05 	sts	0x05ED, r24
     502:	90 93 ee 05 	sts	0x05EE, r25
     506:	a0 93 ef 05 	sts	0x05EF, r26
     50a:	b0 93 f0 05 	sts	0x05F0, r27
	}
	if (*error_code==0){
     50e:	d8 01       	movw	r26, r16
     510:	8c 91       	ld	r24, X
     512:	88 23       	and	r24, r24
     514:	69 f4       	brne	.+26     	; 0x530 <bmp085Convert+0x110>
		up = bmp085ReadPressure(error_code);
     516:	c8 01       	movw	r24, r16
     518:	0e 94 ab 01 	call	0x356	; 0x356 <bmp085ReadPressure>
     51c:	6d 83       	std	Y+5, r22	; 0x05
     51e:	7e 83       	std	Y+6, r23	; 0x06
     520:	8f 83       	std	Y+7, r24	; 0x07
     522:	98 87       	std	Y+8, r25	; 0x08
     524:	09 c0       	rjmp	.+18     	; 0x538 <bmp085Convert+0x118>
//----------------------------------------
void bmp085Convert(int16_t BMP085_calibration_int16_t[],int16_t BMP085_calibration_uint16_t[],int32_t* temperature, int32_t* pressure, uint8_t* error_code)
{

	
	int32_t up=0;
     526:	1d 82       	std	Y+5, r1	; 0x05
     528:	1e 82       	std	Y+6, r1	; 0x06
     52a:	1f 82       	std	Y+7, r1	; 0x07
     52c:	18 86       	std	Y+8, r1	; 0x08
     52e:	04 c0       	rjmp	.+8      	; 0x538 <bmp085Convert+0x118>
     530:	1d 82       	std	Y+5, r1	; 0x05
     532:	1e 82       	std	Y+6, r1	; 0x06
     534:	1f 82       	std	Y+7, r1	; 0x07
     536:	18 86       	std	Y+8, r1	; 0x08
	if (*error_code==0){
		up = bmp085ReadPressure(error_code);
	}
	*/
	
	x1 = ((int32_t)ut - (int32_t)ac6) * (int32_t)ac5 >> 15;
     538:	40 91 ed 05 	lds	r20, 0x05ED
     53c:	50 91 ee 05 	lds	r21, 0x05EE
     540:	60 91 ef 05 	lds	r22, 0x05EF
     544:	70 91 f0 05 	lds	r23, 0x05F0
     548:	80 91 e1 05 	lds	r24, 0x05E1
     54c:	90 91 e2 05 	lds	r25, 0x05E2
     550:	20 91 e3 05 	lds	r18, 0x05E3
     554:	30 91 e4 05 	lds	r19, 0x05E4
     558:	a0 e0       	ldi	r26, 0x00	; 0
     55a:	b0 e0       	ldi	r27, 0x00	; 0
     55c:	7a 01       	movw	r14, r20
     55e:	8b 01       	movw	r16, r22
     560:	e8 1a       	sub	r14, r24
     562:	f9 0a       	sbc	r15, r25
     564:	0a 0b       	sbc	r16, r26
     566:	1b 0b       	sbc	r17, r27
     568:	c8 01       	movw	r24, r16
     56a:	b7 01       	movw	r22, r14
     56c:	40 e0       	ldi	r20, 0x00	; 0
     56e:	50 e0       	ldi	r21, 0x00	; 0
     570:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <__mulsi3>
     574:	4b 01       	movw	r8, r22
     576:	5c 01       	movw	r10, r24
     578:	07 2e       	mov	r0, r23
     57a:	7f e0       	ldi	r23, 0x0F	; 15
     57c:	b5 94       	asr	r11
     57e:	a7 94       	ror	r10
     580:	97 94       	ror	r9
     582:	87 94       	ror	r8
     584:	7a 95       	dec	r23
     586:	d1 f7       	brne	.-12     	; 0x57c <bmp085Convert+0x15c>
     588:	70 2d       	mov	r23, r0
	x2 = ((int32_t)mc << 11) / (x1 + md);
     58a:	80 91 eb 05 	lds	r24, 0x05EB
     58e:	90 91 ec 05 	lds	r25, 0x05EC
     592:	20 91 e7 05 	lds	r18, 0x05E7
     596:	30 91 e8 05 	lds	r19, 0x05E8
     59a:	aa 27       	eor	r26, r26
     59c:	97 fd       	sbrc	r25, 7
     59e:	a0 95       	com	r26
     5a0:	ba 2f       	mov	r27, r26
     5a2:	bc 01       	movw	r22, r24
     5a4:	cd 01       	movw	r24, r26
     5a6:	05 2e       	mov	r0, r21
     5a8:	5b e0       	ldi	r21, 0x0B	; 11
     5aa:	66 0f       	add	r22, r22
     5ac:	77 1f       	adc	r23, r23
     5ae:	88 1f       	adc	r24, r24
     5b0:	99 1f       	adc	r25, r25
     5b2:	5a 95       	dec	r21
     5b4:	d1 f7       	brne	.-12     	; 0x5aa <bmp085Convert+0x18a>
     5b6:	50 2d       	mov	r21, r0
     5b8:	44 27       	eor	r20, r20
     5ba:	37 fd       	sbrc	r19, 7
     5bc:	40 95       	com	r20
     5be:	54 2f       	mov	r21, r20
     5c0:	28 0d       	add	r18, r8
     5c2:	39 1d       	adc	r19, r9
     5c4:	4a 1d       	adc	r20, r10
     5c6:	5b 1d       	adc	r21, r11
     5c8:	0e 94 a7 1a 	call	0x354e	; 0x354e <__divmodsi4>
	b5 = x1 + x2;
     5cc:	82 0e       	add	r8, r18
     5ce:	93 1e       	adc	r9, r19
     5d0:	a4 1e       	adc	r10, r20
     5d2:	b5 1e       	adc	r11, r21
	*temperature = (b5 + 8) >> 4;
     5d4:	d5 01       	movw	r26, r10
     5d6:	c4 01       	movw	r24, r8
     5d8:	08 96       	adiw	r24, 0x08	; 8
     5da:	a1 1d       	adc	r26, r1
     5dc:	b1 1d       	adc	r27, r1
     5de:	68 94       	set
     5e0:	13 f8       	bld	r1, 3
     5e2:	b5 95       	asr	r27
     5e4:	a7 95       	ror	r26
     5e6:	97 95       	ror	r25
     5e8:	87 95       	ror	r24
     5ea:	16 94       	lsr	r1
     5ec:	d1 f7       	brne	.-12     	; 0x5e2 <bmp085Convert+0x1c2>
     5ee:	f6 01       	movw	r30, r12
     5f0:	80 83       	st	Z, r24
     5f2:	91 83       	std	Z+1, r25	; 0x01
     5f4:	a2 83       	std	Z+2, r26	; 0x02
     5f6:	b3 83       	std	Z+3, r27	; 0x03
	
	b6 = b5 - 4000;
     5f8:	0f 2e       	mov	r0, r31
     5fa:	f0 e6       	ldi	r31, 0x60	; 96
     5fc:	ef 2e       	mov	r14, r31
     5fe:	f0 ef       	ldi	r31, 0xF0	; 240
     600:	ff 2e       	mov	r15, r31
     602:	ff ef       	ldi	r31, 0xFF	; 255
     604:	0f 2f       	mov	r16, r31
     606:	ff ef       	ldi	r31, 0xFF	; 255
     608:	1f 2f       	mov	r17, r31
     60a:	f0 2d       	mov	r31, r0
     60c:	8e 0c       	add	r8, r14
     60e:	9f 1c       	adc	r9, r15
     610:	a0 1e       	adc	r10, r16
     612:	b1 1e       	adc	r11, r17
	x1 = (b2 * ((b6 * b6) >> 12)) >> 11;
     614:	20 90 d9 05 	lds	r2, 0x05D9
     618:	30 90 da 05 	lds	r3, 0x05DA
     61c:	c5 01       	movw	r24, r10
     61e:	b4 01       	movw	r22, r8
     620:	a5 01       	movw	r20, r10
     622:	94 01       	movw	r18, r8
     624:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <__mulsi3>
     628:	dc 01       	movw	r26, r24
     62a:	cb 01       	movw	r24, r22
     62c:	8c 01       	movw	r16, r24
     62e:	9d 01       	movw	r18, r26
     630:	0f 2e       	mov	r0, r31
     632:	fc e0       	ldi	r31, 0x0C	; 12
     634:	35 95       	asr	r19
     636:	27 95       	ror	r18
     638:	17 95       	ror	r17
     63a:	07 95       	ror	r16
     63c:	fa 95       	dec	r31
     63e:	d1 f7       	brne	.-12     	; 0x634 <bmp085Convert+0x214>
     640:	f0 2d       	mov	r31, r0
     642:	09 83       	std	Y+1, r16	; 0x01
     644:	1a 83       	std	Y+2, r17	; 0x02
     646:	2b 83       	std	Y+3, r18	; 0x03
     648:	3c 83       	std	Y+4, r19	; 0x04
	x2 = (ac2 * b6) >> 11;
     64a:	e0 90 e5 05 	lds	r14, 0x05E5
     64e:	f0 90 e6 05 	lds	r15, 0x05E6
     652:	fa 86       	std	Y+10, r15	; 0x0a
     654:	e9 86       	std	Y+9, r14	; 0x09
	x3 = x1 + x2;
	b3 = (((((int32_t) ac1) * 4 + x3)<<OSS) + 2)>> 2;
     656:	00 91 dd 05 	lds	r16, 0x05DD
     65a:	10 91 de 05 	lds	r17, 0x05DE
	x1 = (ac3 * b6) >> 13;
     65e:	60 91 f1 05 	lds	r22, 0x05F1
     662:	70 91 f2 05 	lds	r23, 0x05F2
	x2 = (b1 * ((b6 * b6) >> 12)) >> 16;
     666:	60 90 df 05 	lds	r6, 0x05DF
     66a:	70 90 e0 05 	lds	r7, 0x05E0
	x3 = ((x1 + x2) + 2) >> 2;
	b4 = (ac4 * (uint32_t) (x3 + 32768)) >> 15;
     66e:	40 90 e9 05 	lds	r4, 0x05E9
     672:	50 90 ea 05 	lds	r5, 0x05EA
	b6 = b5 - 4000;
	x1 = (b2 * ((b6 * b6) >> 12)) >> 11;
	x2 = (ac2 * b6) >> 11;
	x3 = x1 + x2;
	b3 = (((((int32_t) ac1) * 4 + x3)<<OSS) + 2)>> 2;
	x1 = (ac3 * b6) >> 13;
     676:	88 27       	eor	r24, r24
     678:	77 fd       	sbrc	r23, 7
     67a:	80 95       	com	r24
     67c:	98 2f       	mov	r25, r24
     67e:	a5 01       	movw	r20, r10
     680:	94 01       	movw	r18, r8
     682:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <__mulsi3>
     686:	dc 01       	movw	r26, r24
     688:	cb 01       	movw	r24, r22
     68a:	6c 01       	movw	r12, r24
     68c:	7d 01       	movw	r14, r26
     68e:	0b 2e       	mov	r0, r27
     690:	bd e0       	ldi	r27, 0x0D	; 13
     692:	f5 94       	asr	r15
     694:	e7 94       	ror	r14
     696:	d7 94       	ror	r13
     698:	c7 94       	ror	r12
     69a:	ba 95       	dec	r27
     69c:	d1 f7       	brne	.-12     	; 0x692 <bmp085Convert+0x272>
     69e:	b0 2d       	mov	r27, r0
	x2 = (b1 * ((b6 * b6) >> 12)) >> 16;
     6a0:	93 01       	movw	r18, r6
     6a2:	44 27       	eor	r20, r20
     6a4:	37 fd       	sbrc	r19, 7
     6a6:	40 95       	com	r20
     6a8:	54 2f       	mov	r21, r20
     6aa:	69 81       	ldd	r22, Y+1	; 0x01
     6ac:	7a 81       	ldd	r23, Y+2	; 0x02
     6ae:	8b 81       	ldd	r24, Y+3	; 0x03
     6b0:	9c 81       	ldd	r25, Y+4	; 0x04
     6b2:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <__mulsi3>
     6b6:	dc 01       	movw	r26, r24
     6b8:	cb 01       	movw	r24, r22
     6ba:	cd 01       	movw	r24, r26
     6bc:	bb 27       	eor	r27, r27
     6be:	97 fd       	sbrc	r25, 7
     6c0:	b0 95       	com	r27
     6c2:	ab 2f       	mov	r26, r27
	x3 = ((x1 + x2) + 2) >> 2;
     6c4:	8c 0d       	add	r24, r12
     6c6:	9d 1d       	adc	r25, r13
     6c8:	ae 1d       	adc	r26, r14
     6ca:	bf 1d       	adc	r27, r15
     6cc:	02 96       	adiw	r24, 0x02	; 2
     6ce:	a1 1d       	adc	r26, r1
     6d0:	b1 1d       	adc	r27, r1
     6d2:	b5 95       	asr	r27
     6d4:	a7 95       	ror	r26
     6d6:	97 95       	ror	r25
     6d8:	87 95       	ror	r24
     6da:	b5 95       	asr	r27
     6dc:	a7 95       	ror	r26
     6de:	97 95       	ror	r25
     6e0:	87 95       	ror	r24
	b4 = (ac4 * (uint32_t) (x3 + 32768)) >> 15;
     6e2:	80 50       	subi	r24, 0x00	; 0
     6e4:	90 48       	sbci	r25, 0x80	; 128
     6e6:	af 4f       	sbci	r26, 0xFF	; 255
     6e8:	bf 4f       	sbci	r27, 0xFF	; 255
     6ea:	92 01       	movw	r18, r4
     6ec:	40 e0       	ldi	r20, 0x00	; 0
     6ee:	50 e0       	ldi	r21, 0x00	; 0
     6f0:	bc 01       	movw	r22, r24
     6f2:	cd 01       	movw	r24, r26
     6f4:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <__mulsi3>
     6f8:	dc 01       	movw	r26, r24
     6fa:	cb 01       	movw	r24, r22
     6fc:	2c 01       	movw	r4, r24
     6fe:	3d 01       	movw	r6, r26
     700:	03 2e       	mov	r0, r19
     702:	3f e0       	ldi	r19, 0x0F	; 15
     704:	76 94       	lsr	r7
     706:	67 94       	ror	r6
     708:	57 94       	ror	r5
     70a:	47 94       	ror	r4
     70c:	3a 95       	dec	r19
     70e:	d1 f7       	brne	.-12     	; 0x704 <bmp085Convert+0x2e4>
     710:	30 2d       	mov	r19, r0
	
	b6 = b5 - 4000;
	x1 = (b2 * ((b6 * b6) >> 12)) >> 11;
	x2 = (ac2 * b6) >> 11;
	x3 = x1 + x2;
	b3 = (((((int32_t) ac1) * 4 + x3)<<OSS) + 2)>> 2;
     712:	68 01       	movw	r12, r16
     714:	ee 24       	eor	r14, r14
     716:	d7 fc       	sbrc	r13, 7
     718:	e0 94       	com	r14
     71a:	fe 2c       	mov	r15, r14
     71c:	97 01       	movw	r18, r14
     71e:	86 01       	movw	r16, r12
     720:	00 0f       	add	r16, r16
     722:	11 1f       	adc	r17, r17
     724:	22 1f       	adc	r18, r18
     726:	33 1f       	adc	r19, r19
     728:	00 0f       	add	r16, r16
     72a:	11 1f       	adc	r17, r17
     72c:	22 1f       	adc	r18, r18
     72e:	33 1f       	adc	r19, r19
     730:	0d 87       	std	Y+13, r16	; 0x0d
     732:	1e 87       	std	Y+14, r17	; 0x0e
     734:	2f 87       	std	Y+15, r18	; 0x0f
     736:	38 8b       	std	Y+16, r19	; 0x10
	x2 = ((int32_t)mc << 11) / (x1 + md);
	b5 = x1 + x2;
	*temperature = (b5 + 8) >> 4;
	
	b6 = b5 - 4000;
	x1 = (b2 * ((b6 * b6) >> 12)) >> 11;
     738:	b1 01       	movw	r22, r2
     73a:	88 27       	eor	r24, r24
     73c:	77 fd       	sbrc	r23, 7
     73e:	80 95       	com	r24
     740:	98 2f       	mov	r25, r24
     742:	29 81       	ldd	r18, Y+1	; 0x01
     744:	3a 81       	ldd	r19, Y+2	; 0x02
     746:	4b 81       	ldd	r20, Y+3	; 0x03
     748:	5c 81       	ldd	r21, Y+4	; 0x04
     74a:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <__mulsi3>
     74e:	6b 01       	movw	r12, r22
     750:	7c 01       	movw	r14, r24
     752:	0b 2e       	mov	r0, r27
     754:	bb e0       	ldi	r27, 0x0B	; 11
     756:	f5 94       	asr	r15
     758:	e7 94       	ror	r14
     75a:	d7 94       	ror	r13
     75c:	c7 94       	ror	r12
     75e:	ba 95       	dec	r27
     760:	d1 f7       	brne	.-12     	; 0x756 <bmp085Convert+0x336>
     762:	b0 2d       	mov	r27, r0
	x2 = (ac2 * b6) >> 11;
     764:	09 85       	ldd	r16, Y+9	; 0x09
     766:	1a 85       	ldd	r17, Y+10	; 0x0a
     768:	b8 01       	movw	r22, r16
     76a:	88 27       	eor	r24, r24
     76c:	77 fd       	sbrc	r23, 7
     76e:	80 95       	com	r24
     770:	98 2f       	mov	r25, r24
     772:	a5 01       	movw	r20, r10
     774:	94 01       	movw	r18, r8
     776:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <__mulsi3>
     77a:	dc 01       	movw	r26, r24
     77c:	cb 01       	movw	r24, r22
     77e:	07 2e       	mov	r0, r23
     780:	7b e0       	ldi	r23, 0x0B	; 11
     782:	b5 95       	asr	r27
     784:	a7 95       	ror	r26
     786:	97 95       	ror	r25
     788:	87 95       	ror	r24
     78a:	7a 95       	dec	r23
     78c:	d1 f7       	brne	.-12     	; 0x782 <bmp085Convert+0x362>
     78e:	70 2d       	mov	r23, r0
	x3 = x1 + x2;
     790:	c8 0e       	add	r12, r24
     792:	d9 1e       	adc	r13, r25
     794:	ea 1e       	adc	r14, r26
     796:	fb 1e       	adc	r15, r27
	b3 = (((((int32_t) ac1) * 4 + x3)<<OSS) + 2)>> 2;
     798:	8d 85       	ldd	r24, Y+13	; 0x0d
     79a:	9e 85       	ldd	r25, Y+14	; 0x0e
     79c:	af 85       	ldd	r26, Y+15	; 0x0f
     79e:	b8 89       	ldd	r27, Y+16	; 0x10
     7a0:	8c 0d       	add	r24, r12
     7a2:	9d 1d       	adc	r25, r13
     7a4:	ae 1d       	adc	r26, r14
     7a6:	bf 1d       	adc	r27, r15
     7a8:	02 96       	adiw	r24, 0x02	; 2
     7aa:	a1 1d       	adc	r26, r1
     7ac:	b1 1d       	adc	r27, r1
     7ae:	6c 01       	movw	r12, r24
     7b0:	7d 01       	movw	r14, r26
     7b2:	f5 94       	asr	r15
     7b4:	e7 94       	ror	r14
     7b6:	d7 94       	ror	r13
     7b8:	c7 94       	ror	r12
     7ba:	f5 94       	asr	r15
     7bc:	e7 94       	ror	r14
     7be:	d7 94       	ror	r13
     7c0:	c7 94       	ror	r12
	x1 = (ac3 * b6) >> 13;
	x2 = (b1 * ((b6 * b6) >> 12)) >> 16;
	x3 = ((x1 + x2) + 2) >> 2;
	b4 = (ac4 * (uint32_t) (x3 + 32768)) >> 15;
	b7 = (((uint32_t) (up - b3)) * (50000 >> OSS));
     7c2:	6d 81       	ldd	r22, Y+5	; 0x05
     7c4:	7e 81       	ldd	r23, Y+6	; 0x06
     7c6:	8f 81       	ldd	r24, Y+7	; 0x07
     7c8:	98 85       	ldd	r25, Y+8	; 0x08
     7ca:	6c 19       	sub	r22, r12
     7cc:	7d 09       	sbc	r23, r13
     7ce:	8e 09       	sbc	r24, r14
     7d0:	9f 09       	sbc	r25, r15
     7d2:	20 e5       	ldi	r18, 0x50	; 80
     7d4:	33 ec       	ldi	r19, 0xC3	; 195
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <__mulsi3>

	
	if (b7 < 0x80000000)
     7de:	99 23       	and	r25, r25
     7e0:	5c f0       	brlt	.+22     	; 0x7f8 <bmp085Convert+0x3d8>
	{
		p = (b7 << 1) / b4;
     7e2:	66 0f       	add	r22, r22
     7e4:	77 1f       	adc	r23, r23
     7e6:	88 1f       	adc	r24, r24
     7e8:	99 1f       	adc	r25, r25
     7ea:	a3 01       	movw	r20, r6
     7ec:	92 01       	movw	r18, r4
     7ee:	0e 94 85 1a 	call	0x350a	; 0x350a <__udivmodsi4>
     7f2:	69 01       	movw	r12, r18
     7f4:	7a 01       	movw	r14, r20
     7f6:	0a c0       	rjmp	.+20     	; 0x80c <bmp085Convert+0x3ec>
	}
	else
	{ 
		p = (b7 / b4) << 1;
     7f8:	a3 01       	movw	r20, r6
     7fa:	92 01       	movw	r18, r4
     7fc:	0e 94 85 1a 	call	0x350a	; 0x350a <__udivmodsi4>
     800:	69 01       	movw	r12, r18
     802:	7a 01       	movw	r14, r20
     804:	cc 0c       	add	r12, r12
     806:	dd 1c       	adc	r13, r13
     808:	ee 1c       	adc	r14, r14
     80a:	ff 1c       	adc	r15, r15
	}

	x1 = (p >> 8) * (p >> 8);
     80c:	55 27       	eor	r21, r21
     80e:	f7 fc       	sbrc	r15, 7
     810:	5a 95       	dec	r21
     812:	4f 2d       	mov	r20, r15
     814:	3e 2d       	mov	r19, r14
     816:	2d 2d       	mov	r18, r13
     818:	ca 01       	movw	r24, r20
     81a:	b9 01       	movw	r22, r18
     81c:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <__mulsi3>
	x1 = (x1 * 3038) >> 16;
     820:	2e ed       	ldi	r18, 0xDE	; 222
     822:	3b e0       	ldi	r19, 0x0B	; 11
     824:	40 e0       	ldi	r20, 0x00	; 0
     826:	50 e0       	ldi	r21, 0x00	; 0
     828:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <__mulsi3>
     82c:	4c 01       	movw	r8, r24
     82e:	bb 24       	eor	r11, r11
     830:	97 fc       	sbrc	r9, 7
     832:	b0 94       	com	r11
     834:	ab 2c       	mov	r10, r11
	x2 = (-7357 * p) >> 16;
     836:	c7 01       	movw	r24, r14
     838:	b6 01       	movw	r22, r12
     83a:	23 e4       	ldi	r18, 0x43	; 67
     83c:	33 ee       	ldi	r19, 0xE3	; 227
     83e:	4f ef       	ldi	r20, 0xFF	; 255
     840:	5f ef       	ldi	r21, 0xFF	; 255
     842:	0e 94 52 1a 	call	0x34a4	; 0x34a4 <__mulsi3>
     846:	dc 01       	movw	r26, r24
     848:	cb 01       	movw	r24, r22
     84a:	cd 01       	movw	r24, r26
     84c:	bb 27       	eor	r27, r27
     84e:	97 fd       	sbrc	r25, 7
     850:	b0 95       	com	r27
     852:	ab 2f       	mov	r26, r27
	*pressure = p + ((x1 + x2 + 3791) >> 4);
     854:	88 0d       	add	r24, r8
     856:	99 1d       	adc	r25, r9
     858:	aa 1d       	adc	r26, r10
     85a:	bb 1d       	adc	r27, r11
     85c:	81 53       	subi	r24, 0x31	; 49
     85e:	91 4f       	sbci	r25, 0xF1	; 241
     860:	af 4f       	sbci	r26, 0xFF	; 255
     862:	bf 4f       	sbci	r27, 0xFF	; 255
     864:	68 94       	set
     866:	13 f8       	bld	r1, 3
     868:	b5 95       	asr	r27
     86a:	a7 95       	ror	r26
     86c:	97 95       	ror	r25
     86e:	87 95       	ror	r24
     870:	16 94       	lsr	r1
     872:	d1 f7       	brne	.-12     	; 0x868 <__stack+0x9>
     874:	c8 0e       	add	r12, r24
     876:	d9 1e       	adc	r13, r25
     878:	ea 1e       	adc	r14, r26
     87a:	fb 1e       	adc	r15, r27
     87c:	ab 85       	ldd	r26, Y+11	; 0x0b
     87e:	bc 85       	ldd	r27, Y+12	; 0x0c
     880:	cd 92       	st	X+, r12
     882:	dd 92       	st	X+, r13
     884:	ed 92       	st	X+, r14
     886:	fc 92       	st	X, r15
     888:	13 97       	sbiw	r26, 0x03	; 3
}
     88a:	60 96       	adiw	r28, 0x10	; 16
     88c:	0f b6       	in	r0, 0x3f	; 63
     88e:	f8 94       	cli
     890:	de bf       	out	0x3e, r29	; 62
     892:	0f be       	out	0x3f, r0	; 63
     894:	cd bf       	out	0x3d, r28	; 61
     896:	df 91       	pop	r29
     898:	cf 91       	pop	r28
     89a:	1f 91       	pop	r17
     89c:	0f 91       	pop	r16
     89e:	ff 90       	pop	r15
     8a0:	ef 90       	pop	r14
     8a2:	df 90       	pop	r13
     8a4:	cf 90       	pop	r12
     8a6:	bf 90       	pop	r11
     8a8:	af 90       	pop	r10
     8aa:	9f 90       	pop	r9
     8ac:	8f 90       	pop	r8
     8ae:	7f 90       	pop	r7
     8b0:	6f 90       	pop	r6
     8b2:	5f 90       	pop	r5
     8b4:	4f 90       	pop	r4
     8b6:	3f 90       	pop	r3
     8b8:	2f 90       	pop	r2
     8ba:	08 95       	ret

000008bc <BMP085_Calibration>:
//----------------------------------------
// 
//----------------------------------------

void BMP085_Calibration(int16_t BMP085_calibration_int16_t[],int16_t BMP085_calibration_uint16_t[], uint8_t* errorcode)
{
     8bc:	ef 92       	push	r14
     8be:	ff 92       	push	r15
     8c0:	0f 93       	push	r16
     8c2:	1f 93       	push	r17
     8c4:	cf 93       	push	r28
     8c6:	df 93       	push	r29
     8c8:	8c 01       	movw	r16, r24
     8ca:	7b 01       	movw	r14, r22
     8cc:	ea 01       	movw	r28, r20
	
	input_init();
     8ce:	0e 94 8a 00 	call	0x114	; 0x114 <input_init>

	if (*errorcode==0){
     8d2:	88 81       	ld	r24, Y
     8d4:	88 23       	and	r24, r24
     8d6:	09 f0       	breq	.+2      	; 0x8da <BMP085_Calibration+0x1e>
     8d8:	6f c0       	rjmp	.+222    	; 0x9b8 <BMP085_Calibration+0xfc>
		BMP085_calibration_int16_t[0] = bmp085ReadShort(0xAA,errorcode);//ac1
     8da:	8a ea       	ldi	r24, 0xAA	; 170
     8dc:	be 01       	movw	r22, r28
     8de:	0e 94 8d 00 	call	0x11a	; 0x11a <bmp085ReadShort>
     8e2:	f8 01       	movw	r30, r16
     8e4:	91 83       	std	Z+1, r25	; 0x01
     8e6:	80 83       	st	Z, r24
	}	
	if (*errorcode==0){	
     8e8:	88 81       	ld	r24, Y
     8ea:	88 23       	and	r24, r24
     8ec:	09 f0       	breq	.+2      	; 0x8f0 <BMP085_Calibration+0x34>
     8ee:	64 c0       	rjmp	.+200    	; 0x9b8 <BMP085_Calibration+0xfc>
		BMP085_calibration_int16_t[1] = bmp085ReadShort(0xAC,errorcode);//ac2
     8f0:	8c ea       	ldi	r24, 0xAC	; 172
     8f2:	be 01       	movw	r22, r28
     8f4:	0e 94 8d 00 	call	0x11a	; 0x11a <bmp085ReadShort>
     8f8:	f8 01       	movw	r30, r16
     8fa:	93 83       	std	Z+3, r25	; 0x03
     8fc:	82 83       	std	Z+2, r24	; 0x02
	}
	if (*errorcode==0){	
     8fe:	88 81       	ld	r24, Y
     900:	88 23       	and	r24, r24
     902:	09 f0       	breq	.+2      	; 0x906 <BMP085_Calibration+0x4a>
     904:	59 c0       	rjmp	.+178    	; 0x9b8 <BMP085_Calibration+0xfc>
		BMP085_calibration_int16_t[2] = bmp085ReadShort(0xAE,errorcode);//ac3
     906:	8e ea       	ldi	r24, 0xAE	; 174
     908:	be 01       	movw	r22, r28
     90a:	0e 94 8d 00 	call	0x11a	; 0x11a <bmp085ReadShort>
     90e:	f8 01       	movw	r30, r16
     910:	95 83       	std	Z+5, r25	; 0x05
     912:	84 83       	std	Z+4, r24	; 0x04
	}
	if (*errorcode==0){	
     914:	88 81       	ld	r24, Y
     916:	88 23       	and	r24, r24
     918:	09 f0       	breq	.+2      	; 0x91c <BMP085_Calibration+0x60>
     91a:	4e c0       	rjmp	.+156    	; 0x9b8 <BMP085_Calibration+0xfc>
		BMP085_calibration_uint16_t[0] = bmp085ReadShort(0xB0,errorcode);//ac4
     91c:	80 eb       	ldi	r24, 0xB0	; 176
     91e:	be 01       	movw	r22, r28
     920:	0e 94 8d 00 	call	0x11a	; 0x11a <bmp085ReadShort>
     924:	f7 01       	movw	r30, r14
     926:	91 83       	std	Z+1, r25	; 0x01
     928:	80 83       	st	Z, r24
	}
	if (*errorcode==0){	
     92a:	88 81       	ld	r24, Y
     92c:	88 23       	and	r24, r24
     92e:	09 f0       	breq	.+2      	; 0x932 <BMP085_Calibration+0x76>
     930:	43 c0       	rjmp	.+134    	; 0x9b8 <BMP085_Calibration+0xfc>
		BMP085_calibration_uint16_t[1] = bmp085ReadShort(0xB2,errorcode);//ac5
     932:	82 eb       	ldi	r24, 0xB2	; 178
     934:	be 01       	movw	r22, r28
     936:	0e 94 8d 00 	call	0x11a	; 0x11a <bmp085ReadShort>
     93a:	f7 01       	movw	r30, r14
     93c:	93 83       	std	Z+3, r25	; 0x03
     93e:	82 83       	std	Z+2, r24	; 0x02
	}
	if (*errorcode==0){	
     940:	88 81       	ld	r24, Y
     942:	88 23       	and	r24, r24
     944:	c9 f5       	brne	.+114    	; 0x9b8 <BMP085_Calibration+0xfc>
		BMP085_calibration_uint16_t[2] = bmp085ReadShort(0xB4,errorcode);//ac6
     946:	84 eb       	ldi	r24, 0xB4	; 180
     948:	be 01       	movw	r22, r28
     94a:	0e 94 8d 00 	call	0x11a	; 0x11a <bmp085ReadShort>
     94e:	f7 01       	movw	r30, r14
     950:	95 83       	std	Z+5, r25	; 0x05
     952:	84 83       	std	Z+4, r24	; 0x04
	}
	if (*errorcode==0){	
     954:	88 81       	ld	r24, Y
     956:	88 23       	and	r24, r24
     958:	79 f5       	brne	.+94     	; 0x9b8 <BMP085_Calibration+0xfc>
		BMP085_calibration_int16_t[3] = bmp085ReadShort(0xB6,errorcode);//b1
     95a:	86 eb       	ldi	r24, 0xB6	; 182
     95c:	be 01       	movw	r22, r28
     95e:	0e 94 8d 00 	call	0x11a	; 0x11a <bmp085ReadShort>
     962:	f8 01       	movw	r30, r16
     964:	97 83       	std	Z+7, r25	; 0x07
     966:	86 83       	std	Z+6, r24	; 0x06
	}
	if (*errorcode==0){	
     968:	88 81       	ld	r24, Y
     96a:	88 23       	and	r24, r24
     96c:	29 f5       	brne	.+74     	; 0x9b8 <BMP085_Calibration+0xfc>
		BMP085_calibration_int16_t[4] = bmp085ReadShort(0xB8,errorcode);//b2
     96e:	88 eb       	ldi	r24, 0xB8	; 184
     970:	be 01       	movw	r22, r28
     972:	0e 94 8d 00 	call	0x11a	; 0x11a <bmp085ReadShort>
     976:	f8 01       	movw	r30, r16
     978:	91 87       	std	Z+9, r25	; 0x09
     97a:	80 87       	std	Z+8, r24	; 0x08
	}
	if (*errorcode==0){	
     97c:	88 81       	ld	r24, Y
     97e:	88 23       	and	r24, r24
     980:	d9 f4       	brne	.+54     	; 0x9b8 <BMP085_Calibration+0xfc>
		BMP085_calibration_int16_t[5] = bmp085ReadShort(0xBA,errorcode);//mb
     982:	8a eb       	ldi	r24, 0xBA	; 186
     984:	be 01       	movw	r22, r28
     986:	0e 94 8d 00 	call	0x11a	; 0x11a <bmp085ReadShort>
     98a:	f8 01       	movw	r30, r16
     98c:	93 87       	std	Z+11, r25	; 0x0b
     98e:	82 87       	std	Z+10, r24	; 0x0a
	}
	if (*errorcode==0){	
     990:	88 81       	ld	r24, Y
     992:	88 23       	and	r24, r24
     994:	89 f4       	brne	.+34     	; 0x9b8 <BMP085_Calibration+0xfc>
		BMP085_calibration_int16_t[6] = bmp085ReadShort(0xBC,errorcode);//mc
     996:	8c eb       	ldi	r24, 0xBC	; 188
     998:	be 01       	movw	r22, r28
     99a:	0e 94 8d 00 	call	0x11a	; 0x11a <bmp085ReadShort>
     99e:	f8 01       	movw	r30, r16
     9a0:	95 87       	std	Z+13, r25	; 0x0d
     9a2:	84 87       	std	Z+12, r24	; 0x0c
	}
	if (*errorcode==0){	
     9a4:	88 81       	ld	r24, Y
     9a6:	88 23       	and	r24, r24
     9a8:	39 f4       	brne	.+14     	; 0x9b8 <BMP085_Calibration+0xfc>
		BMP085_calibration_int16_t[7] = bmp085ReadShort(0xBE,errorcode);//md
     9aa:	8e eb       	ldi	r24, 0xBE	; 190
     9ac:	be 01       	movw	r22, r28
     9ae:	0e 94 8d 00 	call	0x11a	; 0x11a <bmp085ReadShort>
     9b2:	f8 01       	movw	r30, r16
     9b4:	97 87       	std	Z+15, r25	; 0x0f
     9b6:	86 87       	std	Z+14, r24	; 0x0e
	}


}
     9b8:	df 91       	pop	r29
     9ba:	cf 91       	pop	r28
     9bc:	1f 91       	pop	r17
     9be:	0f 91       	pop	r16
     9c0:	ff 90       	pop	r15
     9c2:	ef 90       	pop	r14
     9c4:	08 95       	ret

000009c6 <bmp085CalcAltitude>:
//----------------------------------------
// 
//----------------------------------------
int32_t bmp085CalcAltitude(int32_t pressure){
     9c6:	0f 93       	push	r16
     9c8:	1f 93       	push	r17
	float temp;
	int32_t altitude;

	/* 101325 is the preasure at sea level, p0 */
	temp = (float) pressure/101325;
     9ca:	0e 94 c3 17 	call	0x2f86	; 0x2f86 <__floatsisf>
     9ce:	20 e8       	ldi	r18, 0x80	; 128
     9d0:	36 ee       	ldi	r19, 0xE6	; 230
     9d2:	45 ec       	ldi	r20, 0xC5	; 197
     9d4:	57 e4       	ldi	r21, 0x47	; 71
     9d6:	0e 94 28 17 	call	0x2e50	; 0x2e50 <__divsf3>
	temp = 1-pow(temp, 0.19029);
     9da:	22 e6       	ldi	r18, 0x62	; 98
     9dc:	3b ed       	ldi	r19, 0xDB	; 219
     9de:	42 e4       	ldi	r20, 0x42	; 66
     9e0:	5e e3       	ldi	r21, 0x3E	; 62
     9e2:	0e 94 b2 18 	call	0x3164	; 0x3164 <pow>
     9e6:	b6 2f       	mov	r27, r22
     9e8:	a7 2f       	mov	r26, r23
     9ea:	38 2f       	mov	r19, r24
     9ec:	29 2f       	mov	r18, r25
     9ee:	60 e0       	ldi	r22, 0x00	; 0
     9f0:	70 e0       	ldi	r23, 0x00	; 0
     9f2:	80 e8       	ldi	r24, 0x80	; 128
     9f4:	9f e3       	ldi	r25, 0x3F	; 63
     9f6:	42 2f       	mov	r20, r18
     9f8:	0b 2f       	mov	r16, r27
     9fa:	1a 2f       	mov	r17, r26
     9fc:	23 2f       	mov	r18, r19
     9fe:	34 2f       	mov	r19, r20
     a00:	a9 01       	movw	r20, r18
     a02:	98 01       	movw	r18, r16
     a04:	0e 94 c3 16 	call	0x2d86	; 0x2d86 <__subsf3>
	altitude = round(44330*temp*10);
     a08:	20 e0       	ldi	r18, 0x00	; 0
     a0a:	3a e2       	ldi	r19, 0x2A	; 42
     a0c:	4d e2       	ldi	r20, 0x2D	; 45
     a0e:	57 e4       	ldi	r21, 0x47	; 71
     a10:	0e 94 4f 18 	call	0x309e	; 0x309e <__mulsf3>
     a14:	20 e0       	ldi	r18, 0x00	; 0
     a16:	30 e0       	ldi	r19, 0x00	; 0
     a18:	40 e2       	ldi	r20, 0x20	; 32
     a1a:	51 e4       	ldi	r21, 0x41	; 65
     a1c:	0e 94 4f 18 	call	0x309e	; 0x309e <__mulsf3>
     a20:	0e 94 fe 18 	call	0x31fc	; 0x31fc <round>
     a24:	0e 94 90 17 	call	0x2f20	; 0x2f20 <__fixsfsi>
	//get altitude in dm
	return altitude;
}
     a28:	1f 91       	pop	r17
     a2a:	0f 91       	pop	r16
     a2c:	08 95       	ret

00000a2e <imuWriteReg8>:
  	- TRUE:		Value written successfully to register
 	- FALSE:	Error during the writing process

*******************************************************/
uint8_t imuWriteReg8(uint8_t targetAddress, uint8_t reg, uint8_t value)
{
     a2e:	cf 93       	push	r28
     a30:	df 93       	push	r29
     a32:	c6 2f       	mov	r28, r22
     a34:	d4 2f       	mov	r29, r20
	//start the twi master interface
	if (TWIM_Start(targetAddress, TWIM_WRITE))
     a36:	60 e0       	ldi	r22, 0x00	; 0
     a38:	0e 94 dd 07 	call	0xfba	; 0xfba <TWIM_Start>
     a3c:	88 23       	and	r24, r24
     a3e:	71 f0       	breq	.+28     	; 0xa5c <imuWriteReg8+0x2e>
	{
		if (TWIM_Write(reg))
     a40:	8c 2f       	mov	r24, r28
     a42:	0e 94 03 08 	call	0x1006	; 0x1006 <TWIM_Write>
     a46:	88 23       	and	r24, r24
     a48:	49 f0       	breq	.+18     	; 0xa5c <imuWriteReg8+0x2e>
	  	{
	    	if (TWIM_Write(value))
     a4a:	8d 2f       	mov	r24, r29
     a4c:	0e 94 03 08 	call	0x1006	; 0x1006 <TWIM_Write>
     a50:	88 23       	and	r24, r24
     a52:	21 f0       	breq	.+8      	; 0xa5c <imuWriteReg8+0x2e>
	  		{
				//value writte successfully
	    		TWIM_Stop();
     a54:	0e 94 fd 07 	call	0xffa	; 0xffa <TWIM_Stop>
		    	return 1;
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <imuWriteReg8+0x34>
			}
		}
	}
	//error occurred during write process
	TWIM_Stop();
     a5c:	0e 94 fd 07 	call	0xffa	; 0xffa <TWIM_Stop>
	return 0;
     a60:	80 e0       	ldi	r24, 0x00	; 0
}
     a62:	df 91       	pop	r29
     a64:	cf 91       	pop	r28
     a66:	08 95       	ret

00000a68 <initAccelerometer>:

}

void initAccelerometer(void)
{
	imuWriteReg8(ADXL345_addr, 0x2D, 8);
     a68:	83 e5       	ldi	r24, 0x53	; 83
     a6a:	6d e2       	ldi	r22, 0x2D	; 45
     a6c:	48 e0       	ldi	r20, 0x08	; 8
     a6e:	0e 94 17 05 	call	0xa2e	; 0xa2e <imuWriteReg8>
	imuWriteReg8(ADXL345_addr, 0x31, 11);	
     a72:	83 e5       	ldi	r24, 0x53	; 83
     a74:	61 e3       	ldi	r22, 0x31	; 49
     a76:	4b e0       	ldi	r20, 0x0B	; 11
     a78:	0e 94 17 05 	call	0xa2e	; 0xa2e <imuWriteReg8>
}
     a7c:	08 95       	ret

00000a7e <initImu3000>:
	//uint16_t gzOffset;
	 
	// Initialize Gyro
  	/*  - stop clock and synchronour reset clock state
		- reset device  */
	imuWriteReg8(IMU3000_addr, PWR_MGM, 0x87);
     a7e:	88 e6       	ldi	r24, 0x68	; 104
     a80:	6e e3       	ldi	r22, 0x3E	; 62
     a82:	47 e8       	ldi	r20, 0x87	; 135
     a84:	0e 94 17 05 	call	0xa2e	; 0xa2e <imuWriteReg8>

	/*  - select PLL with X Gyro reference as clock source  */
	imuWriteReg8(IMU3000_addr, PWR_MGM, 0x01);
     a88:	88 e6       	ldi	r24, 0x68	; 104
     a8a:	6e e3       	ldi	r22, 0x3E	; 62
     a8c:	41 e0       	ldi	r20, 0x01	; 1
     a8e:	0e 94 17 05 	call	0xa2e	; 0xa2e <imuWriteReg8>
			     on the frequency f_sample */

	/*  - gyro full scale range +/- 2000 /s  
	    - low pass filter bandwith 42 Hz
		- analog gyro sampling rate 1KHz */
	imuWriteReg8(IMU3000_addr, DLPF_FS, FS_SEL_2000 | DLPF_CFG_42);
     a92:	88 e6       	ldi	r24, 0x68	; 104
     a94:	66 e1       	ldi	r22, 0x16	; 22
     a96:	4b e1       	ldi	r20, 0x1B	; 27
     a98:	0e 94 17 05 	call	0xa2e	; 0xa2e <imuWriteReg8>
		-> f_sample = f_internal / (divider+1)
	
		-> here: f_sample = 1KHz / (7+1) = 125Hz -> 8ms per sample	

	*/ 
	imuWriteReg8(IMU3000_addr, SMPLRT_DIV, 7);
     a9c:	88 e6       	ldi	r24, 0x68	; 104
     a9e:	6f e7       	ldi	r22, 0x7F	; 127
     aa0:	47 e0       	ldi	r20, 0x07	; 7
     aa2:	0e 94 17 05 	call	0xa2e	; 0xa2e <imuWriteReg8>

	imuWriteReg8(IMU3000_addr, AUX_SLV_ADDR, ADXL345_addr);
     aa6:	88 e6       	ldi	r24, 0x68	; 104
     aa8:	64 e1       	ldi	r22, 0x14	; 20
     aaa:	43 e5       	ldi	r20, 0x53	; 83
     aac:	0e 94 17 05 	call	0xa2e	; 0xa2e <imuWriteReg8>
	imuWriteReg8(IMU3000_addr, AUX_BURST_ADDR, 0x32);
     ab0:	88 e6       	ldi	r24, 0x68	; 104
     ab2:	68 e1       	ldi	r22, 0x18	; 24
     ab4:	42 e3       	ldi	r20, 0x32	; 50
     ab6:	0e 94 17 05 	call	0xa2e	; 0xa2e <imuWriteReg8>
	imuWriteReg8(IMU3000_addr, USER_CTRL, AUX_IF_RST);
     aba:	88 e6       	ldi	r24, 0x68	; 104
     abc:	6d e3       	ldi	r22, 0x3D	; 61
     abe:	48 e0       	ldi	r20, 0x08	; 8
     ac0:	0e 94 17 05 	call	0xa2e	; 0xa2e <imuWriteReg8>

	// Initialize Auxilliary Accelerometer
	initAccelerometer();
     ac4:	0e 94 34 05 	call	0xa68	; 0xa68 <initAccelerometer>

	imuWriteReg8(IMU3000_addr, USER_CTRL, AUX_IF_RST | AUX_IF_EN);
     ac8:	88 e6       	ldi	r24, 0x68	; 104
     aca:	6d e3       	ldi	r22, 0x3D	; 61
     acc:	48 e2       	ldi	r20, 0x28	; 40
     ace:	0e 94 17 05 	call	0xa2e	; 0xa2e <imuWriteReg8>
	//imuWriteReg16(IMU3000_addr, X_OFFS, gxOffset);
	//imuWriteReg16(IMU3000_addr, Y_OFFS, gyOffset);
	//imuWriteReg16(IMU3000_addr, Z_OFFS, gzOffset);


}
     ad2:	08 95       	ret

00000ad4 <imuReadReg8>:
  	- TRUE:		Value read successfully from register
 	- FALSE:	Error during the reading process

*******************************************************/
uint8_t imuReadReg8(uint8_t targetAddress, uint8_t reg, uint8_t* buffer)
{
     ad4:	0f 93       	push	r16
     ad6:	1f 93       	push	r17
     ad8:	cf 93       	push	r28
     ada:	df 93       	push	r29
     adc:	18 2f       	mov	r17, r24
     ade:	06 2f       	mov	r16, r22
     ae0:	ea 01       	movw	r28, r20
	if (TWIM_Start(targetAddress, TWIM_WRITE))
     ae2:	60 e0       	ldi	r22, 0x00	; 0
     ae4:	0e 94 dd 07 	call	0xfba	; 0xfba <TWIM_Start>
     ae8:	88 23       	and	r24, r24
     aea:	91 f0       	breq	.+36     	; 0xb10 <imuReadReg8+0x3c>
	{
		if (TWIM_Write(reg))
     aec:	80 2f       	mov	r24, r16
     aee:	0e 94 03 08 	call	0x1006	; 0x1006 <TWIM_Write>
     af2:	88 23       	and	r24, r24
     af4:	69 f0       	breq	.+26     	; 0xb10 <imuReadReg8+0x3c>
	    {
			if (TWIM_Start(targetAddress, TWIM_READ))
     af6:	81 2f       	mov	r24, r17
     af8:	61 e0       	ldi	r22, 0x01	; 1
     afa:	0e 94 dd 07 	call	0xfba	; 0xfba <TWIM_Start>
     afe:	88 23       	and	r24, r24
     b00:	39 f0       	breq	.+14     	; 0xb10 <imuReadReg8+0x3c>
	    	{ 
	    		*buffer = TWIM_ReadNack();
     b02:	0e 94 17 08 	call	0x102e	; 0x102e <TWIM_ReadNack>
     b06:	88 83       	st	Y, r24
	    		TWIM_Stop();
     b08:	0e 94 fd 07 	call	0xffa	; 0xffa <TWIM_Stop>
	    		return 1;
     b0c:	81 e0       	ldi	r24, 0x01	; 1
     b0e:	03 c0       	rjmp	.+6      	; 0xb16 <imuReadReg8+0x42>
	  		}
		}
	}
	TWIM_Stop();
     b10:	0e 94 fd 07 	call	0xffa	; 0xffa <TWIM_Stop>
	return 0;
     b14:	80 e0       	ldi	r24, 0x00	; 0
}
     b16:	df 91       	pop	r29
     b18:	cf 91       	pop	r28
     b1a:	1f 91       	pop	r17
     b1c:	0f 91       	pop	r16
     b1e:	08 95       	ret

00000b20 <imuWriteReg16>:
  	- TRUE:		Value written successfully to register
 	- FALSE:	Error during the writing process

*******************************************************/
uint8_t imuWriteReg16(uint8_t targetAddress, uint8_t reg, uint16_t value)
{
     b20:	0f 93       	push	r16
     b22:	1f 93       	push	r17
     b24:	cf 93       	push	r28
     b26:	df 93       	push	r29
     b28:	c8 2f       	mov	r28, r24
     b2a:	d6 2f       	mov	r29, r22
     b2c:	14 2f       	mov	r17, r20
	uint8_t twiStatus = 0;
	
	//at first, write upper 8 bit
	//start the twi master interface
	twiStatus = TWIM_Start(targetAddress, TWIM_WRITE);
     b2e:	60 e0       	ldi	r22, 0x00	; 0
     b30:	0e 94 dd 07 	call	0xfba	; 0xfba <TWIM_Start>
	if (twiStatus)
     b34:	88 23       	and	r24, r24
     b36:	61 f1       	breq	.+88     	; 0xb90 <imuWriteReg16+0x70>
	{
		twiStatus = TWIM_Write(reg);
     b38:	8d 2f       	mov	r24, r29
     b3a:	0e 94 03 08 	call	0x1006	; 0x1006 <TWIM_Write>
		if (twiStatus)
     b3e:	88 23       	and	r24, r24
     b40:	39 f1       	breq	.+78     	; 0xb90 <imuWriteReg16+0x70>
	  	{
			twiStatus = TWIM_Write(value);
     b42:	81 2f       	mov	r24, r17
     b44:	0e 94 03 08 	call	0x1006	; 0x1006 <TWIM_Write>
     b48:	08 2f       	mov	r16, r24
		}
	}
	TWIM_Stop();
     b4a:	0e 94 fd 07 	call	0xffa	; 0xffa <TWIM_Stop>

	// check if an error has occurred
	if (twiStatus == 0)
     b4e:	00 23       	and	r16, r16
     b50:	c9 f0       	breq	.+50     	; 0xb84 <imuWriteReg16+0x64>
	} 


	//if no error has occurred -> write the lower 8 bit
	//start the twi master interface
	twiStatus = TWIM_Start(targetAddress, TWIM_WRITE);
     b52:	8c 2f       	mov	r24, r28
     b54:	60 e0       	ldi	r22, 0x00	; 0
     b56:	0e 94 dd 07 	call	0xfba	; 0xfba <TWIM_Start>
     b5a:	c8 2f       	mov	r28, r24
	if (twiStatus)
     b5c:	88 23       	and	r24, r24
     b5e:	59 f0       	breq	.+22     	; 0xb76 <imuWriteReg16+0x56>
	{
		twiStatus = TWIM_Write((reg+1));
     b60:	8d 2f       	mov	r24, r29
     b62:	8f 5f       	subi	r24, 0xFF	; 255
     b64:	0e 94 03 08 	call	0x1006	; 0x1006 <TWIM_Write>
     b68:	c8 2f       	mov	r28, r24
		if (twiStatus)
     b6a:	88 23       	and	r24, r24
     b6c:	21 f0       	breq	.+8      	; 0xb76 <imuWriteReg16+0x56>
	  	{
			twiStatus = TWIM_Write((uint8_t)(value & 0b11111111));
     b6e:	81 2f       	mov	r24, r17
     b70:	0e 94 03 08 	call	0x1006	; 0x1006 <TWIM_Write>
     b74:	c8 2f       	mov	r28, r24
		}
	}
	TWIM_Stop();
     b76:	0e 94 fd 07 	call	0xffa	; 0xffa <TWIM_Stop>

	// check if an error has occurred
	if (twiStatus == 0)
	{
		// an error has occurred -> cancel write operation
		return 0;
     b7a:	81 e0       	ldi	r24, 0x01	; 1
     b7c:	cc 23       	and	r28, r28
     b7e:	19 f4       	brne	.+6      	; 0xb86 <imuWriteReg16+0x66>
     b80:	80 e0       	ldi	r24, 0x00	; 0
     b82:	01 c0       	rjmp	.+2      	; 0xb86 <imuWriteReg16+0x66>
     b84:	80 e0       	ldi	r24, 0x00	; 0
	else
	{
		return 1;
	}

}
     b86:	df 91       	pop	r29
     b88:	cf 91       	pop	r28
     b8a:	1f 91       	pop	r17
     b8c:	0f 91       	pop	r16
     b8e:	08 95       	ret
		if (twiStatus)
	  	{
			twiStatus = TWIM_Write(value);
		}
	}
	TWIM_Stop();
     b90:	0e 94 fd 07 	call	0xffa	; 0xffa <TWIM_Stop>

	// check if an error has occurred
	if (twiStatus == 0)
	{
		// an error has occurred -> cancel write operation
		return 0;
     b94:	80 e0       	ldi	r24, 0x00	; 0
     b96:	f7 cf       	rjmp	.-18     	; 0xb86 <imuWriteReg16+0x66>

00000b98 <imuReadReg16>:
  	- TRUE:		Value read successfully from register
 	- FALSE:	Error during the reading process

*******************************************************/
uint8_t imuReadReg16(uint8_t targetAddress, uint8_t reg, uint16_t* buffer)
{
     b98:	ff 92       	push	r15
     b9a:	0f 93       	push	r16
     b9c:	1f 93       	push	r17
     b9e:	cf 93       	push	r28
     ba0:	df 93       	push	r29
     ba2:	c8 2f       	mov	r28, r24
     ba4:	d6 2f       	mov	r29, r22
     ba6:	8a 01       	movw	r16, r20
	uint8_t h=0, l=0;
	uint8_t twiStatus;
	
	//at first, read upper 8 bit
	twiStatus = TWIM_Start(targetAddress, TWIM_WRITE);
     ba8:	60 e0       	ldi	r22, 0x00	; 0
     baa:	0e 94 dd 07 	call	0xfba	; 0xfba <TWIM_Start>
	if (twiStatus)
     bae:	88 23       	and	r24, r24
     bb0:	b9 f0       	breq	.+46     	; 0xbe0 <imuReadReg16+0x48>
	{
		twiStatus = TWIM_Write(reg);
     bb2:	8d 2f       	mov	r24, r29
     bb4:	0e 94 03 08 	call	0x1006	; 0x1006 <TWIM_Write>
		if (twiStatus)
     bb8:	88 23       	and	r24, r24
     bba:	91 f0       	breq	.+36     	; 0xbe0 <imuReadReg16+0x48>
	    {
			twiStatus = TWIM_Start(targetAddress, TWIM_READ);
     bbc:	8c 2f       	mov	r24, r28
     bbe:	61 e0       	ldi	r22, 0x01	; 1
     bc0:	0e 94 dd 07 	call	0xfba	; 0xfba <TWIM_Start>
			if (twiStatus)
     bc4:	88 23       	and	r24, r24
     bc6:	61 f0       	breq	.+24     	; 0xbe0 <imuReadReg16+0x48>
	    	{ 
	    		h = TWIM_ReadNack();
     bc8:	0e 94 17 08 	call	0x102e	; 0x102e <TWIM_ReadNack>
     bcc:	f8 2e       	mov	r15, r24
	  		}
		}
	}

	TWIM_Stop();
     bce:	0e 94 fd 07 	call	0xffa	; 0xffa <TWIM_Stop>
		return 0;
	}
	

	//read lower 8 bit
	twiStatus = TWIM_Start(targetAddress, TWIM_WRITE);
     bd2:	8c 2f       	mov	r24, r28
     bd4:	60 e0       	ldi	r22, 0x00	; 0
     bd6:	0e 94 dd 07 	call	0xfba	; 0xfba <TWIM_Start>
	if (twiStatus)
     bda:	88 23       	and	r24, r24
     bdc:	f9 f0       	breq	.+62     	; 0xc1c <imuReadReg16+0x84>
     bde:	04 c0       	rjmp	.+8      	; 0xbe8 <imuReadReg16+0x50>
	    		h = TWIM_ReadNack();
	  		}
		}
	}

	TWIM_Stop();
     be0:	0e 94 fd 07 	call	0xffa	; 0xffa <TWIM_Stop>
	
	//check if an error has occurred
	if (twiStatus == 0)
	{
		// an error has occurred
		return 0;
     be4:	80 e0       	ldi	r24, 0x00	; 0
     be6:	1d c0       	rjmp	.+58     	; 0xc22 <imuReadReg16+0x8a>

	//read lower 8 bit
	twiStatus = TWIM_Start(targetAddress, TWIM_WRITE);
	if (twiStatus)
	{
		twiStatus = TWIM_Write(reg+1);
     be8:	8d 2f       	mov	r24, r29
     bea:	8f 5f       	subi	r24, 0xFF	; 255
     bec:	0e 94 03 08 	call	0x1006	; 0x1006 <TWIM_Write>
		if (twiStatus)
     bf0:	88 23       	and	r24, r24
     bf2:	a1 f0       	breq	.+40     	; 0xc1c <imuReadReg16+0x84>
	    {
			twiStatus = TWIM_Start(targetAddress, TWIM_READ);
     bf4:	8c 2f       	mov	r24, r28
     bf6:	61 e0       	ldi	r22, 0x01	; 1
     bf8:	0e 94 dd 07 	call	0xfba	; 0xfba <TWIM_Start>
			if (twiStatus)
     bfc:	88 23       	and	r24, r24
     bfe:	71 f0       	breq	.+28     	; 0xc1c <imuReadReg16+0x84>
	    	{ 
	    		l = TWIM_ReadNack();
     c00:	0e 94 17 08 	call	0x102e	; 0x102e <TWIM_ReadNack>
     c04:	c8 2f       	mov	r28, r24
	  		}
		}
	}

	TWIM_Stop();
     c06:	0e 94 fd 07 	call	0xffa	; 0xffa <TWIM_Stop>
		return 0;
	}
	else
	{
		//merge the upper and lower 8 bits together to have the 16bit variable
		*buffer = (((uint16_t)h) << 8) + (uint16_t)l;
     c0a:	9f 2d       	mov	r25, r15
     c0c:	80 e0       	ldi	r24, 0x00	; 0
     c0e:	8c 0f       	add	r24, r28
     c10:	91 1d       	adc	r25, r1
     c12:	f8 01       	movw	r30, r16
     c14:	91 83       	std	Z+1, r25	; 0x01
     c16:	80 83       	st	Z, r24
		return 1;
     c18:	81 e0       	ldi	r24, 0x01	; 1
     c1a:	03 c0       	rjmp	.+6      	; 0xc22 <imuReadReg16+0x8a>
	    		l = TWIM_ReadNack();
	  		}
		}
	}

	TWIM_Stop();
     c1c:	0e 94 fd 07 	call	0xffa	; 0xffa <TWIM_Stop>

	//check if an error has occurred
	if (twiStatus == 0)
	{
		// an error has occurred
		return 0;
     c20:	80 e0       	ldi	r24, 0x00	; 0
		//merge the upper and lower 8 bits together to have the 16bit variable
		*buffer = (((uint16_t)h) << 8) + (uint16_t)l;
		return 1;
	}
	
}
     c22:	df 91       	pop	r29
     c24:	cf 91       	pop	r28
     c26:	1f 91       	pop	r17
     c28:	0f 91       	pop	r16
     c2a:	ff 90       	pop	r15
     c2c:	08 95       	ret

00000c2e <imuReadReg16Inv>:
  	- TRUE:		Value read successfully from register
 	- FALSE:	Error during the reading process

*******************************************************/
uint8_t imuReadReg16Inv(uint8_t targetAddress, uint8_t reg, uint16_t* buffer)
{
     c2e:	ff 92       	push	r15
     c30:	0f 93       	push	r16
     c32:	1f 93       	push	r17
     c34:	cf 93       	push	r28
     c36:	df 93       	push	r29
     c38:	18 2f       	mov	r17, r24
     c3a:	06 2f       	mov	r16, r22
     c3c:	ea 01       	movw	r28, r20

	uint8_t h=0, l=0;
	uint8_t twiStatus;
	
	//at first, read upper 8 bit
	twiStatus = TWIM_Start(targetAddress, TWIM_WRITE);
     c3e:	60 e0       	ldi	r22, 0x00	; 0
     c40:	0e 94 dd 07 	call	0xfba	; 0xfba <TWIM_Start>
	if (twiStatus)
     c44:	88 23       	and	r24, r24
     c46:	b9 f0       	breq	.+46     	; 0xc76 <imuReadReg16Inv+0x48>
	{
		twiStatus = TWIM_Write(reg);
     c48:	80 2f       	mov	r24, r16
     c4a:	0e 94 03 08 	call	0x1006	; 0x1006 <TWIM_Write>
		if (twiStatus)
     c4e:	88 23       	and	r24, r24
     c50:	91 f0       	breq	.+36     	; 0xc76 <imuReadReg16Inv+0x48>
	    {
			twiStatus = TWIM_Start(targetAddress, TWIM_READ);
     c52:	81 2f       	mov	r24, r17
     c54:	61 e0       	ldi	r22, 0x01	; 1
     c56:	0e 94 dd 07 	call	0xfba	; 0xfba <TWIM_Start>
			if (twiStatus)
     c5a:	88 23       	and	r24, r24
     c5c:	61 f0       	breq	.+24     	; 0xc76 <imuReadReg16Inv+0x48>
	    	{ 
	    		l = TWIM_ReadNack();
     c5e:	0e 94 17 08 	call	0x102e	; 0x102e <TWIM_ReadNack>
     c62:	f8 2e       	mov	r15, r24
	  		}
		}
	}

	TWIM_Stop();
     c64:	0e 94 fd 07 	call	0xffa	; 0xffa <TWIM_Stop>
		return 0;
	}
	

	//read lower 8 bit
	twiStatus = TWIM_Start(targetAddress, TWIM_WRITE);
     c68:	81 2f       	mov	r24, r17
     c6a:	60 e0       	ldi	r22, 0x00	; 0
     c6c:	0e 94 dd 07 	call	0xfba	; 0xfba <TWIM_Start>
	if (twiStatus)
     c70:	88 23       	and	r24, r24
     c72:	f1 f0       	breq	.+60     	; 0xcb0 <imuReadReg16Inv+0x82>
     c74:	04 c0       	rjmp	.+8      	; 0xc7e <imuReadReg16Inv+0x50>
	    		l = TWIM_ReadNack();
	  		}
		}
	}

	TWIM_Stop();
     c76:	0e 94 fd 07 	call	0xffa	; 0xffa <TWIM_Stop>
	
	//check if an error has occurred
	if (twiStatus == 0)
	{
		// an error has occurred
		return 0;
     c7a:	80 e0       	ldi	r24, 0x00	; 0
     c7c:	1c c0       	rjmp	.+56     	; 0xcb6 <imuReadReg16Inv+0x88>

	//read lower 8 bit
	twiStatus = TWIM_Start(targetAddress, TWIM_WRITE);
	if (twiStatus)
	{
		twiStatus = TWIM_Write(reg+1);
     c7e:	80 2f       	mov	r24, r16
     c80:	8f 5f       	subi	r24, 0xFF	; 255
     c82:	0e 94 03 08 	call	0x1006	; 0x1006 <TWIM_Write>
		if (twiStatus)
     c86:	88 23       	and	r24, r24
     c88:	99 f0       	breq	.+38     	; 0xcb0 <imuReadReg16Inv+0x82>
	    {
			twiStatus = TWIM_Start(targetAddress, TWIM_READ);
     c8a:	81 2f       	mov	r24, r17
     c8c:	61 e0       	ldi	r22, 0x01	; 1
     c8e:	0e 94 dd 07 	call	0xfba	; 0xfba <TWIM_Start>
			if (twiStatus)
     c92:	88 23       	and	r24, r24
     c94:	69 f0       	breq	.+26     	; 0xcb0 <imuReadReg16Inv+0x82>
	    	{ 
	    		h = TWIM_ReadNack();
     c96:	0e 94 17 08 	call	0x102e	; 0x102e <TWIM_ReadNack>
     c9a:	18 2f       	mov	r17, r24
	  		}
		}
	}

	TWIM_Stop();
     c9c:	0e 94 fd 07 	call	0xffa	; 0xffa <TWIM_Stop>
		return 0;
	}
	else
	{
		//merge the upper and lower 8 bits together to have the 16bit variable
		*buffer = (((uint16_t)h) << 8) + (uint16_t)l;
     ca0:	91 2f       	mov	r25, r17
     ca2:	80 e0       	ldi	r24, 0x00	; 0
     ca4:	8f 0d       	add	r24, r15
     ca6:	91 1d       	adc	r25, r1
     ca8:	99 83       	std	Y+1, r25	; 0x01
     caa:	88 83       	st	Y, r24
		return 1;
     cac:	81 e0       	ldi	r24, 0x01	; 1
     cae:	03 c0       	rjmp	.+6      	; 0xcb6 <imuReadReg16Inv+0x88>
	    		h = TWIM_ReadNack();
	  		}
		}
	}

	TWIM_Stop();
     cb0:	0e 94 fd 07 	call	0xffa	; 0xffa <TWIM_Stop>

	//check if an error has occurred
	if (twiStatus == 0)
	{
		// an error has occurred
		return 0;
     cb4:	80 e0       	ldi	r24, 0x00	; 0
		//merge the upper and lower 8 bits together to have the 16bit variable
		*buffer = (((uint16_t)h) << 8) + (uint16_t)l;
		return 1;
	}
	
}
     cb6:	df 91       	pop	r29
     cb8:	cf 91       	pop	r28
     cba:	1f 91       	pop	r17
     cbc:	0f 91       	pop	r16
     cbe:	ff 90       	pop	r15
     cc0:	08 95       	ret

00000cc2 <readImu>:
	imuWriteReg8(ADXL345_addr, 0x31, 11);	
}


void readImu(int16_t *gx, int16_t *gy, int16_t *gz, int16_t *ax, int16_t *ay, int16_t *az)
{
     cc2:	6f 92       	push	r6
     cc4:	7f 92       	push	r7
     cc6:	8f 92       	push	r8
     cc8:	9f 92       	push	r9
     cca:	af 92       	push	r10
     ccc:	bf 92       	push	r11
     cce:	cf 92       	push	r12
     cd0:	df 92       	push	r13
     cd2:	ef 92       	push	r14
     cd4:	ff 92       	push	r15
     cd6:	0f 93       	push	r16
     cd8:	1f 93       	push	r17
     cda:	cf 93       	push	r28
     cdc:	df 93       	push	r29
     cde:	cd b7       	in	r28, 0x3d	; 61
     ce0:	de b7       	in	r29, 0x3e	; 62
     ce2:	2c 97       	sbiw	r28, 0x0c	; 12
     ce4:	0f b6       	in	r0, 0x3f	; 63
     ce6:	f8 94       	cli
     ce8:	de bf       	out	0x3e, r29	; 62
     cea:	0f be       	out	0x3f, r0	; 63
     cec:	cd bf       	out	0x3d, r28	; 61
     cee:	6c 01       	movw	r12, r24
     cf0:	5b 01       	movw	r10, r22
     cf2:	4a 01       	movw	r8, r20
     cf4:	39 01       	movw	r6, r18
	volatile uint16_t tempGX, tempGY, tempGZ;
	volatile uint16_t tempAX, tempAY, tempAZ;


	imuReadReg16(IMU3000_addr, GYRO_XOUT, &tempGX);
     cf6:	88 e6       	ldi	r24, 0x68	; 104
     cf8:	6d e1       	ldi	r22, 0x1D	; 29
     cfa:	ae 01       	movw	r20, r28
     cfc:	4f 5f       	subi	r20, 0xFF	; 255
     cfe:	5f 4f       	sbci	r21, 0xFF	; 255
     d00:	0e 94 cc 05 	call	0xb98	; 0xb98 <imuReadReg16>
    imuReadReg16(IMU3000_addr, GYRO_YOUT, &tempGY);
     d04:	88 e6       	ldi	r24, 0x68	; 104
     d06:	6f e1       	ldi	r22, 0x1F	; 31
     d08:	ae 01       	movw	r20, r28
     d0a:	4d 5f       	subi	r20, 0xFD	; 253
     d0c:	5f 4f       	sbci	r21, 0xFF	; 255
     d0e:	0e 94 cc 05 	call	0xb98	; 0xb98 <imuReadReg16>
    imuReadReg16(IMU3000_addr, GYRO_ZOUT, &tempGZ);
     d12:	88 e6       	ldi	r24, 0x68	; 104
     d14:	61 e2       	ldi	r22, 0x21	; 33
     d16:	ae 01       	movw	r20, r28
     d18:	4b 5f       	subi	r20, 0xFB	; 251
     d1a:	5f 4f       	sbci	r21, 0xFF	; 255
     d1c:	0e 94 cc 05 	call	0xb98	; 0xb98 <imuReadReg16>
    imuReadReg16Inv(IMU3000_addr, AUX_XOUT, &tempAX);
     d20:	88 e6       	ldi	r24, 0x68	; 104
     d22:	63 e2       	ldi	r22, 0x23	; 35
     d24:	ae 01       	movw	r20, r28
     d26:	49 5f       	subi	r20, 0xF9	; 249
     d28:	5f 4f       	sbci	r21, 0xFF	; 255
     d2a:	0e 94 17 06 	call	0xc2e	; 0xc2e <imuReadReg16Inv>
    imuReadReg16Inv(IMU3000_addr, AUX_YOUT, &tempAY);
     d2e:	88 e6       	ldi	r24, 0x68	; 104
     d30:	65 e2       	ldi	r22, 0x25	; 37
     d32:	ae 01       	movw	r20, r28
     d34:	47 5f       	subi	r20, 0xF7	; 247
     d36:	5f 4f       	sbci	r21, 0xFF	; 255
     d38:	0e 94 17 06 	call	0xc2e	; 0xc2e <imuReadReg16Inv>
    imuReadReg16Inv(IMU3000_addr, AUX_ZOUT, &tempAZ);
     d3c:	88 e6       	ldi	r24, 0x68	; 104
     d3e:	67 e2       	ldi	r22, 0x27	; 39
     d40:	ae 01       	movw	r20, r28
     d42:	45 5f       	subi	r20, 0xF5	; 245
     d44:	5f 4f       	sbci	r21, 0xFF	; 255
     d46:	0e 94 17 06 	call	0xc2e	; 0xc2e <imuReadReg16Inv>


	*gx = ((int16_t) tempGX) - gxOffsetExternal;
     d4a:	89 81       	ldd	r24, Y+1	; 0x01
     d4c:	9a 81       	ldd	r25, Y+2	; 0x02
     d4e:	20 91 f5 05 	lds	r18, 0x05F5
     d52:	30 91 f6 05 	lds	r19, 0x05F6
     d56:	82 1b       	sub	r24, r18
     d58:	93 0b       	sbc	r25, r19
     d5a:	f6 01       	movw	r30, r12
     d5c:	91 83       	std	Z+1, r25	; 0x01
     d5e:	80 83       	st	Z, r24
	*gy = ((int16_t) tempGY) - gyOffsetExternal;
     d60:	8b 81       	ldd	r24, Y+3	; 0x03
     d62:	9c 81       	ldd	r25, Y+4	; 0x04
     d64:	20 91 f7 05 	lds	r18, 0x05F7
     d68:	30 91 f8 05 	lds	r19, 0x05F8
     d6c:	82 1b       	sub	r24, r18
     d6e:	93 0b       	sbc	r25, r19
     d70:	f5 01       	movw	r30, r10
     d72:	91 83       	std	Z+1, r25	; 0x01
     d74:	80 83       	st	Z, r24
	*gz = ((int16_t) tempGZ) - gzOffsetExternal;
     d76:	8d 81       	ldd	r24, Y+5	; 0x05
     d78:	9e 81       	ldd	r25, Y+6	; 0x06
     d7a:	20 91 f9 05 	lds	r18, 0x05F9
     d7e:	30 91 fa 05 	lds	r19, 0x05FA
     d82:	82 1b       	sub	r24, r18
     d84:	93 0b       	sbc	r25, r19
     d86:	f4 01       	movw	r30, r8
     d88:	91 83       	std	Z+1, r25	; 0x01
     d8a:	80 83       	st	Z, r24
	*ax = ((int16_t) tempAX) - axOffsetExternal;
     d8c:	8f 81       	ldd	r24, Y+7	; 0x07
     d8e:	98 85       	ldd	r25, Y+8	; 0x08
     d90:	20 91 f3 05 	lds	r18, 0x05F3
     d94:	30 91 f4 05 	lds	r19, 0x05F4
     d98:	82 1b       	sub	r24, r18
     d9a:	93 0b       	sbc	r25, r19
     d9c:	f3 01       	movw	r30, r6
     d9e:	91 83       	std	Z+1, r25	; 0x01
     da0:	80 83       	st	Z, r24
	*ay = ((int16_t) tempAY) - ayOffsetExternal;
     da2:	29 85       	ldd	r18, Y+9	; 0x09
     da4:	3a 85       	ldd	r19, Y+10	; 0x0a
     da6:	80 91 fd 05 	lds	r24, 0x05FD
     daa:	90 91 fe 05 	lds	r25, 0x05FE
     dae:	28 1b       	sub	r18, r24
     db0:	39 0b       	sbc	r19, r25
     db2:	f8 01       	movw	r30, r16
     db4:	31 83       	std	Z+1, r19	; 0x01
     db6:	20 83       	st	Z, r18
	*az = ((int16_t) tempAZ) - azOffsetExternal;
     db8:	8b 85       	ldd	r24, Y+11	; 0x0b
     dba:	9c 85       	ldd	r25, Y+12	; 0x0c
     dbc:	20 91 fb 05 	lds	r18, 0x05FB
     dc0:	30 91 fc 05 	lds	r19, 0x05FC
     dc4:	82 1b       	sub	r24, r18
     dc6:	93 0b       	sbc	r25, r19
     dc8:	f7 01       	movw	r30, r14
     dca:	91 83       	std	Z+1, r25	; 0x01
     dcc:	80 83       	st	Z, r24


}
     dce:	2c 96       	adiw	r28, 0x0c	; 12
     dd0:	0f b6       	in	r0, 0x3f	; 63
     dd2:	f8 94       	cli
     dd4:	de bf       	out	0x3e, r29	; 62
     dd6:	0f be       	out	0x3f, r0	; 63
     dd8:	cd bf       	out	0x3d, r28	; 61
     dda:	df 91       	pop	r29
     ddc:	cf 91       	pop	r28
     dde:	1f 91       	pop	r17
     de0:	0f 91       	pop	r16
     de2:	ff 90       	pop	r15
     de4:	ef 90       	pop	r14
     de6:	df 90       	pop	r13
     de8:	cf 90       	pop	r12
     dea:	bf 90       	pop	r11
     dec:	af 90       	pop	r10
     dee:	9f 90       	pop	r9
     df0:	8f 90       	pop	r8
     df2:	7f 90       	pop	r7
     df4:	6f 90       	pop	r6
     df6:	08 95       	ret

00000df8 <adcInit>:
{
  
  uint16_t result;
 									
								
  ADMUX &= ~((1<<REFS1) | (1<<REFS0)); // externe Referenzspannung nutzen (typischerweise Vcc-Pegel)
     df8:	87 b1       	in	r24, 0x07	; 7
     dfa:	8f 73       	andi	r24, 0x3F	; 63
     dfc:	87 b9       	out	0x07, r24	; 7


  ADCSRA |= ((1<<ADEN) | (1<<ADPS2) | (1<<ADPS1));    	// ADC Prescaler whlen. BIT0 bis BII 2 in ADCSRA
     dfe:	86 b1       	in	r24, 0x06	; 6
     e00:	86 68       	ori	r24, 0x86	; 134
     e02:	86 b9       	out	0x06, r24	; 6
                               					    // UND ADC aktivieren



  //Erste conversion anstoen, danach luft der ADC im free run mode
  ADCSRA |= (1<<ADSC);	
     e04:	36 9a       	sbi	0x06, 6	; 6
  

  //Auf Abschluss der Konvertierung warten
  //Das Register ADCSRA wird mit "1<<ADSC" maskiert. Da ADSC den Wert 6 hat, wartet das while 
  //also solange, bis das Bit6 von ADCSRA == 0 wird.
  while (ADCSRA & (1<<ADSC) ) {}
     e06:	36 99       	sbic	0x06, 6	; 6
     e08:	fe cf       	rjmp	.-4      	; 0xe06 <adcInit+0xe>
  	
  //ADCSRA |= (1<<ADIE);		// ADC - > Interrupt Enable		
  
  /* ADCW muss einmal gelesen werden, sonst wird Ergebnis der nchsten
     Wandlung nicht bernommen. */
  result = ADCW;		 
     e0a:	84 b1       	in	r24, 0x04	; 4
     e0c:	95 b1       	in	r25, 0x05	; 5
   
}
     e0e:	08 95       	ret

00000e10 <adcRead15>:
{
	uint16_t result=0;
	
	// 	Kanal waehlen(durch Parameterbergabe)	
	//  Kanle 4 bis 7 sind verfgbar
	if ((channel >= 4) && (channel <=7))
     e10:	98 2f       	mov	r25, r24
     e12:	94 50       	subi	r25, 0x04	; 4
     e14:	94 30       	cpi	r25, 0x04	; 4
     e16:	08 f4       	brcc	.+2      	; 0xe1a <adcRead15+0xa>
 		ADMUX = channel;                  // 	Kanal waehlen(durch Parameterbergabe)
     e18:	87 b9       	out	0x07, r24	; 7

	//Erste conversion anstoen, danach luft der ADC im free run mode
  	ADCSRA |= (1<<ADSC);	
     e1a:	36 9a       	sbi	0x06, 6	; 6
  

  	//Auf Abschluss der Konvertierung warten
	while (ADCSRA & (1<<ADSC) ) {}
     e1c:	36 99       	sbic	0x06, 6	; 6
     e1e:	fe cf       	rjmp	.-4      	; 0xe1c <adcRead15+0xc>
	
	//result in bit value
	result = ADCW;
     e20:	44 b1       	in	r20, 0x04	; 4
     e22:	55 b1       	in	r21, 0x05	; 5
	//convert result into voltage value
	//korrektes runden mit +(divisor>>1)
	//ohne die 16bit casts wrde das zwischenergebnis auf die bitwertigkeit des
	//niedrigsten teil des terms reduziert (hier 8 bit von 100 oder 15)
	result = ((result * (uint16_t)15 * (int16_t)100)+(1023>>1)) / (uint16_t)1023;
     e24:	2c ed       	ldi	r18, 0xDC	; 220
     e26:	35 e0       	ldi	r19, 0x05	; 5
     e28:	42 9f       	mul	r20, r18
     e2a:	c0 01       	movw	r24, r0
     e2c:	43 9f       	mul	r20, r19
     e2e:	90 0d       	add	r25, r0
     e30:	52 9f       	mul	r21, r18
     e32:	90 0d       	add	r25, r0
     e34:	11 24       	eor	r1, r1
     e36:	81 50       	subi	r24, 0x01	; 1
     e38:	9e 4f       	sbci	r25, 0xFE	; 254
     e3a:	6f ef       	ldi	r22, 0xFF	; 255
     e3c:	73 e0       	ldi	r23, 0x03	; 3
     e3e:	0e 94 71 1a 	call	0x34e2	; 0x34e2 <__udivmodhi4>
     e42:	86 2f       	mov	r24, r22
     e44:	97 2f       	mov	r25, r23

	return result;
}
     e46:	08 95       	ret

00000e48 <adcRead5>:
{
	uint16_t result=0;
	
	// 	Kanal waehlen(durch Parameterbergabe)	
	//  Kanle 4 bis 7 sind verfgbar
	if ((channel >= 4) && (channel <=7))
     e48:	98 2f       	mov	r25, r24
     e4a:	94 50       	subi	r25, 0x04	; 4
     e4c:	94 30       	cpi	r25, 0x04	; 4
     e4e:	08 f4       	brcc	.+2      	; 0xe52 <adcRead5+0xa>
 		ADMUX = channel;                  // 	Kanal waehlen(durch Parameterbergabe)
     e50:	87 b9       	out	0x07, r24	; 7

	//Erste conversion anstoen, danach luft der ADC im free run mode
  	ADCSRA |= (1<<ADSC);	
     e52:	36 9a       	sbi	0x06, 6	; 6
  

  	//Auf Abschluss der Konvertierung warten
	while (ADCSRA & (1<<ADSC) ) {}
     e54:	36 99       	sbic	0x06, 6	; 6
     e56:	fe cf       	rjmp	.-4      	; 0xe54 <adcRead5+0xc>
	
	//result in bit value
	result = ADCW;
     e58:	44 b1       	in	r20, 0x04	; 4
     e5a:	55 b1       	in	r21, 0x05	; 5
	//convert result into voltage value
	//korrektes runden mit +(divisor>>1)
	//ohne die 16bit casts wrde das zwischenergebnis auf die bitwertigkeit des
	//niedrigsten teil des terms reduziert (hier 8 bit von 100 oder 15)
	result = ((result * (uint16_t)5 * (uint16_t)100) + (1023>>1)) / (uint16_t)1023;
     e5c:	24 ef       	ldi	r18, 0xF4	; 244
     e5e:	31 e0       	ldi	r19, 0x01	; 1
     e60:	42 9f       	mul	r20, r18
     e62:	c0 01       	movw	r24, r0
     e64:	43 9f       	mul	r20, r19
     e66:	90 0d       	add	r25, r0
     e68:	52 9f       	mul	r21, r18
     e6a:	90 0d       	add	r25, r0
     e6c:	11 24       	eor	r1, r1
     e6e:	81 50       	subi	r24, 0x01	; 1
     e70:	9e 4f       	sbci	r25, 0xFE	; 254
     e72:	6f ef       	ldi	r22, 0xFF	; 255
     e74:	73 e0       	ldi	r23, 0x03	; 3
     e76:	0e 94 71 1a 	call	0x34e2	; 0x34e2 <__udivmodhi4>
     e7a:	86 2f       	mov	r24, r22
     e7c:	97 2f       	mov	r25, r23

	return result;

}
     e7e:	08 95       	ret

00000e80 <myInit>:
	//Enable interrupts for INT0, INT1, INT2	
	//GICR  |= (1<<BIT7) | (1<<BIT6) | (1<<BIT5); 
	GICR |= (1<<BIT5); //only INT2

*/
}
     e80:	08 95       	ret

00000e82 <pwmInit>:

#include "pwmInit.h"

void pwmInit(uint16_t compare)
{
	DDRD |= (1<<BIT4) | (1<<BIT5);		//D.4&5 als Ausgnge definieren
     e82:	21 b3       	in	r18, 0x11	; 17
     e84:	20 63       	ori	r18, 0x30	; 48
     e86:	21 bb       	out	0x11, r18	; 17
	
	//PWM, Phase Correct with ICR1 as TOP value
	//TOP: 625
	TCCR1A |= (1<<WGM11);	
     e88:	2f b5       	in	r18, 0x2f	; 47
     e8a:	22 60       	ori	r18, 0x02	; 2
     e8c:	2f bd       	out	0x2f, r18	; 47
	TCCR1A &= ~(1<<WGM10);	
     e8e:	2f b5       	in	r18, 0x2f	; 47
     e90:	2e 7f       	andi	r18, 0xFE	; 254
     e92:	2f bd       	out	0x2f, r18	; 47

	TCCR1B |= (1<<WGM13);
     e94:	2e b5       	in	r18, 0x2e	; 46
     e96:	20 61       	ori	r18, 0x10	; 16
     e98:	2e bd       	out	0x2e, r18	; 46
	TCCR1B &= ~(1<<WGM12);
     e9a:	2e b5       	in	r18, 0x2e	; 46
     e9c:	27 7f       	andi	r18, 0xF7	; 247
     e9e:	2e bd       	out	0x2e, r18	; 46

	ICR1 = 625;
     ea0:	21 e7       	ldi	r18, 0x71	; 113
     ea2:	32 e0       	ldi	r19, 0x02	; 2
     ea4:	37 bd       	out	0x27, r19	; 39
     ea6:	26 bd       	out	0x26, r18	; 38
	

	//Nicht invertierende PWM, KanalA -> auf Pin D.5
	//- Clear OC1A/OC1B on Compare Match when up-counting. 
	//- Set OC1A/OC1B on Compare Match when downcounting.
	TCCR1A |= (1<<COM1A1); 	
     ea8:	2f b5       	in	r18, 0x2f	; 47
     eaa:	20 68       	ori	r18, 0x80	; 128
     eac:	2f bd       	out	0x2f, r18	; 47
	TCCR1A &= ~(1<<COM1A0);
     eae:	2f b5       	in	r18, 0x2f	; 47
     eb0:	2f 7b       	andi	r18, 0xBF	; 191
     eb2:	2f bd       	out	0x2f, r18	; 47

	//Prescaler = 64
	TCCR1B |= (1<<CS10) | (1<<CS11);
     eb4:	2e b5       	in	r18, 0x2e	; 46
     eb6:	23 60       	ori	r18, 0x03	; 3
     eb8:	2e bd       	out	0x2e, r18	; 46
	TCCR1B |= ~(1<<CS12); 
     eba:	2e b5       	in	r18, 0x2e	; 46
     ebc:	2b 6f       	ori	r18, 0xFB	; 251
     ebe:	2e bd       	out	0x2e, r18	; 46
		1 	1 	0 	Externer Pin 1, negative Flanke
		1 	1 	1 	Externer Pin 1, positive Flanke 
	*/
	
	//OCR1A->16bit register
	OCR1A=compare;	//Vergleichswert laden
     ec0:	9b bd       	out	0x2b, r25	; 43
     ec2:	8a bd       	out	0x2a, r24	; 42
	
	
}
     ec4:	08 95       	ret

00000ec6 <pwmUpdate>:


void pwmUpdate(uint16_t compare)
{
	OCR1A=compare;	
     ec6:	9b bd       	out	0x2b, r25	; 43
     ec8:	8a bd       	out	0x2a, r24	; 42
}
     eca:	08 95       	ret

00000ecc <timer_init>:
#include "timerInit.h"

void timer_init(uint16_t compare)
{

	TCCR1B |= (1<<WGM12);	//CTC Mode:
     ecc:	2e b5       	in	r18, 0x2e	; 46
     ece:	28 60       	ori	r18, 0x08	; 8
     ed0:	2e bd       	out	0x2e, r18	; 46
							//Timer1 zhlt hoch, bei compare match wird er wieder zu 0 gesetzt

	TCCR1B |= (1<<CS10); //Prescaler nicht aktiviert - es liegt der Systemtakt an
     ed2:	2e b5       	in	r18, 0x2e	; 46
     ed4:	21 60       	ori	r18, 0x01	; 1
     ed6:	2e bd       	out	0x2e, r18	; 46
	1 	0 	1 	CK / 1024
	1 	1 	0 	Externer Pin 1, negative Flanke
	1 	1 	1 	Externer Pin 1, positive Flanke 
*/
	
	OCR1A=compare;	//Vergleichswert laden
     ed8:	9b bd       	out	0x2b, r25	; 43
     eda:	8a bd       	out	0x2a, r24	; 42
	
	
}
     edc:	08 95       	ret

00000ede <i2cSetBitrate>:
void i2cSetBitrate(uint16_t bitratekHz)
{
	uint8_t bitrate_div;
	// set i2c bitrate
	// Set Prescaler to one --> TWPS = 1
	TWSR =((0<<TWPS0)|(0<<TWPS1));
     ede:	11 b8       	out	0x01, r1	; 1
	//calculate bitrate division	
	bitrate_div = (((float)F_CPU/1000.0)/(float)bitratekHz);
     ee0:	bc 01       	movw	r22, r24
     ee2:	80 e0       	ldi	r24, 0x00	; 0
     ee4:	90 e0       	ldi	r25, 0x00	; 0
     ee6:	0e 94 c1 17 	call	0x2f82	; 0x2f82 <__floatunsisf>
     eea:	9b 01       	movw	r18, r22
     eec:	ac 01       	movw	r20, r24
     eee:	60 e0       	ldi	r22, 0x00	; 0
     ef0:	70 e0       	ldi	r23, 0x00	; 0
     ef2:	8a e7       	ldi	r24, 0x7A	; 122
     ef4:	94 e4       	ldi	r25, 0x44	; 68
     ef6:	0e 94 28 17 	call	0x2e50	; 0x2e50 <__divsf3>
     efa:	0e 94 95 17 	call	0x2f2a	; 0x2f2a <__fixunssfsi>
	if(bitrate_div >= 16){
     efe:	60 31       	cpi	r22, 0x10	; 16
     f00:	b8 f0       	brcs	.+46     	; 0xf30 <i2cSetBitrate+0x52>
		bitrate_div = (float)(bitrate_div-16)/8;
     f02:	70 e0       	ldi	r23, 0x00	; 0
     f04:	60 51       	subi	r22, 0x10	; 16
     f06:	70 40       	sbci	r23, 0x00	; 0
     f08:	88 27       	eor	r24, r24
     f0a:	77 fd       	sbrc	r23, 7
     f0c:	80 95       	com	r24
     f0e:	98 2f       	mov	r25, r24
     f10:	0e 94 c3 17 	call	0x2f86	; 0x2f86 <__floatsisf>
     f14:	20 e0       	ldi	r18, 0x00	; 0
     f16:	30 e0       	ldi	r19, 0x00	; 0
     f18:	40 e0       	ldi	r20, 0x00	; 0
     f1a:	5e e3       	ldi	r21, 0x3E	; 62
     f1c:	0e 94 4f 18 	call	0x309e	; 0x309e <__mulsf3>
     f20:	46 2f       	mov	r20, r22
     f22:	57 2f       	mov	r21, r23
     f24:	68 2f       	mov	r22, r24
     f26:	79 2f       	mov	r23, r25
     f28:	cb 01       	movw	r24, r22
     f2a:	ba 01       	movw	r22, r20
     f2c:	0e 94 95 17 	call	0x2f2a	; 0x2f2a <__fixunssfsi>
	}
	//printf("DIV: %d \n",bitrate_div);
	TWBR=(uint8_t)bitrate_div;
     f30:	60 b9       	out	0x00, r22	; 0
	//TWBR=0; -> max speed
}
     f32:	08 95       	ret

00000f34 <i2cSendStart>:
// 
//----------------------------------------
void i2cSendStart(void)
{
	// send start condition
	TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
     f34:	84 ea       	ldi	r24, 0xA4	; 164
     f36:	86 bf       	out	0x36, r24	; 54
}
     f38:	08 95       	ret

00000f3a <i2cSendStop>:
{
	
	uint8_t i = 0;		//time out variable
	uint8_t error_code=0;
	// transmit stop condition
    TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWSTO);	
     f3a:	84 e9       	ldi	r24, 0x94	; 148
     f3c:	86 bf       	out	0x36, r24	; 54

	// wait until stop condition is executed and bus released
    while ((TWCR & (1<<TWSTO)) && (i < 90)){
     f3e:	06 b6       	in	r0, 0x36	; 54
     f40:	04 fe       	sbrs	r0, 4
     f42:	0e c0       	rjmp	.+28     	; 0xf60 <i2cSendStop+0x26>
// 
//----------------------------------------
uint8_t i2cSendStop(void)
{
	
	uint8_t i = 0;		//time out variable
     f44:	80 e0       	ldi	r24, 0x00	; 0
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     f46:	00 00       	nop
    TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWSTO);	

	// wait until stop condition is executed and bus released
    while ((TWCR & (1<<TWSTO)) && (i < 90)){
		_delay_us(1);
		i++;
     f48:	8f 5f       	subi	r24, 0xFF	; 255
	uint8_t error_code=0;
	// transmit stop condition
    TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWSTO);	

	// wait until stop condition is executed and bus released
    while ((TWCR & (1<<TWSTO)) && (i < 90)){
     f4a:	06 b6       	in	r0, 0x36	; 54
     f4c:	04 fe       	sbrs	r0, 4
     f4e:	03 c0       	rjmp	.+6      	; 0xf56 <i2cSendStop+0x1c>
     f50:	8a 35       	cpi	r24, 0x5A	; 90
     f52:	c9 f7       	brne	.-14     	; 0xf46 <i2cSendStop+0xc>
     f54:	02 c0       	rjmp	.+4      	; 0xf5a <i2cSendStop+0x20>
		_delay_us(1);
		i++;
	}
	if (i>89){
     f56:	8a 35       	cpi	r24, 0x5A	; 90
     f58:	28 f0       	brcs	.+10     	; 0xf64 <i2cSendStop+0x2a>
     f5a:	00 00       	nop
		_delay_us(1);
		error_code=100;
     f5c:	84 e6       	ldi	r24, 0x64	; 100
     f5e:	08 95       	ret
//----------------------------------------
uint8_t i2cSendStop(void)
{
	
	uint8_t i = 0;		//time out variable
	uint8_t error_code=0;
     f60:	80 e0       	ldi	r24, 0x00	; 0
     f62:	08 95       	ret
     f64:	80 e0       	ldi	r24, 0x00	; 0
		_delay_us(1);
		error_code=100;

	}
	return error_code;
}
     f66:	08 95       	ret

00000f68 <i2cSendByte>:
// 
//----------------------------------------
void i2cSendByte(unsigned char data)
{
	// save data to the TWDR
	TWDR = data;
     f68:	83 b9       	out	0x03, r24	; 3
	// begin send
	TWCR = (1<<TWINT)|(1<<TWEN);
     f6a:	84 e8       	ldi	r24, 0x84	; 132
     f6c:	86 bf       	out	0x36, r24	; 54
}
     f6e:	08 95       	ret

00000f70 <i2cReceiveByteACK>:
// 
//----------------------------------------
void i2cReceiveByteACK(void)
{

	TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
     f70:	84 ec       	ldi	r24, 0xC4	; 196
     f72:	86 bf       	out	0x36, r24	; 54
}
     f74:	08 95       	ret

00000f76 <i2cReceiveByteNACK>:
// 
//----------------------------------------
void i2cReceiveByteNACK(void)
{

	TWCR = (1<<TWINT)|(1<<TWEN);
     f76:	84 e8       	ldi	r24, 0x84	; 132
     f78:	86 bf       	out	0x36, r24	; 54
}
     f7a:	08 95       	ret

00000f7c <i2cWaitForComplete>:
//----------------------------------------
// 
//----------------------------------------
uint8_t i2cWaitForComplete(void)
{
	uint8_t i = 0;		//time out variable
     f7c:	80 e0       	ldi	r24, 0x00	; 0

	// wait for i2c interface to complete operation
	// -> wait for 90us to pass OR
	// -> wait for twiInterrupt flag to be set (flag == 0)
	//	  is set by hardware when the twi has finished its current job
    while ((!(TWCR & (1<<TWINT))) || (i < 90))
     f7e:	02 c0       	rjmp	.+4      	; 0xf84 <i2cWaitForComplete+0x8>
     f80:	00 00       	nop
	{
		_delay_us(1);
		i++;
     f82:	8f 5f       	subi	r24, 0xFF	; 255

	// wait for i2c interface to complete operation
	// -> wait for 90us to pass OR
	// -> wait for twiInterrupt flag to be set (flag == 0)
	//	  is set by hardware when the twi has finished its current job
    while ((!(TWCR & (1<<TWINT))) || (i < 90))
     f84:	06 b6       	in	r0, 0x36	; 54
     f86:	07 fe       	sbrs	r0, 7
     f88:	fb cf       	rjmp	.-10     	; 0xf80 <i2cWaitForComplete+0x4>
     f8a:	8a 35       	cpi	r24, 0x5A	; 90
     f8c:	c8 f3       	brcs	.-14     	; 0xf80 <i2cWaitForComplete+0x4>
     f8e:	00 00       	nop
		_delay_us(1);
		error_code=100;

	}
	return error_code;
}
     f90:	84 e6       	ldi	r24, 0x64	; 100
     f92:	08 95       	ret

00000f94 <i2cGetReceivedByte>:
// 
//----------------------------------------
uint8_t i2cGetReceivedByte(void)
{
	// retieve received data byte from i2c TWDR
	return (uint8_t)TWDR;
     f94:	83 b1       	in	r24, 0x03	; 3
}
     f96:	08 95       	ret

00000f98 <checki2cReturnCode>:
uint8_t checki2cReturnCode(uint8_t expected_return_code)
{
	uint8_t error_code=0;
	uint8_t i=0;
	//while (error_code!=0 && i!=0 && i<3){
		if ((TWSR & 0xF8) != expected_return_code){
     f98:	21 b1       	in	r18, 0x01	; 1
     f9a:	30 e0       	ldi	r19, 0x00	; 0
     f9c:	28 7f       	andi	r18, 0xF8	; 248
     f9e:	30 70       	andi	r19, 0x00	; 0
     fa0:	90 e0       	ldi	r25, 0x00	; 0
     fa2:	28 17       	cp	r18, r24
     fa4:	39 07       	cpc	r19, r25
     fa6:	11 f4       	brne	.+4      	; 0xfac <checki2cReturnCode+0x14>
//----------------------------------------
// 
//----------------------------------------
uint8_t checki2cReturnCode(uint8_t expected_return_code)
{
	uint8_t error_code=0;
     fa8:	80 e0       	ldi	r24, 0x00	; 0
     faa:	08 95       	ret
	uint8_t i=0;
	//while (error_code!=0 && i!=0 && i<3){
		if ((TWSR & 0xF8) != expected_return_code){
			error_code=10;
     fac:	8a e0       	ldi	r24, 0x0A	; 10
		}
	i++;
//	}
	return error_code;
}
     fae:	08 95       	ret

00000fb0 <TWIM_Init>:

*******************************************************/
uint8_t TWIM_Init (void)
{	
	/* set prescaler to 1 */
	TWSR = ((0<<TWPS0)|(0<<TWPS1));
     fb0:	11 b8       	out	0x01, r1	; 1
	TWBR = 8;
     fb2:	88 e0       	ldi	r24, 0x08	; 8
     fb4:	80 b9       	out	0x00, r24	; 0

	return TRUE;
}
     fb6:	81 e0       	ldi	r24, 0x01	; 1
     fb8:	08 95       	ret

00000fba <TWIM_Start>:
{
	uint8_t		twst;
    /*
    ** Send START condition
	*/
	TWCR = (1<<TWINT)|(1<<TWSTA)|(1<<TWEN);
     fba:	94 ea       	ldi	r25, 0xA4	; 164
     fbc:	96 bf       	out	0x36, r25	; 54
	/*
	** Wait until transmission completed
	*/
	while (!(TWCR & (1<<TWINT)));
     fbe:	06 b6       	in	r0, 0x36	; 54
     fc0:	07 fe       	sbrs	r0, 7
     fc2:	fd cf       	rjmp	.-6      	; 0xfbe <TWIM_Start+0x4>
	/*
	** Check value of TWI Status Register. Mask prescaler bits.
	*/
	twst = TWSR & 0xF8;
     fc4:	91 b1       	in	r25, 0x01	; 1
     fc6:	98 7f       	andi	r25, 0xF8	; 248
	if ((twst != TWI_START) && (twst != TWI_REP_START)) return FALSE;
     fc8:	98 30       	cpi	r25, 0x08	; 8
     fca:	11 f0       	breq	.+4      	; 0xfd0 <TWIM_Start+0x16>
     fcc:	90 31       	cpi	r25, 0x10	; 16
     fce:	89 f4       	brne	.+34     	; 0xff2 <TWIM_Start+0x38>
	/*
	** Send device address
	*/
	TWDR = (Address<<1) + TWIM_Type;
     fd0:	88 0f       	add	r24, r24
     fd2:	68 0f       	add	r22, r24
     fd4:	63 b9       	out	0x03, r22	; 3
	TWCR = (1<<TWINT)|(1<<TWEN);
     fd6:	84 e8       	ldi	r24, 0x84	; 132
     fd8:	86 bf       	out	0x36, r24	; 54
	/*
	** Wait until transmission completed and ACK/NACK has been received
	*/
	while (!(TWCR & (1<<TWINT)));
     fda:	06 b6       	in	r0, 0x36	; 54
     fdc:	07 fe       	sbrs	r0, 7
     fde:	fd cf       	rjmp	.-6      	; 0xfda <TWIM_Start+0x20>
	/*
	** Check value of TWI Status Register. Mask prescaler bits.
	*/
	twst = TWSR & 0xF8;
     fe0:	91 b1       	in	r25, 0x01	; 1
     fe2:	98 7f       	andi	r25, 0xF8	; 248
	if ((twst != TWI_MTX_ADR_ACK) && (twst != TWI_MRX_ADR_ACK)) return FALSE;
     fe4:	98 31       	cpi	r25, 0x18	; 24
     fe6:	39 f0       	breq	.+14     	; 0xff6 <TWIM_Start+0x3c>
 Return Value: uint8_t
  	- TRUE:		OK, TWI Master accessible
 	- FALSE:	Error in starting TWI Master

*******************************************************/
uint8_t TWIM_Start (uint8_t Address, uint8_t TWIM_Type)
     fe8:	81 e0       	ldi	r24, 0x01	; 1
     fea:	90 34       	cpi	r25, 0x40	; 64
     fec:	29 f0       	breq	.+10     	; 0xff8 <TWIM_Start+0x3e>
     fee:	80 e0       	ldi	r24, 0x00	; 0
     ff0:	08 95       	ret
	while (!(TWCR & (1<<TWINT)));
	/*
	** Check value of TWI Status Register. Mask prescaler bits.
	*/
	twst = TWSR & 0xF8;
	if ((twst != TWI_START) && (twst != TWI_REP_START)) return FALSE;
     ff2:	80 e0       	ldi	r24, 0x00	; 0
     ff4:	08 95       	ret
	** Check value of TWI Status Register. Mask prescaler bits.
	*/
	twst = TWSR & 0xF8;
	if ((twst != TWI_MTX_ADR_ACK) && (twst != TWI_MRX_ADR_ACK)) return FALSE;

	return TRUE;
     ff6:	81 e0       	ldi	r24, 0x01	; 1
}
     ff8:	08 95       	ret

00000ffa <TWIM_Stop>:
void TWIM_Stop (void)
{
	/*
	** Send stop condition
	*/
	TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWSTO);
     ffa:	84 e9       	ldi	r24, 0x94	; 148
     ffc:	86 bf       	out	0x36, r24	; 54
	/*
	** Wait until stop condition is executed and bus released
	*/
	while (TWCR & (1<<TWINT));
     ffe:	06 b6       	in	r0, 0x36	; 54
    1000:	07 fc       	sbrc	r0, 7
    1002:	fd cf       	rjmp	.-6      	; 0xffe <TWIM_Stop+0x4>
}
    1004:	08 95       	ret

00001006 <TWIM_Write>:
{
	uint8_t   twst;
	/*
	** Send data to the previously addressed device
	*/
	TWDR = byte;
    1006:	83 b9       	out	0x03, r24	; 3
	TWCR = (1<<TWINT)|(1<<TWEN);
    1008:	84 e8       	ldi	r24, 0x84	; 132
    100a:	86 bf       	out	0x36, r24	; 54
	/*
	** Wait until transmission completed
	*/
	while (!(TWCR & (1<<TWINT)));
    100c:	06 b6       	in	r0, 0x36	; 54
    100e:	07 fe       	sbrs	r0, 7
    1010:	fd cf       	rjmp	.-6      	; 0x100c <TWIM_Write+0x6>
	/*
	** Check value of TWI Status Register. Mask prescaler bits
	*/
	twst = TWSR & 0xF8;
    1012:	91 b1       	in	r25, 0x01	; 1
    1014:	98 7f       	andi	r25, 0xF8	; 248
	if (twst != TWI_MTX_DATA_ACK) return FALSE;
    1016:	81 e0       	ldi	r24, 0x01	; 1
    1018:	98 32       	cpi	r25, 0x28	; 40
    101a:	09 f0       	breq	.+2      	; 0x101e <TWIM_Write+0x18>
    101c:	80 e0       	ldi	r24, 0x00	; 0

	return TRUE;
}
    101e:	08 95       	ret

00001020 <TWIM_ReadAck>:

*******************************************************/
uint8_t TWIM_ReadAck (void)
{
	
	TWCR = (1<<TWINT)|(1<<TWEN)|(1<<TWEA);
    1020:	84 ec       	ldi	r24, 0xC4	; 196
    1022:	86 bf       	out	0x36, r24	; 54

	while (!(TWCR & (1<<TWINT)));    
    1024:	06 b6       	in	r0, 0x36	; 54
    1026:	07 fe       	sbrs	r0, 7
    1028:	fd cf       	rjmp	.-6      	; 0x1024 <TWIM_ReadAck+0x4>

	return TWDR;
    102a:	83 b1       	in	r24, 0x03	; 3
}
    102c:	08 95       	ret

0000102e <TWIM_ReadNack>:
  	- uint8_t	Read byte

*******************************************************/
uint8_t TWIM_ReadNack (void)
{
	TWCR = (1<<TWINT)|(1<<TWEN);
    102e:	84 e8       	ldi	r24, 0x84	; 132
    1030:	86 bf       	out	0x36, r24	; 54

	while(!(TWCR & (1<<TWINT)));
    1032:	06 b6       	in	r0, 0x36	; 54
    1034:	07 fe       	sbrs	r0, 7
    1036:	fd cf       	rjmp	.-6      	; 0x1032 <TWIM_ReadNack+0x4>
	
	return TWDR;
    1038:	83 b1       	in	r24, 0x03	; 3
}
    103a:	08 95       	ret

0000103c <main>:
void vApplicationIdleHook( void );

/*-----------------------------------------------------------*/

int main( void )
{  
    103c:	cf 93       	push	r28
    103e:	df 93       	push	r29
    1040:	cd b7       	in	r28, 0x3d	; 61
    1042:	de b7       	in	r29, 0x3e	; 62
    1044:	a3 97       	sbiw	r28, 0x23	; 35
    1046:	0f b6       	in	r0, 0x3f	; 63
    1048:	f8 94       	cli
    104a:	de bf       	out	0x3e, r29	; 62
    104c:	0f be       	out	0x3f, r0	; 63
    104e:	cd bf       	out	0x3d, r28	; 61
    
    xQueueHandle measurementQueue;
    //xQueueHandle statusQueue;
   
	// ...for temperature and pressure sensor
	int32_t temperature = 0;
    1050:	19 82       	std	Y+1, r1	; 0x01
    1052:	1a 82       	std	Y+2, r1	; 0x02
    1054:	1b 82       	std	Y+3, r1	; 0x03
    1056:	1c 82       	std	Y+4, r1	; 0x04
	int32_t pressure = 0;
    1058:	1d 82       	std	Y+5, r1	; 0x05
    105a:	1e 82       	std	Y+6, r1	; 0x06
    105c:	1f 82       	std	Y+7, r1	; 0x07
    105e:	18 86       	std	Y+8, r1	; 0x08
	int16_t BMP085_calibration_int16_t[8];
	int16_t BMP085_calibration_uint16_t[3];
	uint8_t error_code=0;   
    1060:	1f 8e       	std	Y+31, r1	; 0x1f
	volatile int32_t altitude=0;   
    1062:	18 a2       	lds	r17, 0x98
    1064:	19 a2       	lds	r17, 0x99
    1066:	1a a2       	lds	r17, 0x9a
    1068:	1b a2       	lds	r17, 0x9b
   
    
    //configure time measurment pin as output
    DDRD |= (1<<PB7);
    106a:	8f 9a       	sbi	0x11, 7	; 17
    
    //Initialize TWI 100KHz
    i2cSetBitrate(1);	
    106c:	81 e0       	ldi	r24, 0x01	; 1
    106e:	90 e0       	ldi	r25, 0x00	; 0
    1070:	0e 94 6f 07 	call	0xede	; 0xede <i2cSetBitrate>
    TWIM_Init(); 
    1074:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <TWIM_Init>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1078:	8f ef       	ldi	r24, 0xFF	; 255
    107a:	90 e7       	ldi	r25, 0x70	; 112
    107c:	a2 e0       	ldi	r26, 0x02	; 2
    107e:	81 50       	subi	r24, 0x01	; 1
    1080:	90 40       	sbci	r25, 0x00	; 0
    1082:	a0 40       	sbci	r26, 0x00	; 0
    1084:	e1 f7       	brne	.-8      	; 0x107e <main+0x42>
    1086:	00 c0       	rjmp	.+0      	; 0x1088 <main+0x4c>
    1088:	00 00       	nop

    _delay_ms(100);	
    
    BMP085_Calibration( BMP085_calibration_int16_t, BMP085_calibration_uint16_t,&error_code );
    108a:	ce 01       	movw	r24, r28
    108c:	09 96       	adiw	r24, 0x09	; 9
    108e:	be 01       	movw	r22, r28
    1090:	67 5e       	subi	r22, 0xE7	; 231
    1092:	7f 4f       	sbci	r23, 0xFF	; 255
    1094:	ae 01       	movw	r20, r28
    1096:	41 5e       	subi	r20, 0xE1	; 225
    1098:	5f 4f       	sbci	r21, 0xFF	; 255
    109a:	0e 94 5e 04 	call	0x8bc	; 0x8bc <BMP085_Calibration>
    
    
    while( 1 )
    {
        bmp085Convert( BMP085_calibration_int16_t, BMP085_calibration_uint16_t,&temperature, &pressure,&error_code );
    109e:	ce 01       	movw	r24, r28
    10a0:	09 96       	adiw	r24, 0x09	; 9
    10a2:	be 01       	movw	r22, r28
    10a4:	67 5e       	subi	r22, 0xE7	; 231
    10a6:	7f 4f       	sbci	r23, 0xFF	; 255
    10a8:	ae 01       	movw	r20, r28
    10aa:	4f 5f       	subi	r20, 0xFF	; 255
    10ac:	5f 4f       	sbci	r21, 0xFF	; 255
    10ae:	9e 01       	movw	r18, r28
    10b0:	2b 5f       	subi	r18, 0xFB	; 251
    10b2:	3f 4f       	sbci	r19, 0xFF	; 255
    10b4:	8e 01       	movw	r16, r28
    10b6:	01 5e       	subi	r16, 0xE1	; 225
    10b8:	1f 4f       	sbci	r17, 0xFF	; 255
    10ba:	0e 94 10 02 	call	0x420	; 0x420 <bmp085Convert>
    
        altitude = bmp085CalcAltitude ( pressure );
    10be:	6d 81       	ldd	r22, Y+5	; 0x05
    10c0:	7e 81       	ldd	r23, Y+6	; 0x06
    10c2:	8f 81       	ldd	r24, Y+7	; 0x07
    10c4:	98 85       	ldd	r25, Y+8	; 0x08
    10c6:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <bmp085CalcAltitude>
    10ca:	dc 01       	movw	r26, r24
    10cc:	cb 01       	movw	r24, r22
    10ce:	88 a3       	lds	r24, 0x58
    10d0:	99 a3       	lds	r25, 0x59
    10d2:	aa a3       	lds	r26, 0x5a
    10d4:	bb a3       	lds	r27, 0x5b
    10d6:	8f ef       	ldi	r24, 0xFF	; 255
    10d8:	90 e7       	ldi	r25, 0x70	; 112
    10da:	a2 e0       	ldi	r26, 0x02	; 2
    10dc:	81 50       	subi	r24, 0x01	; 1
    10de:	90 40       	sbci	r25, 0x00	; 0
    10e0:	a0 40       	sbci	r26, 0x00	; 0
    10e2:	e1 f7       	brne	.-8      	; 0x10dc <main+0xa0>
    10e4:	00 c0       	rjmp	.+0      	; 0x10e6 <main+0xaa>
    10e6:	00 00       	nop
    10e8:	da cf       	rjmp	.-76     	; 0x109e <main+0x62>

000010ea <vApplicationIdleHook>:
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
	//vCoRoutineSchedule();
}
    10ea:	08 95       	ret

000010ec <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    10ec:	af 92       	push	r10
    10ee:	bf 92       	push	r11
    10f0:	cf 92       	push	r12
    10f2:	df 92       	push	r13
    10f4:	ef 92       	push	r14
    10f6:	ff 92       	push	r15
    10f8:	0f 93       	push	r16
    10fa:	1f 93       	push	r17
    10fc:	cf 93       	push	r28
    10fe:	df 93       	push	r29
    1100:	6c 01       	movw	r12, r24
    1102:	e6 2e       	mov	r14, r22
    1104:	f4 2e       	mov	r15, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    1106:	8a e1       	ldi	r24, 0x1A	; 26
    1108:	90 e0       	ldi	r25, 0x00	; 0
    110a:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <pvPortMalloc>
    110e:	8c 01       	movw	r16, r24
	if( pxCoRoutine )
    1110:	00 97       	sbiw	r24, 0x00	; 0
    1112:	09 f4       	brne	.+2      	; 0x1116 <xCoRoutineCreate+0x2a>
    1114:	62 c0       	rjmp	.+196    	; 0x11da <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1116:	80 91 8a 00 	lds	r24, 0x008A
    111a:	90 91 8b 00 	lds	r25, 0x008B
    111e:	00 97       	sbiw	r24, 0x00	; 0
    1120:	39 f5       	brne	.+78     	; 0x1170 <xCoRoutineCreate+0x84>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1122:	10 93 8b 00 	sts	0x008B, r17
    1126:	00 93 8a 00 	sts	0x008A, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    112a:	cd e8       	ldi	r28, 0x8D	; 141
    112c:	d0 e0       	ldi	r29, 0x00	; 0
    112e:	ce 01       	movw	r24, r28
    1130:	0e 94 2e 0b 	call	0x165c	; 0x165c <vListInitialise>
    1134:	ce 01       	movw	r24, r28
    1136:	09 96       	adiw	r24, 0x09	; 9
    1138:	0e 94 2e 0b 	call	0x165c	; 0x165c <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    113c:	cf e9       	ldi	r28, 0x9F	; 159
    113e:	d0 e0       	ldi	r29, 0x00	; 0
    1140:	ce 01       	movw	r24, r28
    1142:	0e 94 2e 0b 	call	0x165c	; 0x165c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    1146:	0f 2e       	mov	r0, r31
    1148:	f8 ea       	ldi	r31, 0xA8	; 168
    114a:	af 2e       	mov	r10, r31
    114c:	f0 e0       	ldi	r31, 0x00	; 0
    114e:	bf 2e       	mov	r11, r31
    1150:	f0 2d       	mov	r31, r0
    1152:	c5 01       	movw	r24, r10
    1154:	0e 94 2e 0b 	call	0x165c	; 0x165c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    1158:	81 eb       	ldi	r24, 0xB1	; 177
    115a:	90 e0       	ldi	r25, 0x00	; 0
    115c:	0e 94 2e 0b 	call	0x165c	; 0x165c <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1160:	d0 93 bb 00 	sts	0x00BB, r29
    1164:	c0 93 ba 00 	sts	0x00BA, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1168:	b0 92 bd 00 	sts	0x00BD, r11
    116c:	a0 92 bc 00 	sts	0x00BC, r10
    1170:	ce 2d       	mov	r28, r14
    1172:	e1 10       	cpse	r14, r1
    1174:	c1 e0       	ldi	r28, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1176:	f8 01       	movw	r30, r16
    1178:	11 8e       	std	Z+25, r1	; 0x19
    117a:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    117c:	c6 8b       	std	Z+22, r28	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    117e:	f7 8a       	std	Z+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1180:	c1 92       	st	Z+, r12
    1182:	d1 92       	st	Z+, r13
    1184:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1186:	cf 01       	movw	r24, r30
    1188:	0e 94 3c 0b 	call	0x1678	; 0x1678 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    118c:	c8 01       	movw	r24, r16
    118e:	0c 96       	adiw	r24, 0x0c	; 12
    1190:	0e 94 3c 0b 	call	0x1678	; 0x1678 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1194:	f8 01       	movw	r30, r16
    1196:	11 87       	std	Z+9, r17	; 0x09
    1198:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    119a:	13 8b       	std	Z+19, r17	; 0x13
    119c:	02 8b       	std	Z+18, r16	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( uint32_t ) uxPriority );
    119e:	84 e0       	ldi	r24, 0x04	; 4
    11a0:	90 e0       	ldi	r25, 0x00	; 0
    11a2:	8c 1b       	sub	r24, r28
    11a4:	91 09       	sbc	r25, r1
    11a6:	95 87       	std	Z+13, r25	; 0x0d
    11a8:	84 87       	std	Z+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    11aa:	86 89       	ldd	r24, Z+22	; 0x16
    11ac:	90 91 8c 00 	lds	r25, 0x008C
    11b0:	98 17       	cp	r25, r24
    11b2:	10 f4       	brcc	.+4      	; 0x11b8 <xCoRoutineCreate+0xcc>
    11b4:	80 93 8c 00 	sts	0x008C, r24
    11b8:	90 e0       	ldi	r25, 0x00	; 0
    11ba:	9c 01       	movw	r18, r24
    11bc:	22 0f       	add	r18, r18
    11be:	33 1f       	adc	r19, r19
    11c0:	22 0f       	add	r18, r18
    11c2:	33 1f       	adc	r19, r19
    11c4:	22 0f       	add	r18, r18
    11c6:	33 1f       	adc	r19, r19
    11c8:	82 0f       	add	r24, r18
    11ca:	93 1f       	adc	r25, r19
    11cc:	83 57       	subi	r24, 0x73	; 115
    11ce:	9f 4f       	sbci	r25, 0xFF	; 255
    11d0:	b7 01       	movw	r22, r14
    11d2:	0e 94 40 0b 	call	0x1680	; 0x1680 <vListInsertEnd>

		xReturn = pdPASS;
    11d6:	81 e0       	ldi	r24, 0x01	; 1
    11d8:	01 c0       	rjmp	.+2      	; 0x11dc <xCoRoutineCreate+0xf0>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    11da:	8f ef       	ldi	r24, 0xFF	; 255
	}

	return xReturn;
}
    11dc:	df 91       	pop	r29
    11de:	cf 91       	pop	r28
    11e0:	1f 91       	pop	r17
    11e2:	0f 91       	pop	r16
    11e4:	ff 90       	pop	r15
    11e6:	ef 90       	pop	r14
    11e8:	df 90       	pop	r13
    11ea:	cf 90       	pop	r12
    11ec:	bf 90       	pop	r11
    11ee:	af 90       	pop	r10
    11f0:	08 95       	ret

000011f2 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( uint32_t xTicksToDelay, xList *pxEventList )
{
    11f2:	cf 92       	push	r12
    11f4:	df 92       	push	r13
    11f6:	ef 92       	push	r14
    11f8:	ff 92       	push	r15
    11fa:	cf 93       	push	r28
    11fc:	df 93       	push	r29
    11fe:	dc 01       	movw	r26, r24
    1200:	cb 01       	movw	r24, r22
    1202:	ea 01       	movw	r28, r20
uint32_t xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1204:	c0 90 be 00 	lds	r12, 0x00BE
    1208:	d0 90 bf 00 	lds	r13, 0x00BF
    120c:	e0 90 c0 00 	lds	r14, 0x00C0
    1210:	f0 90 c1 00 	lds	r15, 0x00C1
    1214:	c8 0e       	add	r12, r24
    1216:	d9 1e       	adc	r13, r25
    1218:	ea 1e       	adc	r14, r26
    121a:	fb 1e       	adc	r15, r27

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    121c:	80 91 8a 00 	lds	r24, 0x008A
    1220:	90 91 8b 00 	lds	r25, 0x008B
    1224:	02 96       	adiw	r24, 0x02	; 2
    1226:	0e 94 b3 0b 	call	0x1766	; 0x1766 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    122a:	e0 91 8a 00 	lds	r30, 0x008A
    122e:	f0 91 8b 00 	lds	r31, 0x008B
    1232:	d3 82       	std	Z+3, r13	; 0x03
    1234:	c2 82       	std	Z+2, r12	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1236:	80 91 be 00 	lds	r24, 0x00BE
    123a:	90 91 bf 00 	lds	r25, 0x00BF
    123e:	a0 91 c0 00 	lds	r26, 0x00C0
    1242:	b0 91 c1 00 	lds	r27, 0x00C1
    1246:	c8 16       	cp	r12, r24
    1248:	d9 06       	cpc	r13, r25
    124a:	ea 06       	cpc	r14, r26
    124c:	fb 06       	cpc	r15, r27
    124e:	50 f4       	brcc	.+20     	; 0x1264 <vCoRoutineAddToDelayedList+0x72>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1250:	bf 01       	movw	r22, r30
    1252:	6e 5f       	subi	r22, 0xFE	; 254
    1254:	7f 4f       	sbci	r23, 0xFF	; 255
    1256:	80 91 bc 00 	lds	r24, 0x00BC
    125a:	90 91 bd 00 	lds	r25, 0x00BD
    125e:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vListInsert>
    1262:	09 c0       	rjmp	.+18     	; 0x1276 <vCoRoutineAddToDelayedList+0x84>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1264:	bf 01       	movw	r22, r30
    1266:	6e 5f       	subi	r22, 0xFE	; 254
    1268:	7f 4f       	sbci	r23, 0xFF	; 255
    126a:	80 91 ba 00 	lds	r24, 0x00BA
    126e:	90 91 bb 00 	lds	r25, 0x00BB
    1272:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vListInsert>
	}

	if( pxEventList )
    1276:	20 97       	sbiw	r28, 0x00	; 0
    1278:	49 f0       	breq	.+18     	; 0x128c <vCoRoutineAddToDelayedList+0x9a>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    127a:	60 91 8a 00 	lds	r22, 0x008A
    127e:	70 91 8b 00 	lds	r23, 0x008B
    1282:	64 5f       	subi	r22, 0xF4	; 244
    1284:	7f 4f       	sbci	r23, 0xFF	; 255
    1286:	ce 01       	movw	r24, r28
    1288:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vListInsert>
	}
}
    128c:	df 91       	pop	r29
    128e:	cf 91       	pop	r28
    1290:	ff 90       	pop	r15
    1292:	ef 90       	pop	r14
    1294:	df 90       	pop	r13
    1296:	cf 90       	pop	r12
    1298:	08 95       	ret

0000129a <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    129a:	cf 92       	push	r12
    129c:	df 92       	push	r13
    129e:	ef 92       	push	r14
    12a0:	ff 92       	push	r15
    12a2:	0f 93       	push	r16
    12a4:	1f 93       	push	r17
    12a6:	cf 93       	push	r28
    12a8:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    12aa:	80 91 b1 00 	lds	r24, 0x00B1
    12ae:	88 23       	and	r24, r24
    12b0:	b9 f1       	breq	.+110    	; 0x1320 <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    12b2:	0f 2e       	mov	r0, r31
    12b4:	f6 eb       	ldi	r31, 0xB6	; 182
    12b6:	ef 2e       	mov	r14, r31
    12b8:	f0 e0       	ldi	r31, 0x00	; 0
    12ba:	ff 2e       	mov	r15, r31
    12bc:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    12be:	0f 2e       	mov	r0, r31
    12c0:	f1 eb       	ldi	r31, 0xB1	; 177
    12c2:	cf 2e       	mov	r12, r31
    12c4:	f0 e0       	ldi	r31, 0x00	; 0
    12c6:	df 2e       	mov	r13, r31
    12c8:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    12ca:	f8 94       	cli
		{
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    12cc:	d7 01       	movw	r26, r14
    12ce:	ed 91       	ld	r30, X+
    12d0:	fc 91       	ld	r31, X
    12d2:	c6 81       	ldd	r28, Z+6	; 0x06
    12d4:	d7 81       	ldd	r29, Z+7	; 0x07
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    12d6:	ce 01       	movw	r24, r28
    12d8:	0c 96       	adiw	r24, 0x0c	; 12
    12da:	0e 94 b3 0b 	call	0x1766	; 0x1766 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    12de:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    12e0:	8e 01       	movw	r16, r28
    12e2:	0e 5f       	subi	r16, 0xFE	; 254
    12e4:	1f 4f       	sbci	r17, 0xFF	; 255
    12e6:	c8 01       	movw	r24, r16
    12e8:	0e 94 b3 0b 	call	0x1766	; 0x1766 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    12ec:	8e 89       	ldd	r24, Y+22	; 0x16
    12ee:	90 91 8c 00 	lds	r25, 0x008C
    12f2:	98 17       	cp	r25, r24
    12f4:	10 f4       	brcc	.+4      	; 0x12fa <vCoRoutineSchedule+0x60>
    12f6:	80 93 8c 00 	sts	0x008C, r24
    12fa:	90 e0       	ldi	r25, 0x00	; 0
    12fc:	9c 01       	movw	r18, r24
    12fe:	22 0f       	add	r18, r18
    1300:	33 1f       	adc	r19, r19
    1302:	22 0f       	add	r18, r18
    1304:	33 1f       	adc	r19, r19
    1306:	22 0f       	add	r18, r18
    1308:	33 1f       	adc	r19, r19
    130a:	82 0f       	add	r24, r18
    130c:	93 1f       	adc	r25, r19
    130e:	83 57       	subi	r24, 0x73	; 115
    1310:	9f 4f       	sbci	r25, 0xFF	; 255
    1312:	b8 01       	movw	r22, r16
    1314:	0e 94 40 0b 	call	0x1680	; 0x1680 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1318:	f6 01       	movw	r30, r12
    131a:	80 81       	ld	r24, Z
    131c:	88 23       	and	r24, r24
    131e:	a9 f6       	brne	.-86     	; 0x12ca <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1320:	0e 94 47 12 	call	0x248e	; 0x248e <xTaskGetTickCount>
    1324:	a0 e0       	ldi	r26, 0x00	; 0
    1326:	b0 e0       	ldi	r27, 0x00	; 0
    1328:	40 91 c2 00 	lds	r20, 0x00C2
    132c:	50 91 c3 00 	lds	r21, 0x00C3
    1330:	60 91 c4 00 	lds	r22, 0x00C4
    1334:	70 91 c5 00 	lds	r23, 0x00C5
    1338:	84 1b       	sub	r24, r20
    133a:	95 0b       	sbc	r25, r21
    133c:	a6 0b       	sbc	r26, r22
    133e:	b7 0b       	sbc	r27, r23
    1340:	80 93 c6 00 	sts	0x00C6, r24
    1344:	90 93 c7 00 	sts	0x00C7, r25
    1348:	a0 93 c8 00 	sts	0x00C8, r26
    134c:	b0 93 c9 00 	sts	0x00C9, r27
    1350:	97 c0       	rjmp	.+302    	; 0x1480 <vCoRoutineSchedule+0x1e6>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    1352:	40 91 be 00 	lds	r20, 0x00BE
    1356:	50 91 bf 00 	lds	r21, 0x00BF
    135a:	60 91 c0 00 	lds	r22, 0x00C0
    135e:	70 91 c1 00 	lds	r23, 0x00C1
    1362:	4f 5f       	subi	r20, 0xFF	; 255
    1364:	5f 4f       	sbci	r21, 0xFF	; 255
    1366:	6f 4f       	sbci	r22, 0xFF	; 255
    1368:	7f 4f       	sbci	r23, 0xFF	; 255
    136a:	40 93 be 00 	sts	0x00BE, r20
    136e:	50 93 bf 00 	sts	0x00BF, r21
    1372:	60 93 c0 00 	sts	0x00C0, r22
    1376:	70 93 c1 00 	sts	0x00C1, r23
		xPassedTicks--;
    137a:	01 97       	sbiw	r24, 0x01	; 1
    137c:	a1 09       	sbc	r26, r1
    137e:	b1 09       	sbc	r27, r1
    1380:	80 93 c6 00 	sts	0x00C6, r24
    1384:	90 93 c7 00 	sts	0x00C7, r25
    1388:	a0 93 c8 00 	sts	0x00C8, r26
    138c:	b0 93 c9 00 	sts	0x00C9, r27

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1390:	41 15       	cp	r20, r1
    1392:	51 05       	cpc	r21, r1
    1394:	61 05       	cpc	r22, r1
    1396:	71 05       	cpc	r23, r1
    1398:	81 f4       	brne	.+32     	; 0x13ba <vCoRoutineSchedule+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    139a:	80 91 ba 00 	lds	r24, 0x00BA
    139e:	90 91 bb 00 	lds	r25, 0x00BB
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    13a2:	20 91 bc 00 	lds	r18, 0x00BC
    13a6:	30 91 bd 00 	lds	r19, 0x00BD
    13aa:	30 93 bb 00 	sts	0x00BB, r19
    13ae:	20 93 ba 00 	sts	0x00BA, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
    13b2:	90 93 bd 00 	sts	0x00BD, r25
    13b6:	80 93 bc 00 	sts	0x00BC, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    13ba:	e0 91 ba 00 	lds	r30, 0x00BA
    13be:	f0 91 bb 00 	lds	r31, 0x00BB
    13c2:	80 81       	ld	r24, Z
    13c4:	88 23       	and	r24, r24
    13c6:	09 f4       	brne	.+2      	; 0x13ca <vCoRoutineSchedule+0x130>
    13c8:	5b c0       	rjmp	.+182    	; 0x1480 <vCoRoutineSchedule+0x1e6>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    13ca:	05 80       	ldd	r0, Z+5	; 0x05
    13cc:	f6 81       	ldd	r31, Z+6	; 0x06
    13ce:	e0 2d       	mov	r30, r0
    13d0:	c6 81       	ldd	r28, Z+6	; 0x06
    13d2:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    13d4:	4a 81       	ldd	r20, Y+2	; 0x02
    13d6:	5b 81       	ldd	r21, Y+3	; 0x03
    13d8:	60 e0       	ldi	r22, 0x00	; 0
    13da:	70 e0       	ldi	r23, 0x00	; 0
    13dc:	80 91 be 00 	lds	r24, 0x00BE
    13e0:	90 91 bf 00 	lds	r25, 0x00BF
    13e4:	a0 91 c0 00 	lds	r26, 0x00C0
    13e8:	b0 91 c1 00 	lds	r27, 0x00C1
    13ec:	84 17       	cp	r24, r20
    13ee:	95 07       	cpc	r25, r21
    13f0:	a6 07       	cpc	r26, r22
    13f2:	b7 07       	cpc	r27, r23
    13f4:	b8 f4       	brcc	.+46     	; 0x1424 <vCoRoutineSchedule+0x18a>
    13f6:	44 c0       	rjmp	.+136    	; 0x1480 <vCoRoutineSchedule+0x1e6>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    13f8:	05 80       	ldd	r0, Z+5	; 0x05
    13fa:	f6 81       	ldd	r31, Z+6	; 0x06
    13fc:	e0 2d       	mov	r30, r0
    13fe:	c6 81       	ldd	r28, Z+6	; 0x06
    1400:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1402:	4a 81       	ldd	r20, Y+2	; 0x02
    1404:	5b 81       	ldd	r21, Y+3	; 0x03
    1406:	60 e0       	ldi	r22, 0x00	; 0
    1408:	70 e0       	ldi	r23, 0x00	; 0
    140a:	80 91 be 00 	lds	r24, 0x00BE
    140e:	90 91 bf 00 	lds	r25, 0x00BF
    1412:	a0 91 c0 00 	lds	r26, 0x00C0
    1416:	b0 91 c1 00 	lds	r27, 0x00C1
    141a:	84 17       	cp	r24, r20
    141c:	95 07       	cpc	r25, r21
    141e:	a6 07       	cpc	r26, r22
    1420:	b7 07       	cpc	r27, r23
    1422:	70 f1       	brcs	.+92     	; 0x1480 <vCoRoutineSchedule+0x1e6>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    1424:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );
    1426:	8e 01       	movw	r16, r28
    1428:	0e 5f       	subi	r16, 0xFE	; 254
    142a:	1f 4f       	sbci	r17, 0xFF	; 255
    142c:	c8 01       	movw	r24, r16
    142e:	0e 94 b3 0b 	call	0x1766	; 0x1766 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    1432:	8c 89       	ldd	r24, Y+20	; 0x14
    1434:	9d 89       	ldd	r25, Y+21	; 0x15
    1436:	00 97       	sbiw	r24, 0x00	; 0
    1438:	21 f0       	breq	.+8      	; 0x1442 <vCoRoutineSchedule+0x1a8>
				{
					uxListRemove( &( pxCRCB->xEventListItem ) );
    143a:	ce 01       	movw	r24, r28
    143c:	0c 96       	adiw	r24, 0x0c	; 12
    143e:	0e 94 b3 0b 	call	0x1766	; 0x1766 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1442:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1444:	8e 89       	ldd	r24, Y+22	; 0x16
    1446:	90 91 8c 00 	lds	r25, 0x008C
    144a:	98 17       	cp	r25, r24
    144c:	10 f4       	brcc	.+4      	; 0x1452 <vCoRoutineSchedule+0x1b8>
    144e:	80 93 8c 00 	sts	0x008C, r24
    1452:	90 e0       	ldi	r25, 0x00	; 0
    1454:	9c 01       	movw	r18, r24
    1456:	22 0f       	add	r18, r18
    1458:	33 1f       	adc	r19, r19
    145a:	22 0f       	add	r18, r18
    145c:	33 1f       	adc	r19, r19
    145e:	22 0f       	add	r18, r18
    1460:	33 1f       	adc	r19, r19
    1462:	82 0f       	add	r24, r18
    1464:	93 1f       	adc	r25, r19
    1466:	83 57       	subi	r24, 0x73	; 115
    1468:	9f 4f       	sbci	r25, 0xFF	; 255
    146a:	b8 01       	movw	r22, r16
    146c:	0e 94 40 0b 	call	0x1680	; 0x1680 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1470:	e0 91 ba 00 	lds	r30, 0x00BA
    1474:	f0 91 bb 00 	lds	r31, 0x00BB
    1478:	80 81       	ld	r24, Z
    147a:	88 23       	and	r24, r24
    147c:	09 f0       	breq	.+2      	; 0x1480 <vCoRoutineSchedule+0x1e6>
    147e:	bc cf       	rjmp	.-136    	; 0x13f8 <vCoRoutineSchedule+0x15e>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1480:	80 91 c6 00 	lds	r24, 0x00C6
    1484:	90 91 c7 00 	lds	r25, 0x00C7
    1488:	a0 91 c8 00 	lds	r26, 0x00C8
    148c:	b0 91 c9 00 	lds	r27, 0x00C9
    1490:	00 97       	sbiw	r24, 0x00	; 0
    1492:	a1 05       	cpc	r26, r1
    1494:	b1 05       	cpc	r27, r1
    1496:	09 f0       	breq	.+2      	; 0x149a <vCoRoutineSchedule+0x200>
    1498:	5c cf       	rjmp	.-328    	; 0x1352 <vCoRoutineSchedule+0xb8>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    149a:	80 91 be 00 	lds	r24, 0x00BE
    149e:	90 91 bf 00 	lds	r25, 0x00BF
    14a2:	a0 91 c0 00 	lds	r26, 0x00C0
    14a6:	b0 91 c1 00 	lds	r27, 0x00C1
    14aa:	80 93 c2 00 	sts	0x00C2, r24
    14ae:	90 93 c3 00 	sts	0x00C3, r25
    14b2:	a0 93 c4 00 	sts	0x00C4, r26
    14b6:	b0 93 c5 00 	sts	0x00C5, r27

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    14ba:	20 91 8c 00 	lds	r18, 0x008C
    14be:	82 2f       	mov	r24, r18
    14c0:	90 e0       	ldi	r25, 0x00	; 0
    14c2:	fc 01       	movw	r30, r24
    14c4:	ee 0f       	add	r30, r30
    14c6:	ff 1f       	adc	r31, r31
    14c8:	ee 0f       	add	r30, r30
    14ca:	ff 1f       	adc	r31, r31
    14cc:	ee 0f       	add	r30, r30
    14ce:	ff 1f       	adc	r31, r31
    14d0:	e8 0f       	add	r30, r24
    14d2:	f9 1f       	adc	r31, r25
    14d4:	e3 57       	subi	r30, 0x73	; 115
    14d6:	ff 4f       	sbci	r31, 0xFF	; 255
    14d8:	30 81       	ld	r19, Z
    14da:	33 23       	and	r19, r19
    14dc:	d9 f4       	brne	.+54     	; 0x1514 <vCoRoutineSchedule+0x27a>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    14de:	22 23       	and	r18, r18
    14e0:	31 f4       	brne	.+12     	; 0x14ee <vCoRoutineSchedule+0x254>
    14e2:	47 c0       	rjmp	.+142    	; 0x1572 <vCoRoutineSchedule+0x2d8>
    14e4:	22 23       	and	r18, r18
    14e6:	19 f4       	brne	.+6      	; 0x14ee <vCoRoutineSchedule+0x254>
    14e8:	20 93 8c 00 	sts	0x008C, r18
    14ec:	42 c0       	rjmp	.+132    	; 0x1572 <vCoRoutineSchedule+0x2d8>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    14ee:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    14f0:	82 2f       	mov	r24, r18
    14f2:	90 e0       	ldi	r25, 0x00	; 0
    14f4:	fc 01       	movw	r30, r24
    14f6:	ee 0f       	add	r30, r30
    14f8:	ff 1f       	adc	r31, r31
    14fa:	ee 0f       	add	r30, r30
    14fc:	ff 1f       	adc	r31, r31
    14fe:	ee 0f       	add	r30, r30
    1500:	ff 1f       	adc	r31, r31
    1502:	e8 0f       	add	r30, r24
    1504:	f9 1f       	adc	r31, r25
    1506:	e3 57       	subi	r30, 0x73	; 115
    1508:	ff 4f       	sbci	r31, 0xFF	; 255
    150a:	30 81       	ld	r19, Z
    150c:	33 23       	and	r19, r19
    150e:	51 f3       	breq	.-44     	; 0x14e4 <vCoRoutineSchedule+0x24a>
    1510:	20 93 8c 00 	sts	0x008C, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1514:	fc 01       	movw	r30, r24
    1516:	ee 0f       	add	r30, r30
    1518:	ff 1f       	adc	r31, r31
    151a:	ee 0f       	add	r30, r30
    151c:	ff 1f       	adc	r31, r31
    151e:	ee 0f       	add	r30, r30
    1520:	ff 1f       	adc	r31, r31
    1522:	8e 0f       	add	r24, r30
    1524:	9f 1f       	adc	r25, r31
    1526:	fc 01       	movw	r30, r24
    1528:	e3 57       	subi	r30, 0x73	; 115
    152a:	ff 4f       	sbci	r31, 0xFF	; 255
    152c:	a1 81       	ldd	r26, Z+1	; 0x01
    152e:	b2 81       	ldd	r27, Z+2	; 0x02
    1530:	12 96       	adiw	r26, 0x02	; 2
    1532:	0d 90       	ld	r0, X+
    1534:	bc 91       	ld	r27, X
    1536:	a0 2d       	mov	r26, r0
    1538:	b2 83       	std	Z+2, r27	; 0x02
    153a:	a1 83       	std	Z+1, r26	; 0x01
    153c:	cf 01       	movw	r24, r30
    153e:	03 96       	adiw	r24, 0x03	; 3
    1540:	a8 17       	cp	r26, r24
    1542:	b9 07       	cpc	r27, r25
    1544:	31 f4       	brne	.+12     	; 0x1552 <vCoRoutineSchedule+0x2b8>
    1546:	12 96       	adiw	r26, 0x02	; 2
    1548:	8d 91       	ld	r24, X+
    154a:	9c 91       	ld	r25, X
    154c:	13 97       	sbiw	r26, 0x03	; 3
    154e:	92 83       	std	Z+2, r25	; 0x02
    1550:	81 83       	std	Z+1, r24	; 0x01
    1552:	01 80       	ldd	r0, Z+1	; 0x01
    1554:	f2 81       	ldd	r31, Z+2	; 0x02
    1556:	e0 2d       	mov	r30, r0
    1558:	a6 81       	ldd	r26, Z+6	; 0x06
    155a:	b7 81       	ldd	r27, Z+7	; 0x07
    155c:	b0 93 8b 00 	sts	0x008B, r27
    1560:	a0 93 8a 00 	sts	0x008A, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1564:	ed 91       	ld	r30, X+
    1566:	fc 91       	ld	r31, X
    1568:	11 97       	sbiw	r26, 0x01	; 1
    156a:	cd 01       	movw	r24, r26
    156c:	57 96       	adiw	r26, 0x17	; 23
    156e:	6c 91       	ld	r22, X
    1570:	09 95       	icall

	return;
}
    1572:	df 91       	pop	r29
    1574:	cf 91       	pop	r28
    1576:	1f 91       	pop	r17
    1578:	0f 91       	pop	r16
    157a:	ff 90       	pop	r15
    157c:	ef 90       	pop	r14
    157e:	df 90       	pop	r13
    1580:	cf 90       	pop	r12
    1582:	08 95       	ret

00001584 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    1584:	0f 93       	push	r16
    1586:	1f 93       	push	r17
    1588:	cf 93       	push	r28
    158a:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    158c:	dc 01       	movw	r26, r24
    158e:	15 96       	adiw	r26, 0x05	; 5
    1590:	ed 91       	ld	r30, X+
    1592:	fc 91       	ld	r31, X
    1594:	16 97       	sbiw	r26, 0x06	; 6
    1596:	06 81       	ldd	r16, Z+6	; 0x06
    1598:	17 81       	ldd	r17, Z+7	; 0x07
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    159a:	e8 01       	movw	r28, r16
    159c:	2c 96       	adiw	r28, 0x0c	; 12
    159e:	ce 01       	movw	r24, r28
    15a0:	0e 94 b3 0b 	call	0x1766	; 0x1766 <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    15a4:	81 eb       	ldi	r24, 0xB1	; 177
    15a6:	90 e0       	ldi	r25, 0x00	; 0
    15a8:	be 01       	movw	r22, r28
    15aa:	0e 94 40 0b 	call	0x1680	; 0x1680 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    15ae:	e0 91 8a 00 	lds	r30, 0x008A
    15b2:	f0 91 8b 00 	lds	r31, 0x008B
	{
		xReturn = pdTRUE;
    15b6:	81 e0       	ldi	r24, 0x01	; 1
    15b8:	d8 01       	movw	r26, r16
    15ba:	56 96       	adiw	r26, 0x16	; 22
    15bc:	2c 91       	ld	r18, X
    15be:	56 97       	sbiw	r26, 0x16	; 22
    15c0:	96 89       	ldd	r25, Z+22	; 0x16
    15c2:	29 17       	cp	r18, r25
    15c4:	08 f4       	brcc	.+2      	; 0x15c8 <xCoRoutineRemoveFromEventList+0x44>
    15c6:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    15c8:	df 91       	pop	r29
    15ca:	cf 91       	pop	r28
    15cc:	1f 91       	pop	r17
    15ce:	0f 91       	pop	r16
    15d0:	08 95       	ret

000015d2 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    15d2:	cf 93       	push	r28
    15d4:	df 93       	push	r29
    15d6:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    15d8:	0e 94 41 12 	call	0x2482	; 0x2482 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    15dc:	80 91 ca 00 	lds	r24, 0x00CA
    15e0:	90 91 cb 00 	lds	r25, 0x00CB
    15e4:	00 97       	sbiw	r24, 0x00	; 0
    15e6:	31 f4       	brne	.+12     	; 0x15f4 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    15e8:	8d ec       	ldi	r24, 0xCD	; 205
    15ea:	90 e0       	ldi	r25, 0x00	; 0
    15ec:	90 93 cb 00 	sts	0x00CB, r25
    15f0:	80 93 ca 00 	sts	0x00CA, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    15f4:	20 91 7c 05 	lds	r18, 0x057C
    15f8:	30 91 7d 05 	lds	r19, 0x057D
    15fc:	ce 01       	movw	r24, r28
    15fe:	82 0f       	add	r24, r18
    1600:	93 1f       	adc	r25, r19
    1602:	44 e0       	ldi	r20, 0x04	; 4
    1604:	8f 3a       	cpi	r24, 0xAF	; 175
    1606:	94 07       	cpc	r25, r20
    1608:	70 f4       	brcc	.+28     	; 0x1626 <pvPortMalloc+0x54>
    160a:	28 17       	cp	r18, r24
    160c:	39 07       	cpc	r19, r25
    160e:	70 f4       	brcc	.+28     	; 0x162c <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1610:	c0 91 ca 00 	lds	r28, 0x00CA
    1614:	d0 91 cb 00 	lds	r29, 0x00CB
    1618:	c2 0f       	add	r28, r18
    161a:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    161c:	90 93 7d 05 	sts	0x057D, r25
    1620:	80 93 7c 05 	sts	0x057C, r24
    1624:	05 c0       	rjmp	.+10     	; 0x1630 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
    1626:	c0 e0       	ldi	r28, 0x00	; 0
    1628:	d0 e0       	ldi	r29, 0x00	; 0
    162a:	02 c0       	rjmp	.+4      	; 0x1630 <pvPortMalloc+0x5e>
    162c:	c0 e0       	ldi	r28, 0x00	; 0
    162e:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
			xNextFreeByte += xWantedSize;
		}
	}
	xTaskResumeAll();
    1630:	0e 94 28 13 	call	0x2650	; 0x2650 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1634:	8c 2f       	mov	r24, r28
    1636:	9d 2f       	mov	r25, r29
    1638:	df 91       	pop	r29
    163a:	cf 91       	pop	r28
    163c:	08 95       	ret

0000163e <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    163e:	08 95       	ret

00001640 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1640:	10 92 7d 05 	sts	0x057D, r1
    1644:	10 92 7c 05 	sts	0x057C, r1
}
    1648:	08 95       	ret

0000164a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    164a:	20 91 7c 05 	lds	r18, 0x057C
    164e:	30 91 7d 05 	lds	r19, 0x057D
    1652:	8f ea       	ldi	r24, 0xAF	; 175
    1654:	94 e0       	ldi	r25, 0x04	; 4
    1656:	82 1b       	sub	r24, r18
    1658:	93 0b       	sbc	r25, r19
}
    165a:	08 95       	ret

0000165c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    165c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    165e:	03 96       	adiw	r24, 0x03	; 3
    1660:	92 83       	std	Z+2, r25	; 0x02
    1662:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1664:	2f ef       	ldi	r18, 0xFF	; 255
    1666:	3f ef       	ldi	r19, 0xFF	; 255
    1668:	34 83       	std	Z+4, r19	; 0x04
    166a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    166c:	96 83       	std	Z+6, r25	; 0x06
    166e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1670:	90 87       	std	Z+8, r25	; 0x08
    1672:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1674:	10 82       	st	Z, r1
}
    1676:	08 95       	ret

00001678 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1678:	fc 01       	movw	r30, r24
    167a:	11 86       	std	Z+9, r1	; 0x09
    167c:	10 86       	std	Z+8, r1	; 0x08
}
    167e:	08 95       	ret

00001680 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1680:	cf 93       	push	r28
    1682:	df 93       	push	r29
    1684:	ec 01       	movw	r28, r24
    1686:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1688:	89 81       	ldd	r24, Y+1	; 0x01
    168a:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    168c:	dc 01       	movw	r26, r24
    168e:	12 96       	adiw	r26, 0x02	; 2
    1690:	2d 91       	ld	r18, X+
    1692:	3c 91       	ld	r19, X
    1694:	13 97       	sbiw	r26, 0x03	; 3
    1696:	33 83       	std	Z+3, r19	; 0x03
    1698:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    169a:	29 81       	ldd	r18, Y+1	; 0x01
    169c:	3a 81       	ldd	r19, Y+2	; 0x02
    169e:	35 83       	std	Z+5, r19	; 0x05
    16a0:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    16a2:	12 96       	adiw	r26, 0x02	; 2
    16a4:	2d 91       	ld	r18, X+
    16a6:	3c 91       	ld	r19, X
    16a8:	13 97       	sbiw	r26, 0x03	; 3
    16aa:	d9 01       	movw	r26, r18
    16ac:	15 96       	adiw	r26, 0x05	; 5
    16ae:	7c 93       	st	X, r23
    16b0:	6e 93       	st	-X, r22
    16b2:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    16b4:	dc 01       	movw	r26, r24
    16b6:	13 96       	adiw	r26, 0x03	; 3
    16b8:	7c 93       	st	X, r23
    16ba:	6e 93       	st	-X, r22
    16bc:	12 97       	sbiw	r26, 0x02	; 2
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    16be:	7a 83       	std	Y+2, r23	; 0x02
    16c0:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    16c2:	d1 87       	std	Z+9, r29	; 0x09
    16c4:	c0 87       	std	Z+8, r28	; 0x08

	( pxList->uxNumberOfItems )++;
    16c6:	88 81       	ld	r24, Y
    16c8:	8f 5f       	subi	r24, 0xFF	; 255
    16ca:	88 83       	st	Y, r24
}
    16cc:	df 91       	pop	r29
    16ce:	cf 91       	pop	r28
    16d0:	08 95       	ret

000016d2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    16d2:	cf 93       	push	r28
    16d4:	df 93       	push	r29
    16d6:	9c 01       	movw	r18, r24
    16d8:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
uint32_t xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    16da:	48 81       	ld	r20, Y
    16dc:	59 81       	ldd	r21, Y+1	; 0x01
    16de:	60 e0       	ldi	r22, 0x00	; 0
    16e0:	70 e0       	ldi	r23, 0x00	; 0
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    16e2:	4f 3f       	cpi	r20, 0xFF	; 255
    16e4:	8f ef       	ldi	r24, 0xFF	; 255
    16e6:	58 07       	cpc	r21, r24
    16e8:	80 e0       	ldi	r24, 0x00	; 0
    16ea:	68 07       	cpc	r22, r24
    16ec:	80 e0       	ldi	r24, 0x00	; 0
    16ee:	78 07       	cpc	r23, r24
    16f0:	31 f4       	brne	.+12     	; 0x16fe <vListInsert+0x2c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    16f2:	d9 01       	movw	r26, r18
    16f4:	17 96       	adiw	r26, 0x07	; 7
    16f6:	ed 91       	ld	r30, X+
    16f8:	fc 91       	ld	r31, X
    16fa:	18 97       	sbiw	r26, 0x08	; 8
    16fc:	1f c0       	rjmp	.+62     	; 0x173c <vListInsert+0x6a>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    16fe:	f9 01       	movw	r30, r18
    1700:	33 96       	adiw	r30, 0x03	; 3
    1702:	d9 01       	movw	r26, r18
    1704:	15 96       	adiw	r26, 0x05	; 5
    1706:	8d 91       	ld	r24, X+
    1708:	9c 91       	ld	r25, X
    170a:	16 97       	sbiw	r26, 0x06	; 6
    170c:	dc 01       	movw	r26, r24
    170e:	8d 91       	ld	r24, X+
    1710:	9c 91       	ld	r25, X
    1712:	a0 e0       	ldi	r26, 0x00	; 0
    1714:	b0 e0       	ldi	r27, 0x00	; 0
    1716:	48 17       	cp	r20, r24
    1718:	59 07       	cpc	r21, r25
    171a:	6a 07       	cpc	r22, r26
    171c:	7b 07       	cpc	r23, r27
    171e:	70 f0       	brcs	.+28     	; 0x173c <vListInsert+0x6a>
    1720:	02 80       	ldd	r0, Z+2	; 0x02
    1722:	f3 81       	ldd	r31, Z+3	; 0x03
    1724:	e0 2d       	mov	r30, r0
    1726:	a2 81       	ldd	r26, Z+2	; 0x02
    1728:	b3 81       	ldd	r27, Z+3	; 0x03
    172a:	8d 91       	ld	r24, X+
    172c:	9c 91       	ld	r25, X
    172e:	a0 e0       	ldi	r26, 0x00	; 0
    1730:	b0 e0       	ldi	r27, 0x00	; 0
    1732:	48 17       	cp	r20, r24
    1734:	59 07       	cpc	r21, r25
    1736:	6a 07       	cpc	r22, r26
    1738:	7b 07       	cpc	r23, r27
    173a:	90 f7       	brcc	.-28     	; 0x1720 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    173c:	a2 81       	ldd	r26, Z+2	; 0x02
    173e:	b3 81       	ldd	r27, Z+3	; 0x03
    1740:	bb 83       	std	Y+3, r27	; 0x03
    1742:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1744:	15 96       	adiw	r26, 0x05	; 5
    1746:	dc 93       	st	X, r29
    1748:	ce 93       	st	-X, r28
    174a:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
    174c:	fd 83       	std	Y+5, r31	; 0x05
    174e:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1750:	d3 83       	std	Z+3, r29	; 0x03
    1752:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1754:	39 87       	std	Y+9, r19	; 0x09
    1756:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1758:	f9 01       	movw	r30, r18
    175a:	80 81       	ld	r24, Z
    175c:	8f 5f       	subi	r24, 0xFF	; 255
    175e:	80 83       	st	Z, r24
}
    1760:	df 91       	pop	r29
    1762:	cf 91       	pop	r28
    1764:	08 95       	ret

00001766 <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
    1766:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1768:	a2 81       	ldd	r26, Z+2	; 0x02
    176a:	b3 81       	ldd	r27, Z+3	; 0x03
    176c:	84 81       	ldd	r24, Z+4	; 0x04
    176e:	95 81       	ldd	r25, Z+5	; 0x05
    1770:	15 96       	adiw	r26, 0x05	; 5
    1772:	9c 93       	st	X, r25
    1774:	8e 93       	st	-X, r24
    1776:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1778:	a4 81       	ldd	r26, Z+4	; 0x04
    177a:	b5 81       	ldd	r27, Z+5	; 0x05
    177c:	82 81       	ldd	r24, Z+2	; 0x02
    177e:	93 81       	ldd	r25, Z+3	; 0x03
    1780:	13 96       	adiw	r26, 0x03	; 3
    1782:	9c 93       	st	X, r25
    1784:	8e 93       	st	-X, r24
    1786:	12 97       	sbiw	r26, 0x02	; 2

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1788:	a0 85       	ldd	r26, Z+8	; 0x08
    178a:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    178c:	11 96       	adiw	r26, 0x01	; 1
    178e:	8d 91       	ld	r24, X+
    1790:	9c 91       	ld	r25, X
    1792:	12 97       	sbiw	r26, 0x02	; 2
    1794:	8e 17       	cp	r24, r30
    1796:	9f 07       	cpc	r25, r31
    1798:	31 f4       	brne	.+12     	; 0x17a6 <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    179a:	84 81       	ldd	r24, Z+4	; 0x04
    179c:	95 81       	ldd	r25, Z+5	; 0x05
    179e:	12 96       	adiw	r26, 0x02	; 2
    17a0:	9c 93       	st	X, r25
    17a2:	8e 93       	st	-X, r24
    17a4:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    17a6:	11 86       	std	Z+9, r1	; 0x09
    17a8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    17aa:	8c 91       	ld	r24, X
    17ac:	81 50       	subi	r24, 0x01	; 1
    17ae:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    17b0:	8c 91       	ld	r24, X
}
    17b2:	08 95       	ret

000017b4 <pxPortInitialiseStack>:
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    17b4:	21 e1       	ldi	r18, 0x11	; 17
    17b6:	fc 01       	movw	r30, r24
    17b8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    17ba:	31 97       	sbiw	r30, 0x01	; 1
    17bc:	32 e2       	ldi	r19, 0x22	; 34
    17be:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    17c0:	fc 01       	movw	r30, r24
    17c2:	32 97       	sbiw	r30, 0x02	; 2
    17c4:	a3 e3       	ldi	r26, 0x33	; 51
    17c6:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    17c8:	fc 01       	movw	r30, r24
    17ca:	33 97       	sbiw	r30, 0x03	; 3
    17cc:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    17ce:	fc 01       	movw	r30, r24
    17d0:	34 97       	sbiw	r30, 0x04	; 4
    17d2:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    17d4:	fc 01       	movw	r30, r24
    17d6:	35 97       	sbiw	r30, 0x05	; 5
    17d8:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    17da:	fc 01       	movw	r30, r24
    17dc:	36 97       	sbiw	r30, 0x06	; 6
    17de:	60 e8       	ldi	r22, 0x80	; 128
    17e0:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    17e2:	fc 01       	movw	r30, r24
    17e4:	37 97       	sbiw	r30, 0x07	; 7
    17e6:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    17e8:	fc 01       	movw	r30, r24
    17ea:	38 97       	sbiw	r30, 0x08	; 8
    17ec:	62 e0       	ldi	r22, 0x02	; 2
    17ee:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    17f0:	fc 01       	movw	r30, r24
    17f2:	39 97       	sbiw	r30, 0x09	; 9
    17f4:	63 e0       	ldi	r22, 0x03	; 3
    17f6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    17f8:	fc 01       	movw	r30, r24
    17fa:	3a 97       	sbiw	r30, 0x0a	; 10
    17fc:	64 e0       	ldi	r22, 0x04	; 4
    17fe:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1800:	fc 01       	movw	r30, r24
    1802:	3b 97       	sbiw	r30, 0x0b	; 11
    1804:	65 e0       	ldi	r22, 0x05	; 5
    1806:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    1808:	fc 01       	movw	r30, r24
    180a:	3c 97       	sbiw	r30, 0x0c	; 12
    180c:	66 e0       	ldi	r22, 0x06	; 6
    180e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    1810:	fc 01       	movw	r30, r24
    1812:	3d 97       	sbiw	r30, 0x0d	; 13
    1814:	67 e0       	ldi	r22, 0x07	; 7
    1816:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1818:	fc 01       	movw	r30, r24
    181a:	3e 97       	sbiw	r30, 0x0e	; 14
    181c:	68 e0       	ldi	r22, 0x08	; 8
    181e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1820:	fc 01       	movw	r30, r24
    1822:	3f 97       	sbiw	r30, 0x0f	; 15
    1824:	69 e0       	ldi	r22, 0x09	; 9
    1826:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1828:	fc 01       	movw	r30, r24
    182a:	70 97       	sbiw	r30, 0x10	; 16
    182c:	60 e1       	ldi	r22, 0x10	; 16
    182e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1830:	fc 01       	movw	r30, r24
    1832:	71 97       	sbiw	r30, 0x11	; 17
    1834:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1836:	fc 01       	movw	r30, r24
    1838:	72 97       	sbiw	r30, 0x12	; 18
    183a:	22 e1       	ldi	r18, 0x12	; 18
    183c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    183e:	fc 01       	movw	r30, r24
    1840:	73 97       	sbiw	r30, 0x13	; 19
    1842:	23 e1       	ldi	r18, 0x13	; 19
    1844:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1846:	fc 01       	movw	r30, r24
    1848:	74 97       	sbiw	r30, 0x14	; 20
    184a:	24 e1       	ldi	r18, 0x14	; 20
    184c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    184e:	fc 01       	movw	r30, r24
    1850:	75 97       	sbiw	r30, 0x15	; 21
    1852:	25 e1       	ldi	r18, 0x15	; 21
    1854:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1856:	fc 01       	movw	r30, r24
    1858:	76 97       	sbiw	r30, 0x16	; 22
    185a:	26 e1       	ldi	r18, 0x16	; 22
    185c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    185e:	fc 01       	movw	r30, r24
    1860:	77 97       	sbiw	r30, 0x17	; 23
    1862:	27 e1       	ldi	r18, 0x17	; 23
    1864:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1866:	fc 01       	movw	r30, r24
    1868:	78 97       	sbiw	r30, 0x18	; 24
    186a:	28 e1       	ldi	r18, 0x18	; 24
    186c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    186e:	fc 01       	movw	r30, r24
    1870:	79 97       	sbiw	r30, 0x19	; 25
    1872:	29 e1       	ldi	r18, 0x19	; 25
    1874:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1876:	fc 01       	movw	r30, r24
    1878:	7a 97       	sbiw	r30, 0x1a	; 26
    187a:	20 e2       	ldi	r18, 0x20	; 32
    187c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    187e:	fc 01       	movw	r30, r24
    1880:	7b 97       	sbiw	r30, 0x1b	; 27
    1882:	21 e2       	ldi	r18, 0x21	; 33
    1884:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    1886:	fc 01       	movw	r30, r24
    1888:	7c 97       	sbiw	r30, 0x1c	; 28
    188a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    188c:	fc 01       	movw	r30, r24
    188e:	7d 97       	sbiw	r30, 0x1d	; 29
    1890:	23 e2       	ldi	r18, 0x23	; 35
    1892:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1894:	fc 01       	movw	r30, r24
    1896:	7e 97       	sbiw	r30, 0x1e	; 30
    1898:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    189a:	fc 01       	movw	r30, r24
    189c:	7f 97       	sbiw	r30, 0x1f	; 31
    189e:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    18a0:	fc 01       	movw	r30, r24
    18a2:	b0 97       	sbiw	r30, 0x20	; 32
    18a4:	26 e2       	ldi	r18, 0x26	; 38
    18a6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    18a8:	fc 01       	movw	r30, r24
    18aa:	b1 97       	sbiw	r30, 0x21	; 33
    18ac:	27 e2       	ldi	r18, 0x27	; 39
    18ae:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    18b0:	fc 01       	movw	r30, r24
    18b2:	b2 97       	sbiw	r30, 0x22	; 34
    18b4:	28 e2       	ldi	r18, 0x28	; 40
    18b6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    18b8:	fc 01       	movw	r30, r24
    18ba:	b3 97       	sbiw	r30, 0x23	; 35
    18bc:	29 e2       	ldi	r18, 0x29	; 41
    18be:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    18c0:	fc 01       	movw	r30, r24
    18c2:	b4 97       	sbiw	r30, 0x24	; 36
    18c4:	20 e3       	ldi	r18, 0x30	; 48
    18c6:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    18c8:	fc 01       	movw	r30, r24
    18ca:	b5 97       	sbiw	r30, 0x25	; 37
    18cc:	21 e3       	ldi	r18, 0x31	; 49
    18ce:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    18d0:	86 97       	sbiw	r24, 0x26	; 38
}
    18d2:	08 95       	ret

000018d4 <xPortStartScheduler>:
	//ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	//ulCompareMatch >>= 8;
	//ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	//OCR1AH = ucHighByte;
	//OCR1AL = ucLowByte;
    OCR0 = ulCompareMatch; 
    18d4:	8d e7       	ldi	r24, 0x7D	; 125
    18d6:	8c bf       	out	0x3c, r24	; 60
	/* Setup clock source and compare match behaviour. */
	//MOD: atmega32A
	//ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	//TCCR1B = ucLowByte;
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR0 = ucLowByte;
    18d8:	8b e0       	ldi	r24, 0x0B	; 11
    18da:	83 bf       	out	0x33, r24	; 51
	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	//MOD: atmega32A
	//ucLowByte = TIMSK;
	//-> enable Timer1 Output Compare A
	ucLowByte = TIMSK;
    18dc:	89 b7       	in	r24, 0x39	; 57
	
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    18de:	82 60       	ori	r24, 0x02	; 2
	
	//MOD: atmega1284p
	//TIMSK = ucLowByte;
	TIMSK = ucLowByte;
    18e0:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    18e2:	a0 91 7e 05 	lds	r26, 0x057E
    18e6:	b0 91 7f 05 	lds	r27, 0x057F
    18ea:	cd 91       	ld	r28, X+
    18ec:	cd bf       	out	0x3d, r28	; 61
    18ee:	dd 91       	ld	r29, X+
    18f0:	de bf       	out	0x3e, r29	; 62
    18f2:	ff 91       	pop	r31
    18f4:	ef 91       	pop	r30
    18f6:	df 91       	pop	r29
    18f8:	cf 91       	pop	r28
    18fa:	bf 91       	pop	r27
    18fc:	af 91       	pop	r26
    18fe:	9f 91       	pop	r25
    1900:	8f 91       	pop	r24
    1902:	7f 91       	pop	r23
    1904:	6f 91       	pop	r22
    1906:	5f 91       	pop	r21
    1908:	4f 91       	pop	r20
    190a:	3f 91       	pop	r19
    190c:	2f 91       	pop	r18
    190e:	1f 91       	pop	r17
    1910:	0f 91       	pop	r16
    1912:	ff 90       	pop	r15
    1914:	ef 90       	pop	r14
    1916:	df 90       	pop	r13
    1918:	cf 90       	pop	r12
    191a:	bf 90       	pop	r11
    191c:	af 90       	pop	r10
    191e:	9f 90       	pop	r9
    1920:	8f 90       	pop	r8
    1922:	7f 90       	pop	r7
    1924:	6f 90       	pop	r6
    1926:	5f 90       	pop	r5
    1928:	4f 90       	pop	r4
    192a:	3f 90       	pop	r3
    192c:	2f 90       	pop	r2
    192e:	1f 90       	pop	r1
    1930:	0f 90       	pop	r0
    1932:	0f be       	out	0x3f, r0	; 63
    1934:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1936:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1938:	81 e0       	ldi	r24, 0x01	; 1
    193a:	08 95       	ret

0000193c <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    193c:	08 95       	ret

0000193e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    193e:	0f 92       	push	r0
    1940:	0f b6       	in	r0, 0x3f	; 63
    1942:	f8 94       	cli
    1944:	0f 92       	push	r0
    1946:	1f 92       	push	r1
    1948:	11 24       	eor	r1, r1
    194a:	2f 92       	push	r2
    194c:	3f 92       	push	r3
    194e:	4f 92       	push	r4
    1950:	5f 92       	push	r5
    1952:	6f 92       	push	r6
    1954:	7f 92       	push	r7
    1956:	8f 92       	push	r8
    1958:	9f 92       	push	r9
    195a:	af 92       	push	r10
    195c:	bf 92       	push	r11
    195e:	cf 92       	push	r12
    1960:	df 92       	push	r13
    1962:	ef 92       	push	r14
    1964:	ff 92       	push	r15
    1966:	0f 93       	push	r16
    1968:	1f 93       	push	r17
    196a:	2f 93       	push	r18
    196c:	3f 93       	push	r19
    196e:	4f 93       	push	r20
    1970:	5f 93       	push	r21
    1972:	6f 93       	push	r22
    1974:	7f 93       	push	r23
    1976:	8f 93       	push	r24
    1978:	9f 93       	push	r25
    197a:	af 93       	push	r26
    197c:	bf 93       	push	r27
    197e:	cf 93       	push	r28
    1980:	df 93       	push	r29
    1982:	ef 93       	push	r30
    1984:	ff 93       	push	r31
    1986:	a0 91 7e 05 	lds	r26, 0x057E
    198a:	b0 91 7f 05 	lds	r27, 0x057F
    198e:	0d b6       	in	r0, 0x3d	; 61
    1990:	0d 92       	st	X+, r0
    1992:	0e b6       	in	r0, 0x3e	; 62
    1994:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1996:	0e 94 6e 14 	call	0x28dc	; 0x28dc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    199a:	a0 91 7e 05 	lds	r26, 0x057E
    199e:	b0 91 7f 05 	lds	r27, 0x057F
    19a2:	cd 91       	ld	r28, X+
    19a4:	cd bf       	out	0x3d, r28	; 61
    19a6:	dd 91       	ld	r29, X+
    19a8:	de bf       	out	0x3e, r29	; 62
    19aa:	ff 91       	pop	r31
    19ac:	ef 91       	pop	r30
    19ae:	df 91       	pop	r29
    19b0:	cf 91       	pop	r28
    19b2:	bf 91       	pop	r27
    19b4:	af 91       	pop	r26
    19b6:	9f 91       	pop	r25
    19b8:	8f 91       	pop	r24
    19ba:	7f 91       	pop	r23
    19bc:	6f 91       	pop	r22
    19be:	5f 91       	pop	r21
    19c0:	4f 91       	pop	r20
    19c2:	3f 91       	pop	r19
    19c4:	2f 91       	pop	r18
    19c6:	1f 91       	pop	r17
    19c8:	0f 91       	pop	r16
    19ca:	ff 90       	pop	r15
    19cc:	ef 90       	pop	r14
    19ce:	df 90       	pop	r13
    19d0:	cf 90       	pop	r12
    19d2:	bf 90       	pop	r11
    19d4:	af 90       	pop	r10
    19d6:	9f 90       	pop	r9
    19d8:	8f 90       	pop	r8
    19da:	7f 90       	pop	r7
    19dc:	6f 90       	pop	r6
    19de:	5f 90       	pop	r5
    19e0:	4f 90       	pop	r4
    19e2:	3f 90       	pop	r3
    19e4:	2f 90       	pop	r2
    19e6:	1f 90       	pop	r1
    19e8:	0f 90       	pop	r0
    19ea:	0f be       	out	0x3f, r0	; 63
    19ec:	0f 90       	pop	r0

	asm volatile ( "ret" );
    19ee:	08 95       	ret

000019f0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    19f0:	0f 92       	push	r0
    19f2:	0f b6       	in	r0, 0x3f	; 63
    19f4:	f8 94       	cli
    19f6:	0f 92       	push	r0
    19f8:	1f 92       	push	r1
    19fa:	11 24       	eor	r1, r1
    19fc:	2f 92       	push	r2
    19fe:	3f 92       	push	r3
    1a00:	4f 92       	push	r4
    1a02:	5f 92       	push	r5
    1a04:	6f 92       	push	r6
    1a06:	7f 92       	push	r7
    1a08:	8f 92       	push	r8
    1a0a:	9f 92       	push	r9
    1a0c:	af 92       	push	r10
    1a0e:	bf 92       	push	r11
    1a10:	cf 92       	push	r12
    1a12:	df 92       	push	r13
    1a14:	ef 92       	push	r14
    1a16:	ff 92       	push	r15
    1a18:	0f 93       	push	r16
    1a1a:	1f 93       	push	r17
    1a1c:	2f 93       	push	r18
    1a1e:	3f 93       	push	r19
    1a20:	4f 93       	push	r20
    1a22:	5f 93       	push	r21
    1a24:	6f 93       	push	r22
    1a26:	7f 93       	push	r23
    1a28:	8f 93       	push	r24
    1a2a:	9f 93       	push	r25
    1a2c:	af 93       	push	r26
    1a2e:	bf 93       	push	r27
    1a30:	cf 93       	push	r28
    1a32:	df 93       	push	r29
    1a34:	ef 93       	push	r30
    1a36:	ff 93       	push	r31
    1a38:	a0 91 7e 05 	lds	r26, 0x057E
    1a3c:	b0 91 7f 05 	lds	r27, 0x057F
    1a40:	0d b6       	in	r0, 0x3d	; 61
    1a42:	0d 92       	st	X+, r0
    1a44:	0e b6       	in	r0, 0x3e	; 62
    1a46:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1a48:	0e 94 59 12 	call	0x24b2	; 0x24b2 <vTaskIncrementTick>
	vTaskSwitchContext();
    1a4c:	0e 94 6e 14 	call	0x28dc	; 0x28dc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1a50:	a0 91 7e 05 	lds	r26, 0x057E
    1a54:	b0 91 7f 05 	lds	r27, 0x057F
    1a58:	cd 91       	ld	r28, X+
    1a5a:	cd bf       	out	0x3d, r28	; 61
    1a5c:	dd 91       	ld	r29, X+
    1a5e:	de bf       	out	0x3e, r29	; 62
    1a60:	ff 91       	pop	r31
    1a62:	ef 91       	pop	r30
    1a64:	df 91       	pop	r29
    1a66:	cf 91       	pop	r28
    1a68:	bf 91       	pop	r27
    1a6a:	af 91       	pop	r26
    1a6c:	9f 91       	pop	r25
    1a6e:	8f 91       	pop	r24
    1a70:	7f 91       	pop	r23
    1a72:	6f 91       	pop	r22
    1a74:	5f 91       	pop	r21
    1a76:	4f 91       	pop	r20
    1a78:	3f 91       	pop	r19
    1a7a:	2f 91       	pop	r18
    1a7c:	1f 91       	pop	r17
    1a7e:	0f 91       	pop	r16
    1a80:	ff 90       	pop	r15
    1a82:	ef 90       	pop	r14
    1a84:	df 90       	pop	r13
    1a86:	cf 90       	pop	r12
    1a88:	bf 90       	pop	r11
    1a8a:	af 90       	pop	r10
    1a8c:	9f 90       	pop	r9
    1a8e:	8f 90       	pop	r8
    1a90:	7f 90       	pop	r7
    1a92:	6f 90       	pop	r6
    1a94:	5f 90       	pop	r5
    1a96:	4f 90       	pop	r4
    1a98:	3f 90       	pop	r3
    1a9a:	2f 90       	pop	r2
    1a9c:	1f 90       	pop	r1
    1a9e:	0f 90       	pop	r0
    1aa0:	0f be       	out	0x3f, r0	; 63
    1aa2:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1aa4:	08 95       	ret

00001aa6 <__vector_10>:
	//ISR (TIMER1_COMPA_vect)
	ISR (TIMER0_COMP_vect) __attribute__ ( ( signal, naked ) );
	ISR (TIMER0_COMP_vect)    
	{
        //PORTB ^= (1<<PB0);
		vPortYieldFromTick();
    1aa6:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1aaa:	18 95       	reti

00001aac <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    1aac:	cf 93       	push	r28
    1aae:	df 93       	push	r29
    1ab0:	dc 01       	movw	r26, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    1ab2:	cd 91       	ld	r28, X+
    1ab4:	dc 91       	ld	r29, X
    1ab6:	11 97       	sbiw	r26, 0x01	; 1
    1ab8:	20 97       	sbiw	r28, 0x00	; 0
    1aba:	21 f1       	breq	.+72     	; 0x1b04 <prvCopyDataFromQueue+0x58>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1abc:	5c 96       	adiw	r26, 0x1c	; 28
    1abe:	4c 91       	ld	r20, X
    1ac0:	5c 97       	sbiw	r26, 0x1c	; 28
    1ac2:	16 96       	adiw	r26, 0x06	; 6
    1ac4:	2d 91       	ld	r18, X+
    1ac6:	3c 91       	ld	r19, X
    1ac8:	17 97       	sbiw	r26, 0x07	; 7
    1aca:	24 0f       	add	r18, r20
    1acc:	31 1d       	adc	r19, r1
    1ace:	17 96       	adiw	r26, 0x07	; 7
    1ad0:	3c 93       	st	X, r19
    1ad2:	2e 93       	st	-X, r18
    1ad4:	16 97       	sbiw	r26, 0x06	; 6
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1ad6:	12 96       	adiw	r26, 0x02	; 2
    1ad8:	ed 91       	ld	r30, X+
    1ada:	fc 91       	ld	r31, X
    1adc:	13 97       	sbiw	r26, 0x03	; 3
    1ade:	2e 17       	cp	r18, r30
    1ae0:	3f 07       	cpc	r19, r31
    1ae2:	20 f0       	brcs	.+8      	; 0x1aec <prvCopyDataFromQueue+0x40>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    1ae4:	17 96       	adiw	r26, 0x07	; 7
    1ae6:	dc 93       	st	X, r29
    1ae8:	ce 93       	st	-X, r28
    1aea:	16 97       	sbiw	r26, 0x06	; 6
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1aec:	16 96       	adiw	r26, 0x06	; 6
    1aee:	3c 91       	ld	r19, X
    1af0:	16 97       	sbiw	r26, 0x06	; 6
    1af2:	17 96       	adiw	r26, 0x07	; 7
    1af4:	2c 91       	ld	r18, X
    1af6:	86 2f       	mov	r24, r22
    1af8:	97 2f       	mov	r25, r23
    1afa:	63 2f       	mov	r22, r19
    1afc:	72 2f       	mov	r23, r18
    1afe:	50 e0       	ldi	r21, 0x00	; 0
    1b00:	0e 94 c2 1a 	call	0x3584	; 0x3584 <memcpy>
	}
}
    1b04:	df 91       	pop	r29
    1b06:	cf 91       	pop	r28
    1b08:	08 95       	ret

00001b0a <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1b0a:	cf 93       	push	r28
    1b0c:	df 93       	push	r29
    1b0e:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1b10:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1b12:	22 23       	and	r18, r18
    1b14:	a9 f1       	breq	.+106    	; 0x1b80 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    1b16:	44 23       	and	r20, r20
    1b18:	b9 f4       	brne	.+46     	; 0x1b48 <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1b1a:	8c 81       	ldd	r24, Y+4	; 0x04
    1b1c:	9d 81       	ldd	r25, Y+5	; 0x05
    1b1e:	42 2f       	mov	r20, r18
    1b20:	50 e0       	ldi	r21, 0x00	; 0
    1b22:	0e 94 c2 1a 	call	0x3584	; 0x3584 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    1b26:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1b28:	8c 81       	ldd	r24, Y+4	; 0x04
    1b2a:	9d 81       	ldd	r25, Y+5	; 0x05
    1b2c:	82 0f       	add	r24, r18
    1b2e:	91 1d       	adc	r25, r1
    1b30:	9d 83       	std	Y+5, r25	; 0x05
    1b32:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    1b34:	2a 81       	ldd	r18, Y+2	; 0x02
    1b36:	3b 81       	ldd	r19, Y+3	; 0x03
    1b38:	82 17       	cp	r24, r18
    1b3a:	93 07       	cpc	r25, r19
    1b3c:	08 f1       	brcs	.+66     	; 0x1b80 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    1b3e:	88 81       	ld	r24, Y
    1b40:	99 81       	ldd	r25, Y+1	; 0x01
    1b42:	9d 83       	std	Y+5, r25	; 0x05
    1b44:	8c 83       	std	Y+4, r24	; 0x04
    1b46:	1c c0       	rjmp	.+56     	; 0x1b80 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1b48:	8e 81       	ldd	r24, Y+6	; 0x06
    1b4a:	9f 81       	ldd	r25, Y+7	; 0x07
    1b4c:	42 2f       	mov	r20, r18
    1b4e:	50 e0       	ldi	r21, 0x00	; 0
    1b50:	0e 94 c2 1a 	call	0x3584	; 0x3584 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    1b54:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1b56:	50 e0       	ldi	r21, 0x00	; 0
    1b58:	50 95       	com	r21
    1b5a:	41 95       	neg	r20
    1b5c:	5f 4f       	sbci	r21, 0xFF	; 255
    1b5e:	8e 81       	ldd	r24, Y+6	; 0x06
    1b60:	9f 81       	ldd	r25, Y+7	; 0x07
    1b62:	84 0f       	add	r24, r20
    1b64:	95 1f       	adc	r25, r21
    1b66:	9f 83       	std	Y+7, r25	; 0x07
    1b68:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    1b6a:	28 81       	ld	r18, Y
    1b6c:	39 81       	ldd	r19, Y+1	; 0x01
    1b6e:	82 17       	cp	r24, r18
    1b70:	93 07       	cpc	r25, r19
    1b72:	30 f4       	brcc	.+12     	; 0x1b80 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    1b74:	8a 81       	ldd	r24, Y+2	; 0x02
    1b76:	9b 81       	ldd	r25, Y+3	; 0x03
    1b78:	48 0f       	add	r20, r24
    1b7a:	59 1f       	adc	r21, r25
    1b7c:	5f 83       	std	Y+7, r21	; 0x07
    1b7e:	4e 83       	std	Y+6, r20	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    1b80:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1b82:	8f 5f       	subi	r24, 0xFF	; 255
    1b84:	8a 8f       	std	Y+26, r24	; 0x1a
}
    1b86:	df 91       	pop	r29
    1b88:	cf 91       	pop	r28
    1b8a:	08 95       	ret

00001b8c <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQUEUE *pxQueue )
{
    1b8c:	0f 93       	push	r16
    1b8e:	1f 93       	push	r17
    1b90:	cf 93       	push	r28
    1b92:	df 93       	push	r29
    1b94:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1b96:	0f b6       	in	r0, 0x3f	; 63
    1b98:	f8 94       	cli
    1b9a:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1b9c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1b9e:	18 16       	cp	r1, r24
    1ba0:	c4 f4       	brge	.+48     	; 0x1bd2 <prvUnlockQueue+0x46>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ba2:	89 89       	ldd	r24, Y+17	; 0x11
    1ba4:	88 23       	and	r24, r24
    1ba6:	29 f4       	brne	.+10     	; 0x1bb2 <prvUnlockQueue+0x26>
    1ba8:	14 c0       	rjmp	.+40     	; 0x1bd2 <prvUnlockQueue+0x46>
    1baa:	89 89       	ldd	r24, Y+17	; 0x11
    1bac:	88 23       	and	r24, r24
    1bae:	21 f4       	brne	.+8      	; 0x1bb8 <prvUnlockQueue+0x2c>
    1bb0:	10 c0       	rjmp	.+32     	; 0x1bd2 <prvUnlockQueue+0x46>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1bb2:	8e 01       	movw	r16, r28
    1bb4:	0f 5e       	subi	r16, 0xEF	; 239
    1bb6:	1f 4f       	sbci	r17, 0xFF	; 255
    1bb8:	c8 01       	movw	r24, r16
    1bba:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <xTaskRemoveFromEventList>
    1bbe:	88 23       	and	r24, r24
    1bc0:	11 f0       	breq	.+4      	; 0x1bc6 <prvUnlockQueue+0x3a>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    1bc2:	0e 94 75 15 	call	0x2aea	; 0x2aea <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    1bc6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1bc8:	81 50       	subi	r24, 0x01	; 1
    1bca:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1bcc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1bce:	18 16       	cp	r1, r24
    1bd0:	64 f3       	brlt	.-40     	; 0x1baa <prvUnlockQueue+0x1e>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1bd2:	8f ef       	ldi	r24, 0xFF	; 255
    1bd4:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    1bd6:	0f 90       	pop	r0
    1bd8:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    1bda:	0f b6       	in	r0, 0x3f	; 63
    1bdc:	f8 94       	cli
    1bde:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1be0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1be2:	18 16       	cp	r1, r24
    1be4:	c4 f4       	brge	.+48     	; 0x1c16 <prvUnlockQueue+0x8a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1be6:	88 85       	ldd	r24, Y+8	; 0x08
    1be8:	88 23       	and	r24, r24
    1bea:	29 f4       	brne	.+10     	; 0x1bf6 <prvUnlockQueue+0x6a>
    1bec:	14 c0       	rjmp	.+40     	; 0x1c16 <prvUnlockQueue+0x8a>
    1bee:	88 85       	ldd	r24, Y+8	; 0x08
    1bf0:	88 23       	and	r24, r24
    1bf2:	21 f4       	brne	.+8      	; 0x1bfc <prvUnlockQueue+0x70>
    1bf4:	10 c0       	rjmp	.+32     	; 0x1c16 <prvUnlockQueue+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1bf6:	8e 01       	movw	r16, r28
    1bf8:	08 5f       	subi	r16, 0xF8	; 248
    1bfa:	1f 4f       	sbci	r17, 0xFF	; 255
    1bfc:	c8 01       	movw	r24, r16
    1bfe:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <xTaskRemoveFromEventList>
    1c02:	88 23       	and	r24, r24
    1c04:	11 f0       	breq	.+4      	; 0x1c0a <prvUnlockQueue+0x7e>
				{
					vTaskMissedYield();
    1c06:	0e 94 75 15 	call	0x2aea	; 0x2aea <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1c0a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1c0c:	81 50       	subi	r24, 0x01	; 1
    1c0e:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    1c10:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1c12:	18 16       	cp	r1, r24
    1c14:	64 f3       	brlt	.-40     	; 0x1bee <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1c16:	8f ef       	ldi	r24, 0xFF	; 255
    1c18:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1c1a:	0f 90       	pop	r0
    1c1c:	0f be       	out	0x3f, r0	; 63
}
    1c1e:	df 91       	pop	r29
    1c20:	cf 91       	pop	r28
    1c22:	1f 91       	pop	r17
    1c24:	0f 91       	pop	r16
    1c26:	08 95       	ret

00001c28 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
    1c28:	cf 93       	push	r28
    1c2a:	df 93       	push	r29
    1c2c:	ec 01       	movw	r28, r24
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1c2e:	0f b6       	in	r0, 0x3f	; 63
    1c30:	f8 94       	cli
    1c32:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1c34:	48 81       	ld	r20, Y
    1c36:	59 81       	ldd	r21, Y+1	; 0x01
    1c38:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1c3a:	30 e0       	ldi	r19, 0x00	; 0
    1c3c:	ec 8d       	ldd	r30, Y+28	; 0x1c
    1c3e:	f0 e0       	ldi	r31, 0x00	; 0
    1c40:	2e 9f       	mul	r18, r30
    1c42:	c0 01       	movw	r24, r0
    1c44:	2f 9f       	mul	r18, r31
    1c46:	90 0d       	add	r25, r0
    1c48:	3e 9f       	mul	r19, r30
    1c4a:	90 0d       	add	r25, r0
    1c4c:	11 24       	eor	r1, r1
    1c4e:	84 0f       	add	r24, r20
    1c50:	95 1f       	adc	r25, r21
    1c52:	9b 83       	std	Y+3, r25	; 0x03
    1c54:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1c56:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1c58:	5d 83       	std	Y+5, r21	; 0x05
    1c5a:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    1c5c:	c9 01       	movw	r24, r18
    1c5e:	01 97       	sbiw	r24, 0x01	; 1
    1c60:	e8 9f       	mul	r30, r24
    1c62:	90 01       	movw	r18, r0
    1c64:	e9 9f       	mul	r30, r25
    1c66:	30 0d       	add	r19, r0
    1c68:	f8 9f       	mul	r31, r24
    1c6a:	30 0d       	add	r19, r0
    1c6c:	11 24       	eor	r1, r1
    1c6e:	24 0f       	add	r18, r20
    1c70:	35 1f       	adc	r19, r21
    1c72:	3f 83       	std	Y+7, r19	; 0x07
    1c74:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    1c76:	8f ef       	ldi	r24, 0xFF	; 255
    1c78:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1c7a:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1c7c:	66 23       	and	r22, r22
    1c7e:	61 f4       	brne	.+24     	; 0x1c98 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1c80:	88 85       	ldd	r24, Y+8	; 0x08
    1c82:	88 23       	and	r24, r24
    1c84:	89 f0       	breq	.+34     	; 0x1ca8 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1c86:	ce 01       	movw	r24, r28
    1c88:	08 96       	adiw	r24, 0x08	; 8
    1c8a:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <xTaskRemoveFromEventList>
    1c8e:	81 30       	cpi	r24, 0x01	; 1
    1c90:	59 f4       	brne	.+22     	; 0x1ca8 <xQueueGenericReset+0x80>
				{
					portYIELD_WITHIN_API();
    1c92:	0e 94 9f 0c 	call	0x193e	; 0x193e <vPortYield>
    1c96:	08 c0       	rjmp	.+16     	; 0x1ca8 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1c98:	ce 01       	movw	r24, r28
    1c9a:	08 96       	adiw	r24, 0x08	; 8
    1c9c:	0e 94 2e 0b 	call	0x165c	; 0x165c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1ca0:	ce 01       	movw	r24, r28
    1ca2:	41 96       	adiw	r24, 0x11	; 17
    1ca4:	0e 94 2e 0b 	call	0x165c	; 0x165c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1ca8:	0f 90       	pop	r0
    1caa:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1cac:	81 e0       	ldi	r24, 0x01	; 1
    1cae:	df 91       	pop	r29
    1cb0:	cf 91       	pop	r28
    1cb2:	08 95       	ret

00001cb4 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    1cb4:	0f 93       	push	r16
    1cb6:	1f 93       	push	r17
    1cb8:	cf 93       	push	r28
    1cba:	df 93       	push	r29
    1cbc:	18 2f       	mov	r17, r24
    1cbe:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1cc0:	88 23       	and	r24, r24
    1cc2:	f9 f0       	breq	.+62     	; 0x1d02 <xQueueGenericCreate+0x4e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1cc4:	8f e1       	ldi	r24, 0x1F	; 31
    1cc6:	90 e0       	ldi	r25, 0x00	; 0
    1cc8:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <pvPortMalloc>
    1ccc:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    1cce:	00 97       	sbiw	r24, 0x00	; 0
    1cd0:	d9 f0       	breq	.+54     	; 0x1d08 <xQueueGenericCreate+0x54>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1cd2:	01 9f       	mul	r16, r17
    1cd4:	c0 01       	movw	r24, r0
    1cd6:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1cd8:	01 96       	adiw	r24, 0x01	; 1
    1cda:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <pvPortMalloc>
    1cde:	99 83       	std	Y+1, r25	; 0x01
    1ce0:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    1ce2:	00 97       	sbiw	r24, 0x00	; 0
    1ce4:	41 f0       	breq	.+16     	; 0x1cf6 <xQueueGenericCreate+0x42>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    1ce6:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1ce8:	0c 8f       	std	Y+28, r16	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
    1cea:	ce 01       	movw	r24, r28
    1cec:	61 e0       	ldi	r22, 0x01	; 1
    1cee:	0e 94 14 0e 	call	0x1c28	; 0x1c28 <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1cf2:	ce 01       	movw	r24, r28
    1cf4:	0b c0       	rjmp	.+22     	; 0x1d0c <xQueueGenericCreate+0x58>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    1cf6:	ce 01       	movw	r24, r28
    1cf8:	0e 94 1f 0b 	call	0x163e	; 0x163e <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1cfc:	80 e0       	ldi	r24, 0x00	; 0
    1cfe:	90 e0       	ldi	r25, 0x00	; 0
    1d00:	05 c0       	rjmp	.+10     	; 0x1d0c <xQueueGenericCreate+0x58>
    1d02:	80 e0       	ldi	r24, 0x00	; 0
    1d04:	90 e0       	ldi	r25, 0x00	; 0
    1d06:	02 c0       	rjmp	.+4      	; 0x1d0c <xQueueGenericCreate+0x58>
    1d08:	80 e0       	ldi	r24, 0x00	; 0
    1d0a:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    1d0c:	df 91       	pop	r29
    1d0e:	cf 91       	pop	r28
    1d10:	1f 91       	pop	r17
    1d12:	0f 91       	pop	r16
    1d14:	08 95       	ret

00001d16 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, uint32_t xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1d16:	8f 92       	push	r8
    1d18:	9f 92       	push	r9
    1d1a:	bf 92       	push	r11
    1d1c:	cf 92       	push	r12
    1d1e:	df 92       	push	r13
    1d20:	ef 92       	push	r14
    1d22:	ff 92       	push	r15
    1d24:	0f 93       	push	r16
    1d26:	1f 93       	push	r17
    1d28:	cf 93       	push	r28
    1d2a:	df 93       	push	r29
    1d2c:	cd b7       	in	r28, 0x3d	; 61
    1d2e:	de b7       	in	r29, 0x3e	; 62
    1d30:	29 97       	sbiw	r28, 0x09	; 9
    1d32:	0f b6       	in	r0, 0x3f	; 63
    1d34:	f8 94       	cli
    1d36:	de bf       	out	0x3e, r29	; 62
    1d38:	0f be       	out	0x3f, r0	; 63
    1d3a:	cd bf       	out	0x3d, r28	; 61
    1d3c:	7c 01       	movw	r14, r24
    1d3e:	4b 01       	movw	r8, r22
    1d40:	2e 83       	std	Y+6, r18	; 0x06
    1d42:	3f 83       	std	Y+7, r19	; 0x07
    1d44:	48 87       	std	Y+8, r20	; 0x08
    1d46:	59 87       	std	Y+9, r21	; 0x09
    1d48:	b0 2e       	mov	r11, r16
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1d4a:	10 e0       	ldi	r17, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1d4c:	01 e0       	ldi	r16, 0x01	; 1
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1d4e:	cc 24       	eor	r12, r12
    1d50:	dd 24       	eor	r13, r13
    1d52:	68 94       	set
    1d54:	c3 f8       	bld	r12, 3
    1d56:	c8 0e       	add	r12, r24
    1d58:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1d5a:	0f b6       	in	r0, 0x3f	; 63
    1d5c:	f8 94       	cli
    1d5e:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1d60:	f7 01       	movw	r30, r14
    1d62:	92 8d       	ldd	r25, Z+26	; 0x1a
    1d64:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d66:	98 17       	cp	r25, r24
    1d68:	a8 f4       	brcc	.+42     	; 0x1d94 <xQueueGenericSend+0x7e>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1d6a:	c7 01       	movw	r24, r14
    1d6c:	b4 01       	movw	r22, r8
    1d6e:	4b 2d       	mov	r20, r11
    1d70:	0e 94 85 0d 	call	0x1b0a	; 0x1b0a <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1d74:	f7 01       	movw	r30, r14
    1d76:	81 89       	ldd	r24, Z+17	; 0x11
    1d78:	88 23       	and	r24, r24
    1d7a:	41 f0       	breq	.+16     	; 0x1d8c <xQueueGenericSend+0x76>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1d7c:	c7 01       	movw	r24, r14
    1d7e:	41 96       	adiw	r24, 0x11	; 17
    1d80:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <xTaskRemoveFromEventList>
    1d84:	81 30       	cpi	r24, 0x01	; 1
    1d86:	11 f4       	brne	.+4      	; 0x1d8c <xQueueGenericSend+0x76>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							portYIELD_WITHIN_API();
    1d88:	0e 94 9f 0c 	call	0x193e	; 0x193e <vPortYield>
						}
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1d8c:	0f 90       	pop	r0
    1d8e:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1d90:	81 e0       	ldi	r24, 0x01	; 1
    1d92:	56 c0       	rjmp	.+172    	; 0x1e40 <xQueueGenericSend+0x12a>
			}
			else
			{
				if( xTicksToWait == ( uint32_t ) 0 )
    1d94:	8e 81       	ldd	r24, Y+6	; 0x06
    1d96:	9f 81       	ldd	r25, Y+7	; 0x07
    1d98:	a8 85       	ldd	r26, Y+8	; 0x08
    1d9a:	b9 85       	ldd	r27, Y+9	; 0x09
    1d9c:	00 97       	sbiw	r24, 0x00	; 0
    1d9e:	a1 05       	cpc	r26, r1
    1da0:	b1 05       	cpc	r27, r1
    1da2:	21 f4       	brne	.+8      	; 0x1dac <xQueueGenericSend+0x96>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1da4:	0f 90       	pop	r0
    1da6:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1da8:	80 e0       	ldi	r24, 0x00	; 0
    1daa:	4a c0       	rjmp	.+148    	; 0x1e40 <xQueueGenericSend+0x12a>
				}
				else if( xEntryTimeSet == pdFALSE )
    1dac:	11 23       	and	r17, r17
    1dae:	29 f4       	brne	.+10     	; 0x1dba <xQueueGenericSend+0xa4>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1db0:	ce 01       	movw	r24, r28
    1db2:	01 96       	adiw	r24, 0x01	; 1
    1db4:	0e 94 30 15 	call	0x2a60	; 0x2a60 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1db8:	10 2f       	mov	r17, r16
				}
			}
		}
		taskEXIT_CRITICAL();
    1dba:	0f 90       	pop	r0
    1dbc:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1dbe:	0e 94 41 12 	call	0x2482	; 0x2482 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1dc2:	0f b6       	in	r0, 0x3f	; 63
    1dc4:	f8 94       	cli
    1dc6:	0f 92       	push	r0
    1dc8:	f7 01       	movw	r30, r14
    1dca:	85 8d       	ldd	r24, Z+29	; 0x1d
    1dcc:	8f 3f       	cpi	r24, 0xFF	; 255
    1dce:	09 f4       	brne	.+2      	; 0x1dd2 <xQueueGenericSend+0xbc>
    1dd0:	15 8e       	std	Z+29, r1	; 0x1d
    1dd2:	f7 01       	movw	r30, r14
    1dd4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1dd6:	8f 3f       	cpi	r24, 0xFF	; 255
    1dd8:	09 f4       	brne	.+2      	; 0x1ddc <xQueueGenericSend+0xc6>
    1dda:	16 8e       	std	Z+30, r1	; 0x1e
    1ddc:	0f 90       	pop	r0
    1dde:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1de0:	ce 01       	movw	r24, r28
    1de2:	01 96       	adiw	r24, 0x01	; 1
    1de4:	be 01       	movw	r22, r28
    1de6:	6a 5f       	subi	r22, 0xFA	; 250
    1de8:	7f 4f       	sbci	r23, 0xFF	; 255
    1dea:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <xTaskCheckForTimeOut>
    1dee:	88 23       	and	r24, r24
    1df0:	09 f5       	brne	.+66     	; 0x1e34 <xQueueGenericSend+0x11e>

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1df2:	0f b6       	in	r0, 0x3f	; 63
    1df4:	f8 94       	cli
    1df6:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1df8:	f7 01       	movw	r30, r14
    1dfa:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1dfc:	0f 90       	pop	r0
    1dfe:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1e00:	f7 01       	movw	r30, r14
    1e02:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e04:	98 17       	cp	r25, r24
    1e06:	81 f4       	brne	.+32     	; 0x1e28 <xQueueGenericSend+0x112>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1e08:	6e 81       	ldd	r22, Y+6	; 0x06
    1e0a:	7f 81       	ldd	r23, Y+7	; 0x07
    1e0c:	c6 01       	movw	r24, r12
    1e0e:	0e 94 cb 14 	call	0x2996	; 0x2996 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1e12:	c7 01       	movw	r24, r14
    1e14:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1e18:	0e 94 28 13 	call	0x2650	; 0x2650 <xTaskResumeAll>
    1e1c:	88 23       	and	r24, r24
    1e1e:	09 f0       	breq	.+2      	; 0x1e22 <xQueueGenericSend+0x10c>
    1e20:	9c cf       	rjmp	.-200    	; 0x1d5a <xQueueGenericSend+0x44>
				{
					portYIELD_WITHIN_API();
    1e22:	0e 94 9f 0c 	call	0x193e	; 0x193e <vPortYield>
    1e26:	99 cf       	rjmp	.-206    	; 0x1d5a <xQueueGenericSend+0x44>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1e28:	c7 01       	movw	r24, r14
    1e2a:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1e2e:	0e 94 28 13 	call	0x2650	; 0x2650 <xTaskResumeAll>
    1e32:	93 cf       	rjmp	.-218    	; 0x1d5a <xQueueGenericSend+0x44>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1e34:	c7 01       	movw	r24, r14
    1e36:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1e3a:	0e 94 28 13 	call	0x2650	; 0x2650 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1e3e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    1e40:	29 96       	adiw	r28, 0x09	; 9
    1e42:	0f b6       	in	r0, 0x3f	; 63
    1e44:	f8 94       	cli
    1e46:	de bf       	out	0x3e, r29	; 62
    1e48:	0f be       	out	0x3f, r0	; 63
    1e4a:	cd bf       	out	0x3d, r28	; 61
    1e4c:	df 91       	pop	r29
    1e4e:	cf 91       	pop	r28
    1e50:	1f 91       	pop	r17
    1e52:	0f 91       	pop	r16
    1e54:	ff 90       	pop	r15
    1e56:	ef 90       	pop	r14
    1e58:	df 90       	pop	r13
    1e5a:	cf 90       	pop	r12
    1e5c:	bf 90       	pop	r11
    1e5e:	9f 90       	pop	r9
    1e60:	8f 90       	pop	r8
    1e62:	08 95       	ret

00001e64 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1e64:	0f 93       	push	r16
    1e66:	1f 93       	push	r17
    1e68:	cf 93       	push	r28
    1e6a:	df 93       	push	r29
    1e6c:	ec 01       	movw	r28, r24
    1e6e:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1e70:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1e72:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1e74:	98 17       	cp	r25, r24
    1e76:	e0 f4       	brcc	.+56     	; 0x1eb0 <xQueueGenericSendFromISR+0x4c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1e78:	ce 01       	movw	r24, r28
    1e7a:	42 2f       	mov	r20, r18
    1e7c:	0e 94 85 0d 	call	0x1b0a	; 0x1b0a <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1e80:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1e82:	8f 3f       	cpi	r24, 0xFF	; 255
    1e84:	81 f4       	brne	.+32     	; 0x1ea6 <xQueueGenericSendFromISR+0x42>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e86:	89 89       	ldd	r24, Y+17	; 0x11
    1e88:	88 23       	and	r24, r24
    1e8a:	a1 f0       	breq	.+40     	; 0x1eb4 <xQueueGenericSendFromISR+0x50>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e8c:	ce 01       	movw	r24, r28
    1e8e:	41 96       	adiw	r24, 0x11	; 17
    1e90:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <xTaskRemoveFromEventList>
    1e94:	88 23       	and	r24, r24
    1e96:	81 f0       	breq	.+32     	; 0x1eb8 <xQueueGenericSendFromISR+0x54>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1e98:	01 15       	cp	r16, r1
    1e9a:	11 05       	cpc	r17, r1
    1e9c:	79 f0       	breq	.+30     	; 0x1ebc <xQueueGenericSendFromISR+0x58>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1e9e:	81 e0       	ldi	r24, 0x01	; 1
    1ea0:	f8 01       	movw	r30, r16
    1ea2:	80 83       	st	Z, r24
    1ea4:	0c c0       	rjmp	.+24     	; 0x1ebe <xQueueGenericSendFromISR+0x5a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1ea6:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1ea8:	8f 5f       	subi	r24, 0xFF	; 255
    1eaa:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1eac:	81 e0       	ldi	r24, 0x01	; 1
    1eae:	07 c0       	rjmp	.+14     	; 0x1ebe <xQueueGenericSendFromISR+0x5a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1eb0:	80 e0       	ldi	r24, 0x00	; 0
    1eb2:	05 c0       	rjmp	.+10     	; 0x1ebe <xQueueGenericSendFromISR+0x5a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1eb4:	81 e0       	ldi	r24, 0x01	; 1
    1eb6:	03 c0       	rjmp	.+6      	; 0x1ebe <xQueueGenericSendFromISR+0x5a>
    1eb8:	81 e0       	ldi	r24, 0x01	; 1
    1eba:	01 c0       	rjmp	.+2      	; 0x1ebe <xQueueGenericSendFromISR+0x5a>
    1ebc:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1ebe:	df 91       	pop	r29
    1ec0:	cf 91       	pop	r28
    1ec2:	1f 91       	pop	r17
    1ec4:	0f 91       	pop	r16
    1ec6:	08 95       	ret

00001ec8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, uint32_t xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1ec8:	8f 92       	push	r8
    1eca:	9f 92       	push	r9
    1ecc:	bf 92       	push	r11
    1ece:	cf 92       	push	r12
    1ed0:	df 92       	push	r13
    1ed2:	ef 92       	push	r14
    1ed4:	ff 92       	push	r15
    1ed6:	0f 93       	push	r16
    1ed8:	1f 93       	push	r17
    1eda:	cf 93       	push	r28
    1edc:	df 93       	push	r29
    1ede:	cd b7       	in	r28, 0x3d	; 61
    1ee0:	de b7       	in	r29, 0x3e	; 62
    1ee2:	29 97       	sbiw	r28, 0x09	; 9
    1ee4:	0f b6       	in	r0, 0x3f	; 63
    1ee6:	f8 94       	cli
    1ee8:	de bf       	out	0x3e, r29	; 62
    1eea:	0f be       	out	0x3f, r0	; 63
    1eec:	cd bf       	out	0x3d, r28	; 61
    1eee:	7c 01       	movw	r14, r24
    1ef0:	4b 01       	movw	r8, r22
    1ef2:	2e 83       	std	Y+6, r18	; 0x06
    1ef4:	3f 83       	std	Y+7, r19	; 0x07
    1ef6:	48 87       	std	Y+8, r20	; 0x08
    1ef8:	59 87       	std	Y+9, r21	; 0x09
    1efa:	b0 2e       	mov	r11, r16
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1efc:	10 e0       	ldi	r17, 0x00	; 0
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1efe:	01 e0       	ldi	r16, 0x01	; 1
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1f00:	0f 2e       	mov	r0, r31
    1f02:	f1 e1       	ldi	r31, 0x11	; 17
    1f04:	cf 2e       	mov	r12, r31
    1f06:	dd 24       	eor	r13, r13
    1f08:	f0 2d       	mov	r31, r0
    1f0a:	c8 0e       	add	r12, r24
    1f0c:	d9 1e       	adc	r13, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1f0e:	0f b6       	in	r0, 0x3f	; 63
    1f10:	f8 94       	cli
    1f12:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1f14:	f7 01       	movw	r30, r14
    1f16:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f18:	88 23       	and	r24, r24
    1f1a:	51 f1       	breq	.+84     	; 0x1f70 <xQueueGenericReceive+0xa8>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1f1c:	06 81       	ldd	r16, Z+6	; 0x06
    1f1e:	17 81       	ldd	r17, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    1f20:	c7 01       	movw	r24, r14
    1f22:	b4 01       	movw	r22, r8
    1f24:	0e 94 56 0d 	call	0x1aac	; 0x1aac <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    1f28:	bb 20       	and	r11, r11
    1f2a:	81 f4       	brne	.+32     	; 0x1f4c <xQueueGenericReceive+0x84>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    1f2c:	f7 01       	movw	r30, r14
    1f2e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f30:	81 50       	subi	r24, 0x01	; 1
    1f32:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f34:	80 85       	ldd	r24, Z+8	; 0x08
    1f36:	88 23       	and	r24, r24
    1f38:	b9 f0       	breq	.+46     	; 0x1f68 <xQueueGenericReceive+0xa0>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1f3a:	c7 01       	movw	r24, r14
    1f3c:	08 96       	adiw	r24, 0x08	; 8
    1f3e:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <xTaskRemoveFromEventList>
    1f42:	81 30       	cpi	r24, 0x01	; 1
    1f44:	89 f4       	brne	.+34     	; 0x1f68 <xQueueGenericReceive+0xa0>
						{
							portYIELD_WITHIN_API();
    1f46:	0e 94 9f 0c 	call	0x193e	; 0x193e <vPortYield>
    1f4a:	0e c0       	rjmp	.+28     	; 0x1f68 <xQueueGenericReceive+0xa0>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    1f4c:	f7 01       	movw	r30, r14
    1f4e:	17 83       	std	Z+7, r17	; 0x07
    1f50:	06 83       	std	Z+6, r16	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f52:	81 89       	ldd	r24, Z+17	; 0x11
    1f54:	88 23       	and	r24, r24
    1f56:	41 f0       	breq	.+16     	; 0x1f68 <xQueueGenericReceive+0xa0>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f58:	c7 01       	movw	r24, r14
    1f5a:	41 96       	adiw	r24, 0x11	; 17
    1f5c:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <xTaskRemoveFromEventList>
    1f60:	88 23       	and	r24, r24
    1f62:	11 f0       	breq	.+4      	; 0x1f68 <xQueueGenericReceive+0xa0>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    1f64:	0e 94 9f 0c 	call	0x193e	; 0x193e <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    1f68:	0f 90       	pop	r0
    1f6a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1f6c:	81 e0       	ldi	r24, 0x01	; 1
    1f6e:	54 c0       	rjmp	.+168    	; 0x2018 <xQueueGenericReceive+0x150>
			}
			else
			{
				if( xTicksToWait == ( uint32_t ) 0 )
    1f70:	8e 81       	ldd	r24, Y+6	; 0x06
    1f72:	9f 81       	ldd	r25, Y+7	; 0x07
    1f74:	a8 85       	ldd	r26, Y+8	; 0x08
    1f76:	b9 85       	ldd	r27, Y+9	; 0x09
    1f78:	00 97       	sbiw	r24, 0x00	; 0
    1f7a:	a1 05       	cpc	r26, r1
    1f7c:	b1 05       	cpc	r27, r1
    1f7e:	21 f4       	brne	.+8      	; 0x1f88 <xQueueGenericReceive+0xc0>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1f80:	0f 90       	pop	r0
    1f82:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1f84:	80 e0       	ldi	r24, 0x00	; 0
    1f86:	48 c0       	rjmp	.+144    	; 0x2018 <xQueueGenericReceive+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    1f88:	11 23       	and	r17, r17
    1f8a:	29 f4       	brne	.+10     	; 0x1f96 <xQueueGenericReceive+0xce>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1f8c:	ce 01       	movw	r24, r28
    1f8e:	01 96       	adiw	r24, 0x01	; 1
    1f90:	0e 94 30 15 	call	0x2a60	; 0x2a60 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1f94:	10 2f       	mov	r17, r16
				}
			}
		}
		taskEXIT_CRITICAL();
    1f96:	0f 90       	pop	r0
    1f98:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1f9a:	0e 94 41 12 	call	0x2482	; 0x2482 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1f9e:	0f b6       	in	r0, 0x3f	; 63
    1fa0:	f8 94       	cli
    1fa2:	0f 92       	push	r0
    1fa4:	f7 01       	movw	r30, r14
    1fa6:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fa8:	8f 3f       	cpi	r24, 0xFF	; 255
    1faa:	09 f4       	brne	.+2      	; 0x1fae <xQueueGenericReceive+0xe6>
    1fac:	15 8e       	std	Z+29, r1	; 0x1d
    1fae:	f7 01       	movw	r30, r14
    1fb0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fb2:	8f 3f       	cpi	r24, 0xFF	; 255
    1fb4:	09 f4       	brne	.+2      	; 0x1fb8 <xQueueGenericReceive+0xf0>
    1fb6:	16 8e       	std	Z+30, r1	; 0x1e
    1fb8:	0f 90       	pop	r0
    1fba:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1fbc:	ce 01       	movw	r24, r28
    1fbe:	01 96       	adiw	r24, 0x01	; 1
    1fc0:	be 01       	movw	r22, r28
    1fc2:	6a 5f       	subi	r22, 0xFA	; 250
    1fc4:	7f 4f       	sbci	r23, 0xFF	; 255
    1fc6:	0e 94 3f 15 	call	0x2a7e	; 0x2a7e <xTaskCheckForTimeOut>
    1fca:	88 23       	and	r24, r24
    1fcc:	f9 f4       	brne	.+62     	; 0x200c <xQueueGenericReceive+0x144>

static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1fce:	0f b6       	in	r0, 0x3f	; 63
    1fd0:	f8 94       	cli
    1fd2:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == 0 )
    1fd4:	f7 01       	movw	r30, r14
    1fd6:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1fd8:	0f 90       	pop	r0
    1fda:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1fdc:	88 23       	and	r24, r24
    1fde:	81 f4       	brne	.+32     	; 0x2000 <xQueueGenericReceive+0x138>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1fe0:	6e 81       	ldd	r22, Y+6	; 0x06
    1fe2:	7f 81       	ldd	r23, Y+7	; 0x07
    1fe4:	c6 01       	movw	r24, r12
    1fe6:	0e 94 cb 14 	call	0x2996	; 0x2996 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    1fea:	c7 01       	movw	r24, r14
    1fec:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1ff0:	0e 94 28 13 	call	0x2650	; 0x2650 <xTaskResumeAll>
    1ff4:	88 23       	and	r24, r24
    1ff6:	09 f0       	breq	.+2      	; 0x1ffa <xQueueGenericReceive+0x132>
    1ff8:	8a cf       	rjmp	.-236    	; 0x1f0e <xQueueGenericReceive+0x46>
				{
					portYIELD_WITHIN_API();
    1ffa:	0e 94 9f 0c 	call	0x193e	; 0x193e <vPortYield>
    1ffe:	87 cf       	rjmp	.-242    	; 0x1f0e <xQueueGenericReceive+0x46>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2000:	c7 01       	movw	r24, r14
    2002:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2006:	0e 94 28 13 	call	0x2650	; 0x2650 <xTaskResumeAll>
    200a:	81 cf       	rjmp	.-254    	; 0x1f0e <xQueueGenericReceive+0x46>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    200c:	c7 01       	movw	r24, r14
    200e:	0e 94 c6 0d 	call	0x1b8c	; 0x1b8c <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2012:	0e 94 28 13 	call	0x2650	; 0x2650 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2016:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    2018:	29 96       	adiw	r28, 0x09	; 9
    201a:	0f b6       	in	r0, 0x3f	; 63
    201c:	f8 94       	cli
    201e:	de bf       	out	0x3e, r29	; 62
    2020:	0f be       	out	0x3f, r0	; 63
    2022:	cd bf       	out	0x3d, r28	; 61
    2024:	df 91       	pop	r29
    2026:	cf 91       	pop	r28
    2028:	1f 91       	pop	r17
    202a:	0f 91       	pop	r16
    202c:	ff 90       	pop	r15
    202e:	ef 90       	pop	r14
    2030:	df 90       	pop	r13
    2032:	cf 90       	pop	r12
    2034:	bf 90       	pop	r11
    2036:	9f 90       	pop	r9
    2038:	8f 90       	pop	r8
    203a:	08 95       	ret

0000203c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    203c:	0f 93       	push	r16
    203e:	1f 93       	push	r17
    2040:	cf 93       	push	r28
    2042:	df 93       	push	r29
    2044:	ec 01       	movw	r28, r24
    2046:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2048:	8a 8d       	ldd	r24, Y+26	; 0x1a
    204a:	88 23       	and	r24, r24
    204c:	f1 f0       	breq	.+60     	; 0x208a <xQueueReceiveFromISR+0x4e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    204e:	ce 01       	movw	r24, r28
    2050:	0e 94 56 0d 	call	0x1aac	; 0x1aac <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2054:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2056:	81 50       	subi	r24, 0x01	; 1
    2058:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    205a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    205c:	8f 3f       	cpi	r24, 0xFF	; 255
    205e:	81 f4       	brne	.+32     	; 0x2080 <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2060:	88 85       	ldd	r24, Y+8	; 0x08
    2062:	88 23       	and	r24, r24
    2064:	a1 f0       	breq	.+40     	; 0x208e <xQueueReceiveFromISR+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2066:	ce 01       	movw	r24, r28
    2068:	08 96       	adiw	r24, 0x08	; 8
    206a:	0e 94 e8 14 	call	0x29d0	; 0x29d0 <xTaskRemoveFromEventList>
    206e:	88 23       	and	r24, r24
    2070:	81 f0       	breq	.+32     	; 0x2092 <xQueueReceiveFromISR+0x56>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2072:	01 15       	cp	r16, r1
    2074:	11 05       	cpc	r17, r1
    2076:	79 f0       	breq	.+30     	; 0x2096 <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2078:	81 e0       	ldi	r24, 0x01	; 1
    207a:	f8 01       	movw	r30, r16
    207c:	80 83       	st	Z, r24
    207e:	0c c0       	rjmp	.+24     	; 0x2098 <xQueueReceiveFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2080:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2082:	8f 5f       	subi	r24, 0xFF	; 255
    2084:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2086:	81 e0       	ldi	r24, 0x01	; 1
    2088:	07 c0       	rjmp	.+14     	; 0x2098 <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			xReturn = pdFAIL;
    208a:	80 e0       	ldi	r24, 0x00	; 0
    208c:	05 c0       	rjmp	.+10     	; 0x2098 <xQueueReceiveFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    208e:	81 e0       	ldi	r24, 0x01	; 1
    2090:	03 c0       	rjmp	.+6      	; 0x2098 <xQueueReceiveFromISR+0x5c>
    2092:	81 e0       	ldi	r24, 0x01	; 1
    2094:	01 c0       	rjmp	.+2      	; 0x2098 <xQueueReceiveFromISR+0x5c>
    2096:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2098:	df 91       	pop	r29
    209a:	cf 91       	pop	r28
    209c:	1f 91       	pop	r17
    209e:	0f 91       	pop	r16
    20a0:	08 95       	ret

000020a2 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    20a2:	0f b6       	in	r0, 0x3f	; 63
    20a4:	f8 94       	cli
    20a6:	0f 92       	push	r0
		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
    20a8:	fc 01       	movw	r30, r24
    20aa:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    20ac:	0f 90       	pop	r0
    20ae:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    20b0:	08 95       	ret

000020b2 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
    20b2:	fc 01       	movw	r30, r24
    20b4:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    20b6:	08 95       	ret

000020b8 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle xQueue )
{
    20b8:	cf 93       	push	r28
    20ba:	df 93       	push	r29
    20bc:	ec 01       	movw	r28, r24
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		prvQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue->pcHead );
    20be:	88 81       	ld	r24, Y
    20c0:	99 81       	ldd	r25, Y+1	; 0x01
    20c2:	0e 94 1f 0b 	call	0x163e	; 0x163e <vPortFree>
	vPortFree( pxQueue );
    20c6:	ce 01       	movw	r24, r28
    20c8:	0e 94 1f 0b 	call	0x163e	; 0x163e <vPortFree>
}
    20cc:	df 91       	pop	r29
    20ce:	cf 91       	pop	r28
    20d0:	08 95       	ret

000020d2 <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == 0 )
    20d2:	fc 01       	movw	r30, r24
    20d4:	92 8d       	ldd	r25, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    20d6:	81 e0       	ldi	r24, 0x01	; 1
    20d8:	91 11       	cpse	r25, r1
    20da:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    20dc:	08 95       	ret

000020de <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
{
    20de:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
    20e0:	22 8d       	ldd	r18, Z+26	; 0x1a
	{
		xReturn = pdTRUE;
    20e2:	81 e0       	ldi	r24, 0x01	; 1
    20e4:	93 8d       	ldd	r25, Z+27	; 0x1b
    20e6:	29 13       	cpse	r18, r25
    20e8:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    20ea:	08 95       	ret

000020ec <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( uint16_t xTimeToWake )
{
    20ec:	cf 93       	push	r28
    20ee:	df 93       	push	r29
    20f0:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    20f2:	e0 91 7e 05 	lds	r30, 0x057E
    20f6:	f0 91 7f 05 	lds	r31, 0x057F
    20fa:	93 83       	std	Z+3, r25	; 0x03
    20fc:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    20fe:	80 91 86 05 	lds	r24, 0x0586
    2102:	90 91 87 05 	lds	r25, 0x0587
    2106:	c8 17       	cp	r28, r24
    2108:	d9 07       	cpc	r29, r25
    210a:	68 f4       	brcc	.+26     	; 0x2126 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    210c:	80 91 8a 05 	lds	r24, 0x058A
    2110:	90 91 8b 05 	lds	r25, 0x058B
    2114:	60 91 7e 05 	lds	r22, 0x057E
    2118:	70 91 7f 05 	lds	r23, 0x057F
    211c:	6e 5f       	subi	r22, 0xFE	; 254
    211e:	7f 4f       	sbci	r23, 0xFF	; 255
    2120:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vListInsert>
    2124:	17 c0       	rjmp	.+46     	; 0x2154 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2126:	80 91 8c 05 	lds	r24, 0x058C
    212a:	90 91 8d 05 	lds	r25, 0x058D
    212e:	60 91 7e 05 	lds	r22, 0x057E
    2132:	70 91 7f 05 	lds	r23, 0x057F
    2136:	6e 5f       	subi	r22, 0xFE	; 254
    2138:	7f 4f       	sbci	r23, 0xFF	; 255
    213a:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    213e:	80 91 65 00 	lds	r24, 0x0065
    2142:	90 91 66 00 	lds	r25, 0x0066
    2146:	c8 17       	cp	r28, r24
    2148:	d9 07       	cpc	r29, r25
    214a:	20 f4       	brcc	.+8      	; 0x2154 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    214c:	d0 93 66 00 	sts	0x0066, r29
    2150:	c0 93 65 00 	sts	0x0065, r28
		}
	}
}
    2154:	df 91       	pop	r29
    2156:	cf 91       	pop	r28
    2158:	08 95       	ret

0000215a <xTaskGenericCreate>:
#endif

/*lint +e956 */

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    215a:	4f 92       	push	r4
    215c:	5f 92       	push	r5
    215e:	6f 92       	push	r6
    2160:	7f 92       	push	r7
    2162:	8f 92       	push	r8
    2164:	9f 92       	push	r9
    2166:	bf 92       	push	r11
    2168:	cf 92       	push	r12
    216a:	df 92       	push	r13
    216c:	ef 92       	push	r14
    216e:	ff 92       	push	r15
    2170:	0f 93       	push	r16
    2172:	1f 93       	push	r17
    2174:	cf 93       	push	r28
    2176:	df 93       	push	r29
    2178:	2c 01       	movw	r4, r24
    217a:	4b 01       	movw	r8, r22
    217c:	ea 01       	movw	r28, r20
    217e:	39 01       	movw	r6, r18
    2180:	b0 2e       	mov	r11, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2182:	88 e2       	ldi	r24, 0x28	; 40
    2184:	90 e0       	ldi	r25, 0x00	; 0
    2186:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <pvPortMalloc>
    218a:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    218c:	00 97       	sbiw	r24, 0x00	; 0
    218e:	09 f4       	brne	.+2      	; 0x2192 <xTaskGenericCreate+0x38>
    2190:	e2 c0       	rjmp	.+452    	; 0x2356 <xTaskGenericCreate+0x1fc>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2192:	c1 14       	cp	r12, r1
    2194:	d1 04       	cpc	r13, r1
    2196:	09 f0       	breq	.+2      	; 0x219a <xTaskGenericCreate+0x40>
    2198:	f3 c0       	rjmp	.+486    	; 0x2380 <xTaskGenericCreate+0x226>
    219a:	ce 01       	movw	r24, r28
    219c:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <pvPortMalloc>
    21a0:	6c 01       	movw	r12, r24
    21a2:	f8 01       	movw	r30, r16
    21a4:	90 8f       	std	Z+24, r25	; 0x18
    21a6:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    21a8:	00 97       	sbiw	r24, 0x00	; 0
    21aa:	29 f4       	brne	.+10     	; 0x21b6 <xTaskGenericCreate+0x5c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    21ac:	c8 01       	movw	r24, r16
    21ae:	0e 94 1f 0b 	call	0x163e	; 0x163e <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    21b2:	8f ef       	ldi	r24, 0xFF	; 255
    21b4:	d5 c0       	rjmp	.+426    	; 0x2360 <xTaskGenericCreate+0x206>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    21b6:	c6 01       	movw	r24, r12
    21b8:	65 ea       	ldi	r22, 0xA5	; 165
    21ba:	70 e0       	ldi	r23, 0x00	; 0
    21bc:	ae 01       	movw	r20, r28
    21be:	0e 94 cb 1a 	call	0x3596	; 0x3596 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    21c2:	9e 01       	movw	r18, r28
    21c4:	21 50       	subi	r18, 0x01	; 1
    21c6:	30 40       	sbci	r19, 0x00	; 0
    21c8:	f8 01       	movw	r30, r16
    21ca:	87 89       	ldd	r24, Z+23	; 0x17
    21cc:	90 8d       	ldd	r25, Z+24	; 0x18
    21ce:	6c 01       	movw	r12, r24
    21d0:	c2 0e       	add	r12, r18
    21d2:	d3 1e       	adc	r13, r19
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    21d4:	c8 01       	movw	r24, r16
    21d6:	49 96       	adiw	r24, 0x19	; 25
    21d8:	b4 01       	movw	r22, r8
    21da:	4f e0       	ldi	r20, 0x0F	; 15
    21dc:	50 e0       	ldi	r21, 0x00	; 0
    21de:	0e 94 d2 1a 	call	0x35a4	; 0x35a4 <strncpy>
	}
	#endif /* configMAX_TASK_NAME_LEN */
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    21e2:	f8 01       	movw	r30, r16
    21e4:	17 a2       	lds	r17, 0x97
    21e6:	cb 2d       	mov	r28, r11
    21e8:	f3 e0       	ldi	r31, 0x03	; 3
    21ea:	fb 15       	cp	r31, r11
    21ec:	08 f4       	brcc	.+2      	; 0x21f0 <xTaskGenericCreate+0x96>
    21ee:	c3 e0       	ldi	r28, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    21f0:	f8 01       	movw	r30, r16
    21f2:	c6 8b       	std	Z+22, r28	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    21f4:	88 24       	eor	r8, r8
    21f6:	99 24       	eor	r9, r9
    21f8:	68 94       	set
    21fa:	81 f8       	bld	r8, 1
    21fc:	80 0e       	add	r8, r16
    21fe:	91 1e       	adc	r9, r17
    2200:	c4 01       	movw	r24, r8
    2202:	0e 94 3c 0b 	call	0x1678	; 0x1678 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2206:	c8 01       	movw	r24, r16
    2208:	0c 96       	adiw	r24, 0x0c	; 12
    220a:	0e 94 3c 0b 	call	0x1678	; 0x1678 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    220e:	f8 01       	movw	r30, r16
    2210:	11 87       	std	Z+9, r17	; 0x09
    2212:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( uint16_t ) uxPriority );
    2214:	84 e0       	ldi	r24, 0x04	; 4
    2216:	90 e0       	ldi	r25, 0x00	; 0
    2218:	8c 1b       	sub	r24, r28
    221a:	91 09       	sbc	r25, r1
    221c:	95 87       	std	Z+13, r25	; 0x0d
    221e:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2220:	13 8b       	std	Z+19, r17	; 0x13
    2222:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2224:	c6 01       	movw	r24, r12
    2226:	b2 01       	movw	r22, r4
    2228:	a3 01       	movw	r20, r6
    222a:	0e 94 da 0b 	call	0x17b4	; 0x17b4 <pxPortInitialiseStack>
    222e:	f8 01       	movw	r30, r16
    2230:	91 83       	std	Z+1, r25	; 0x01
    2232:	80 83       	st	Z, r24
		#endif /* portUSING_MPU_WRAPPERS */

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    2234:	e1 14       	cp	r14, r1
    2236:	f1 04       	cpc	r15, r1
    2238:	19 f0       	breq	.+6      	; 0x2240 <xTaskGenericCreate+0xe6>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    223a:	f7 01       	movw	r30, r14
    223c:	11 83       	std	Z+1, r17	; 0x01
    223e:	00 83       	st	Z, r16
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    2240:	0f b6       	in	r0, 0x3f	; 63
    2242:	f8 94       	cli
    2244:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2246:	80 91 88 05 	lds	r24, 0x0588
    224a:	8f 5f       	subi	r24, 0xFF	; 255
    224c:	80 93 88 05 	sts	0x0588, r24
			if( pxCurrentTCB == NULL )
    2250:	80 91 7e 05 	lds	r24, 0x057E
    2254:	90 91 7f 05 	lds	r25, 0x057F
    2258:	00 97       	sbiw	r24, 0x00	; 0
    225a:	d9 f5       	brne	.+118    	; 0x22d2 <xTaskGenericCreate+0x178>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    225c:	10 93 7f 05 	sts	0x057F, r17
    2260:	00 93 7e 05 	sts	0x057E, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2264:	80 91 88 05 	lds	r24, 0x0588
    2268:	81 30       	cpi	r24, 0x01	; 1
    226a:	09 f0       	breq	.+2      	; 0x226e <xTaskGenericCreate+0x114>
    226c:	41 c0       	rjmp	.+130    	; 0x22f0 <xTaskGenericCreate+0x196>
    226e:	c0 e0       	ldi	r28, 0x00	; 0
    2270:	d0 e0       	ldi	r29, 0x00	; 0
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2272:	ce 01       	movw	r24, r28
    2274:	88 0f       	add	r24, r24
    2276:	99 1f       	adc	r25, r25
    2278:	88 0f       	add	r24, r24
    227a:	99 1f       	adc	r25, r25
    227c:	88 0f       	add	r24, r24
    227e:	99 1f       	adc	r25, r25
    2280:	8c 0f       	add	r24, r28
    2282:	9d 1f       	adc	r25, r29
    2284:	80 57       	subi	r24, 0x70	; 112
    2286:	9a 4f       	sbci	r25, 0xFA	; 250
    2288:	0e 94 2e 0b 	call	0x165c	; 0x165c <vListInitialise>
    228c:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    228e:	c4 30       	cpi	r28, 0x04	; 4
    2290:	d1 05       	cpc	r29, r1
    2292:	79 f7       	brne	.-34     	; 0x2272 <xTaskGenericCreate+0x118>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2294:	c4 eb       	ldi	r28, 0xB4	; 180
    2296:	d5 e0       	ldi	r29, 0x05	; 5
    2298:	ce 01       	movw	r24, r28
    229a:	0e 94 2e 0b 	call	0x165c	; 0x165c <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    229e:	0f 2e       	mov	r0, r31
    22a0:	fd eb       	ldi	r31, 0xBD	; 189
    22a2:	ef 2e       	mov	r14, r31
    22a4:	f5 e0       	ldi	r31, 0x05	; 5
    22a6:	ff 2e       	mov	r15, r31
    22a8:	f0 2d       	mov	r31, r0
    22aa:	c7 01       	movw	r24, r14
    22ac:	0e 94 2e 0b 	call	0x165c	; 0x165c <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    22b0:	86 ec       	ldi	r24, 0xC6	; 198
    22b2:	95 e0       	ldi	r25, 0x05	; 5
    22b4:	0e 94 2e 0b 	call	0x165c	; 0x165c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    22b8:	8f ec       	ldi	r24, 0xCF	; 207
    22ba:	95 e0       	ldi	r25, 0x05	; 5
    22bc:	0e 94 2e 0b 	call	0x165c	; 0x165c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    22c0:	d0 93 8d 05 	sts	0x058D, r29
    22c4:	c0 93 8c 05 	sts	0x058C, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    22c8:	f0 92 8b 05 	sts	0x058B, r15
    22cc:	e0 92 8a 05 	sts	0x058A, r14
    22d0:	0f c0       	rjmp	.+30     	; 0x22f0 <xTaskGenericCreate+0x196>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    22d2:	80 91 84 05 	lds	r24, 0x0584
    22d6:	88 23       	and	r24, r24
    22d8:	59 f4       	brne	.+22     	; 0x22f0 <xTaskGenericCreate+0x196>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    22da:	e0 91 7e 05 	lds	r30, 0x057E
    22de:	f0 91 7f 05 	lds	r31, 0x057F
    22e2:	86 89       	ldd	r24, Z+22	; 0x16
    22e4:	b8 16       	cp	r11, r24
    22e6:	20 f0       	brcs	.+8      	; 0x22f0 <xTaskGenericCreate+0x196>
					{
						pxCurrentTCB = pxNewTCB;
    22e8:	10 93 7f 05 	sts	0x057F, r17
    22ec:	00 93 7e 05 	sts	0x057E, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    22f0:	f8 01       	movw	r30, r16
    22f2:	86 89       	ldd	r24, Z+22	; 0x16
    22f4:	90 91 8e 05 	lds	r25, 0x058E
    22f8:	98 17       	cp	r25, r24
    22fa:	10 f4       	brcc	.+4      	; 0x2300 <xTaskGenericCreate+0x1a6>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    22fc:	80 93 8e 05 	sts	0x058E, r24
			}

			uxTaskNumber++;
    2300:	90 91 8f 05 	lds	r25, 0x058F
    2304:	9f 5f       	subi	r25, 0xFF	; 255
    2306:	90 93 8f 05 	sts	0x058F, r25
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyQueue( pxNewTCB );
    230a:	90 91 85 05 	lds	r25, 0x0585
    230e:	98 17       	cp	r25, r24
    2310:	10 f4       	brcc	.+4      	; 0x2316 <xTaskGenericCreate+0x1bc>
    2312:	80 93 85 05 	sts	0x0585, r24
    2316:	90 e0       	ldi	r25, 0x00	; 0
    2318:	9c 01       	movw	r18, r24
    231a:	22 0f       	add	r18, r18
    231c:	33 1f       	adc	r19, r19
    231e:	22 0f       	add	r18, r18
    2320:	33 1f       	adc	r19, r19
    2322:	22 0f       	add	r18, r18
    2324:	33 1f       	adc	r19, r19
    2326:	82 0f       	add	r24, r18
    2328:	93 1f       	adc	r25, r19
    232a:	80 57       	subi	r24, 0x70	; 112
    232c:	9a 4f       	sbci	r25, 0xFA	; 250
    232e:	b4 01       	movw	r22, r8
    2330:	0e 94 40 0b 	call	0x1680	; 0x1680 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    2334:	0f 90       	pop	r0
    2336:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    2338:	80 91 84 05 	lds	r24, 0x0584
    233c:	88 23       	and	r24, r24
    233e:	69 f0       	breq	.+26     	; 0x235a <xTaskGenericCreate+0x200>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2340:	e0 91 7e 05 	lds	r30, 0x057E
    2344:	f0 91 7f 05 	lds	r31, 0x057F
    2348:	86 89       	ldd	r24, Z+22	; 0x16
    234a:	8b 15       	cp	r24, r11
    234c:	40 f4       	brcc	.+16     	; 0x235e <xTaskGenericCreate+0x204>
			{
				portYIELD_WITHIN_API();
    234e:	0e 94 9f 0c 	call	0x193e	; 0x193e <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    2352:	81 e0       	ldi	r24, 0x01	; 1
    2354:	05 c0       	rjmp	.+10     	; 0x2360 <xTaskGenericCreate+0x206>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2356:	8f ef       	ldi	r24, 0xFF	; 255
    2358:	03 c0       	rjmp	.+6      	; 0x2360 <xTaskGenericCreate+0x206>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    235a:	81 e0       	ldi	r24, 0x01	; 1
    235c:	01 c0       	rjmp	.+2      	; 0x2360 <xTaskGenericCreate+0x206>
    235e:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    2360:	df 91       	pop	r29
    2362:	cf 91       	pop	r28
    2364:	1f 91       	pop	r17
    2366:	0f 91       	pop	r16
    2368:	ff 90       	pop	r15
    236a:	ef 90       	pop	r14
    236c:	df 90       	pop	r13
    236e:	cf 90       	pop	r12
    2370:	bf 90       	pop	r11
    2372:	9f 90       	pop	r9
    2374:	8f 90       	pop	r8
    2376:	7f 90       	pop	r7
    2378:	6f 90       	pop	r6
    237a:	5f 90       	pop	r5
    237c:	4f 90       	pop	r4
    237e:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2380:	fc 01       	movw	r30, r24
    2382:	d0 8e       	std	Z+24, r13	; 0x18
    2384:	c7 8a       	std	Z+23, r12	; 0x17
    2386:	17 cf       	rjmp	.-466    	; 0x21b6 <xTaskGenericCreate+0x5c>

00002388 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle xTaskToDelete )
	{
    2388:	ef 92       	push	r14
    238a:	ff 92       	push	r15
    238c:	0f 93       	push	r16
    238e:	1f 93       	push	r17
    2390:	cf 93       	push	r28
    2392:	df 93       	push	r29
    2394:	7c 01       	movw	r14, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    2396:	0f b6       	in	r0, 0x3f	; 63
    2398:	f8 94       	cli
    239a:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( xTaskToDelete == pxCurrentTCB )
    239c:	80 91 7e 05 	lds	r24, 0x057E
    23a0:	90 91 7f 05 	lds	r25, 0x057F
    23a4:	e8 16       	cp	r14, r24
    23a6:	f9 06       	cpc	r15, r25
    23a8:	21 f0       	breq	.+8      	; 0x23b2 <vTaskDelete+0x2a>
			{
				xTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    23aa:	e1 14       	cp	r14, r1
    23ac:	f1 04       	cpc	r15, r1
    23ae:	41 f4       	brne	.+16     	; 0x23c0 <vTaskDelete+0x38>
    23b0:	02 c0       	rjmp	.+4      	; 0x23b6 <vTaskDelete+0x2e>
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( xTaskToDelete == pxCurrentTCB )
			{
				xTaskToDelete = NULL;
    23b2:	ee 24       	eor	r14, r14
    23b4:	ff 24       	eor	r15, r15
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    23b6:	c0 91 7e 05 	lds	r28, 0x057E
    23ba:	d0 91 7f 05 	lds	r29, 0x057F
    23be:	01 c0       	rjmp	.+2      	; 0x23c2 <vTaskDelete+0x3a>
    23c0:	e7 01       	movw	r28, r14

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    23c2:	8e 01       	movw	r16, r28
    23c4:	0e 5f       	subi	r16, 0xFE	; 254
    23c6:	1f 4f       	sbci	r17, 0xFF	; 255
    23c8:	c8 01       	movw	r24, r16
    23ca:	0e 94 b3 0b 	call	0x1766	; 0x1766 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    23ce:	8c 89       	ldd	r24, Y+20	; 0x14
    23d0:	9d 89       	ldd	r25, Y+21	; 0x15
    23d2:	00 97       	sbiw	r24, 0x00	; 0
    23d4:	21 f0       	breq	.+8      	; 0x23de <vTaskDelete+0x56>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
    23d6:	ce 01       	movw	r24, r28
    23d8:	0c 96       	adiw	r24, 0x0c	; 12
    23da:	0e 94 b3 0b 	call	0x1766	; 0x1766 <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    23de:	8f ec       	ldi	r24, 0xCF	; 207
    23e0:	95 e0       	ldi	r25, 0x05	; 5
    23e2:	b8 01       	movw	r22, r16
    23e4:	0e 94 40 0b 	call	0x1680	; 0x1680 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    23e8:	80 91 89 05 	lds	r24, 0x0589
    23ec:	8f 5f       	subi	r24, 0xFF	; 255
    23ee:	80 93 89 05 	sts	0x0589, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    23f2:	80 91 8f 05 	lds	r24, 0x058F
    23f6:	8f 5f       	subi	r24, 0xFF	; 255
    23f8:	80 93 8f 05 	sts	0x058F, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    23fc:	0f 90       	pop	r0
    23fe:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    2400:	80 91 84 05 	lds	r24, 0x0584
    2404:	88 23       	and	r24, r24
    2406:	29 f0       	breq	.+10     	; 0x2412 <vTaskDelete+0x8a>
		{
			if( ( void * ) xTaskToDelete == NULL )
    2408:	e1 14       	cp	r14, r1
    240a:	f1 04       	cpc	r15, r1
    240c:	11 f4       	brne	.+4      	; 0x2412 <vTaskDelete+0x8a>
			{
				portYIELD_WITHIN_API();
    240e:	0e 94 9f 0c 	call	0x193e	; 0x193e <vPortYield>
			}
		}
	}
    2412:	df 91       	pop	r29
    2414:	cf 91       	pop	r28
    2416:	1f 91       	pop	r17
    2418:	0f 91       	pop	r16
    241a:	ff 90       	pop	r15
    241c:	ef 90       	pop	r14
    241e:	08 95       	ret

00002420 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    2420:	af 92       	push	r10
    2422:	bf 92       	push	r11
    2424:	cf 92       	push	r12
    2426:	df 92       	push	r13
    2428:	ef 92       	push	r14
    242a:	ff 92       	push	r15
    242c:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    242e:	88 eb       	ldi	r24, 0xB8	; 184
    2430:	93 e1       	ldi	r25, 0x13	; 19
    2432:	60 e6       	ldi	r22, 0x60	; 96
    2434:	70 e0       	ldi	r23, 0x00	; 0
    2436:	45 e5       	ldi	r20, 0x55	; 85
    2438:	50 e0       	ldi	r21, 0x00	; 0
    243a:	20 e0       	ldi	r18, 0x00	; 0
    243c:	30 e0       	ldi	r19, 0x00	; 0
    243e:	00 e0       	ldi	r16, 0x00	; 0
    2440:	ee 24       	eor	r14, r14
    2442:	ff 24       	eor	r15, r15
    2444:	cc 24       	eor	r12, r12
    2446:	dd 24       	eor	r13, r13
    2448:	aa 24       	eor	r10, r10
    244a:	bb 24       	eor	r11, r11
    244c:	0e 94 ad 10 	call	0x215a	; 0x215a <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    2450:	81 30       	cpi	r24, 0x01	; 1
    2452:	49 f4       	brne	.+18     	; 0x2466 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2454:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2456:	80 93 84 05 	sts	0x0584, r24
		xTickCount = ( uint16_t ) 0U;
    245a:	10 92 87 05 	sts	0x0587, r1
    245e:	10 92 86 05 	sts	0x0586, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2462:	0e 94 6a 0c 	call	0x18d4	; 0x18d4 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    2466:	0f 91       	pop	r16
    2468:	ff 90       	pop	r15
    246a:	ef 90       	pop	r14
    246c:	df 90       	pop	r13
    246e:	cf 90       	pop	r12
    2470:	bf 90       	pop	r11
    2472:	af 90       	pop	r10
    2474:	08 95       	ret

00002476 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2476:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2478:	10 92 84 05 	sts	0x0584, r1
	vPortEndScheduler();
    247c:	0e 94 9e 0c 	call	0x193c	; 0x193c <vPortEndScheduler>
}
    2480:	08 95       	ret

00002482 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2482:	80 91 83 05 	lds	r24, 0x0583
    2486:	8f 5f       	subi	r24, 0xFF	; 255
    2488:	80 93 83 05 	sts	0x0583, r24
}
    248c:	08 95       	ret

0000248e <xTaskGetTickCount>:
uint16_t xTaskGetTickCount( void )
{
uint16_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    248e:	0f b6       	in	r0, 0x3f	; 63
    2490:	f8 94       	cli
    2492:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2494:	80 91 86 05 	lds	r24, 0x0586
    2498:	90 91 87 05 	lds	r25, 0x0587
	}
	taskEXIT_CRITICAL();
    249c:	0f 90       	pop	r0
    249e:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    24a0:	08 95       	ret

000024a2 <xTaskGetTickCountFromISR>:
{
uint16_t xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    24a2:	80 91 86 05 	lds	r24, 0x0586
    24a6:	90 91 87 05 	lds	r25, 0x0587
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    24aa:	08 95       	ret

000024ac <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    24ac:	80 91 88 05 	lds	r24, 0x0588
}
    24b0:	08 95       	ret

000024b2 <vTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    24b2:	0f 93       	push	r16
    24b4:	1f 93       	push	r17
    24b6:	cf 93       	push	r28
    24b8:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    24ba:	80 91 83 05 	lds	r24, 0x0583
    24be:	88 23       	and	r24, r24
    24c0:	09 f0       	breq	.+2      	; 0x24c4 <vTaskIncrementTick+0x12>
    24c2:	bc c0       	rjmp	.+376    	; 0x263c <vTaskIncrementTick+0x18a>
	{
		++xTickCount;
    24c4:	80 91 86 05 	lds	r24, 0x0586
    24c8:	90 91 87 05 	lds	r25, 0x0587
    24cc:	01 96       	adiw	r24, 0x01	; 1
    24ce:	90 93 87 05 	sts	0x0587, r25
    24d2:	80 93 86 05 	sts	0x0586, r24
        
if( xTickCount==65535 )
    24d6:	80 91 86 05 	lds	r24, 0x0586
    24da:	90 91 87 05 	lds	r25, 0x0587
    24de:	2f ef       	ldi	r18, 0xFF	; 255
    24e0:	8f 3f       	cpi	r24, 0xFF	; 255
    24e2:	92 07       	cpc	r25, r18
    24e4:	09 f4       	brne	.+2      	; 0x24e8 <vTaskIncrementTick+0x36>
{
    asm("nop");
    24e6:	00 00       	nop
}
        
		if( xTickCount == ( uint16_t ) 0U )
    24e8:	80 91 86 05 	lds	r24, 0x0586
    24ec:	90 91 87 05 	lds	r25, 0x0587
    24f0:	00 97       	sbiw	r24, 0x00	; 0
    24f2:	99 f5       	brne	.+102    	; 0x255a <vTaskIncrementTick+0xa8>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
    24f4:	80 91 8c 05 	lds	r24, 0x058C
    24f8:	90 91 8d 05 	lds	r25, 0x058D
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    24fc:	20 91 8a 05 	lds	r18, 0x058A
    2500:	30 91 8b 05 	lds	r19, 0x058B
    2504:	30 93 8d 05 	sts	0x058D, r19
    2508:	20 93 8c 05 	sts	0x058C, r18
			pxOverflowDelayedTaskList = pxTemp;
    250c:	90 93 8b 05 	sts	0x058B, r25
    2510:	80 93 8a 05 	sts	0x058A, r24
			xNumOfOverflows++;
    2514:	80 91 80 05 	lds	r24, 0x0580
    2518:	8f 5f       	subi	r24, 0xFF	; 255
    251a:	80 93 80 05 	sts	0x0580, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    251e:	e0 91 8c 05 	lds	r30, 0x058C
    2522:	f0 91 8d 05 	lds	r31, 0x058D
    2526:	80 81       	ld	r24, Z
    2528:	88 23       	and	r24, r24
    252a:	39 f4       	brne	.+14     	; 0x253a <vTaskIncrementTick+0x88>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    252c:	8f ef       	ldi	r24, 0xFF	; 255
    252e:	9f ef       	ldi	r25, 0xFF	; 255
    2530:	90 93 66 00 	sts	0x0066, r25
    2534:	80 93 65 00 	sts	0x0065, r24
    2538:	10 c0       	rjmp	.+32     	; 0x255a <vTaskIncrementTick+0xa8>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    253a:	e0 91 8c 05 	lds	r30, 0x058C
    253e:	f0 91 8d 05 	lds	r31, 0x058D
    2542:	05 80       	ldd	r0, Z+5	; 0x05
    2544:	f6 81       	ldd	r31, Z+6	; 0x06
    2546:	e0 2d       	mov	r30, r0
    2548:	06 80       	ldd	r0, Z+6	; 0x06
    254a:	f7 81       	ldd	r31, Z+7	; 0x07
    254c:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    254e:	82 81       	ldd	r24, Z+2	; 0x02
    2550:	93 81       	ldd	r25, Z+3	; 0x03
    2552:	90 93 66 00 	sts	0x0066, r25
    2556:	80 93 65 00 	sts	0x0065, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    255a:	20 91 86 05 	lds	r18, 0x0586
    255e:	30 91 87 05 	lds	r19, 0x0587
    2562:	80 91 65 00 	lds	r24, 0x0065
    2566:	90 91 66 00 	lds	r25, 0x0066
    256a:	28 17       	cp	r18, r24
    256c:	39 07       	cpc	r19, r25
    256e:	08 f4       	brcc	.+2      	; 0x2572 <vTaskIncrementTick+0xc0>
    2570:	6a c0       	rjmp	.+212    	; 0x2646 <vTaskIncrementTick+0x194>
    2572:	e0 91 8c 05 	lds	r30, 0x058C
    2576:	f0 91 8d 05 	lds	r31, 0x058D
    257a:	80 81       	ld	r24, Z
    257c:	88 23       	and	r24, r24
    257e:	99 f0       	breq	.+38     	; 0x25a6 <vTaskIncrementTick+0xf4>
    2580:	e0 91 8c 05 	lds	r30, 0x058C
    2584:	f0 91 8d 05 	lds	r31, 0x058D
    2588:	05 80       	ldd	r0, Z+5	; 0x05
    258a:	f6 81       	ldd	r31, Z+6	; 0x06
    258c:	e0 2d       	mov	r30, r0
    258e:	c6 81       	ldd	r28, Z+6	; 0x06
    2590:	d7 81       	ldd	r29, Z+7	; 0x07
    2592:	8a 81       	ldd	r24, Y+2	; 0x02
    2594:	9b 81       	ldd	r25, Y+3	; 0x03
    2596:	20 91 86 05 	lds	r18, 0x0586
    259a:	30 91 87 05 	lds	r19, 0x0587
    259e:	28 17       	cp	r18, r24
    25a0:	39 07       	cpc	r19, r25
    25a2:	f8 f4       	brcc	.+62     	; 0x25e2 <vTaskIncrementTick+0x130>
    25a4:	19 c0       	rjmp	.+50     	; 0x25d8 <vTaskIncrementTick+0x126>
    25a6:	8f ef       	ldi	r24, 0xFF	; 255
    25a8:	9f ef       	ldi	r25, 0xFF	; 255
    25aa:	90 93 66 00 	sts	0x0066, r25
    25ae:	80 93 65 00 	sts	0x0065, r24
    25b2:	49 c0       	rjmp	.+146    	; 0x2646 <vTaskIncrementTick+0x194>
    25b4:	e0 91 8c 05 	lds	r30, 0x058C
    25b8:	f0 91 8d 05 	lds	r31, 0x058D
    25bc:	05 80       	ldd	r0, Z+5	; 0x05
    25be:	f6 81       	ldd	r31, Z+6	; 0x06
    25c0:	e0 2d       	mov	r30, r0
    25c2:	c6 81       	ldd	r28, Z+6	; 0x06
    25c4:	d7 81       	ldd	r29, Z+7	; 0x07
    25c6:	8a 81       	ldd	r24, Y+2	; 0x02
    25c8:	9b 81       	ldd	r25, Y+3	; 0x03
    25ca:	20 91 86 05 	lds	r18, 0x0586
    25ce:	30 91 87 05 	lds	r19, 0x0587
    25d2:	28 17       	cp	r18, r24
    25d4:	39 07       	cpc	r19, r25
    25d6:	28 f4       	brcc	.+10     	; 0x25e2 <vTaskIncrementTick+0x130>
    25d8:	90 93 66 00 	sts	0x0066, r25
    25dc:	80 93 65 00 	sts	0x0065, r24
    25e0:	32 c0       	rjmp	.+100    	; 0x2646 <vTaskIncrementTick+0x194>
    25e2:	8e 01       	movw	r16, r28
    25e4:	0e 5f       	subi	r16, 0xFE	; 254
    25e6:	1f 4f       	sbci	r17, 0xFF	; 255
    25e8:	c8 01       	movw	r24, r16
    25ea:	0e 94 b3 0b 	call	0x1766	; 0x1766 <uxListRemove>
    25ee:	8c 89       	ldd	r24, Y+20	; 0x14
    25f0:	9d 89       	ldd	r25, Y+21	; 0x15
    25f2:	00 97       	sbiw	r24, 0x00	; 0
    25f4:	21 f0       	breq	.+8      	; 0x25fe <vTaskIncrementTick+0x14c>
    25f6:	ce 01       	movw	r24, r28
    25f8:	0c 96       	adiw	r24, 0x0c	; 12
    25fa:	0e 94 b3 0b 	call	0x1766	; 0x1766 <uxListRemove>
    25fe:	8e 89       	ldd	r24, Y+22	; 0x16
    2600:	90 91 85 05 	lds	r25, 0x0585
    2604:	98 17       	cp	r25, r24
    2606:	10 f4       	brcc	.+4      	; 0x260c <vTaskIncrementTick+0x15a>
    2608:	80 93 85 05 	sts	0x0585, r24
    260c:	90 e0       	ldi	r25, 0x00	; 0
    260e:	9c 01       	movw	r18, r24
    2610:	22 0f       	add	r18, r18
    2612:	33 1f       	adc	r19, r19
    2614:	22 0f       	add	r18, r18
    2616:	33 1f       	adc	r19, r19
    2618:	22 0f       	add	r18, r18
    261a:	33 1f       	adc	r19, r19
    261c:	82 0f       	add	r24, r18
    261e:	93 1f       	adc	r25, r19
    2620:	80 57       	subi	r24, 0x70	; 112
    2622:	9a 4f       	sbci	r25, 0xFA	; 250
    2624:	b8 01       	movw	r22, r16
    2626:	0e 94 40 0b 	call	0x1680	; 0x1680 <vListInsertEnd>
    262a:	e0 91 8c 05 	lds	r30, 0x058C
    262e:	f0 91 8d 05 	lds	r31, 0x058D
    2632:	80 81       	ld	r24, Z
    2634:	88 23       	and	r24, r24
    2636:	09 f0       	breq	.+2      	; 0x263a <vTaskIncrementTick+0x188>
    2638:	bd cf       	rjmp	.-134    	; 0x25b4 <vTaskIncrementTick+0x102>
    263a:	b5 cf       	rjmp	.-150    	; 0x25a6 <vTaskIncrementTick+0xf4>
	}
	else
	{
		++uxMissedTicks;
    263c:	80 91 82 05 	lds	r24, 0x0582
    2640:	8f 5f       	subi	r24, 0xFF	; 255
    2642:	80 93 82 05 	sts	0x0582, r24
		{
			vApplicationTickHook();
		}
	}
	#endif /* configUSE_TICK_HOOK */
}
    2646:	df 91       	pop	r29
    2648:	cf 91       	pop	r28
    264a:	1f 91       	pop	r17
    264c:	0f 91       	pop	r16
    264e:	08 95       	ret

00002650 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2650:	af 92       	push	r10
    2652:	bf 92       	push	r11
    2654:	cf 92       	push	r12
    2656:	df 92       	push	r13
    2658:	ef 92       	push	r14
    265a:	ff 92       	push	r15
    265c:	0f 93       	push	r16
    265e:	1f 93       	push	r17
    2660:	cf 93       	push	r28
    2662:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2664:	0f b6       	in	r0, 0x3f	; 63
    2666:	f8 94       	cli
    2668:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    266a:	80 91 83 05 	lds	r24, 0x0583
    266e:	81 50       	subi	r24, 0x01	; 1
    2670:	80 93 83 05 	sts	0x0583, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2674:	80 91 83 05 	lds	r24, 0x0583
    2678:	88 23       	and	r24, r24
    267a:	09 f0       	breq	.+2      	; 0x267e <xTaskResumeAll+0x2e>
    267c:	69 c0       	rjmp	.+210    	; 0x2750 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    267e:	80 91 88 05 	lds	r24, 0x0588
    2682:	88 23       	and	r24, r24
    2684:	81 f5       	brne	.+96     	; 0x26e6 <xTaskResumeAll+0x96>
    2686:	67 c0       	rjmp	.+206    	; 0x2756 <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2688:	d6 01       	movw	r26, r12
    268a:	ed 91       	ld	r30, X+
    268c:	fc 91       	ld	r31, X
    268e:	c6 81       	ldd	r28, Z+6	; 0x06
    2690:	d7 81       	ldd	r29, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
    2692:	ce 01       	movw	r24, r28
    2694:	0c 96       	adiw	r24, 0x0c	; 12
    2696:	0e 94 b3 0b 	call	0x1766	; 0x1766 <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
    269a:	8e 01       	movw	r16, r28
    269c:	0e 5f       	subi	r16, 0xFE	; 254
    269e:	1f 4f       	sbci	r17, 0xFF	; 255
    26a0:	c8 01       	movw	r24, r16
    26a2:	0e 94 b3 0b 	call	0x1766	; 0x1766 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    26a6:	8e 89       	ldd	r24, Y+22	; 0x16
    26a8:	90 91 85 05 	lds	r25, 0x0585
    26ac:	98 17       	cp	r25, r24
    26ae:	10 f4       	brcc	.+4      	; 0x26b4 <xTaskResumeAll+0x64>
    26b0:	80 93 85 05 	sts	0x0585, r24
    26b4:	90 e0       	ldi	r25, 0x00	; 0
    26b6:	9c 01       	movw	r18, r24
    26b8:	22 0f       	add	r18, r18
    26ba:	33 1f       	adc	r19, r19
    26bc:	22 0f       	add	r18, r18
    26be:	33 1f       	adc	r19, r19
    26c0:	22 0f       	add	r18, r18
    26c2:	33 1f       	adc	r19, r19
    26c4:	82 0f       	add	r24, r18
    26c6:	93 1f       	adc	r25, r19
    26c8:	80 57       	subi	r24, 0x70	; 112
    26ca:	9a 4f       	sbci	r25, 0xFA	; 250
    26cc:	b8 01       	movw	r22, r16
    26ce:	0e 94 40 0b 	call	0x1680	; 0x1680 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    26d2:	e0 91 7e 05 	lds	r30, 0x057E
    26d6:	f0 91 7f 05 	lds	r31, 0x057F
    26da:	9e 89       	ldd	r25, Y+22	; 0x16
    26dc:	86 89       	ldd	r24, Z+22	; 0x16
    26de:	98 17       	cp	r25, r24
    26e0:	88 f0       	brcs	.+34     	; 0x2704 <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    26e2:	ba 2c       	mov	r11, r10
    26e4:	0f c0       	rjmp	.+30     	; 0x2704 <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    26e6:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    26e8:	0f 2e       	mov	r0, r31
    26ea:	f6 ec       	ldi	r31, 0xC6	; 198
    26ec:	ef 2e       	mov	r14, r31
    26ee:	f5 e0       	ldi	r31, 0x05	; 5
    26f0:	ff 2e       	mov	r15, r31
    26f2:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    26f4:	0f 2e       	mov	r0, r31
    26f6:	fb ec       	ldi	r31, 0xCB	; 203
    26f8:	cf 2e       	mov	r12, r31
    26fa:	f5 e0       	ldi	r31, 0x05	; 5
    26fc:	df 2e       	mov	r13, r31
    26fe:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    2700:	aa 24       	eor	r10, r10
    2702:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2704:	f7 01       	movw	r30, r14
    2706:	80 81       	ld	r24, Z
    2708:	88 23       	and	r24, r24
    270a:	09 f0       	breq	.+2      	; 0x270e <xTaskResumeAll+0xbe>
    270c:	bd cf       	rjmp	.-134    	; 0x2688 <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    270e:	80 91 82 05 	lds	r24, 0x0582
    2712:	88 23       	and	r24, r24
    2714:	81 f0       	breq	.+32     	; 0x2736 <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2716:	80 91 82 05 	lds	r24, 0x0582
    271a:	88 23       	and	r24, r24
    271c:	99 f0       	breq	.+38     	; 0x2744 <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    271e:	0e 94 59 12 	call	0x24b2	; 0x24b2 <vTaskIncrementTick>
						--uxMissedTicks;
    2722:	80 91 82 05 	lds	r24, 0x0582
    2726:	81 50       	subi	r24, 0x01	; 1
    2728:	80 93 82 05 	sts	0x0582, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    272c:	80 91 82 05 	lds	r24, 0x0582
    2730:	88 23       	and	r24, r24
    2732:	a9 f7       	brne	.-22     	; 0x271e <xTaskResumeAll+0xce>
    2734:	07 c0       	rjmp	.+14     	; 0x2744 <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2736:	f1 e0       	ldi	r31, 0x01	; 1
    2738:	bf 16       	cp	r11, r31
    273a:	21 f0       	breq	.+8      	; 0x2744 <xTaskResumeAll+0xf4>
    273c:	80 91 81 05 	lds	r24, 0x0581
    2740:	81 30       	cpi	r24, 0x01	; 1
    2742:	41 f4       	brne	.+16     	; 0x2754 <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    2744:	10 92 81 05 	sts	0x0581, r1
					portYIELD_WITHIN_API();
    2748:	0e 94 9f 0c 	call	0x193e	; 0x193e <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    274c:	81 e0       	ldi	r24, 0x01	; 1
    274e:	03 c0       	rjmp	.+6      	; 0x2756 <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2750:	80 e0       	ldi	r24, 0x00	; 0
    2752:	01 c0       	rjmp	.+2      	; 0x2756 <xTaskResumeAll+0x106>
    2754:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2756:	0f 90       	pop	r0
    2758:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    275a:	df 91       	pop	r29
    275c:	cf 91       	pop	r28
    275e:	1f 91       	pop	r17
    2760:	0f 91       	pop	r16
    2762:	ff 90       	pop	r15
    2764:	ef 90       	pop	r14
    2766:	df 90       	pop	r13
    2768:	cf 90       	pop	r12
    276a:	bf 90       	pop	r11
    276c:	af 90       	pop	r10
    276e:	08 95       	ret

00002770 <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2770:	0f ec       	ldi	r16, 0xCF	; 207
    2772:	15 e0       	ldi	r17, 0x05	; 5
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    2774:	0f 2e       	mov	r0, r31
    2776:	f4 ed       	ldi	r31, 0xD4	; 212
    2778:	ef 2e       	mov	r14, r31
    277a:	f5 e0       	ldi	r31, 0x05	; 5
    277c:	ff 2e       	mov	r15, r31
    277e:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    2780:	0f 2e       	mov	r0, r31
    2782:	f0 e9       	ldi	r31, 0x90	; 144
    2784:	cf 2e       	mov	r12, r31
    2786:	f5 e0       	ldi	r31, 0x05	; 5
    2788:	df 2e       	mov	r13, r31
    278a:	f0 2d       	mov	r31, r0
    278c:	27 c0       	rjmp	.+78     	; 0x27dc <prvIdleTask+0x6c>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
    278e:	0e 94 41 12 	call	0x2482	; 0x2482 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    2792:	d8 01       	movw	r26, r16
    2794:	cc 91       	ld	r28, X
			xTaskResumeAll();
    2796:	0e 94 28 13 	call	0x2650	; 0x2650 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    279a:	cc 23       	and	r28, r28
    279c:	f9 f0       	breq	.+62     	; 0x27dc <prvIdleTask+0x6c>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    279e:	0f b6       	in	r0, 0x3f	; 63
    27a0:	f8 94       	cli
    27a2:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    27a4:	d7 01       	movw	r26, r14
    27a6:	ed 91       	ld	r30, X+
    27a8:	fc 91       	ld	r31, X
    27aa:	c6 81       	ldd	r28, Z+6	; 0x06
    27ac:	d7 81       	ldd	r29, Z+7	; 0x07
					uxListRemove( &( pxTCB->xGenericListItem ) );
    27ae:	ce 01       	movw	r24, r28
    27b0:	02 96       	adiw	r24, 0x02	; 2
    27b2:	0e 94 b3 0b 	call	0x1766	; 0x1766 <uxListRemove>
					--uxCurrentNumberOfTasks;
    27b6:	80 91 88 05 	lds	r24, 0x0588
    27ba:	81 50       	subi	r24, 0x01	; 1
    27bc:	80 93 88 05 	sts	0x0588, r24
					--uxTasksDeleted;
    27c0:	80 91 89 05 	lds	r24, 0x0589
    27c4:	81 50       	subi	r24, 0x01	; 1
    27c6:	80 93 89 05 	sts	0x0589, r24
				}
				taskEXIT_CRITICAL();
    27ca:	0f 90       	pop	r0
    27cc:	0f be       	out	0x3f, r0	; 63
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    27ce:	8f 89       	ldd	r24, Y+23	; 0x17
    27d0:	98 8d       	ldd	r25, Y+24	; 0x18
    27d2:	0e 94 1f 0b 	call	0x163e	; 0x163e <vPortFree>
		vPortFree( pxTCB );
    27d6:	ce 01       	movw	r24, r28
    27d8:	0e 94 1f 0b 	call	0x163e	; 0x163e <vPortFree>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    27dc:	80 91 89 05 	lds	r24, 0x0589
    27e0:	88 23       	and	r24, r24
    27e2:	a9 f6       	brne	.-86     	; 0x278e <prvIdleTask+0x1e>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    27e4:	f6 01       	movw	r30, r12
    27e6:	80 81       	ld	r24, Z
    27e8:	82 30       	cpi	r24, 0x02	; 2
    27ea:	c0 f3       	brcs	.-16     	; 0x27dc <prvIdleTask+0x6c>
			{
				taskYIELD();
    27ec:	0e 94 9f 0c 	call	0x193e	; 0x193e <vPortYield>
    27f0:	f5 cf       	rjmp	.-22     	; 0x27dc <prvIdleTask+0x6c>

000027f2 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( uint16_t xTicksToDelay )
	{
    27f2:	cf 93       	push	r28
    27f4:	df 93       	push	r29
    27f6:	ec 01       	movw	r28, r24
	uint16_t xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( uint16_t ) 0U )
    27f8:	00 97       	sbiw	r24, 0x00	; 0
    27fa:	b1 f0       	breq	.+44     	; 0x2828 <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    27fc:	0e 94 41 12 	call	0x2482	; 0x2482 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2800:	80 91 86 05 	lds	r24, 0x0586
    2804:	90 91 87 05 	lds	r25, 0x0587
    2808:	c8 0f       	add	r28, r24
    280a:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    280c:	80 91 7e 05 	lds	r24, 0x057E
    2810:	90 91 7f 05 	lds	r25, 0x057F
    2814:	02 96       	adiw	r24, 0x02	; 2
    2816:	0e 94 b3 0b 	call	0x1766	; 0x1766 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    281a:	ce 01       	movw	r24, r28
    281c:	0e 94 76 10 	call	0x20ec	; 0x20ec <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2820:	0e 94 28 13 	call	0x2650	; 0x2650 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2824:	88 23       	and	r24, r24
    2826:	11 f4       	brne	.+4      	; 0x282c <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    2828:	0e 94 9f 0c 	call	0x193e	; 0x193e <vPortYield>
		}
	}
    282c:	df 91       	pop	r29
    282e:	cf 91       	pop	r28
    2830:	08 95       	ret

00002832 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( uint16_t * const pxPreviousWakeTime, uint16_t xTimeIncrement )
	{
    2832:	0f 93       	push	r16
    2834:	1f 93       	push	r17
    2836:	cf 93       	push	r28
    2838:	df 93       	push	r29
    283a:	8c 01       	movw	r16, r24
    283c:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

if( *pxPreviousWakeTime!=xTickCount )
    283e:	80 91 86 05 	lds	r24, 0x0586
    2842:	90 91 87 05 	lds	r25, 0x0587
    2846:	f8 01       	movw	r30, r16
    2848:	20 81       	ld	r18, Z
    284a:	31 81       	ldd	r19, Z+1	; 0x01
    284c:	28 17       	cp	r18, r24
    284e:	39 07       	cpc	r19, r25
    2850:	09 f0       	breq	.+2      	; 0x2854 <vTaskDelayUntil+0x22>
{
    asm ("nop");
    2852:	00 00       	nop
    
}

		vTaskSuspendAll();
    2854:	0e 94 41 12 	call	0x2482	; 0x2482 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2858:	f8 01       	movw	r30, r16
    285a:	80 81       	ld	r24, Z
    285c:	91 81       	ldd	r25, Z+1	; 0x01
    285e:	c8 0f       	add	r28, r24
    2860:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    2862:	20 91 86 05 	lds	r18, 0x0586
    2866:	30 91 87 05 	lds	r19, 0x0587
    286a:	28 17       	cp	r18, r24
    286c:	39 07       	cpc	r19, r25
    286e:	68 f4       	brcc	.+26     	; 0x288a <vTaskDelayUntil+0x58>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2870:	c8 17       	cp	r28, r24
    2872:	d9 07       	cpc	r29, r25
    2874:	50 f5       	brcc	.+84     	; 0x28ca <vTaskDelayUntil+0x98>
    2876:	80 91 86 05 	lds	r24, 0x0586
    287a:	90 91 87 05 	lds	r25, 0x0587
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    287e:	d1 83       	std	Z+1, r29	; 0x01
    2880:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    2882:	8c 17       	cp	r24, r28
    2884:	9d 07       	cpc	r25, r29
    2886:	b0 f4       	brcc	.+44     	; 0x28b4 <vTaskDelayUntil+0x82>
    2888:	0b c0       	rjmp	.+22     	; 0x28a0 <vTaskDelayUntil+0x6e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    288a:	c8 17       	cp	r28, r24
    288c:	d9 07       	cpc	r29, r25
    288e:	c8 f0       	brcs	.+50     	; 0x28c2 <vTaskDelayUntil+0x90>
    2890:	80 91 86 05 	lds	r24, 0x0586
    2894:	90 91 87 05 	lds	r25, 0x0587
    2898:	8c 17       	cp	r24, r28
    289a:	9d 07       	cpc	r25, r29
    289c:	90 f0       	brcs	.+36     	; 0x28c2 <vTaskDelayUntil+0x90>
    289e:	15 c0       	rjmp	.+42     	; 0x28ca <vTaskDelayUntil+0x98>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    28a0:	80 91 7e 05 	lds	r24, 0x057E
    28a4:	90 91 7f 05 	lds	r25, 0x057F
    28a8:	02 96       	adiw	r24, 0x02	; 2
    28aa:	0e 94 b3 0b 	call	0x1766	; 0x1766 <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    28ae:	ce 01       	movw	r24, r28
    28b0:	0e 94 76 10 	call	0x20ec	; 0x20ec <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    28b4:	0e 94 28 13 	call	0x2650	; 0x2650 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    28b8:	88 23       	and	r24, r24
    28ba:	59 f4       	brne	.+22     	; 0x28d2 <vTaskDelayUntil+0xa0>
		{
			portYIELD_WITHIN_API();
    28bc:	0e 94 9f 0c 	call	0x193e	; 0x193e <vPortYield>
    28c0:	08 c0       	rjmp	.+16     	; 0x28d2 <vTaskDelayUntil+0xa0>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    28c2:	f8 01       	movw	r30, r16
    28c4:	d1 83       	std	Z+1, r29	; 0x01
    28c6:	c0 83       	st	Z, r28
    28c8:	eb cf       	rjmp	.-42     	; 0x28a0 <vTaskDelayUntil+0x6e>
    28ca:	f8 01       	movw	r30, r16
    28cc:	d1 83       	std	Z+1, r29	; 0x01
    28ce:	c0 83       	st	Z, r28
    28d0:	f1 cf       	rjmp	.-30     	; 0x28b4 <vTaskDelayUntil+0x82>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    28d2:	df 91       	pop	r29
    28d4:	cf 91       	pop	r28
    28d6:	1f 91       	pop	r17
    28d8:	0f 91       	pop	r16
    28da:	08 95       	ret

000028dc <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    28dc:	80 91 83 05 	lds	r24, 0x0583
    28e0:	88 23       	and	r24, r24
    28e2:	99 f4       	brne	.+38     	; 0x290a <vTaskSwitchContext+0x2e>
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    28e4:	80 91 85 05 	lds	r24, 0x0585
    28e8:	90 e0       	ldi	r25, 0x00	; 0
    28ea:	fc 01       	movw	r30, r24
    28ec:	ee 0f       	add	r30, r30
    28ee:	ff 1f       	adc	r31, r31
    28f0:	ee 0f       	add	r30, r30
    28f2:	ff 1f       	adc	r31, r31
    28f4:	ee 0f       	add	r30, r30
    28f6:	ff 1f       	adc	r31, r31
    28f8:	8e 0f       	add	r24, r30
    28fa:	9f 1f       	adc	r25, r31
    28fc:	fc 01       	movw	r30, r24
    28fe:	e0 57       	subi	r30, 0x70	; 112
    2900:	fa 4f       	sbci	r31, 0xFA	; 250
    2902:	80 81       	ld	r24, Z
    2904:	88 23       	and	r24, r24
    2906:	29 f0       	breq	.+10     	; 0x2912 <vTaskSwitchContext+0x36>
    2908:	1b c0       	rjmp	.+54     	; 0x2940 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    290a:	81 e0       	ldi	r24, 0x01	; 1
    290c:	80 93 81 05 	sts	0x0581, r24
    2910:	08 95       	ret
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    2912:	80 91 85 05 	lds	r24, 0x0585
    2916:	81 50       	subi	r24, 0x01	; 1
    2918:	80 93 85 05 	sts	0x0585, r24
    291c:	80 91 85 05 	lds	r24, 0x0585
    2920:	90 e0       	ldi	r25, 0x00	; 0
    2922:	fc 01       	movw	r30, r24
    2924:	ee 0f       	add	r30, r30
    2926:	ff 1f       	adc	r31, r31
    2928:	ee 0f       	add	r30, r30
    292a:	ff 1f       	adc	r31, r31
    292c:	ee 0f       	add	r30, r30
    292e:	ff 1f       	adc	r31, r31
    2930:	8e 0f       	add	r24, r30
    2932:	9f 1f       	adc	r25, r31
    2934:	fc 01       	movw	r30, r24
    2936:	e0 57       	subi	r30, 0x70	; 112
    2938:	fa 4f       	sbci	r31, 0xFA	; 250
    293a:	80 81       	ld	r24, Z
    293c:	88 23       	and	r24, r24
    293e:	49 f3       	breq	.-46     	; 0x2912 <vTaskSwitchContext+0x36>
    2940:	80 91 85 05 	lds	r24, 0x0585
    2944:	90 e0       	ldi	r25, 0x00	; 0
    2946:	fc 01       	movw	r30, r24
    2948:	ee 0f       	add	r30, r30
    294a:	ff 1f       	adc	r31, r31
    294c:	ee 0f       	add	r30, r30
    294e:	ff 1f       	adc	r31, r31
    2950:	ee 0f       	add	r30, r30
    2952:	ff 1f       	adc	r31, r31
    2954:	e8 0f       	add	r30, r24
    2956:	f9 1f       	adc	r31, r25
    2958:	e0 57       	subi	r30, 0x70	; 112
    295a:	fa 4f       	sbci	r31, 0xFA	; 250
    295c:	a1 81       	ldd	r26, Z+1	; 0x01
    295e:	b2 81       	ldd	r27, Z+2	; 0x02
    2960:	12 96       	adiw	r26, 0x02	; 2
    2962:	0d 90       	ld	r0, X+
    2964:	bc 91       	ld	r27, X
    2966:	a0 2d       	mov	r26, r0
    2968:	b2 83       	std	Z+2, r27	; 0x02
    296a:	a1 83       	std	Z+1, r26	; 0x01
    296c:	cf 01       	movw	r24, r30
    296e:	03 96       	adiw	r24, 0x03	; 3
    2970:	a8 17       	cp	r26, r24
    2972:	b9 07       	cpc	r27, r25
    2974:	31 f4       	brne	.+12     	; 0x2982 <vTaskSwitchContext+0xa6>
    2976:	12 96       	adiw	r26, 0x02	; 2
    2978:	8d 91       	ld	r24, X+
    297a:	9c 91       	ld	r25, X
    297c:	13 97       	sbiw	r26, 0x03	; 3
    297e:	92 83       	std	Z+2, r25	; 0x02
    2980:	81 83       	std	Z+1, r24	; 0x01
    2982:	01 80       	ldd	r0, Z+1	; 0x01
    2984:	f2 81       	ldd	r31, Z+2	; 0x02
    2986:	e0 2d       	mov	r30, r0
    2988:	86 81       	ldd	r24, Z+6	; 0x06
    298a:	97 81       	ldd	r25, Z+7	; 0x07
    298c:	90 93 7f 05 	sts	0x057F, r25
    2990:	80 93 7e 05 	sts	0x057E, r24
    2994:	08 95       	ret

00002996 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, uint16_t xTicksToWait )
{
    2996:	cf 93       	push	r28
    2998:	df 93       	push	r29
    299a:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    299c:	60 91 7e 05 	lds	r22, 0x057E
    29a0:	70 91 7f 05 	lds	r23, 0x057F
    29a4:	64 5f       	subi	r22, 0xF4	; 244
    29a6:	7f 4f       	sbci	r23, 0xFF	; 255
    29a8:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    29ac:	80 91 7e 05 	lds	r24, 0x057E
    29b0:	90 91 7f 05 	lds	r25, 0x057F
    29b4:	02 96       	adiw	r24, 0x02	; 2
    29b6:	0e 94 b3 0b 	call	0x1766	; 0x1766 <uxListRemove>
	}
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    29ba:	80 91 86 05 	lds	r24, 0x0586
    29be:	90 91 87 05 	lds	r25, 0x0587
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    29c2:	8c 0f       	add	r24, r28
    29c4:	9d 1f       	adc	r25, r29
    29c6:	0e 94 76 10 	call	0x20ec	; 0x20ec <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    29ca:	df 91       	pop	r29
    29cc:	cf 91       	pop	r28
    29ce:	08 95       	ret

000029d0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    29d0:	0f 93       	push	r16
    29d2:	1f 93       	push	r17
    29d4:	cf 93       	push	r28
    29d6:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    29d8:	dc 01       	movw	r26, r24
    29da:	15 96       	adiw	r26, 0x05	; 5
    29dc:	ed 91       	ld	r30, X+
    29de:	fc 91       	ld	r31, X
    29e0:	16 97       	sbiw	r26, 0x06	; 6
    29e2:	06 81       	ldd	r16, Z+6	; 0x06
    29e4:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    29e6:	e8 01       	movw	r28, r16
    29e8:	2c 96       	adiw	r28, 0x0c	; 12
    29ea:	ce 01       	movw	r24, r28
    29ec:	0e 94 b3 0b 	call	0x1766	; 0x1766 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    29f0:	80 91 83 05 	lds	r24, 0x0583
    29f4:	88 23       	and	r24, r24
    29f6:	e9 f4       	brne	.+58     	; 0x2a32 <xTaskRemoveFromEventList+0x62>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    29f8:	e8 01       	movw	r28, r16
    29fa:	22 96       	adiw	r28, 0x02	; 2
    29fc:	ce 01       	movw	r24, r28
    29fe:	0e 94 b3 0b 	call	0x1766	; 0x1766 <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    2a02:	f8 01       	movw	r30, r16
    2a04:	86 89       	ldd	r24, Z+22	; 0x16
    2a06:	90 91 85 05 	lds	r25, 0x0585
    2a0a:	98 17       	cp	r25, r24
    2a0c:	10 f4       	brcc	.+4      	; 0x2a12 <xTaskRemoveFromEventList+0x42>
    2a0e:	80 93 85 05 	sts	0x0585, r24
    2a12:	90 e0       	ldi	r25, 0x00	; 0
    2a14:	9c 01       	movw	r18, r24
    2a16:	22 0f       	add	r18, r18
    2a18:	33 1f       	adc	r19, r19
    2a1a:	22 0f       	add	r18, r18
    2a1c:	33 1f       	adc	r19, r19
    2a1e:	22 0f       	add	r18, r18
    2a20:	33 1f       	adc	r19, r19
    2a22:	82 0f       	add	r24, r18
    2a24:	93 1f       	adc	r25, r19
    2a26:	80 57       	subi	r24, 0x70	; 112
    2a28:	9a 4f       	sbci	r25, 0xFA	; 250
    2a2a:	be 01       	movw	r22, r28
    2a2c:	0e 94 40 0b 	call	0x1680	; 0x1680 <vListInsertEnd>
    2a30:	05 c0       	rjmp	.+10     	; 0x2a3c <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    2a32:	86 ec       	ldi	r24, 0xC6	; 198
    2a34:	95 e0       	ldi	r25, 0x05	; 5
    2a36:	be 01       	movw	r22, r28
    2a38:	0e 94 40 0b 	call	0x1680	; 0x1680 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2a3c:	e0 91 7e 05 	lds	r30, 0x057E
    2a40:	f0 91 7f 05 	lds	r31, 0x057F
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    2a44:	81 e0       	ldi	r24, 0x01	; 1
    2a46:	d8 01       	movw	r26, r16
    2a48:	56 96       	adiw	r26, 0x16	; 22
    2a4a:	2c 91       	ld	r18, X
    2a4c:	56 97       	sbiw	r26, 0x16	; 22
    2a4e:	96 89       	ldd	r25, Z+22	; 0x16
    2a50:	29 17       	cp	r18, r25
    2a52:	08 f4       	brcc	.+2      	; 0x2a56 <xTaskRemoveFromEventList+0x86>
    2a54:	80 e0       	ldi	r24, 0x00	; 0
}
    2a56:	df 91       	pop	r29
    2a58:	cf 91       	pop	r28
    2a5a:	1f 91       	pop	r17
    2a5c:	0f 91       	pop	r16
    2a5e:	08 95       	ret

00002a60 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    2a60:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2a62:	80 91 80 05 	lds	r24, 0x0580
    2a66:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    2a68:	40 91 86 05 	lds	r20, 0x0586
    2a6c:	50 91 87 05 	lds	r21, 0x0587
    2a70:	60 e0       	ldi	r22, 0x00	; 0
    2a72:	70 e0       	ldi	r23, 0x00	; 0
    2a74:	41 83       	std	Z+1, r20	; 0x01
    2a76:	52 83       	std	Z+2, r21	; 0x02
    2a78:	63 83       	std	Z+3, r22	; 0x03
    2a7a:	74 83       	std	Z+4, r23	; 0x04
}
    2a7c:	08 95       	ret

00002a7e <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, uint16_t * const pxTicksToWait )
{
    2a7e:	fc 01       	movw	r30, r24
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2a80:	0f b6       	in	r0, 0x3f	; 63
    2a82:	f8 94       	cli
    2a84:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( uint16_t ) xTickCount >= ( uint16_t ) pxTimeOut->xTimeOnEntering ) )
    2a86:	80 91 80 05 	lds	r24, 0x0580
    2a8a:	90 81       	ld	r25, Z
    2a8c:	98 17       	cp	r25, r24
    2a8e:	49 f0       	breq	.+18     	; 0x2aa2 <xTaskCheckForTimeOut+0x24>
    2a90:	80 91 86 05 	lds	r24, 0x0586
    2a94:	90 91 87 05 	lds	r25, 0x0587
    2a98:	21 81       	ldd	r18, Z+1	; 0x01
    2a9a:	32 81       	ldd	r19, Z+2	; 0x02
    2a9c:	82 17       	cp	r24, r18
    2a9e:	93 07       	cpc	r25, r19
    2aa0:	f0 f4       	brcc	.+60     	; 0x2ade <xTaskCheckForTimeOut+0x60>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( uint16_t ) ( ( uint16_t ) xTickCount - ( uint16_t ) pxTimeOut->xTimeOnEntering ) ) < ( uint16_t ) *pxTicksToWait )
    2aa2:	80 91 86 05 	lds	r24, 0x0586
    2aa6:	90 91 87 05 	lds	r25, 0x0587
    2aaa:	21 81       	ldd	r18, Z+1	; 0x01
    2aac:	32 81       	ldd	r19, Z+2	; 0x02
    2aae:	db 01       	movw	r26, r22
    2ab0:	4d 91       	ld	r20, X+
    2ab2:	5c 91       	ld	r21, X
    2ab4:	11 97       	sbiw	r26, 0x01	; 1
    2ab6:	82 1b       	sub	r24, r18
    2ab8:	93 0b       	sbc	r25, r19
    2aba:	84 17       	cp	r24, r20
    2abc:	95 07       	cpc	r25, r21
    2abe:	88 f4       	brcc	.+34     	; 0x2ae2 <xTaskCheckForTimeOut+0x64>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( uint16_t ) xTickCount - ( uint16_t ) pxTimeOut->xTimeOnEntering );
    2ac0:	80 91 86 05 	lds	r24, 0x0586
    2ac4:	90 91 87 05 	lds	r25, 0x0587
    2ac8:	28 1b       	sub	r18, r24
    2aca:	39 0b       	sbc	r19, r25
    2acc:	24 0f       	add	r18, r20
    2ace:	35 1f       	adc	r19, r21
    2ad0:	2d 93       	st	X+, r18
    2ad2:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    2ad4:	cf 01       	movw	r24, r30
    2ad6:	0e 94 30 15 	call	0x2a60	; 0x2a60 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2ada:	80 e0       	ldi	r24, 0x00	; 0
    2adc:	03 c0       	rjmp	.+6      	; 0x2ae4 <xTaskCheckForTimeOut+0x66>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2ade:	81 e0       	ldi	r24, 0x01	; 1
    2ae0:	01 c0       	rjmp	.+2      	; 0x2ae4 <xTaskCheckForTimeOut+0x66>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2ae2:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    2ae4:	0f 90       	pop	r0
    2ae6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2ae8:	08 95       	ret

00002aea <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    2aea:	81 e0       	ldi	r24, 0x01	; 1
    2aec:	80 93 81 05 	sts	0x0581, r24
}
    2af0:	08 95       	ret

00002af2 <executeCommunicationTask>:
    xTaskCreate( executeCommunicationTask, ( signed char * ) "commTask", sysCommunicationTaskSTACK_SIZE,  ( void * ) taskParams , uxPriority, ( xTaskHandle * ) NULL );
}


static portTASK_FUNCTION( executeCommunicationTask, pvParameters )
{
    2af2:	cf 93       	push	r28
    2af4:	df 93       	push	r29
    2af6:	00 d0       	rcall	.+0      	; 0x2af8 <executeCommunicationTask+0x6>
    2af8:	00 d0       	rcall	.+0      	; 0x2afa <executeCommunicationTask+0x8>
    2afa:	cd b7       	in	r28, 0x3d	; 61
    2afc:	de b7       	in	r29, 0x3e	; 62
    uint8_t successFlag=0;
    
    taskParams = ( communicationTaskParameters * ) pvParameters;
        
    //Initialize the wake up time with the current time
    xLastWakeUpTime = xTaskGetTickCount();    
    2afe:	0e 94 47 12 	call	0x248e	; 0x248e <xTaskGetTickCount>
    2b02:	a0 e0       	ldi	r26, 0x00	; 0
    2b04:	b0 e0       	ldi	r27, 0x00	; 0
    2b06:	89 83       	std	Y+1, r24	; 0x01
    2b08:	9a 83       	std	Y+2, r25	; 0x02
    2b0a:	ab 83       	std	Y+3, r26	; 0x03
    2b0c:	bc 83       	std	Y+4, r27	; 0x04
    
    for(;;)
    {
        vTaskDelayUntil( &xLastWakeUpTime, COMMUNICATION_TASK_CYCLE );
    2b0e:	ce 01       	movw	r24, r28
    2b10:	01 96       	adiw	r24, 0x01	; 1
    2b12:	64 ef       	ldi	r22, 0xF4	; 244
    2b14:	71 e0       	ldi	r23, 0x01	; 1
    2b16:	0e 94 19 14 	call	0x2832	; 0x2832 <vTaskDelayUntil>
    2b1a:	f9 cf       	rjmp	.-14     	; 0x2b0e <executeCommunicationTask+0x1c>

00002b1c <startCommunicationTask>:
*/
static portBASE_TYPE xCommunicationTaskStatus = pdPASS;


void startCommunicationTask( unsigned portBASE_TYPE uxPriority, xQueueHandle* measQueue )
{  
    2b1c:	af 92       	push	r10
    2b1e:	bf 92       	push	r11
    2b20:	cf 92       	push	r12
    2b22:	df 92       	push	r13
    2b24:	ef 92       	push	r14
    2b26:	ff 92       	push	r15
    2b28:	0f 93       	push	r16
    2b2a:	cf 93       	push	r28
    2b2c:	df 93       	push	r29
    2b2e:	08 2f       	mov	r16, r24
    2b30:	eb 01       	movw	r28, r22
    adcInit();
    2b32:	0e 94 fc 06 	call	0xdf8	; 0xdf8 <adcInit>
        
    //Set high side driver pins to outputs
    DDRC |= ( (1<<PC6) | (1<<PC7) );    
    2b36:	84 b3       	in	r24, 0x14	; 20
    2b38:	80 6c       	ori	r24, 0xC0	; 192
    2b3a:	84 bb       	out	0x14, r24	; 20
    //switch on high side driver
    PORTC |=  ( (1<<PC6) | (1<<PC7) );       
    2b3c:	85 b3       	in	r24, 0x15	; 21
    2b3e:	80 6c       	ori	r24, 0xC0	; 192
    2b40:	85 bb       	out	0x15, r24	; 21
        
    //create task parameter
    communicationTaskParameters *taskParams;
    taskParams = ( communicationTaskParameters * ) pvPortMalloc( sizeof( communicationTaskParameters ) );
    2b42:	82 e0       	ldi	r24, 0x02	; 2
    2b44:	90 e0       	ldi	r25, 0x00	; 0
    2b46:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <pvPortMalloc>
    2b4a:	9c 01       	movw	r18, r24
    taskParams->measurementQueue = *measQueue;
    2b4c:	88 81       	ld	r24, Y
    2b4e:	99 81       	ldd	r25, Y+1	; 0x01
    2b50:	f9 01       	movw	r30, r18
    2b52:	91 83       	std	Z+1, r25	; 0x01
    2b54:	80 83       	st	Z, r24
    //taskParams->statusQueue = *statQueue;
    
    xTaskCreate( executeCommunicationTask, ( signed char * ) "commTask", sysCommunicationTaskSTACK_SIZE,  ( void * ) taskParams , uxPriority, ( xTaskHandle * ) NULL );
    2b56:	89 e7       	ldi	r24, 0x79	; 121
    2b58:	95 e1       	ldi	r25, 0x15	; 21
    2b5a:	67 e6       	ldi	r22, 0x67	; 103
    2b5c:	70 e0       	ldi	r23, 0x00	; 0
    2b5e:	45 e5       	ldi	r20, 0x55	; 85
    2b60:	50 e0       	ldi	r21, 0x00	; 0
    2b62:	ee 24       	eor	r14, r14
    2b64:	ff 24       	eor	r15, r15
    2b66:	cc 24       	eor	r12, r12
    2b68:	dd 24       	eor	r13, r13
    2b6a:	aa 24       	eor	r10, r10
    2b6c:	bb 24       	eor	r11, r11
    2b6e:	0e 94 ad 10 	call	0x215a	; 0x215a <xTaskGenericCreate>
}
    2b72:	df 91       	pop	r29
    2b74:	cf 91       	pop	r28
    2b76:	0f 91       	pop	r16
    2b78:	ff 90       	pop	r15
    2b7a:	ef 90       	pop	r14
    2b7c:	df 90       	pop	r13
    2b7e:	cf 90       	pop	r12
    2b80:	bf 90       	pop	r11
    2b82:	af 90       	pop	r10
    2b84:	08 95       	ret

00002b86 <xIsCommunicationTaskStillRunning>:
	{
		xReturn = pdPASS;
	}

	return xReturn;
    2b86:	81 e0       	ldi	r24, 0x01	; 1
    2b88:	08 95       	ret

00002b8a <executeNavigatorTask>:
    xTaskCreate( executeNavigatorTask, ( signed char * ) "NavTask", sysNavigatorTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
}


static portTASK_FUNCTION( executeNavigatorTask, pvParameters )
{
    2b8a:	cf 93       	push	r28
    2b8c:	df 93       	push	r29
    2b8e:	00 d0       	rcall	.+0      	; 0x2b90 <executeNavigatorTask+0x6>
    2b90:	00 d0       	rcall	.+0      	; 0x2b92 <executeNavigatorTask+0x8>
    2b92:	cd b7       	in	r28, 0x3d	; 61
    2b94:	de b7       	in	r29, 0x3e	; 62
    uint32_t xLastWakeUpTime;

    //Initialize the wake up time with the current time
    xLastWakeUpTime = xTaskGetTickCount();
    2b96:	0e 94 47 12 	call	0x248e	; 0x248e <xTaskGetTickCount>
    2b9a:	a0 e0       	ldi	r26, 0x00	; 0
    2b9c:	b0 e0       	ldi	r27, 0x00	; 0
    2b9e:	89 83       	std	Y+1, r24	; 0x01
    2ba0:	9a 83       	std	Y+2, r25	; 0x02
    2ba2:	ab 83       	std	Y+3, r26	; 0x03
    2ba4:	bc 83       	std	Y+4, r27	; 0x04

    for(;;)
    {
        //Execute this task each 50ms
        vTaskDelayUntil( &xLastWakeUpTime, NAVIGATOR_TASK_CYCLE );
    2ba6:	ce 01       	movw	r24, r28
    2ba8:	01 96       	adiw	r24, 0x01	; 1
    2baa:	64 e6       	ldi	r22, 0x64	; 100
    2bac:	70 e0       	ldi	r23, 0x00	; 0
    2bae:	0e 94 19 14 	call	0x2832	; 0x2832 <vTaskDelayUntil>
    2bb2:	f9 cf       	rjmp	.-14     	; 0x2ba6 <executeNavigatorTask+0x1c>

00002bb4 <startNavigatorTask>:
   Used to signal an error condition inside this task
*/
static portBASE_TYPE xNavigatorTaskStatus = pdPASS;

void startNavigatorTask( unsigned portBASE_TYPE uxPriority, xQueueHandle *statQueue )
{
    2bb4:	af 92       	push	r10
    2bb6:	bf 92       	push	r11
    2bb8:	cf 92       	push	r12
    2bba:	df 92       	push	r13
    2bbc:	ef 92       	push	r14
    2bbe:	ff 92       	push	r15
    2bc0:	0f 93       	push	r16
    2bc2:	cf 93       	push	r28
    2bc4:	df 93       	push	r29
    2bc6:	08 2f       	mov	r16, r24
    2bc8:	eb 01       	movw	r28, r22
    //set pins PB0 (green LED) & PB1 (red LED) to outputs
    DDRB |= ( (1<<PB0) | (1<<PB1) );
    2bca:	87 b3       	in	r24, 0x17	; 23
    2bcc:	83 60       	ori	r24, 0x03	; 3
    2bce:	87 bb       	out	0x17, r24	; 23
    
    navigatorTaskParameters *taskParams;
    taskParams = ( navigatorTaskParameters * ) pvPortMalloc( sizeof( navigatorTaskParameters ) );
    2bd0:	82 e0       	ldi	r24, 0x02	; 2
    2bd2:	90 e0       	ldi	r25, 0x00	; 0
    2bd4:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <pvPortMalloc>
    2bd8:	9c 01       	movw	r18, r24
    taskParams->statusQueue = *statQueue;
    2bda:	88 81       	ld	r24, Y
    2bdc:	99 81       	ldd	r25, Y+1	; 0x01
    2bde:	f9 01       	movw	r30, r18
    2be0:	91 83       	std	Z+1, r25	; 0x01
    2be2:	80 83       	st	Z, r24

    xTaskCreate( executeNavigatorTask, ( signed char * ) "NavTask", sysNavigatorTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
    2be4:	85 ec       	ldi	r24, 0xC5	; 197
    2be6:	95 e1       	ldi	r25, 0x15	; 21
    2be8:	60 e7       	ldi	r22, 0x70	; 112
    2bea:	70 e0       	ldi	r23, 0x00	; 0
    2bec:	45 e5       	ldi	r20, 0x55	; 85
    2bee:	50 e0       	ldi	r21, 0x00	; 0
    2bf0:	ee 24       	eor	r14, r14
    2bf2:	ff 24       	eor	r15, r15
    2bf4:	cc 24       	eor	r12, r12
    2bf6:	dd 24       	eor	r13, r13
    2bf8:	aa 24       	eor	r10, r10
    2bfa:	bb 24       	eor	r11, r11
    2bfc:	0e 94 ad 10 	call	0x215a	; 0x215a <xTaskGenericCreate>
}
    2c00:	df 91       	pop	r29
    2c02:	cf 91       	pop	r28
    2c04:	0f 91       	pop	r16
    2c06:	ff 90       	pop	r15
    2c08:	ef 90       	pop	r14
    2c0a:	df 90       	pop	r13
    2c0c:	cf 90       	pop	r12
    2c0e:	bf 90       	pop	r11
    2c10:	af 90       	pop	r10
    2c12:	08 95       	ret

00002c14 <xIsNavigatorTaskStillRunning>:
    {
        xReturn = pdPASS;
    }

    return xReturn;
    2c14:	81 e0       	ldi	r24, 0x01	; 1
    2c16:	08 95       	ret

00002c18 <executeSensorTask>:
    xTaskCreate( executeSensorTask, ( signed char * ) "SensorTask", sysSensorTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
}


static portTASK_FUNCTION( executeSensorTask, pvParameters )
{
    2c18:	cf 93       	push	r28
    2c1a:	df 93       	push	r29
    2c1c:	00 d0       	rcall	.+0      	; 0x2c1e <executeSensorTask+0x6>
    2c1e:	00 d0       	rcall	.+0      	; 0x2c20 <executeSensorTask+0x8>
    2c20:	cd b7       	in	r28, 0x3d	; 61
    2c22:	de b7       	in	r29, 0x3e	; 62
    uint32_t xLastWakeUpTime;
    uint16_t ledCycleCounter = 0;
    
    //Initialize the wake up time with the current time
    xLastWakeUpTime = xTaskGetTickCount();
    2c24:	0e 94 47 12 	call	0x248e	; 0x248e <xTaskGetTickCount>
    2c28:	a0 e0       	ldi	r26, 0x00	; 0
    2c2a:	b0 e0       	ldi	r27, 0x00	; 0
    2c2c:	89 83       	std	Y+1, r24	; 0x01
    2c2e:	9a 83       	std	Y+2, r25	; 0x02
    2c30:	ab 83       	std	Y+3, r26	; 0x03
    2c32:	bc 83       	std	Y+4, r27	; 0x04


static portTASK_FUNCTION( executeSensorTask, pvParameters )
{
    uint32_t xLastWakeUpTime;
    uint16_t ledCycleCounter = 0;
    2c34:	00 e0       	ldi	r16, 0x00	; 0
    2c36:	10 e0       	ldi	r17, 0x00	; 0
{
    static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xIsCommunicationTaskStillRunning() != pdTRUE )
	{
		xErrorHasOccurred = pdTRUE;
    2c38:	ff 24       	eor	r15, r15
    2c3a:	f3 94       	inc	r15
        {
            //signal error condition
        }

        //toogle the green led each 500ms
        if( ledCycleCounter % GREEN_LED_TOGGLE_CYCLE == 0 )
    2c3c:	0f 2e       	mov	r0, r31
    2c3e:	f4 ef       	ldi	r31, 0xF4	; 244
    2c40:	cf 2e       	mov	r12, r31
    2c42:	f1 e0       	ldi	r31, 0x01	; 1
    2c44:	df 2e       	mov	r13, r31
    2c46:	f0 2d       	mov	r31, r0
            PORTA ^= (1<<PA7);
        }
        
        if( ledCycleCounter > 65000 )
        {
            ledCycleCounter = 0;
    2c48:	aa 24       	eor	r10, r10
    2c4a:	bb 24       	eor	r11, r11
    2c4c:	01 c0       	rjmp	.+2      	; 0x2c50 <executeSensorTask+0x38>
    2c4e:	85 01       	movw	r16, r10
    xLastWakeUpTime = xTaskGetTickCount();

    for(;;)
    {
        //Execute this task each 50ms
        vTaskDelayUntil( &xLastWakeUpTime, SENSOR_TASK_CYCLE );
    2c50:	ce 01       	movw	r24, r28
    2c52:	01 96       	adiw	r24, 0x01	; 1
    2c54:	64 e6       	ldi	r22, 0x64	; 100
    2c56:	70 e0       	ldi	r23, 0x00	; 0
    2c58:	0e 94 19 14 	call	0x2832	; 0x2832 <vTaskDelayUntil>

        ledCycleCounter += 50;
    2c5c:	0e 5c       	subi	r16, 0xCE	; 206
    2c5e:	1f 4f       	sbci	r17, 0xFF	; 255
 */
static portBASE_TYPE prvCheckOtherTasksAreStillRunning( void )
{
    static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xIsCommunicationTaskStillRunning() != pdTRUE )
    2c60:	0e 94 c3 15 	call	0x2b86	; 0x2b86 <xIsCommunicationTaskStillRunning>
    2c64:	81 30       	cpi	r24, 0x01	; 1
    2c66:	11 f0       	breq	.+4      	; 0x2c6c <executeSensorTask+0x54>
	{
		xErrorHasOccurred = pdTRUE;
    2c68:	f0 92 d8 05 	sts	0x05D8, r15
	}

	if( xIsOperatorTaskStillRunning() != pdTRUE )
    2c6c:	0e 94 c1 16 	call	0x2d82	; 0x2d82 <xIsOperatorTaskStillRunning>
    2c70:	81 30       	cpi	r24, 0x01	; 1
    2c72:	11 f0       	breq	.+4      	; 0x2c78 <executeSensorTask+0x60>
	{
		xErrorHasOccurred = pdTRUE;
    2c74:	f0 92 d8 05 	sts	0x05D8, r15
	}

	if( xIsNavigatorTaskStillRunning() != pdTRUE )
    2c78:	0e 94 0a 16 	call	0x2c14	; 0x2c14 <xIsNavigatorTaskStillRunning>
    2c7c:	81 30       	cpi	r24, 0x01	; 1
    2c7e:	91 05       	cpc	r25, r1
    2c80:	11 f0       	breq	.+4      	; 0x2c86 <executeSensorTask+0x6e>
	{
    	xErrorHasOccurred = pdTRUE;
    2c82:	f0 92 d8 05 	sts	0x05D8, r15
        {
            //signal error condition
        }

        //toogle the green led each 500ms
        if( ledCycleCounter % GREEN_LED_TOGGLE_CYCLE == 0 )
    2c86:	c8 01       	movw	r24, r16
    2c88:	b6 01       	movw	r22, r12
    2c8a:	0e 94 71 1a 	call	0x34e2	; 0x34e2 <__udivmodhi4>
    2c8e:	00 97       	sbiw	r24, 0x00	; 0
    2c90:	19 f4       	brne	.+6      	; 0x2c98 <executeSensorTask+0x80>
        {
            PORTA ^= (1<<PA7);
    2c92:	8b b3       	in	r24, 0x1b	; 27
    2c94:	80 58       	subi	r24, 0x80	; 128
    2c96:	8b bb       	out	0x1b, r24	; 27
        }
        
        if( ledCycleCounter > 65000 )
    2c98:	8d ef       	ldi	r24, 0xFD	; 253
    2c9a:	09 3e       	cpi	r16, 0xE9	; 233
    2c9c:	18 07       	cpc	r17, r24
    2c9e:	b8 f6       	brcc	.-82     	; 0x2c4e <executeSensorTask+0x36>
    2ca0:	d7 cf       	rjmp	.-82     	; 0x2c50 <executeSensorTask+0x38>

00002ca2 <startSensorTask>:

static portBASE_TYPE prvCheckOtherTasksAreStillRunning( void );


void startSensorTask( unsigned portBASE_TYPE uxPriority, xQueueHandle *statQueue )
{
    2ca2:	af 92       	push	r10
    2ca4:	bf 92       	push	r11
    2ca6:	cf 92       	push	r12
    2ca8:	df 92       	push	r13
    2caa:	ef 92       	push	r14
    2cac:	ff 92       	push	r15
    2cae:	0f 93       	push	r16
    2cb0:	cf 93       	push	r28
    2cb2:	df 93       	push	r29
    2cb4:	08 2f       	mov	r16, r24
    2cb6:	eb 01       	movw	r28, r22
    //set pin PA7 (green LED) to be an output
    DDRA |= (1<<PA7);
    2cb8:	d7 9a       	sbi	0x1a, 7	; 26
    
    sensorTaskParameters *taskParams;
    taskParams = ( sensorTaskParameters * ) pvPortMalloc( sizeof( sensorTaskParameters ) );
    2cba:	82 e0       	ldi	r24, 0x02	; 2
    2cbc:	90 e0       	ldi	r25, 0x00	; 0
    2cbe:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <pvPortMalloc>
    2cc2:	9c 01       	movw	r18, r24
    taskParams->statusQueue = *statQueue;
    2cc4:	88 81       	ld	r24, Y
    2cc6:	99 81       	ldd	r25, Y+1	; 0x01
    2cc8:	f9 01       	movw	r30, r18
    2cca:	91 83       	std	Z+1, r25	; 0x01
    2ccc:	80 83       	st	Z, r24

    xTaskCreate( executeSensorTask, ( signed char * ) "SensorTask", sysSensorTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
    2cce:	8c e0       	ldi	r24, 0x0C	; 12
    2cd0:	96 e1       	ldi	r25, 0x16	; 22
    2cd2:	68 e7       	ldi	r22, 0x78	; 120
    2cd4:	70 e0       	ldi	r23, 0x00	; 0
    2cd6:	45 e5       	ldi	r20, 0x55	; 85
    2cd8:	50 e0       	ldi	r21, 0x00	; 0
    2cda:	ee 24       	eor	r14, r14
    2cdc:	ff 24       	eor	r15, r15
    2cde:	cc 24       	eor	r12, r12
    2ce0:	dd 24       	eor	r13, r13
    2ce2:	aa 24       	eor	r10, r10
    2ce4:	bb 24       	eor	r11, r11
    2ce6:	0e 94 ad 10 	call	0x215a	; 0x215a <xTaskGenericCreate>
}
    2cea:	df 91       	pop	r29
    2cec:	cf 91       	pop	r28
    2cee:	0f 91       	pop	r16
    2cf0:	ff 90       	pop	r15
    2cf2:	ef 90       	pop	r14
    2cf4:	df 90       	pop	r13
    2cf6:	cf 90       	pop	r12
    2cf8:	bf 90       	pop	r11
    2cfa:	af 90       	pop	r10
    2cfc:	08 95       	ret

00002cfe <executeOperatorTask>:
    xTaskCreate( executeOperatorTask, ( signed char * ) "opTask", sysOperatorTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
}


static portTASK_FUNCTION( executeOperatorTask, pvParameters )
{
    2cfe:	cf 93       	push	r28
    2d00:	df 93       	push	r29
    2d02:	00 d0       	rcall	.+0      	; 0x2d04 <executeOperatorTask+0x6>
    2d04:	00 d0       	rcall	.+0      	; 0x2d06 <executeOperatorTask+0x8>
    2d06:	cd b7       	in	r28, 0x3d	; 61
    2d08:	de b7       	in	r29, 0x3e	; 62
    operatorTaskParameters *taskParams;
    
    taskParams = ( operatorTaskParameters * ) pvParameters;
    
    //Initialize the wake up time with the current time
    xLastWakeUpTime = xTaskGetTickCount();
    2d0a:	0e 94 47 12 	call	0x248e	; 0x248e <xTaskGetTickCount>
    2d0e:	a0 e0       	ldi	r26, 0x00	; 0
    2d10:	b0 e0       	ldi	r27, 0x00	; 0
    2d12:	89 83       	std	Y+1, r24	; 0x01
    2d14:	9a 83       	std	Y+2, r25	; 0x02
    2d16:	ab 83       	std	Y+3, r26	; 0x03
    2d18:	bc 83       	std	Y+4, r27	; 0x04
    
    for(;;)
    {
        
        //Execute this task each 15ms
        vTaskDelayUntil( &xLastWakeUpTime, OPERATOR_TASK_CYCLE );
    2d1a:	ce 01       	movw	r24, r28
    2d1c:	01 96       	adiw	r24, 0x01	; 1
    2d1e:	6f e0       	ldi	r22, 0x0F	; 15
    2d20:	70 e0       	ldi	r23, 0x00	; 0
    2d22:	0e 94 19 14 	call	0x2832	; 0x2832 <vTaskDelayUntil>
    2d26:	f9 cf       	rjmp	.-14     	; 0x2d1a <executeOperatorTask+0x1c>

00002d28 <startOperatorTask>:
   Used to signal an error condition inside this task
*/
static portBASE_TYPE xOperatorTaskStatus = pdPASS;

void startOperatorTask( unsigned portBASE_TYPE uxPriority, xQueueHandle *measQueue )
{
    2d28:	af 92       	push	r10
    2d2a:	bf 92       	push	r11
    2d2c:	cf 92       	push	r12
    2d2e:	df 92       	push	r13
    2d30:	ef 92       	push	r14
    2d32:	ff 92       	push	r15
    2d34:	0f 93       	push	r16
    2d36:	cf 93       	push	r28
    2d38:	df 93       	push	r29
    2d3a:	08 2f       	mov	r16, r24
    2d3c:	eb 01       	movw	r28, r22
    operatorTaskParameters *taskParams;
    taskParams = ( operatorTaskParameters * ) pvPortMalloc( sizeof( operatorTaskParameters ) );
    2d3e:	82 e0       	ldi	r24, 0x02	; 2
    2d40:	90 e0       	ldi	r25, 0x00	; 0
    2d42:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <pvPortMalloc>
    2d46:	9c 01       	movw	r18, r24
    taskParams->measurementQueue = *measQueue;
    2d48:	88 81       	ld	r24, Y
    2d4a:	99 81       	ldd	r25, Y+1	; 0x01
    2d4c:	f9 01       	movw	r30, r18
    2d4e:	91 83       	std	Z+1, r25	; 0x01
    2d50:	80 83       	st	Z, r24
    
    xTaskCreate( executeOperatorTask, ( signed char * ) "opTask", sysOperatorTaskSTACK_SIZE, ( void * ) taskParams, uxPriority, ( xTaskHandle * ) NULL );
    2d52:	8f e7       	ldi	r24, 0x7F	; 127
    2d54:	96 e1       	ldi	r25, 0x16	; 22
    2d56:	63 e8       	ldi	r22, 0x83	; 131
    2d58:	70 e0       	ldi	r23, 0x00	; 0
    2d5a:	45 e5       	ldi	r20, 0x55	; 85
    2d5c:	50 e0       	ldi	r21, 0x00	; 0
    2d5e:	ee 24       	eor	r14, r14
    2d60:	ff 24       	eor	r15, r15
    2d62:	cc 24       	eor	r12, r12
    2d64:	dd 24       	eor	r13, r13
    2d66:	aa 24       	eor	r10, r10
    2d68:	bb 24       	eor	r11, r11
    2d6a:	0e 94 ad 10 	call	0x215a	; 0x215a <xTaskGenericCreate>
}
    2d6e:	df 91       	pop	r29
    2d70:	cf 91       	pop	r28
    2d72:	0f 91       	pop	r16
    2d74:	ff 90       	pop	r15
    2d76:	ef 90       	pop	r14
    2d78:	df 90       	pop	r13
    2d7a:	cf 90       	pop	r12
    2d7c:	bf 90       	pop	r11
    2d7e:	af 90       	pop	r10
    2d80:	08 95       	ret

00002d82 <xIsOperatorTaskStillRunning>:
    {
        xReturn = pdPASS;
    }

    return xReturn;
    2d82:	81 e0       	ldi	r24, 0x01	; 1
    2d84:	08 95       	ret

00002d86 <__subsf3>:
    2d86:	50 58       	subi	r21, 0x80	; 128

00002d88 <__addsf3>:
    2d88:	bb 27       	eor	r27, r27
    2d8a:	aa 27       	eor	r26, r26
    2d8c:	0e d0       	rcall	.+28     	; 0x2daa <__addsf3x>
    2d8e:	4d c1       	rjmp	.+666    	; 0x302a <__fp_round>
    2d90:	3e d1       	rcall	.+636    	; 0x300e <__fp_pscA>
    2d92:	30 f0       	brcs	.+12     	; 0x2da0 <__addsf3+0x18>
    2d94:	43 d1       	rcall	.+646    	; 0x301c <__fp_pscB>
    2d96:	20 f0       	brcs	.+8      	; 0x2da0 <__addsf3+0x18>
    2d98:	31 f4       	brne	.+12     	; 0x2da6 <__addsf3+0x1e>
    2d9a:	9f 3f       	cpi	r25, 0xFF	; 255
    2d9c:	11 f4       	brne	.+4      	; 0x2da2 <__addsf3+0x1a>
    2d9e:	1e f4       	brtc	.+6      	; 0x2da6 <__addsf3+0x1e>
    2da0:	33 c1       	rjmp	.+614    	; 0x3008 <__fp_nan>
    2da2:	0e f4       	brtc	.+2      	; 0x2da6 <__addsf3+0x1e>
    2da4:	e0 95       	com	r30
    2da6:	e7 fb       	bst	r30, 7
    2da8:	29 c1       	rjmp	.+594    	; 0x2ffc <__fp_inf>

00002daa <__addsf3x>:
    2daa:	e9 2f       	mov	r30, r25
    2dac:	4f d1       	rcall	.+670    	; 0x304c <__fp_split3>
    2dae:	80 f3       	brcs	.-32     	; 0x2d90 <__addsf3+0x8>
    2db0:	ba 17       	cp	r27, r26
    2db2:	62 07       	cpc	r22, r18
    2db4:	73 07       	cpc	r23, r19
    2db6:	84 07       	cpc	r24, r20
    2db8:	95 07       	cpc	r25, r21
    2dba:	18 f0       	brcs	.+6      	; 0x2dc2 <__addsf3x+0x18>
    2dbc:	71 f4       	brne	.+28     	; 0x2dda <__addsf3x+0x30>
    2dbe:	9e f5       	brtc	.+102    	; 0x2e26 <__addsf3x+0x7c>
    2dc0:	67 c1       	rjmp	.+718    	; 0x3090 <__fp_zero>
    2dc2:	0e f4       	brtc	.+2      	; 0x2dc6 <__addsf3x+0x1c>
    2dc4:	e0 95       	com	r30
    2dc6:	0b 2e       	mov	r0, r27
    2dc8:	ba 2f       	mov	r27, r26
    2dca:	a0 2d       	mov	r26, r0
    2dcc:	0b 01       	movw	r0, r22
    2dce:	b9 01       	movw	r22, r18
    2dd0:	90 01       	movw	r18, r0
    2dd2:	0c 01       	movw	r0, r24
    2dd4:	ca 01       	movw	r24, r20
    2dd6:	a0 01       	movw	r20, r0
    2dd8:	11 24       	eor	r1, r1
    2dda:	ff 27       	eor	r31, r31
    2ddc:	59 1b       	sub	r21, r25
    2dde:	99 f0       	breq	.+38     	; 0x2e06 <__addsf3x+0x5c>
    2de0:	59 3f       	cpi	r21, 0xF9	; 249
    2de2:	50 f4       	brcc	.+20     	; 0x2df8 <__addsf3x+0x4e>
    2de4:	50 3e       	cpi	r21, 0xE0	; 224
    2de6:	68 f1       	brcs	.+90     	; 0x2e42 <__addsf3x+0x98>
    2de8:	1a 16       	cp	r1, r26
    2dea:	f0 40       	sbci	r31, 0x00	; 0
    2dec:	a2 2f       	mov	r26, r18
    2dee:	23 2f       	mov	r18, r19
    2df0:	34 2f       	mov	r19, r20
    2df2:	44 27       	eor	r20, r20
    2df4:	58 5f       	subi	r21, 0xF8	; 248
    2df6:	f3 cf       	rjmp	.-26     	; 0x2dde <__addsf3x+0x34>
    2df8:	46 95       	lsr	r20
    2dfa:	37 95       	ror	r19
    2dfc:	27 95       	ror	r18
    2dfe:	a7 95       	ror	r26
    2e00:	f0 40       	sbci	r31, 0x00	; 0
    2e02:	53 95       	inc	r21
    2e04:	c9 f7       	brne	.-14     	; 0x2df8 <__addsf3x+0x4e>
    2e06:	7e f4       	brtc	.+30     	; 0x2e26 <__addsf3x+0x7c>
    2e08:	1f 16       	cp	r1, r31
    2e0a:	ba 0b       	sbc	r27, r26
    2e0c:	62 0b       	sbc	r22, r18
    2e0e:	73 0b       	sbc	r23, r19
    2e10:	84 0b       	sbc	r24, r20
    2e12:	ba f0       	brmi	.+46     	; 0x2e42 <__addsf3x+0x98>
    2e14:	91 50       	subi	r25, 0x01	; 1
    2e16:	a1 f0       	breq	.+40     	; 0x2e40 <__addsf3x+0x96>
    2e18:	ff 0f       	add	r31, r31
    2e1a:	bb 1f       	adc	r27, r27
    2e1c:	66 1f       	adc	r22, r22
    2e1e:	77 1f       	adc	r23, r23
    2e20:	88 1f       	adc	r24, r24
    2e22:	c2 f7       	brpl	.-16     	; 0x2e14 <__addsf3x+0x6a>
    2e24:	0e c0       	rjmp	.+28     	; 0x2e42 <__addsf3x+0x98>
    2e26:	ba 0f       	add	r27, r26
    2e28:	62 1f       	adc	r22, r18
    2e2a:	73 1f       	adc	r23, r19
    2e2c:	84 1f       	adc	r24, r20
    2e2e:	48 f4       	brcc	.+18     	; 0x2e42 <__addsf3x+0x98>
    2e30:	87 95       	ror	r24
    2e32:	77 95       	ror	r23
    2e34:	67 95       	ror	r22
    2e36:	b7 95       	ror	r27
    2e38:	f7 95       	ror	r31
    2e3a:	9e 3f       	cpi	r25, 0xFE	; 254
    2e3c:	08 f0       	brcs	.+2      	; 0x2e40 <__addsf3x+0x96>
    2e3e:	b3 cf       	rjmp	.-154    	; 0x2da6 <__addsf3+0x1e>
    2e40:	93 95       	inc	r25
    2e42:	88 0f       	add	r24, r24
    2e44:	08 f0       	brcs	.+2      	; 0x2e48 <__addsf3x+0x9e>
    2e46:	99 27       	eor	r25, r25
    2e48:	ee 0f       	add	r30, r30
    2e4a:	97 95       	ror	r25
    2e4c:	87 95       	ror	r24
    2e4e:	08 95       	ret

00002e50 <__divsf3>:
    2e50:	0c d0       	rcall	.+24     	; 0x2e6a <__divsf3x>
    2e52:	eb c0       	rjmp	.+470    	; 0x302a <__fp_round>
    2e54:	e3 d0       	rcall	.+454    	; 0x301c <__fp_pscB>
    2e56:	40 f0       	brcs	.+16     	; 0x2e68 <__divsf3+0x18>
    2e58:	da d0       	rcall	.+436    	; 0x300e <__fp_pscA>
    2e5a:	30 f0       	brcs	.+12     	; 0x2e68 <__divsf3+0x18>
    2e5c:	21 f4       	brne	.+8      	; 0x2e66 <__divsf3+0x16>
    2e5e:	5f 3f       	cpi	r21, 0xFF	; 255
    2e60:	19 f0       	breq	.+6      	; 0x2e68 <__divsf3+0x18>
    2e62:	cc c0       	rjmp	.+408    	; 0x2ffc <__fp_inf>
    2e64:	51 11       	cpse	r21, r1
    2e66:	15 c1       	rjmp	.+554    	; 0x3092 <__fp_szero>
    2e68:	cf c0       	rjmp	.+414    	; 0x3008 <__fp_nan>

00002e6a <__divsf3x>:
    2e6a:	f0 d0       	rcall	.+480    	; 0x304c <__fp_split3>
    2e6c:	98 f3       	brcs	.-26     	; 0x2e54 <__divsf3+0x4>

00002e6e <__divsf3_pse>:
    2e6e:	99 23       	and	r25, r25
    2e70:	c9 f3       	breq	.-14     	; 0x2e64 <__divsf3+0x14>
    2e72:	55 23       	and	r21, r21
    2e74:	b1 f3       	breq	.-20     	; 0x2e62 <__divsf3+0x12>
    2e76:	95 1b       	sub	r25, r21
    2e78:	55 0b       	sbc	r21, r21
    2e7a:	bb 27       	eor	r27, r27
    2e7c:	aa 27       	eor	r26, r26
    2e7e:	62 17       	cp	r22, r18
    2e80:	73 07       	cpc	r23, r19
    2e82:	84 07       	cpc	r24, r20
    2e84:	38 f0       	brcs	.+14     	; 0x2e94 <__divsf3_pse+0x26>
    2e86:	9f 5f       	subi	r25, 0xFF	; 255
    2e88:	5f 4f       	sbci	r21, 0xFF	; 255
    2e8a:	22 0f       	add	r18, r18
    2e8c:	33 1f       	adc	r19, r19
    2e8e:	44 1f       	adc	r20, r20
    2e90:	aa 1f       	adc	r26, r26
    2e92:	a9 f3       	breq	.-22     	; 0x2e7e <__divsf3_pse+0x10>
    2e94:	33 d0       	rcall	.+102    	; 0x2efc <__divsf3_pse+0x8e>
    2e96:	0e 2e       	mov	r0, r30
    2e98:	3a f0       	brmi	.+14     	; 0x2ea8 <__divsf3_pse+0x3a>
    2e9a:	e0 e8       	ldi	r30, 0x80	; 128
    2e9c:	30 d0       	rcall	.+96     	; 0x2efe <__divsf3_pse+0x90>
    2e9e:	91 50       	subi	r25, 0x01	; 1
    2ea0:	50 40       	sbci	r21, 0x00	; 0
    2ea2:	e6 95       	lsr	r30
    2ea4:	00 1c       	adc	r0, r0
    2ea6:	ca f7       	brpl	.-14     	; 0x2e9a <__divsf3_pse+0x2c>
    2ea8:	29 d0       	rcall	.+82     	; 0x2efc <__divsf3_pse+0x8e>
    2eaa:	fe 2f       	mov	r31, r30
    2eac:	27 d0       	rcall	.+78     	; 0x2efc <__divsf3_pse+0x8e>
    2eae:	66 0f       	add	r22, r22
    2eb0:	77 1f       	adc	r23, r23
    2eb2:	88 1f       	adc	r24, r24
    2eb4:	bb 1f       	adc	r27, r27
    2eb6:	26 17       	cp	r18, r22
    2eb8:	37 07       	cpc	r19, r23
    2eba:	48 07       	cpc	r20, r24
    2ebc:	ab 07       	cpc	r26, r27
    2ebe:	b0 e8       	ldi	r27, 0x80	; 128
    2ec0:	09 f0       	breq	.+2      	; 0x2ec4 <__divsf3_pse+0x56>
    2ec2:	bb 0b       	sbc	r27, r27
    2ec4:	80 2d       	mov	r24, r0
    2ec6:	bf 01       	movw	r22, r30
    2ec8:	ff 27       	eor	r31, r31
    2eca:	93 58       	subi	r25, 0x83	; 131
    2ecc:	5f 4f       	sbci	r21, 0xFF	; 255
    2ece:	2a f0       	brmi	.+10     	; 0x2eda <__divsf3_pse+0x6c>
    2ed0:	9e 3f       	cpi	r25, 0xFE	; 254
    2ed2:	51 05       	cpc	r21, r1
    2ed4:	68 f0       	brcs	.+26     	; 0x2ef0 <__divsf3_pse+0x82>
    2ed6:	92 c0       	rjmp	.+292    	; 0x2ffc <__fp_inf>
    2ed8:	dc c0       	rjmp	.+440    	; 0x3092 <__fp_szero>
    2eda:	5f 3f       	cpi	r21, 0xFF	; 255
    2edc:	ec f3       	brlt	.-6      	; 0x2ed8 <__divsf3_pse+0x6a>
    2ede:	98 3e       	cpi	r25, 0xE8	; 232
    2ee0:	dc f3       	brlt	.-10     	; 0x2ed8 <__divsf3_pse+0x6a>
    2ee2:	86 95       	lsr	r24
    2ee4:	77 95       	ror	r23
    2ee6:	67 95       	ror	r22
    2ee8:	b7 95       	ror	r27
    2eea:	f7 95       	ror	r31
    2eec:	9f 5f       	subi	r25, 0xFF	; 255
    2eee:	c9 f7       	brne	.-14     	; 0x2ee2 <__divsf3_pse+0x74>
    2ef0:	88 0f       	add	r24, r24
    2ef2:	91 1d       	adc	r25, r1
    2ef4:	96 95       	lsr	r25
    2ef6:	87 95       	ror	r24
    2ef8:	97 f9       	bld	r25, 7
    2efa:	08 95       	ret
    2efc:	e1 e0       	ldi	r30, 0x01	; 1
    2efe:	66 0f       	add	r22, r22
    2f00:	77 1f       	adc	r23, r23
    2f02:	88 1f       	adc	r24, r24
    2f04:	bb 1f       	adc	r27, r27
    2f06:	62 17       	cp	r22, r18
    2f08:	73 07       	cpc	r23, r19
    2f0a:	84 07       	cpc	r24, r20
    2f0c:	ba 07       	cpc	r27, r26
    2f0e:	20 f0       	brcs	.+8      	; 0x2f18 <__divsf3_pse+0xaa>
    2f10:	62 1b       	sub	r22, r18
    2f12:	73 0b       	sbc	r23, r19
    2f14:	84 0b       	sbc	r24, r20
    2f16:	ba 0b       	sbc	r27, r26
    2f18:	ee 1f       	adc	r30, r30
    2f1a:	88 f7       	brcc	.-30     	; 0x2efe <__divsf3_pse+0x90>
    2f1c:	e0 95       	com	r30
    2f1e:	08 95       	ret

00002f20 <__fixsfsi>:
    2f20:	04 d0       	rcall	.+8      	; 0x2f2a <__fixunssfsi>
    2f22:	68 94       	set
    2f24:	b1 11       	cpse	r27, r1
    2f26:	b5 c0       	rjmp	.+362    	; 0x3092 <__fp_szero>
    2f28:	08 95       	ret

00002f2a <__fixunssfsi>:
    2f2a:	98 d0       	rcall	.+304    	; 0x305c <__fp_splitA>
    2f2c:	88 f0       	brcs	.+34     	; 0x2f50 <__fixunssfsi+0x26>
    2f2e:	9f 57       	subi	r25, 0x7F	; 127
    2f30:	90 f0       	brcs	.+36     	; 0x2f56 <__fixunssfsi+0x2c>
    2f32:	b9 2f       	mov	r27, r25
    2f34:	99 27       	eor	r25, r25
    2f36:	b7 51       	subi	r27, 0x17	; 23
    2f38:	a0 f0       	brcs	.+40     	; 0x2f62 <__fixunssfsi+0x38>
    2f3a:	d1 f0       	breq	.+52     	; 0x2f70 <__fixunssfsi+0x46>
    2f3c:	66 0f       	add	r22, r22
    2f3e:	77 1f       	adc	r23, r23
    2f40:	88 1f       	adc	r24, r24
    2f42:	99 1f       	adc	r25, r25
    2f44:	1a f0       	brmi	.+6      	; 0x2f4c <__fixunssfsi+0x22>
    2f46:	ba 95       	dec	r27
    2f48:	c9 f7       	brne	.-14     	; 0x2f3c <__fixunssfsi+0x12>
    2f4a:	12 c0       	rjmp	.+36     	; 0x2f70 <__fixunssfsi+0x46>
    2f4c:	b1 30       	cpi	r27, 0x01	; 1
    2f4e:	81 f0       	breq	.+32     	; 0x2f70 <__fixunssfsi+0x46>
    2f50:	9f d0       	rcall	.+318    	; 0x3090 <__fp_zero>
    2f52:	b1 e0       	ldi	r27, 0x01	; 1
    2f54:	08 95       	ret
    2f56:	9c c0       	rjmp	.+312    	; 0x3090 <__fp_zero>
    2f58:	67 2f       	mov	r22, r23
    2f5a:	78 2f       	mov	r23, r24
    2f5c:	88 27       	eor	r24, r24
    2f5e:	b8 5f       	subi	r27, 0xF8	; 248
    2f60:	39 f0       	breq	.+14     	; 0x2f70 <__fixunssfsi+0x46>
    2f62:	b9 3f       	cpi	r27, 0xF9	; 249
    2f64:	cc f3       	brlt	.-14     	; 0x2f58 <__fixunssfsi+0x2e>
    2f66:	86 95       	lsr	r24
    2f68:	77 95       	ror	r23
    2f6a:	67 95       	ror	r22
    2f6c:	b3 95       	inc	r27
    2f6e:	d9 f7       	brne	.-10     	; 0x2f66 <__fixunssfsi+0x3c>
    2f70:	3e f4       	brtc	.+14     	; 0x2f80 <__fixunssfsi+0x56>
    2f72:	90 95       	com	r25
    2f74:	80 95       	com	r24
    2f76:	70 95       	com	r23
    2f78:	61 95       	neg	r22
    2f7a:	7f 4f       	sbci	r23, 0xFF	; 255
    2f7c:	8f 4f       	sbci	r24, 0xFF	; 255
    2f7e:	9f 4f       	sbci	r25, 0xFF	; 255
    2f80:	08 95       	ret

00002f82 <__floatunsisf>:
    2f82:	e8 94       	clt
    2f84:	09 c0       	rjmp	.+18     	; 0x2f98 <__floatsisf+0x12>

00002f86 <__floatsisf>:
    2f86:	97 fb       	bst	r25, 7
    2f88:	3e f4       	brtc	.+14     	; 0x2f98 <__floatsisf+0x12>
    2f8a:	90 95       	com	r25
    2f8c:	80 95       	com	r24
    2f8e:	70 95       	com	r23
    2f90:	61 95       	neg	r22
    2f92:	7f 4f       	sbci	r23, 0xFF	; 255
    2f94:	8f 4f       	sbci	r24, 0xFF	; 255
    2f96:	9f 4f       	sbci	r25, 0xFF	; 255
    2f98:	99 23       	and	r25, r25
    2f9a:	a9 f0       	breq	.+42     	; 0x2fc6 <__floatsisf+0x40>
    2f9c:	f9 2f       	mov	r31, r25
    2f9e:	96 e9       	ldi	r25, 0x96	; 150
    2fa0:	bb 27       	eor	r27, r27
    2fa2:	93 95       	inc	r25
    2fa4:	f6 95       	lsr	r31
    2fa6:	87 95       	ror	r24
    2fa8:	77 95       	ror	r23
    2faa:	67 95       	ror	r22
    2fac:	b7 95       	ror	r27
    2fae:	f1 11       	cpse	r31, r1
    2fb0:	f8 cf       	rjmp	.-16     	; 0x2fa2 <__floatsisf+0x1c>
    2fb2:	fa f4       	brpl	.+62     	; 0x2ff2 <__floatsisf+0x6c>
    2fb4:	bb 0f       	add	r27, r27
    2fb6:	11 f4       	brne	.+4      	; 0x2fbc <__floatsisf+0x36>
    2fb8:	60 ff       	sbrs	r22, 0
    2fba:	1b c0       	rjmp	.+54     	; 0x2ff2 <__floatsisf+0x6c>
    2fbc:	6f 5f       	subi	r22, 0xFF	; 255
    2fbe:	7f 4f       	sbci	r23, 0xFF	; 255
    2fc0:	8f 4f       	sbci	r24, 0xFF	; 255
    2fc2:	9f 4f       	sbci	r25, 0xFF	; 255
    2fc4:	16 c0       	rjmp	.+44     	; 0x2ff2 <__floatsisf+0x6c>
    2fc6:	88 23       	and	r24, r24
    2fc8:	11 f0       	breq	.+4      	; 0x2fce <__floatsisf+0x48>
    2fca:	96 e9       	ldi	r25, 0x96	; 150
    2fcc:	11 c0       	rjmp	.+34     	; 0x2ff0 <__floatsisf+0x6a>
    2fce:	77 23       	and	r23, r23
    2fd0:	21 f0       	breq	.+8      	; 0x2fda <__floatsisf+0x54>
    2fd2:	9e e8       	ldi	r25, 0x8E	; 142
    2fd4:	87 2f       	mov	r24, r23
    2fd6:	76 2f       	mov	r23, r22
    2fd8:	05 c0       	rjmp	.+10     	; 0x2fe4 <__floatsisf+0x5e>
    2fda:	66 23       	and	r22, r22
    2fdc:	71 f0       	breq	.+28     	; 0x2ffa <__floatsisf+0x74>
    2fde:	96 e8       	ldi	r25, 0x86	; 134
    2fe0:	86 2f       	mov	r24, r22
    2fe2:	70 e0       	ldi	r23, 0x00	; 0
    2fe4:	60 e0       	ldi	r22, 0x00	; 0
    2fe6:	2a f0       	brmi	.+10     	; 0x2ff2 <__floatsisf+0x6c>
    2fe8:	9a 95       	dec	r25
    2fea:	66 0f       	add	r22, r22
    2fec:	77 1f       	adc	r23, r23
    2fee:	88 1f       	adc	r24, r24
    2ff0:	da f7       	brpl	.-10     	; 0x2fe8 <__floatsisf+0x62>
    2ff2:	88 0f       	add	r24, r24
    2ff4:	96 95       	lsr	r25
    2ff6:	87 95       	ror	r24
    2ff8:	97 f9       	bld	r25, 7
    2ffa:	08 95       	ret

00002ffc <__fp_inf>:
    2ffc:	97 f9       	bld	r25, 7
    2ffe:	9f 67       	ori	r25, 0x7F	; 127
    3000:	80 e8       	ldi	r24, 0x80	; 128
    3002:	70 e0       	ldi	r23, 0x00	; 0
    3004:	60 e0       	ldi	r22, 0x00	; 0
    3006:	08 95       	ret

00003008 <__fp_nan>:
    3008:	9f ef       	ldi	r25, 0xFF	; 255
    300a:	80 ec       	ldi	r24, 0xC0	; 192
    300c:	08 95       	ret

0000300e <__fp_pscA>:
    300e:	00 24       	eor	r0, r0
    3010:	0a 94       	dec	r0
    3012:	16 16       	cp	r1, r22
    3014:	17 06       	cpc	r1, r23
    3016:	18 06       	cpc	r1, r24
    3018:	09 06       	cpc	r0, r25
    301a:	08 95       	ret

0000301c <__fp_pscB>:
    301c:	00 24       	eor	r0, r0
    301e:	0a 94       	dec	r0
    3020:	12 16       	cp	r1, r18
    3022:	13 06       	cpc	r1, r19
    3024:	14 06       	cpc	r1, r20
    3026:	05 06       	cpc	r0, r21
    3028:	08 95       	ret

0000302a <__fp_round>:
    302a:	09 2e       	mov	r0, r25
    302c:	03 94       	inc	r0
    302e:	00 0c       	add	r0, r0
    3030:	11 f4       	brne	.+4      	; 0x3036 <__fp_round+0xc>
    3032:	88 23       	and	r24, r24
    3034:	52 f0       	brmi	.+20     	; 0x304a <__fp_round+0x20>
    3036:	bb 0f       	add	r27, r27
    3038:	40 f4       	brcc	.+16     	; 0x304a <__fp_round+0x20>
    303a:	bf 2b       	or	r27, r31
    303c:	11 f4       	brne	.+4      	; 0x3042 <__fp_round+0x18>
    303e:	60 ff       	sbrs	r22, 0
    3040:	04 c0       	rjmp	.+8      	; 0x304a <__fp_round+0x20>
    3042:	6f 5f       	subi	r22, 0xFF	; 255
    3044:	7f 4f       	sbci	r23, 0xFF	; 255
    3046:	8f 4f       	sbci	r24, 0xFF	; 255
    3048:	9f 4f       	sbci	r25, 0xFF	; 255
    304a:	08 95       	ret

0000304c <__fp_split3>:
    304c:	57 fd       	sbrc	r21, 7
    304e:	90 58       	subi	r25, 0x80	; 128
    3050:	44 0f       	add	r20, r20
    3052:	55 1f       	adc	r21, r21
    3054:	59 f0       	breq	.+22     	; 0x306c <__fp_splitA+0x10>
    3056:	5f 3f       	cpi	r21, 0xFF	; 255
    3058:	71 f0       	breq	.+28     	; 0x3076 <__fp_splitA+0x1a>
    305a:	47 95       	ror	r20

0000305c <__fp_splitA>:
    305c:	88 0f       	add	r24, r24
    305e:	97 fb       	bst	r25, 7
    3060:	99 1f       	adc	r25, r25
    3062:	61 f0       	breq	.+24     	; 0x307c <__fp_splitA+0x20>
    3064:	9f 3f       	cpi	r25, 0xFF	; 255
    3066:	79 f0       	breq	.+30     	; 0x3086 <__fp_splitA+0x2a>
    3068:	87 95       	ror	r24
    306a:	08 95       	ret
    306c:	12 16       	cp	r1, r18
    306e:	13 06       	cpc	r1, r19
    3070:	14 06       	cpc	r1, r20
    3072:	55 1f       	adc	r21, r21
    3074:	f2 cf       	rjmp	.-28     	; 0x305a <__fp_split3+0xe>
    3076:	46 95       	lsr	r20
    3078:	f1 df       	rcall	.-30     	; 0x305c <__fp_splitA>
    307a:	08 c0       	rjmp	.+16     	; 0x308c <__fp_splitA+0x30>
    307c:	16 16       	cp	r1, r22
    307e:	17 06       	cpc	r1, r23
    3080:	18 06       	cpc	r1, r24
    3082:	99 1f       	adc	r25, r25
    3084:	f1 cf       	rjmp	.-30     	; 0x3068 <__fp_splitA+0xc>
    3086:	86 95       	lsr	r24
    3088:	71 05       	cpc	r23, r1
    308a:	61 05       	cpc	r22, r1
    308c:	08 94       	sec
    308e:	08 95       	ret

00003090 <__fp_zero>:
    3090:	e8 94       	clt

00003092 <__fp_szero>:
    3092:	bb 27       	eor	r27, r27
    3094:	66 27       	eor	r22, r22
    3096:	77 27       	eor	r23, r23
    3098:	cb 01       	movw	r24, r22
    309a:	97 f9       	bld	r25, 7
    309c:	08 95       	ret

0000309e <__mulsf3>:
    309e:	0b d0       	rcall	.+22     	; 0x30b6 <__mulsf3x>
    30a0:	c4 cf       	rjmp	.-120    	; 0x302a <__fp_round>
    30a2:	b5 df       	rcall	.-150    	; 0x300e <__fp_pscA>
    30a4:	28 f0       	brcs	.+10     	; 0x30b0 <__mulsf3+0x12>
    30a6:	ba df       	rcall	.-140    	; 0x301c <__fp_pscB>
    30a8:	18 f0       	brcs	.+6      	; 0x30b0 <__mulsf3+0x12>
    30aa:	95 23       	and	r25, r21
    30ac:	09 f0       	breq	.+2      	; 0x30b0 <__mulsf3+0x12>
    30ae:	a6 cf       	rjmp	.-180    	; 0x2ffc <__fp_inf>
    30b0:	ab cf       	rjmp	.-170    	; 0x3008 <__fp_nan>
    30b2:	11 24       	eor	r1, r1
    30b4:	ee cf       	rjmp	.-36     	; 0x3092 <__fp_szero>

000030b6 <__mulsf3x>:
    30b6:	ca df       	rcall	.-108    	; 0x304c <__fp_split3>
    30b8:	a0 f3       	brcs	.-24     	; 0x30a2 <__mulsf3+0x4>

000030ba <__mulsf3_pse>:
    30ba:	95 9f       	mul	r25, r21
    30bc:	d1 f3       	breq	.-12     	; 0x30b2 <__mulsf3+0x14>
    30be:	95 0f       	add	r25, r21
    30c0:	50 e0       	ldi	r21, 0x00	; 0
    30c2:	55 1f       	adc	r21, r21
    30c4:	62 9f       	mul	r22, r18
    30c6:	f0 01       	movw	r30, r0
    30c8:	72 9f       	mul	r23, r18
    30ca:	bb 27       	eor	r27, r27
    30cc:	f0 0d       	add	r31, r0
    30ce:	b1 1d       	adc	r27, r1
    30d0:	63 9f       	mul	r22, r19
    30d2:	aa 27       	eor	r26, r26
    30d4:	f0 0d       	add	r31, r0
    30d6:	b1 1d       	adc	r27, r1
    30d8:	aa 1f       	adc	r26, r26
    30da:	64 9f       	mul	r22, r20
    30dc:	66 27       	eor	r22, r22
    30de:	b0 0d       	add	r27, r0
    30e0:	a1 1d       	adc	r26, r1
    30e2:	66 1f       	adc	r22, r22
    30e4:	82 9f       	mul	r24, r18
    30e6:	22 27       	eor	r18, r18
    30e8:	b0 0d       	add	r27, r0
    30ea:	a1 1d       	adc	r26, r1
    30ec:	62 1f       	adc	r22, r18
    30ee:	73 9f       	mul	r23, r19
    30f0:	b0 0d       	add	r27, r0
    30f2:	a1 1d       	adc	r26, r1
    30f4:	62 1f       	adc	r22, r18
    30f6:	83 9f       	mul	r24, r19
    30f8:	a0 0d       	add	r26, r0
    30fa:	61 1d       	adc	r22, r1
    30fc:	22 1f       	adc	r18, r18
    30fe:	74 9f       	mul	r23, r20
    3100:	33 27       	eor	r19, r19
    3102:	a0 0d       	add	r26, r0
    3104:	61 1d       	adc	r22, r1
    3106:	23 1f       	adc	r18, r19
    3108:	84 9f       	mul	r24, r20
    310a:	60 0d       	add	r22, r0
    310c:	21 1d       	adc	r18, r1
    310e:	82 2f       	mov	r24, r18
    3110:	76 2f       	mov	r23, r22
    3112:	6a 2f       	mov	r22, r26
    3114:	11 24       	eor	r1, r1
    3116:	9f 57       	subi	r25, 0x7F	; 127
    3118:	50 40       	sbci	r21, 0x00	; 0
    311a:	8a f0       	brmi	.+34     	; 0x313e <__mulsf3_pse+0x84>
    311c:	e1 f0       	breq	.+56     	; 0x3156 <__mulsf3_pse+0x9c>
    311e:	88 23       	and	r24, r24
    3120:	4a f0       	brmi	.+18     	; 0x3134 <__mulsf3_pse+0x7a>
    3122:	ee 0f       	add	r30, r30
    3124:	ff 1f       	adc	r31, r31
    3126:	bb 1f       	adc	r27, r27
    3128:	66 1f       	adc	r22, r22
    312a:	77 1f       	adc	r23, r23
    312c:	88 1f       	adc	r24, r24
    312e:	91 50       	subi	r25, 0x01	; 1
    3130:	50 40       	sbci	r21, 0x00	; 0
    3132:	a9 f7       	brne	.-22     	; 0x311e <__mulsf3_pse+0x64>
    3134:	9e 3f       	cpi	r25, 0xFE	; 254
    3136:	51 05       	cpc	r21, r1
    3138:	70 f0       	brcs	.+28     	; 0x3156 <__mulsf3_pse+0x9c>
    313a:	60 cf       	rjmp	.-320    	; 0x2ffc <__fp_inf>
    313c:	aa cf       	rjmp	.-172    	; 0x3092 <__fp_szero>
    313e:	5f 3f       	cpi	r21, 0xFF	; 255
    3140:	ec f3       	brlt	.-6      	; 0x313c <__mulsf3_pse+0x82>
    3142:	98 3e       	cpi	r25, 0xE8	; 232
    3144:	dc f3       	brlt	.-10     	; 0x313c <__mulsf3_pse+0x82>
    3146:	86 95       	lsr	r24
    3148:	77 95       	ror	r23
    314a:	67 95       	ror	r22
    314c:	b7 95       	ror	r27
    314e:	f7 95       	ror	r31
    3150:	e7 95       	ror	r30
    3152:	9f 5f       	subi	r25, 0xFF	; 255
    3154:	c1 f7       	brne	.-16     	; 0x3146 <__mulsf3_pse+0x8c>
    3156:	fe 2b       	or	r31, r30
    3158:	88 0f       	add	r24, r24
    315a:	91 1d       	adc	r25, r1
    315c:	96 95       	lsr	r25
    315e:	87 95       	ror	r24
    3160:	97 f9       	bld	r25, 7
    3162:	08 95       	ret

00003164 <pow>:
    3164:	fa 01       	movw	r30, r20
    3166:	ee 0f       	add	r30, r30
    3168:	ff 1f       	adc	r31, r31
    316a:	30 96       	adiw	r30, 0x00	; 0
    316c:	21 05       	cpc	r18, r1
    316e:	31 05       	cpc	r19, r1
    3170:	99 f1       	breq	.+102    	; 0x31d8 <pow+0x74>
    3172:	61 15       	cp	r22, r1
    3174:	71 05       	cpc	r23, r1
    3176:	61 f4       	brne	.+24     	; 0x3190 <pow+0x2c>
    3178:	80 38       	cpi	r24, 0x80	; 128
    317a:	bf e3       	ldi	r27, 0x3F	; 63
    317c:	9b 07       	cpc	r25, r27
    317e:	49 f1       	breq	.+82     	; 0x31d2 <pow+0x6e>
    3180:	68 94       	set
    3182:	90 38       	cpi	r25, 0x80	; 128
    3184:	81 05       	cpc	r24, r1
    3186:	61 f0       	breq	.+24     	; 0x31a0 <pow+0x3c>
    3188:	80 38       	cpi	r24, 0x80	; 128
    318a:	bf ef       	ldi	r27, 0xFF	; 255
    318c:	9b 07       	cpc	r25, r27
    318e:	41 f0       	breq	.+16     	; 0x31a0 <pow+0x3c>
    3190:	99 23       	and	r25, r25
    3192:	42 f5       	brpl	.+80     	; 0x31e4 <pow+0x80>
    3194:	ff 3f       	cpi	r31, 0xFF	; 255
    3196:	e1 05       	cpc	r30, r1
    3198:	31 05       	cpc	r19, r1
    319a:	21 05       	cpc	r18, r1
    319c:	11 f1       	breq	.+68     	; 0x31e2 <pow+0x7e>
    319e:	e8 94       	clt
    31a0:	08 94       	sec
    31a2:	e7 95       	ror	r30
    31a4:	d9 01       	movw	r26, r18
    31a6:	aa 23       	and	r26, r26
    31a8:	29 f4       	brne	.+10     	; 0x31b4 <pow+0x50>
    31aa:	ab 2f       	mov	r26, r27
    31ac:	be 2f       	mov	r27, r30
    31ae:	f8 5f       	subi	r31, 0xF8	; 248
    31b0:	d0 f3       	brcs	.-12     	; 0x31a6 <pow+0x42>
    31b2:	10 c0       	rjmp	.+32     	; 0x31d4 <pow+0x70>
    31b4:	ff 5f       	subi	r31, 0xFF	; 255
    31b6:	70 f4       	brcc	.+28     	; 0x31d4 <pow+0x70>
    31b8:	a6 95       	lsr	r26
    31ba:	e0 f7       	brcc	.-8      	; 0x31b4 <pow+0x50>
    31bc:	f7 39       	cpi	r31, 0x97	; 151
    31be:	50 f0       	brcs	.+20     	; 0x31d4 <pow+0x70>
    31c0:	19 f0       	breq	.+6      	; 0x31c8 <pow+0x64>
    31c2:	ff 3a       	cpi	r31, 0xAF	; 175
    31c4:	38 f4       	brcc	.+14     	; 0x31d4 <pow+0x70>
    31c6:	9f 77       	andi	r25, 0x7F	; 127
    31c8:	9f 93       	push	r25
    31ca:	0c d0       	rcall	.+24     	; 0x31e4 <pow+0x80>
    31cc:	0f 90       	pop	r0
    31ce:	07 fc       	sbrc	r0, 7
    31d0:	90 58       	subi	r25, 0x80	; 128
    31d2:	08 95       	ret
    31d4:	3e f0       	brts	.+14     	; 0x31e4 <pow+0x80>
    31d6:	18 cf       	rjmp	.-464    	; 0x3008 <__fp_nan>
    31d8:	60 e0       	ldi	r22, 0x00	; 0
    31da:	70 e0       	ldi	r23, 0x00	; 0
    31dc:	80 e8       	ldi	r24, 0x80	; 128
    31de:	9f e3       	ldi	r25, 0x3F	; 63
    31e0:	08 95       	ret
    31e2:	4f e7       	ldi	r20, 0x7F	; 127
    31e4:	9f 77       	andi	r25, 0x7F	; 127
    31e6:	5f 93       	push	r21
    31e8:	4f 93       	push	r20
    31ea:	3f 93       	push	r19
    31ec:	2f 93       	push	r18
    31ee:	e7 d0       	rcall	.+462    	; 0x33be <log>
    31f0:	2f 91       	pop	r18
    31f2:	3f 91       	pop	r19
    31f4:	4f 91       	pop	r20
    31f6:	5f 91       	pop	r21
    31f8:	52 df       	rcall	.-348    	; 0x309e <__mulsf3>
    31fa:	25 c0       	rjmp	.+74     	; 0x3246 <exp>

000031fc <round>:
    31fc:	2f df       	rcall	.-418    	; 0x305c <__fp_splitA>
    31fe:	e0 f0       	brcs	.+56     	; 0x3238 <round+0x3c>
    3200:	9e 37       	cpi	r25, 0x7E	; 126
    3202:	d8 f0       	brcs	.+54     	; 0x323a <round+0x3e>
    3204:	96 39       	cpi	r25, 0x96	; 150
    3206:	b8 f4       	brcc	.+46     	; 0x3236 <round+0x3a>
    3208:	9e 38       	cpi	r25, 0x8E	; 142
    320a:	48 f4       	brcc	.+18     	; 0x321e <round+0x22>
    320c:	67 2f       	mov	r22, r23
    320e:	78 2f       	mov	r23, r24
    3210:	88 27       	eor	r24, r24
    3212:	98 5f       	subi	r25, 0xF8	; 248
    3214:	f9 cf       	rjmp	.-14     	; 0x3208 <round+0xc>
    3216:	86 95       	lsr	r24
    3218:	77 95       	ror	r23
    321a:	67 95       	ror	r22
    321c:	93 95       	inc	r25
    321e:	95 39       	cpi	r25, 0x95	; 149
    3220:	d0 f3       	brcs	.-12     	; 0x3216 <round+0x1a>
    3222:	b6 2f       	mov	r27, r22
    3224:	b1 70       	andi	r27, 0x01	; 1
    3226:	6b 0f       	add	r22, r27
    3228:	71 1d       	adc	r23, r1
    322a:	81 1d       	adc	r24, r1
    322c:	20 f4       	brcc	.+8      	; 0x3236 <round+0x3a>
    322e:	87 95       	ror	r24
    3230:	77 95       	ror	r23
    3232:	67 95       	ror	r22
    3234:	93 95       	inc	r25
    3236:	33 c0       	rjmp	.+102    	; 0x329e <__fp_mintl>
    3238:	4d c0       	rjmp	.+154    	; 0x32d4 <__fp_mpack>
    323a:	2b cf       	rjmp	.-426    	; 0x3092 <__fp_szero>
    323c:	19 f4       	brne	.+6      	; 0x3244 <round+0x48>
    323e:	0e f0       	brts	.+2      	; 0x3242 <round+0x46>
    3240:	dd ce       	rjmp	.-582    	; 0x2ffc <__fp_inf>
    3242:	26 cf       	rjmp	.-436    	; 0x3090 <__fp_zero>
    3244:	e1 ce       	rjmp	.-574    	; 0x3008 <__fp_nan>

00003246 <exp>:
    3246:	0a df       	rcall	.-492    	; 0x305c <__fp_splitA>
    3248:	c8 f3       	brcs	.-14     	; 0x323c <round+0x40>
    324a:	96 38       	cpi	r25, 0x86	; 134
    324c:	c0 f7       	brcc	.-16     	; 0x323e <round+0x42>
    324e:	07 f8       	bld	r0, 7
    3250:	0f 92       	push	r0
    3252:	e8 94       	clt
    3254:	2b e3       	ldi	r18, 0x3B	; 59
    3256:	3a ea       	ldi	r19, 0xAA	; 170
    3258:	48 eb       	ldi	r20, 0xB8	; 184
    325a:	5f e7       	ldi	r21, 0x7F	; 127
    325c:	2e df       	rcall	.-420    	; 0x30ba <__mulsf3_pse>
    325e:	0f 92       	push	r0
    3260:	0f 92       	push	r0
    3262:	0f 92       	push	r0
    3264:	4d b7       	in	r20, 0x3d	; 61
    3266:	5e b7       	in	r21, 0x3e	; 62
    3268:	0f 92       	push	r0
    326a:	e9 d0       	rcall	.+466    	; 0x343e <modf>
    326c:	e4 e5       	ldi	r30, 0x54	; 84
    326e:	f0 e0       	ldi	r31, 0x00	; 0
    3270:	3f d0       	rcall	.+126    	; 0x32f0 <__fp_powser>
    3272:	4f 91       	pop	r20
    3274:	5f 91       	pop	r21
    3276:	ef 91       	pop	r30
    3278:	ff 91       	pop	r31
    327a:	e5 95       	asr	r30
    327c:	ee 1f       	adc	r30, r30
    327e:	ff 1f       	adc	r31, r31
    3280:	49 f0       	breq	.+18     	; 0x3294 <exp+0x4e>
    3282:	fe 57       	subi	r31, 0x7E	; 126
    3284:	e0 68       	ori	r30, 0x80	; 128
    3286:	44 27       	eor	r20, r20
    3288:	ee 0f       	add	r30, r30
    328a:	44 1f       	adc	r20, r20
    328c:	fa 95       	dec	r31
    328e:	e1 f7       	brne	.-8      	; 0x3288 <exp+0x42>
    3290:	41 95       	neg	r20
    3292:	55 0b       	sbc	r21, r21
    3294:	5b d0       	rcall	.+182    	; 0x334c <ldexp>
    3296:	0f 90       	pop	r0
    3298:	07 fe       	sbrs	r0, 7
    329a:	4f c0       	rjmp	.+158    	; 0x333a <inverse>
    329c:	08 95       	ret

0000329e <__fp_mintl>:
    329e:	88 23       	and	r24, r24
    32a0:	71 f4       	brne	.+28     	; 0x32be <__fp_mintl+0x20>
    32a2:	77 23       	and	r23, r23
    32a4:	21 f0       	breq	.+8      	; 0x32ae <__fp_mintl+0x10>
    32a6:	98 50       	subi	r25, 0x08	; 8
    32a8:	87 2b       	or	r24, r23
    32aa:	76 2f       	mov	r23, r22
    32ac:	07 c0       	rjmp	.+14     	; 0x32bc <__fp_mintl+0x1e>
    32ae:	66 23       	and	r22, r22
    32b0:	11 f4       	brne	.+4      	; 0x32b6 <__fp_mintl+0x18>
    32b2:	99 27       	eor	r25, r25
    32b4:	0d c0       	rjmp	.+26     	; 0x32d0 <__fp_mintl+0x32>
    32b6:	90 51       	subi	r25, 0x10	; 16
    32b8:	86 2b       	or	r24, r22
    32ba:	70 e0       	ldi	r23, 0x00	; 0
    32bc:	60 e0       	ldi	r22, 0x00	; 0
    32be:	2a f0       	brmi	.+10     	; 0x32ca <__fp_mintl+0x2c>
    32c0:	9a 95       	dec	r25
    32c2:	66 0f       	add	r22, r22
    32c4:	77 1f       	adc	r23, r23
    32c6:	88 1f       	adc	r24, r24
    32c8:	da f7       	brpl	.-10     	; 0x32c0 <__fp_mintl+0x22>
    32ca:	88 0f       	add	r24, r24
    32cc:	96 95       	lsr	r25
    32ce:	87 95       	ror	r24
    32d0:	97 f9       	bld	r25, 7
    32d2:	08 95       	ret

000032d4 <__fp_mpack>:
    32d4:	9f 3f       	cpi	r25, 0xFF	; 255
    32d6:	31 f0       	breq	.+12     	; 0x32e4 <__fp_mpack_finite+0xc>

000032d8 <__fp_mpack_finite>:
    32d8:	91 50       	subi	r25, 0x01	; 1
    32da:	20 f4       	brcc	.+8      	; 0x32e4 <__fp_mpack_finite+0xc>
    32dc:	87 95       	ror	r24
    32de:	77 95       	ror	r23
    32e0:	67 95       	ror	r22
    32e2:	b7 95       	ror	r27
    32e4:	88 0f       	add	r24, r24
    32e6:	91 1d       	adc	r25, r1
    32e8:	96 95       	lsr	r25
    32ea:	87 95       	ror	r24
    32ec:	97 f9       	bld	r25, 7
    32ee:	08 95       	ret

000032f0 <__fp_powser>:
    32f0:	df 93       	push	r29
    32f2:	cf 93       	push	r28
    32f4:	1f 93       	push	r17
    32f6:	0f 93       	push	r16
    32f8:	ff 92       	push	r15
    32fa:	ef 92       	push	r14
    32fc:	df 92       	push	r13
    32fe:	7b 01       	movw	r14, r22
    3300:	8c 01       	movw	r16, r24
    3302:	68 94       	set
    3304:	05 c0       	rjmp	.+10     	; 0x3310 <__fp_powser+0x20>
    3306:	da 2e       	mov	r13, r26
    3308:	ef 01       	movw	r28, r30
    330a:	d5 de       	rcall	.-598    	; 0x30b6 <__mulsf3x>
    330c:	fe 01       	movw	r30, r28
    330e:	e8 94       	clt
    3310:	a5 91       	lpm	r26, Z+
    3312:	25 91       	lpm	r18, Z+
    3314:	35 91       	lpm	r19, Z+
    3316:	45 91       	lpm	r20, Z+
    3318:	55 91       	lpm	r21, Z+
    331a:	ae f3       	brts	.-22     	; 0x3306 <__fp_powser+0x16>
    331c:	ef 01       	movw	r28, r30
    331e:	45 dd       	rcall	.-1398   	; 0x2daa <__addsf3x>
    3320:	fe 01       	movw	r30, r28
    3322:	97 01       	movw	r18, r14
    3324:	a8 01       	movw	r20, r16
    3326:	da 94       	dec	r13
    3328:	79 f7       	brne	.-34     	; 0x3308 <__fp_powser+0x18>
    332a:	df 90       	pop	r13
    332c:	ef 90       	pop	r14
    332e:	ff 90       	pop	r15
    3330:	0f 91       	pop	r16
    3332:	1f 91       	pop	r17
    3334:	cf 91       	pop	r28
    3336:	df 91       	pop	r29
    3338:	08 95       	ret

0000333a <inverse>:
    333a:	9b 01       	movw	r18, r22
    333c:	ac 01       	movw	r20, r24
    333e:	60 e0       	ldi	r22, 0x00	; 0
    3340:	70 e0       	ldi	r23, 0x00	; 0
    3342:	80 e8       	ldi	r24, 0x80	; 128
    3344:	9f e3       	ldi	r25, 0x3F	; 63
    3346:	84 cd       	rjmp	.-1272   	; 0x2e50 <__divsf3>
    3348:	59 ce       	rjmp	.-846    	; 0x2ffc <__fp_inf>
    334a:	c4 cf       	rjmp	.-120    	; 0x32d4 <__fp_mpack>

0000334c <ldexp>:
    334c:	87 de       	rcall	.-754    	; 0x305c <__fp_splitA>
    334e:	e8 f3       	brcs	.-6      	; 0x334a <inverse+0x10>
    3350:	99 23       	and	r25, r25
    3352:	d9 f3       	breq	.-10     	; 0x334a <inverse+0x10>
    3354:	94 0f       	add	r25, r20
    3356:	51 1d       	adc	r21, r1
    3358:	bb f3       	brvs	.-18     	; 0x3348 <inverse+0xe>
    335a:	91 50       	subi	r25, 0x01	; 1
    335c:	50 40       	sbci	r21, 0x00	; 0
    335e:	94 f0       	brlt	.+36     	; 0x3384 <ldexp+0x38>
    3360:	59 f0       	breq	.+22     	; 0x3378 <ldexp+0x2c>
    3362:	88 23       	and	r24, r24
    3364:	32 f0       	brmi	.+12     	; 0x3372 <ldexp+0x26>
    3366:	66 0f       	add	r22, r22
    3368:	77 1f       	adc	r23, r23
    336a:	88 1f       	adc	r24, r24
    336c:	91 50       	subi	r25, 0x01	; 1
    336e:	50 40       	sbci	r21, 0x00	; 0
    3370:	c1 f7       	brne	.-16     	; 0x3362 <ldexp+0x16>
    3372:	9e 3f       	cpi	r25, 0xFE	; 254
    3374:	51 05       	cpc	r21, r1
    3376:	44 f7       	brge	.-48     	; 0x3348 <inverse+0xe>
    3378:	88 0f       	add	r24, r24
    337a:	91 1d       	adc	r25, r1
    337c:	96 95       	lsr	r25
    337e:	87 95       	ror	r24
    3380:	97 f9       	bld	r25, 7
    3382:	08 95       	ret
    3384:	5f 3f       	cpi	r21, 0xFF	; 255
    3386:	ac f0       	brlt	.+42     	; 0x33b2 <ldexp+0x66>
    3388:	98 3e       	cpi	r25, 0xE8	; 232
    338a:	9c f0       	brlt	.+38     	; 0x33b2 <ldexp+0x66>
    338c:	bb 27       	eor	r27, r27
    338e:	86 95       	lsr	r24
    3390:	77 95       	ror	r23
    3392:	67 95       	ror	r22
    3394:	b7 95       	ror	r27
    3396:	08 f4       	brcc	.+2      	; 0x339a <ldexp+0x4e>
    3398:	b1 60       	ori	r27, 0x01	; 1
    339a:	93 95       	inc	r25
    339c:	c1 f7       	brne	.-16     	; 0x338e <ldexp+0x42>
    339e:	bb 0f       	add	r27, r27
    33a0:	58 f7       	brcc	.-42     	; 0x3378 <ldexp+0x2c>
    33a2:	11 f4       	brne	.+4      	; 0x33a8 <ldexp+0x5c>
    33a4:	60 ff       	sbrs	r22, 0
    33a6:	e8 cf       	rjmp	.-48     	; 0x3378 <ldexp+0x2c>
    33a8:	6f 5f       	subi	r22, 0xFF	; 255
    33aa:	7f 4f       	sbci	r23, 0xFF	; 255
    33ac:	8f 4f       	sbci	r24, 0xFF	; 255
    33ae:	9f 4f       	sbci	r25, 0xFF	; 255
    33b0:	e3 cf       	rjmp	.-58     	; 0x3378 <ldexp+0x2c>
    33b2:	6f ce       	rjmp	.-802    	; 0x3092 <__fp_szero>
    33b4:	0e f0       	brts	.+2      	; 0x33b8 <ldexp+0x6c>
    33b6:	8e cf       	rjmp	.-228    	; 0x32d4 <__fp_mpack>
    33b8:	27 ce       	rjmp	.-946    	; 0x3008 <__fp_nan>
    33ba:	68 94       	set
    33bc:	1f ce       	rjmp	.-962    	; 0x2ffc <__fp_inf>

000033be <log>:
    33be:	4e de       	rcall	.-868    	; 0x305c <__fp_splitA>
    33c0:	c8 f3       	brcs	.-14     	; 0x33b4 <ldexp+0x68>
    33c2:	99 23       	and	r25, r25
    33c4:	d1 f3       	breq	.-12     	; 0x33ba <ldexp+0x6e>
    33c6:	c6 f3       	brts	.-16     	; 0x33b8 <ldexp+0x6c>
    33c8:	df 93       	push	r29
    33ca:	cf 93       	push	r28
    33cc:	1f 93       	push	r17
    33ce:	0f 93       	push	r16
    33d0:	ff 92       	push	r15
    33d2:	c9 2f       	mov	r28, r25
    33d4:	dd 27       	eor	r29, r29
    33d6:	88 23       	and	r24, r24
    33d8:	2a f0       	brmi	.+10     	; 0x33e4 <log+0x26>
    33da:	21 97       	sbiw	r28, 0x01	; 1
    33dc:	66 0f       	add	r22, r22
    33de:	77 1f       	adc	r23, r23
    33e0:	88 1f       	adc	r24, r24
    33e2:	da f7       	brpl	.-10     	; 0x33da <log+0x1c>
    33e4:	20 e0       	ldi	r18, 0x00	; 0
    33e6:	30 e0       	ldi	r19, 0x00	; 0
    33e8:	40 e8       	ldi	r20, 0x80	; 128
    33ea:	5f eb       	ldi	r21, 0xBF	; 191
    33ec:	9f e3       	ldi	r25, 0x3F	; 63
    33ee:	88 39       	cpi	r24, 0x98	; 152
    33f0:	20 f0       	brcs	.+8      	; 0x33fa <log+0x3c>
    33f2:	80 3e       	cpi	r24, 0xE0	; 224
    33f4:	30 f0       	brcs	.+12     	; 0x3402 <log+0x44>
    33f6:	21 96       	adiw	r28, 0x01	; 1
    33f8:	8f 77       	andi	r24, 0x7F	; 127
    33fa:	c6 dc       	rcall	.-1652   	; 0x2d88 <__addsf3>
    33fc:	ec e7       	ldi	r30, 0x7C	; 124
    33fe:	f0 e0       	ldi	r31, 0x00	; 0
    3400:	03 c0       	rjmp	.+6      	; 0x3408 <log+0x4a>
    3402:	c2 dc       	rcall	.-1660   	; 0x2d88 <__addsf3>
    3404:	e9 ea       	ldi	r30, 0xA9	; 169
    3406:	f0 e0       	ldi	r31, 0x00	; 0
    3408:	73 df       	rcall	.-282    	; 0x32f0 <__fp_powser>
    340a:	8b 01       	movw	r16, r22
    340c:	be 01       	movw	r22, r28
    340e:	ec 01       	movw	r28, r24
    3410:	fb 2e       	mov	r15, r27
    3412:	6f 57       	subi	r22, 0x7F	; 127
    3414:	71 09       	sbc	r23, r1
    3416:	75 95       	asr	r23
    3418:	77 1f       	adc	r23, r23
    341a:	88 0b       	sbc	r24, r24
    341c:	99 0b       	sbc	r25, r25
    341e:	b3 dd       	rcall	.-1178   	; 0x2f86 <__floatsisf>
    3420:	28 e1       	ldi	r18, 0x18	; 24
    3422:	32 e7       	ldi	r19, 0x72	; 114
    3424:	41 e3       	ldi	r20, 0x31	; 49
    3426:	5f e3       	ldi	r21, 0x3F	; 63
    3428:	46 de       	rcall	.-884    	; 0x30b6 <__mulsf3x>
    342a:	af 2d       	mov	r26, r15
    342c:	98 01       	movw	r18, r16
    342e:	ae 01       	movw	r20, r28
    3430:	ff 90       	pop	r15
    3432:	0f 91       	pop	r16
    3434:	1f 91       	pop	r17
    3436:	cf 91       	pop	r28
    3438:	df 91       	pop	r29
    343a:	b7 dc       	rcall	.-1682   	; 0x2daa <__addsf3x>
    343c:	f6 cd       	rjmp	.-1044   	; 0x302a <__fp_round>

0000343e <modf>:
    343e:	fa 01       	movw	r30, r20
    3440:	dc 01       	movw	r26, r24
    3442:	aa 0f       	add	r26, r26
    3444:	bb 1f       	adc	r27, r27
    3446:	9b 01       	movw	r18, r22
    3448:	ac 01       	movw	r20, r24
    344a:	bf 57       	subi	r27, 0x7F	; 127
    344c:	28 f4       	brcc	.+10     	; 0x3458 <modf+0x1a>
    344e:	22 27       	eor	r18, r18
    3450:	33 27       	eor	r19, r19
    3452:	44 27       	eor	r20, r20
    3454:	50 78       	andi	r21, 0x80	; 128
    3456:	1f c0       	rjmp	.+62     	; 0x3496 <modf+0x58>
    3458:	b7 51       	subi	r27, 0x17	; 23
    345a:	88 f4       	brcc	.+34     	; 0x347e <modf+0x40>
    345c:	ab 2f       	mov	r26, r27
    345e:	00 24       	eor	r0, r0
    3460:	46 95       	lsr	r20
    3462:	37 95       	ror	r19
    3464:	27 95       	ror	r18
    3466:	01 1c       	adc	r0, r1
    3468:	a3 95       	inc	r26
    346a:	d2 f3       	brmi	.-12     	; 0x3460 <modf+0x22>
    346c:	00 20       	and	r0, r0
    346e:	69 f0       	breq	.+26     	; 0x348a <modf+0x4c>
    3470:	22 0f       	add	r18, r18
    3472:	33 1f       	adc	r19, r19
    3474:	44 1f       	adc	r20, r20
    3476:	b3 95       	inc	r27
    3478:	da f3       	brmi	.-10     	; 0x3470 <modf+0x32>
    347a:	0d d0       	rcall	.+26     	; 0x3496 <modf+0x58>
    347c:	84 cc       	rjmp	.-1784   	; 0x2d86 <__subsf3>
    347e:	61 30       	cpi	r22, 0x01	; 1
    3480:	71 05       	cpc	r23, r1
    3482:	a0 e8       	ldi	r26, 0x80	; 128
    3484:	8a 07       	cpc	r24, r26
    3486:	b9 46       	sbci	r27, 0x69	; 105
    3488:	30 f4       	brcc	.+12     	; 0x3496 <modf+0x58>
    348a:	9b 01       	movw	r18, r22
    348c:	ac 01       	movw	r20, r24
    348e:	66 27       	eor	r22, r22
    3490:	77 27       	eor	r23, r23
    3492:	88 27       	eor	r24, r24
    3494:	90 78       	andi	r25, 0x80	; 128
    3496:	30 96       	adiw	r30, 0x00	; 0
    3498:	21 f0       	breq	.+8      	; 0x34a2 <modf+0x64>
    349a:	20 83       	st	Z, r18
    349c:	31 83       	std	Z+1, r19	; 0x01
    349e:	42 83       	std	Z+2, r20	; 0x02
    34a0:	53 83       	std	Z+3, r21	; 0x03
    34a2:	08 95       	ret

000034a4 <__mulsi3>:
    34a4:	62 9f       	mul	r22, r18
    34a6:	d0 01       	movw	r26, r0
    34a8:	73 9f       	mul	r23, r19
    34aa:	f0 01       	movw	r30, r0
    34ac:	82 9f       	mul	r24, r18
    34ae:	e0 0d       	add	r30, r0
    34b0:	f1 1d       	adc	r31, r1
    34b2:	64 9f       	mul	r22, r20
    34b4:	e0 0d       	add	r30, r0
    34b6:	f1 1d       	adc	r31, r1
    34b8:	92 9f       	mul	r25, r18
    34ba:	f0 0d       	add	r31, r0
    34bc:	83 9f       	mul	r24, r19
    34be:	f0 0d       	add	r31, r0
    34c0:	74 9f       	mul	r23, r20
    34c2:	f0 0d       	add	r31, r0
    34c4:	65 9f       	mul	r22, r21
    34c6:	f0 0d       	add	r31, r0
    34c8:	99 27       	eor	r25, r25
    34ca:	72 9f       	mul	r23, r18
    34cc:	b0 0d       	add	r27, r0
    34ce:	e1 1d       	adc	r30, r1
    34d0:	f9 1f       	adc	r31, r25
    34d2:	63 9f       	mul	r22, r19
    34d4:	b0 0d       	add	r27, r0
    34d6:	e1 1d       	adc	r30, r1
    34d8:	f9 1f       	adc	r31, r25
    34da:	bd 01       	movw	r22, r26
    34dc:	cf 01       	movw	r24, r30
    34de:	11 24       	eor	r1, r1
    34e0:	08 95       	ret

000034e2 <__udivmodhi4>:
    34e2:	aa 1b       	sub	r26, r26
    34e4:	bb 1b       	sub	r27, r27
    34e6:	51 e1       	ldi	r21, 0x11	; 17
    34e8:	07 c0       	rjmp	.+14     	; 0x34f8 <__udivmodhi4_ep>

000034ea <__udivmodhi4_loop>:
    34ea:	aa 1f       	adc	r26, r26
    34ec:	bb 1f       	adc	r27, r27
    34ee:	a6 17       	cp	r26, r22
    34f0:	b7 07       	cpc	r27, r23
    34f2:	10 f0       	brcs	.+4      	; 0x34f8 <__udivmodhi4_ep>
    34f4:	a6 1b       	sub	r26, r22
    34f6:	b7 0b       	sbc	r27, r23

000034f8 <__udivmodhi4_ep>:
    34f8:	88 1f       	adc	r24, r24
    34fa:	99 1f       	adc	r25, r25
    34fc:	5a 95       	dec	r21
    34fe:	a9 f7       	brne	.-22     	; 0x34ea <__udivmodhi4_loop>
    3500:	80 95       	com	r24
    3502:	90 95       	com	r25
    3504:	bc 01       	movw	r22, r24
    3506:	cd 01       	movw	r24, r26
    3508:	08 95       	ret

0000350a <__udivmodsi4>:
    350a:	a1 e2       	ldi	r26, 0x21	; 33
    350c:	1a 2e       	mov	r1, r26
    350e:	aa 1b       	sub	r26, r26
    3510:	bb 1b       	sub	r27, r27
    3512:	fd 01       	movw	r30, r26
    3514:	0d c0       	rjmp	.+26     	; 0x3530 <__udivmodsi4_ep>

00003516 <__udivmodsi4_loop>:
    3516:	aa 1f       	adc	r26, r26
    3518:	bb 1f       	adc	r27, r27
    351a:	ee 1f       	adc	r30, r30
    351c:	ff 1f       	adc	r31, r31
    351e:	a2 17       	cp	r26, r18
    3520:	b3 07       	cpc	r27, r19
    3522:	e4 07       	cpc	r30, r20
    3524:	f5 07       	cpc	r31, r21
    3526:	20 f0       	brcs	.+8      	; 0x3530 <__udivmodsi4_ep>
    3528:	a2 1b       	sub	r26, r18
    352a:	b3 0b       	sbc	r27, r19
    352c:	e4 0b       	sbc	r30, r20
    352e:	f5 0b       	sbc	r31, r21

00003530 <__udivmodsi4_ep>:
    3530:	66 1f       	adc	r22, r22
    3532:	77 1f       	adc	r23, r23
    3534:	88 1f       	adc	r24, r24
    3536:	99 1f       	adc	r25, r25
    3538:	1a 94       	dec	r1
    353a:	69 f7       	brne	.-38     	; 0x3516 <__udivmodsi4_loop>
    353c:	60 95       	com	r22
    353e:	70 95       	com	r23
    3540:	80 95       	com	r24
    3542:	90 95       	com	r25
    3544:	9b 01       	movw	r18, r22
    3546:	ac 01       	movw	r20, r24
    3548:	bd 01       	movw	r22, r26
    354a:	cf 01       	movw	r24, r30
    354c:	08 95       	ret

0000354e <__divmodsi4>:
    354e:	97 fb       	bst	r25, 7
    3550:	09 2e       	mov	r0, r25
    3552:	05 26       	eor	r0, r21
    3554:	0e d0       	rcall	.+28     	; 0x3572 <__divmodsi4_neg1>
    3556:	57 fd       	sbrc	r21, 7
    3558:	04 d0       	rcall	.+8      	; 0x3562 <__divmodsi4_neg2>
    355a:	d7 df       	rcall	.-82     	; 0x350a <__udivmodsi4>
    355c:	0a d0       	rcall	.+20     	; 0x3572 <__divmodsi4_neg1>
    355e:	00 1c       	adc	r0, r0
    3560:	38 f4       	brcc	.+14     	; 0x3570 <__divmodsi4_exit>

00003562 <__divmodsi4_neg2>:
    3562:	50 95       	com	r21
    3564:	40 95       	com	r20
    3566:	30 95       	com	r19
    3568:	21 95       	neg	r18
    356a:	3f 4f       	sbci	r19, 0xFF	; 255
    356c:	4f 4f       	sbci	r20, 0xFF	; 255
    356e:	5f 4f       	sbci	r21, 0xFF	; 255

00003570 <__divmodsi4_exit>:
    3570:	08 95       	ret

00003572 <__divmodsi4_neg1>:
    3572:	f6 f7       	brtc	.-4      	; 0x3570 <__divmodsi4_exit>
    3574:	90 95       	com	r25
    3576:	80 95       	com	r24
    3578:	70 95       	com	r23
    357a:	61 95       	neg	r22
    357c:	7f 4f       	sbci	r23, 0xFF	; 255
    357e:	8f 4f       	sbci	r24, 0xFF	; 255
    3580:	9f 4f       	sbci	r25, 0xFF	; 255
    3582:	08 95       	ret

00003584 <memcpy>:
    3584:	fb 01       	movw	r30, r22
    3586:	dc 01       	movw	r26, r24
    3588:	02 c0       	rjmp	.+4      	; 0x358e <memcpy+0xa>
    358a:	01 90       	ld	r0, Z+
    358c:	0d 92       	st	X+, r0
    358e:	41 50       	subi	r20, 0x01	; 1
    3590:	50 40       	sbci	r21, 0x00	; 0
    3592:	d8 f7       	brcc	.-10     	; 0x358a <memcpy+0x6>
    3594:	08 95       	ret

00003596 <memset>:
    3596:	dc 01       	movw	r26, r24
    3598:	01 c0       	rjmp	.+2      	; 0x359c <memset+0x6>
    359a:	6d 93       	st	X+, r22
    359c:	41 50       	subi	r20, 0x01	; 1
    359e:	50 40       	sbci	r21, 0x00	; 0
    35a0:	e0 f7       	brcc	.-8      	; 0x359a <memset+0x4>
    35a2:	08 95       	ret

000035a4 <strncpy>:
    35a4:	fb 01       	movw	r30, r22
    35a6:	dc 01       	movw	r26, r24
    35a8:	41 50       	subi	r20, 0x01	; 1
    35aa:	50 40       	sbci	r21, 0x00	; 0
    35ac:	48 f0       	brcs	.+18     	; 0x35c0 <strncpy+0x1c>
    35ae:	01 90       	ld	r0, Z+
    35b0:	0d 92       	st	X+, r0
    35b2:	00 20       	and	r0, r0
    35b4:	c9 f7       	brne	.-14     	; 0x35a8 <strncpy+0x4>
    35b6:	01 c0       	rjmp	.+2      	; 0x35ba <strncpy+0x16>
    35b8:	1d 92       	st	X+, r1
    35ba:	41 50       	subi	r20, 0x01	; 1
    35bc:	50 40       	sbci	r21, 0x00	; 0
    35be:	e0 f7       	brcc	.-8      	; 0x35b8 <strncpy+0x14>
    35c0:	08 95       	ret

000035c2 <_exit>:
    35c2:	f8 94       	cli

000035c4 <__stop_program>:
    35c4:	ff cf       	rjmp	.-2      	; 0x35c4 <__stop_program>
