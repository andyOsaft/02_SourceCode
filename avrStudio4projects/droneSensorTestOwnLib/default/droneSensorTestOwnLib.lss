
droneSensorTestOwnLib.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001ba2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  00001ba2  00001c36  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000026  00800068  00800068  00001c3e  2**0
                  ALLOC
  3 .debug_aranges 00000120  00000000  00000000  00001c3e  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000065a  00000000  00000000  00001d5e  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002847  00000000  00000000  000023b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000cc4  00000000  00000000  00004bff  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001eb9  00000000  00000000  000058c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000410  00000000  00000000  0000777c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000801  00000000  00000000  00007b8c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000015b7  00000000  00000000  0000838d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000000b0  00000000  00000000  00009944  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 57 03 	jmp	0x6ae	; 0x6ae <__ctors_end>
       4:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>
       8:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>
       c:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>
      10:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>
      14:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>
      18:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>
      1c:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>
      20:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>
      24:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>
      28:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>
      2c:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>
      30:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>
      34:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>
      38:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>
      3c:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>
      40:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>
      44:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>
      48:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>
      4c:	0c 94 de 03 	jmp	0x7bc	; 0x7bc <__vector_19>
      50:	0c 94 74 03 	jmp	0x6e8	; 0x6e8 <__bad_interrupt>

00000054 <font_fixed_8px_data>:
      54:	00 00 00 00 00 00 00 3e 45 51 45 3e 00 3e 6b 6f     .......>EQE>.>ko
      64:	6b 3e 00 1c 3e 7c 3e 1c 00 18 3c 7e 3c 18 00 30     k>..>|>...<~<..0
      74:	36 7f 36 30 00 18 5c 7e 5c 18 00 00 00 00 00 00     6.60..\~\.......
	...
      94:	00 00 00 30 48 4a 36 0e 00 06 29 79 29 06 00 00     ...0HJ6...)y)...
      a4:	00 00 00 00 00 60 7e 0a 35 3f 00 2a 1c 36 1c 2a     .....`~.5?.*.6.*
      b4:	00 00 7f 3e 1c 08 00 08 1c 3e 7f 00 00 14 36 7f     ...>.....>....6.
      c4:	36 14 00 00 5f 00 5f 00 00 06 09 7f 01 7f 00 22     6..._._........"
      d4:	4d 55 59 22 00 60 60 60 60 00 00 14 b6 ff b6 14     MUY".````.......
      e4:	00 04 06 7f 06 04 00 10 30 7f 30 10 00 08 08 3e     ........0.0....>
      f4:	1c 08 00 08 1c 3e 08 08 00 78 40 40 40 40 00 08     .....>...x@@@@..
     104:	3e 08 3e 08 00 30 3c 3f 3c 30 00 03 0f 3f 0f 03     >.>..0<?<0...?..
	...
     11c:	06 5f 06 00 00 07 03 00 07 03 00 24 7e 24 7e 24     ._.........$~$~$
     12c:	00 24 2b 6a 12 00 00 63 13 08 64 63 00 36 49 56     .$+j...c..dc.6IV
     13c:	20 50 00 00 07 03 00 00 00 00 3e 41 00 00 00 00      P........>A....
     14c:	41 3e 00 00 00 08 3e 1c 3e 08 00 08 08 3e 08 08     A>....>.>....>..
     15c:	00 00 e0 60 00 00 00 08 08 08 08 08 00 00 60 60     ...`..........``
     16c:	00 00 00 20 10 08 04 02 00 3e 51 49 45 3e 00 00     ... .....>QIE>..
     17c:	42 7f 40 00 00 62 51 49 49 46 00 22 49 49 49 36     B.@..bQIIF."III6
     18c:	00 18 14 12 7f 10 00 2f 49 49 49 31 00 3c 4a 49     ......./III1.<JI
     19c:	49 30 00 01 71 09 05 03 00 36 49 49 49 36 00 06     I0..q....6III6..
     1ac:	49 49 29 1e 00 00 6c 6c 00 00 00 00 ec 6c 00 00     II)...ll.....l..
     1bc:	00 08 14 22 41 00 00 24 24 24 24 24 00 00 41 22     ..."A..$$$$$..A"
     1cc:	14 08 00 02 01 59 09 06 00 3e 41 5d 55 1e 00 7e     .....Y...>A]U..~
     1dc:	11 11 11 7e 00 7f 49 49 49 36 00 3e 41 41 41 22     ...~..III6.>AAA"
     1ec:	00 7f 41 41 41 3e 00 7f 49 49 49 41 00 7f 09 09     ..AAA>..IIIA....
     1fc:	09 01 00 3e 41 49 49 7a 00 7f 08 08 08 7f 00 00     ...>AIIz........
     20c:	41 7f 41 00 00 30 40 40 40 3f 00 7f 08 14 22 41     A.A..0@@@?...."A
     21c:	00 7f 40 40 40 40 00 7f 02 04 02 7f 00 7f 02 04     ..@@@@..........
     22c:	08 7f 00 3e 41 41 41 3e 00 7f 09 09 09 06 00 3e     ...>AAA>.......>
     23c:	41 51 21 5e 00 7f 09 09 19 66 00 26 49 49 49 32     AQ!^.....f.&III2
     24c:	00 01 01 7f 01 01 00 3f 40 40 40 3f 00 1f 20 40     .......?@@@?.. @
     25c:	20 1f 00 3f 40 3c 40 3f 00 63 14 08 14 63 00 07      ..?@<@?.c...c..
     26c:	08 70 08 07 00 71 49 45 43 00 00 00 7f 41 41 00     .p...qIEC....AA.
     27c:	00 02 04 08 10 20 00 00 41 41 7f 00 00 04 02 01     ..... ..AA......
     28c:	02 04 80 80 80 80 80 80 00 00 03 07 00 00 00 20     ............... 
     29c:	54 54 54 78 00 7f 44 44 44 38 00 38 44 44 44 28     TTTx..DDD8.8DDD(
     2ac:	00 38 44 44 44 7f 00 38 54 54 54 08 00 08 7e 09     .8DDD..8TTT...~.
     2bc:	09 00 00 18 a4 a4 a4 7c 00 7f 04 04 78 00 00 00     .......|....x...
     2cc:	00 7d 40 00 00 40 80 84 7d 00 00 7f 10 28 44 00     .}@..@..}....(D.
     2dc:	00 00 00 7f 40 00 00 7c 04 18 04 78 00 7c 04 04     ....@..|...x.|..
     2ec:	78 00 00 38 44 44 44 38 00 fc 44 44 44 38 00 38     x..8DDD8..DDD8.8
     2fc:	44 44 44 fc 00 44 78 44 04 08 00 08 54 54 54 20     DDD..DxD....TTT 
     30c:	00 04 3e 44 24 00 00 3c 40 20 7c 00 00 1c 20 40     ..>D$..<@ |... @
     31c:	20 1c 00 3c 60 30 60 3c 00 6c 10 10 6c 00 00 9c      ..<`0`<.l..l...
     32c:	a0 60 3c 00 00 64 54 54 4c 00 00 08 3e 41 41 00     .`<..dTTL...>AA.
     33c:	00 00 00 77 00 00 00 00 41 41 3e 08 00 02 01 02     ...w....AA>.....
     34c:	01 00 00 3c 26 23 26 3c 00 1e a1 e1 21 12 00 3d     ...<&#&<....!..=
     35c:	40 20 7d 00 00 38 54 54 55 09 00 20 55 55 55 78     @ }..8TTU.. UUUx
     36c:	00 20 55 54 55 78 00 20 55 55 54 78 00 20 57 55     . UTUx. UUTx. WU
     37c:	57 78 00 1c a2 e2 22 14 00 38 55 55 55 08 00 38     Wx...."..8UUU..8
     38c:	55 54 55 08 00 38 55 55 54 08 00 00 01 7c 41 00     UTU..8UUT....|A.
     39c:	00 00 01 7d 41 00 00 00 01 7c 40 00 00 70 29 24     ...}A....|@..p)$
     3ac:	29 70 00 78 2f 25 2f 78 00 7c 54 54 55 45 00 34     )p.x/%/x.|TTUE.4
     3bc:	54 7c 54 58 00 7e 09 7f 49 49 00 38 45 45 39 00     T|TX.~..II.8EE9.
     3cc:	00 38 45 44 39 00 00 39 45 44 38 00 00 3c 41 21     .8ED9..9ED8..<A!
     3dc:	7d 00 00 3d 41 20 7c 00 00 9c a1 60 3d 00 00 3d     }..=A |....`=..=
     3ec:	42 42 3d 00 00 3c 41 40 3d 00 80 70 68 58 38 04     BB=..<A@=..phX8.
     3fc:	00 48 3e 49 49 62 00 7e 61 5d 43 3f 00 22 14 08     .H>IIb.~a]C?."..
     40c:	14 22 00 40 88 7e 09 02 00 20 54 55 55 78 00 00     .".@.~... TUUx..
     41c:	00 7d 41 00 00 38 44 45 39 00 00 3c 40 21 7d 00     .}A..8DE9..<@!}.
     42c:	00 7a 09 0a 71 00 00 7a 11 22 79 00 00 08 55 55     .z..q..z."y...UU
     43c:	55 5e 00 4e 51 51 4e 00 00 30 48 4d 40 20 3e 41     U^.NQQN..0HM@ >A
     44c:	5d 4b 55 3e 04 04 04 04 04 1c 00 17 08 4c 6a 50     ]KU>.........LjP
     45c:	00 17 08 34 2a 78 00 00 30 7d 30 00 00 08 14 00     ...4*x..0}0.....
     46c:	08 14 00 14 08 00 14 08 44 11 44 11 44 11 aa 55     ........D.D.D..U
     47c:	aa 55 aa 55 bb ee bb ee bb ee 00 00 00 ff 00 00     .U.U............
     48c:	08 08 08 ff 00 00 00 70 28 25 29 70 00 70 29 25     .......p(%)p.p)%
     49c:	29 70 00 70 29 25 28 70 3e 41 5d 55 41 3e 0a fb     )p.p)%(p>A]UA>..
     4ac:	00 ff 00 00 00 ff 00 ff 00 00 0a fa 02 fe 00 00     ................
     4bc:	0a 0b 08 0f 00 00 00 18 24 66 24 00 00 29 2a 7c     ........$f$..)*|
     4cc:	2a 29 08 08 08 f8 00 00 00 00 00 0f 08 08 08 08     *)..............
     4dc:	08 0f 08 08 08 08 08 f8 08 08 00 00 00 ff 08 08     ................
     4ec:	08 08 08 08 08 08 08 08 08 ff 08 08 00 20 56 55     ............. VU
     4fc:	56 79 00 70 2a 25 2a 71 00 0f 08 0b 0a 0a 00 fe     Vy.p*%*q........
     50c:	02 fa 0a 0a 0a 0b 08 0b 0a 0a 0a fa 02 fa 0a 0a     ................
     51c:	00 ff 00 fb 0a 0a 0a 0a 0a 0a 0a 0a 0a fb 00 fb     ................
     52c:	0a 0a 00 5d 22 22 22 5d 00 22 55 59 30 00 00 08     ...]"""]."UY0...
     53c:	7f 49 41 3e 00 7c 55 55 55 44 00 7c 55 54 55 44     .IA>.|UUUD.|UTUD
     54c:	00 7c 55 55 54 44 00 00 00 07 00 00 00 00 44 7d     .|UUTD........D}
     55c:	45 00 00 00 45 7d 45 00 00 00 45 7c 45 00 08 08     E...E}E...E|E...
     56c:	08 0f 00 00 00 00 00 f8 08 08 ff ff ff ff ff ff     ................
     57c:	f0 f0 f0 f0 f0 f0 00 00 00 77 00 00 00 00 45 7d     .........w....E}
     58c:	44 00 0f 0f 0f 0f 0f 0f 00 3c 42 43 3d 00 00 fe     D........<BC=...
     59c:	4a 4a 34 00 00 3c 43 43 3d 00 00 3d 43 42 3c 00     JJ4..<CC=..=CB<.
     5ac:	00 32 49 4a 31 00 00 3a 45 46 39 00 00 fc 20 20     .2IJ1..:EF9...  
     5bc:	1c 00 00 fe aa 28 10 00 00 ff a5 24 18 00 00 3c     .....(.....$...<
     5cc:	40 41 3d 00 00 3c 41 41 3d 00 00 3d 41 40 3c 00     @A=..<AA=..=A@<.
     5dc:	00 9c a0 61 3d 00 00 04 08 71 09 04 00 00 02 02     ...a=....q......
     5ec:	02 00 00 00 07 03 00 00 00 00 08 08 08 00 00 00     ................
     5fc:	24 2e 24 00 00 24 24 24 24 24 05 17 0a 34 2a 78     $.$..$$$$$...4*x
     60c:	00 06 09 7f 01 7f 00 22 4d 55 59 22 00 08 08 2a     ......."MUY"...*
     61c:	08 08 00 00 08 18 18 00 00 06 09 09 06 00 00 00     ................
     62c:	08 00 08 00 00 00 08 00 00 00 00 02 0f 00 00 00     ................
     63c:	00 09 0f 05 00 00 00 09 0d 0a 00 00 00 3c 3c 3c     .............<<<
     64c:	3c 00 00 00 00 00 00 00                             <.......

00000654 <font_fixed_8px>:
     654:	00 06 06 08 00 ff 00 00 54 00                       ........T.

0000065e <__c.1989>:
     65e:	6c 61 73 74 20 6f 6e 65 20 20 20 20 20 00           last one     .

0000066c <__c.1987>:
     66c:	6d 64 3a 20 20 00                                   md:  .

00000672 <__c.1985>:
     672:	6d 63 3a 20 20 00                                   mc:  .

00000678 <__c.1983>:
     678:	6d 62 3a 20 20 00                                   mb:  .

0000067e <__c.1981>:
     67e:	62 32 3a 20 20 00                                   b2:  .

00000684 <__c.1979>:
     684:	62 31 3a 20 20 00                                   b1:  .

0000068a <__c.1977>:
     68a:	61 63 36 3a 20 00                                   ac6: .

00000690 <__c.1975>:
     690:	61 63 35 3a 20 00                                   ac5: .

00000696 <__c.1973>:
     696:	61 63 34 3a 20 00                                   ac4: .

0000069c <__c.1971>:
     69c:	61 63 33 3a 20 00                                   ac3: .

000006a2 <__c.1969>:
     6a2:	61 63 32 3a 20 00                                   ac2: .

000006a8 <__c.1967>:
     6a8:	61 63 31 3a 20 00                                   ac1: .

000006ae <__ctors_end>:
     6ae:	11 24       	eor	r1, r1
     6b0:	1f be       	out	0x3f, r1	; 63
     6b2:	cf e5       	ldi	r28, 0x5F	; 95
     6b4:	d8 e0       	ldi	r29, 0x08	; 8
     6b6:	de bf       	out	0x3e, r29	; 62
     6b8:	cd bf       	out	0x3d, r28	; 61

000006ba <__do_copy_data>:
     6ba:	10 e0       	ldi	r17, 0x00	; 0
     6bc:	a0 e6       	ldi	r26, 0x60	; 96
     6be:	b0 e0       	ldi	r27, 0x00	; 0
     6c0:	e2 ea       	ldi	r30, 0xA2	; 162
     6c2:	fb e1       	ldi	r31, 0x1B	; 27
     6c4:	02 c0       	rjmp	.+4      	; 0x6ca <.do_copy_data_start>

000006c6 <.do_copy_data_loop>:
     6c6:	05 90       	lpm	r0, Z+
     6c8:	0d 92       	st	X+, r0

000006ca <.do_copy_data_start>:
     6ca:	a8 36       	cpi	r26, 0x68	; 104
     6cc:	b1 07       	cpc	r27, r17
     6ce:	d9 f7       	brne	.-10     	; 0x6c6 <.do_copy_data_loop>

000006d0 <__do_clear_bss>:
     6d0:	10 e0       	ldi	r17, 0x00	; 0
     6d2:	a8 e6       	ldi	r26, 0x68	; 104
     6d4:	b0 e0       	ldi	r27, 0x00	; 0
     6d6:	01 c0       	rjmp	.+2      	; 0x6da <.do_clear_bss_start>

000006d8 <.do_clear_bss_loop>:
     6d8:	1d 92       	st	X+, r1

000006da <.do_clear_bss_start>:
     6da:	ae 38       	cpi	r26, 0x8E	; 142
     6dc:	b1 07       	cpc	r27, r17
     6de:	e1 f7       	brne	.-8      	; 0x6d8 <.do_clear_bss_loop>
     6e0:	0e 94 76 03 	call	0x6ec	; 0x6ec <main>
     6e4:	0c 94 cf 0d 	jmp	0x1b9e	; 0x1b9e <_exit>

000006e8 <__bad_interrupt>:
     6e8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006ec <main>:




int main (void)
{
     6ec:	df 93       	push	r29
     6ee:	cf 93       	push	r28
     6f0:	00 d0       	rcall	.+0      	; 0x6f2 <main+0x6>
     6f2:	cd b7       	in	r28, 0x3d	; 61
     6f4:	de b7       	in	r29, 0x3e	; 62
	
	
	volatile int16_t temperature;
	
	sei();
     6f6:	78 94       	sei
	
	myInit();
     6f8:	0e 94 32 0a 	call	0x1464	; 0x1464 <myInit>
	
	//TWI_Master_Initialise();
	//pwmInit(100);
	
	lcd_set_font(FONT_FIXED_8,NORMAL);
     6fc:	84 e5       	ldi	r24, 0x54	; 84
     6fe:	96 e0       	ldi	r25, 0x06	; 6
     700:	60 e0       	ldi	r22, 0x00	; 0
     702:	0e 94 70 06 	call	0xce0	; 0xce0 <lcd_set_font>
	//lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("Init ... done!"));
	
	bmp085_getCalibrationData();
     706:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <bmp085_getCalibrationData>
	//bmp085_displayCalibrationData();
	
	while(1)
	{

		temperature = bmp085_readTemp();	
     70a:	0e 94 c0 0a 	call	0x1580	; 0x1580 <bmp085_readTemp>
     70e:	7a 83       	std	Y+2, r23	; 0x02
     710:	69 83       	std	Y+1, r22	; 0x01
     712:	fb cf       	rjmp	.-10     	; 0x70a <main+0x1e>

00000714 <TWI_Master_Initialise>:
Call this function to set up the TWI master to its initial standby state.
Remember to enable interrupts from the main application after initializing the TWI.
****************************************************************************/
void TWI_Master_Initialise(void)
{
	TWBR = TWI_TWBR;                        // Set bit rate register (Baudrate). Defined in header file.
     714:	80 e2       	ldi	r24, 0x20	; 32
     716:	80 b9       	out	0x00, r24	; 0
    // TWSR = TWI_TWPS;                     // Not used. Driver presumes prescaler to be 00.
	//TWDR = 0xFF;							// Default content = SDA released.
	TWCR = (1<<TWEN);//|						// Enable TWI-interface and release TWI pins.
     718:	84 e0       	ldi	r24, 0x04	; 4
     71a:	86 bf       	out	0x36, r24	; 54
         //(0<<TWIE)|(0<<TWINT)|              // Disable Interupt.
         //(0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|   // No Signal requests.
         //(0<<TWWC);                         //
}    
     71c:	08 95       	ret

0000071e <TWI_Transceiver_Busy>:
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
 	return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
     71e:	86 b7       	in	r24, 0x36	; 54
}
     720:	81 70       	andi	r24, 0x01	; 1
     722:	08 95       	ret

00000724 <TWI_Get_State_Info>:
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
	  while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
     724:	06 b6       	in	r0, 0x36	; 54
     726:	00 fc       	sbrc	r0, 0
     728:	fd cf       	rjmp	.-6      	; 0x724 <TWI_Get_State_Info>
	  return ( TWI_state );                         // Return error state.
}
     72a:	80 91 60 00 	lds	r24, 0x0060
     72e:	08 95       	ret

00000730 <TWI_Start_Transceiver_With_Data>:
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
     730:	fc 01       	movw	r30, r24
	  unsigned char temp;

	  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
     732:	06 b6       	in	r0, 0x36	; 54
     734:	00 fc       	sbrc	r0, 0
     736:	fd cf       	rjmp	.-6      	; 0x732 <TWI_Start_Transceiver_With_Data+0x2>

	  TWI_msgSize = msgSize;                        // Number of data to transmit.
     738:	60 93 6e 00 	sts	0x006E, r22
	  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
     73c:	80 81       	ld	r24, Z
     73e:	80 93 6a 00 	sts	0x006A, r24
	  
	  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
     742:	80 fd       	sbrc	r24, 0
     744:	0d c0       	rjmp	.+26     	; 0x760 <TWI_Start_Transceiver_With_Data+0x30>
     746:	4e 2f       	mov	r20, r30
     748:	ab e6       	ldi	r26, 0x6B	; 107
     74a:	b0 e0       	ldi	r27, 0x00	; 0
     74c:	cf 01       	movw	r24, r30
     74e:	fc 01       	movw	r30, r24
     750:	02 c0       	rjmp	.+4      	; 0x756 <TWI_Start_Transceiver_With_Data+0x26>
	  {
		for ( temp = 1; temp < msgSize; temp++ )
		  TWI_buf[ temp ] = msg[ temp ];
     752:	80 81       	ld	r24, Z
     754:	8d 93       	st	X+, r24
     756:	31 96       	adiw	r30, 0x01	; 1
	  TWI_msgSize = msgSize;                        // Number of data to transmit.
	  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
	  
	  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
	  {
		for ( temp = 1; temp < msgSize; temp++ )
     758:	8e 2f       	mov	r24, r30
     75a:	84 1b       	sub	r24, r20
     75c:	86 17       	cp	r24, r22
     75e:	c8 f3       	brcs	.-14     	; 0x752 <TWI_Start_Transceiver_With_Data+0x22>
		  TWI_buf[ temp ] = msg[ temp ];
	  }
	  
	  //TWI_statusReg.all = 0;
	  TWI_statusReg.all = 0;      
     760:	10 92 68 00 	sts	0x0068, r1
	  TWI_state         = TWI_NO_STATE ;
     764:	88 ef       	ldi	r24, 0xF8	; 248
     766:	80 93 60 00 	sts	0x0060, r24
	  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
     76a:	85 ea       	ldi	r24, 0xA5	; 165
     76c:	86 bf       	out	0x36, r24	; 54
			 (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interrupt and clear the flag.
			 (1<<TWSTA);                            // Initiate a START condition.

}
     76e:	08 95       	ret

00000770 <TWI_Start_Transceiver>:
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
     770:	06 b6       	in	r0, 0x36	; 54
     772:	00 fc       	sbrc	r0, 0
     774:	fd cf       	rjmp	.-6      	; 0x770 <TWI_Start_Transceiver>
	  
	TWI_statusReg.all = 0;      
     776:	10 92 68 00 	sts	0x0068, r1
	TWI_state         = TWI_NO_STATE ;
     77a:	88 ef       	ldi	r24, 0xF8	; 248
     77c:	80 93 60 00 	sts	0x0060, r24
	  
	TWCR = (1<<TWEN)|                             // TWI Interface enabled.
     780:	85 ea       	ldi	r24, 0xA5	; 165
     782:	86 bf       	out	0x36, r24	; 54
			(1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
			(0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
			(0<<TWWC);                             //
}
     784:	08 95       	ret

00000786 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
     786:	ac 01       	movw	r20, r24
	unsigned char i;

	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
     788:	06 b6       	in	r0, 0x36	; 54
     78a:	00 fc       	sbrc	r0, 0
     78c:	fd cf       	rjmp	.-6      	; 0x788 <TWI_Get_Data_From_Transceiver+0x2>

	if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
     78e:	80 91 68 00 	lds	r24, 0x0068
     792:	80 ff       	sbrs	r24, 0
     794:	0f c0       	rjmp	.+30     	; 0x7b4 <TWI_Get_Data_From_Transceiver+0x2e>
     796:	20 e0       	ldi	r18, 0x00	; 0
     798:	30 e0       	ldi	r19, 0x00	; 0
     79a:	0a c0       	rjmp	.+20     	; 0x7b0 <TWI_Get_Data_From_Transceiver+0x2a>
	{                                             
		for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
		{
			msg[ i ] = TWI_buf[ i ];
     79c:	fa 01       	movw	r30, r20
     79e:	e2 0f       	add	r30, r18
     7a0:	f3 1f       	adc	r31, r19
     7a2:	d9 01       	movw	r26, r18
     7a4:	a6 59       	subi	r26, 0x96	; 150
     7a6:	bf 4f       	sbci	r27, 0xFF	; 255
     7a8:	8c 91       	ld	r24, X
     7aa:	80 83       	st	Z, r24
     7ac:	2f 5f       	subi	r18, 0xFF	; 255
     7ae:	3f 4f       	sbci	r19, 0xFF	; 255

	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

	if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
	{                                             
		for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
     7b0:	26 17       	cp	r18, r22
     7b2:	a0 f3       	brcs	.-24     	; 0x79c <TWI_Get_Data_From_Transceiver+0x16>
     7b4:	80 91 68 00 	lds	r24, 0x0068
			msg[ i ] = TWI_buf[ i ];
		}
	}

	return( TWI_statusReg.lastTransOK );                                   
}
     7b8:	81 70       	andi	r24, 0x01	; 1
     7ba:	08 95       	ret

000007bc <__vector_19>:
//#pragma vector=TWI_vect
//__interrupt void TWI_ISR(void)
//-> adapted to gcc style
//TWI_vect
ISR(_VECTOR(19))
{
     7bc:	1f 92       	push	r1
     7be:	0f 92       	push	r0
     7c0:	0f b6       	in	r0, 0x3f	; 63
     7c2:	0f 92       	push	r0
     7c4:	11 24       	eor	r1, r1
     7c6:	2f 93       	push	r18
     7c8:	3f 93       	push	r19
     7ca:	8f 93       	push	r24
     7cc:	9f 93       	push	r25
     7ce:	ef 93       	push	r30
     7d0:	ff 93       	push	r31
  
  
  
 
  
  switch (TWSR)
     7d2:	81 b1       	in	r24, 0x01	; 1
     7d4:	88 32       	cpi	r24, 0x28	; 40
     7d6:	c9 f0       	breq	.+50     	; 0x80a <__vector_19+0x4e>
     7d8:	89 32       	cpi	r24, 0x29	; 41
     7da:	40 f4       	brcc	.+16     	; 0x7ec <__vector_19+0x30>
     7dc:	80 31       	cpi	r24, 0x10	; 16
     7de:	99 f0       	breq	.+38     	; 0x806 <__vector_19+0x4a>
     7e0:	88 31       	cpi	r24, 0x18	; 24
     7e2:	99 f0       	breq	.+38     	; 0x80a <__vector_19+0x4e>
     7e4:	88 30       	cpi	r24, 0x08	; 8
     7e6:	09 f0       	breq	.+2      	; 0x7ea <__vector_19+0x2e>
     7e8:	4b c0       	rjmp	.+150    	; 0x880 <__stack+0x21>
     7ea:	0d c0       	rjmp	.+26     	; 0x806 <__vector_19+0x4a>
     7ec:	80 34       	cpi	r24, 0x40	; 64
     7ee:	51 f1       	breq	.+84     	; 0x844 <__vector_19+0x88>
     7f0:	81 34       	cpi	r24, 0x41	; 65
     7f2:	20 f4       	brcc	.+8      	; 0x7fc <__vector_19+0x40>
     7f4:	88 33       	cpi	r24, 0x38	; 56
     7f6:	09 f0       	breq	.+2      	; 0x7fa <__vector_19+0x3e>
     7f8:	43 c0       	rjmp	.+134    	; 0x880 <__stack+0x21>
     7fa:	40 c0       	rjmp	.+128    	; 0x87c <__stack+0x1d>
     7fc:	80 35       	cpi	r24, 0x50	; 80
     7fe:	b9 f0       	breq	.+46     	; 0x82e <__vector_19+0x72>
     800:	88 35       	cpi	r24, 0x58	; 88
     802:	f1 f5       	brne	.+124    	; 0x880 <__stack+0x21>
     804:	2d c0       	rjmp	.+90     	; 0x860 <__stack+0x1>
  {
    case TWI_START:             // START has been transmitted  
	case TWI_REP_START:         // Repeated START has been transmitted
		TWI_bufPtr = 0;         // Set buffer pointer to the TWI Address location
     806:	10 92 69 00 	sts	0x0069, r1
    
	case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
		if (TWI_bufPtr < TWI_msgSize)
     80a:	90 91 69 00 	lds	r25, 0x0069
     80e:	80 91 6e 00 	lds	r24, 0x006E
     812:	98 17       	cp	r25, r24
     814:	60 f5       	brcc	.+88     	; 0x86e <__stack+0xf>
		{
			TWDR = TWI_buf[TWI_bufPtr++];
     816:	90 91 69 00 	lds	r25, 0x0069
     81a:	e9 2f       	mov	r30, r25
     81c:	f0 e0       	ldi	r31, 0x00	; 0
     81e:	e6 59       	subi	r30, 0x96	; 150
     820:	ff 4f       	sbci	r31, 0xFF	; 255
     822:	80 81       	ld	r24, Z
     824:	83 b9       	out	0x03, r24	; 3
     826:	9f 5f       	subi	r25, 0xFF	; 255
     828:	90 93 69 00 	sts	0x0069, r25
     82c:	17 c0       	rjmp	.+46     	; 0x85c <__vector_19+0xa0>
				   (0<<TWWC);                                 //
		}
		break;
    
	case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
		TWI_buf[TWI_bufPtr++] = TWDR;
     82e:	80 91 69 00 	lds	r24, 0x0069
     832:	93 b1       	in	r25, 0x03	; 3
     834:	e8 2f       	mov	r30, r24
     836:	f0 e0       	ldi	r31, 0x00	; 0
     838:	e6 59       	subi	r30, 0x96	; 150
     83a:	ff 4f       	sbci	r31, 0xFF	; 255
     83c:	90 83       	st	Z, r25
     83e:	8f 5f       	subi	r24, 0xFF	; 255
     840:	80 93 69 00 	sts	0x0069, r24
    
	case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
		if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
     844:	20 91 69 00 	lds	r18, 0x0069
     848:	30 e0       	ldi	r19, 0x00	; 0
     84a:	80 91 6e 00 	lds	r24, 0x006E
     84e:	90 e0       	ldi	r25, 0x00	; 0
     850:	01 97       	sbiw	r24, 0x01	; 1
     852:	28 17       	cp	r18, r24
     854:	39 07       	cpc	r19, r25
     856:	14 f4       	brge	.+4      	; 0x85c <__vector_19+0xa0>
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     858:	85 ec       	ldi	r24, 0xC5	; 197
     85a:	16 c0       	rjmp	.+44     	; 0x888 <__stack+0x29>
				   (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
				   (0<<TWWC);                                 //  
		}
		else                    // Send NACK after next reception
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     85c:	85 e8       	ldi	r24, 0x85	; 133
     85e:	14 c0       	rjmp	.+40     	; 0x888 <__stack+0x29>
				   (0<<TWWC);                                 // 
		}    
		break; 
    
	case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
		TWI_buf[TWI_bufPtr] = TWDR;
     860:	e0 91 69 00 	lds	r30, 0x0069
     864:	83 b1       	in	r24, 0x03	; 3
     866:	f0 e0       	ldi	r31, 0x00	; 0
     868:	e6 59       	subi	r30, 0x96	; 150
     86a:	ff 4f       	sbci	r31, 0xFF	; 255
     86c:	80 83       	st	Z, r24
		TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
     86e:	80 91 68 00 	lds	r24, 0x0068
     872:	81 60       	ori	r24, 0x01	; 1
     874:	80 93 68 00 	sts	0x0068, r24
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     878:	84 e9       	ldi	r24, 0x94	; 148
     87a:	06 c0       	rjmp	.+12     	; 0x888 <__stack+0x29>
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
		break;      
    
	case TWI_ARB_LOST:          // Arbitration lost
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
     87c:	85 ea       	ldi	r24, 0xA5	; 165
     87e:	04 c0       	rjmp	.+8      	; 0x888 <__stack+0x29>
//    case TWI_NO_STATE              // No relevant state information available; TWINT = “0”
   
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
   
    default:     
		TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
     880:	81 b1       	in	r24, 0x01	; 1
     882:	80 93 60 00 	sts	0x0060, r24
                                                        // Reset TWI Interface
		TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
     886:	84 e0       	ldi	r24, 0x04	; 4
     888:	86 bf       	out	0x36, r24	; 54
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }

}
     88a:	ff 91       	pop	r31
     88c:	ef 91       	pop	r30
     88e:	9f 91       	pop	r25
     890:	8f 91       	pop	r24
     892:	3f 91       	pop	r19
     894:	2f 91       	pop	r18
     896:	0f 90       	pop	r0
     898:	0f be       	out	0x3f, r0	; 63
     89a:	0f 90       	pop	r0
     89c:	1f 90       	pop	r1
     89e:	18 95       	reti

000008a0 <lcd_inc_page>:
/******************************************************************************
 * Changes the internal cursor by s pages
 * s             - number of pages to move
 */ 
uint8_t lcd_inc_page(int8_t s) {
  uint8_t p = lcd_current_page;
     8a0:	90 91 6f 00 	lds	r25, 0x006F
  p += s;
     8a4:	98 0f       	add	r25, r24
  p %= LCD_RAM_PAGES;    //all lcd have lcd_ram_pages which is power of two
     8a6:	93 70       	andi	r25, 0x03	; 3
  lcd_current_page = p;
     8a8:	90 93 6f 00 	sts	0x006F, r25
  return p;
  }
     8ac:	89 2f       	mov	r24, r25
     8ae:	08 95       	ret

000008b0 <lcd_inc_column>:

/******************************************************************************
 * Changes the internal cursor by s columns, including wrapping (if selected)
 * s             - number of columns to move
 */ 
uint8_t lcd_inc_column(int16_t s) {
     8b0:	ac 01       	movw	r20, r24
  uint16_t c = lcd_current_column;
     8b2:	80 91 70 00 	lds	r24, 0x0070
  c += s;
     8b6:	9a 01       	movw	r18, r20
     8b8:	28 0f       	add	r18, r24
     8ba:	31 1d       	adc	r19, r1
     8bc:	80 91 6f 00 	lds	r24, 0x006F
     8c0:	0c c0       	rjmp	.+24     	; 0x8da <lcd_inc_column+0x2a>
#if LCD_WRAP_AROUND == 1
  while (c >= LCD_WIDTH) {
    if (s > 0) lcd_inc_page(1);
     8c2:	14 16       	cp	r1, r20
     8c4:	15 06       	cpc	r1, r21
     8c6:	2c f4       	brge	.+10     	; 0x8d2 <lcd_inc_column+0x22>
 * Changes the internal cursor by s pages
 * s             - number of pages to move
 */ 
uint8_t lcd_inc_page(int8_t s) {
  uint8_t p = lcd_current_page;
  p += s;
     8c8:	8f 5f       	subi	r24, 0xFF	; 255
  p %= LCD_RAM_PAGES;    //all lcd have lcd_ram_pages which is power of two
     8ca:	83 70       	andi	r24, 0x03	; 3
  c += s;
#if LCD_WRAP_AROUND == 1
  while (c >= LCD_WIDTH) {
    if (s > 0) lcd_inc_page(1);
    else       lcd_inc_page(-1);
    if (s > 0) c -= LCD_WIDTH;
     8cc:	24 58       	subi	r18, 0x84	; 132
     8ce:	30 40       	sbci	r19, 0x00	; 0
     8d0:	04 c0       	rjmp	.+8      	; 0x8da <lcd_inc_column+0x2a>
 * Changes the internal cursor by s pages
 * s             - number of pages to move
 */ 
uint8_t lcd_inc_page(int8_t s) {
  uint8_t p = lcd_current_page;
  p += s;
     8d2:	81 50       	subi	r24, 0x01	; 1
  p %= LCD_RAM_PAGES;    //all lcd have lcd_ram_pages which is power of two
     8d4:	83 70       	andi	r24, 0x03	; 3
#if LCD_WRAP_AROUND == 1
  while (c >= LCD_WIDTH) {
    if (s > 0) lcd_inc_page(1);
    else       lcd_inc_page(-1);
    if (s > 0) c -= LCD_WIDTH;
    else       c += LCD_WIDTH;
     8d6:	2c 57       	subi	r18, 0x7C	; 124
     8d8:	3f 4f       	sbci	r19, 0xFF	; 255
 */ 
uint8_t lcd_inc_column(int16_t s) {
  uint16_t c = lcd_current_column;
  c += s;
#if LCD_WRAP_AROUND == 1
  while (c >= LCD_WIDTH) {
     8da:	24 38       	cpi	r18, 0x84	; 132
     8dc:	31 05       	cpc	r19, r1
     8de:	88 f7       	brcc	.-30     	; 0x8c2 <lcd_inc_column+0x12>
     8e0:	80 93 6f 00 	sts	0x006F, r24
    else       lcd_inc_page(-1);
    if (s > 0) c -= LCD_WIDTH;
    else       c += LCD_WIDTH;
    }
#endif
  lcd_current_column = c;
     8e4:	20 93 70 00 	sts	0x0070, r18
  return c;
  }
     8e8:	82 2f       	mov	r24, r18
     8ea:	08 95       	ret

000008ec <lcd_data>:
/******************************************************************************
 * Writes one data byte
 * data          - the data byte
 */
void lcd_data(uint8_t data) {
  LCD_SELECT();
     8ec:	c4 98       	cbi	0x18, 4	; 24
  LCD_DRAM();
     8ee:	dd 9a       	sbi	0x1b, 5	; 27
  spi_write(data);
     8f0:	8f b9       	out	0x0f, r24	; 15
  LCD_UNSELECT();
     8f2:	77 9b       	sbis	0x0e, 7	; 14
     8f4:	fe cf       	rjmp	.-4      	; 0x8f2 <lcd_data+0x6>
     8f6:	c4 9a       	sbi	0x18, 4	; 24
  lcd_inc_column(1);
     8f8:	81 e0       	ldi	r24, 0x01	; 1
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	0e 94 58 04 	call	0x8b0	; 0x8b0 <lcd_inc_column>
  }
     900:	08 95       	ret

00000902 <lcd_command>:
/******************************************************************************
 * Writes one command byte
 * cmd           - the command byte
 */
void lcd_command(uint8_t cmd) {
  LCD_SELECT();
     902:	c4 98       	cbi	0x18, 4	; 24
  LCD_CMD();
     904:	dd 98       	cbi	0x1b, 5	; 27
   
  spi_write(cmd);
     906:	8f b9       	out	0x0f, r24	; 15
  
  
  //LCD_UNSELECT();
  while(!(SPSR & (1<<SPIF)));
     908:	77 9b       	sbis	0x0e, 7	; 14
     90a:	fe cf       	rjmp	.-4      	; 0x908 <lcd_command+0x6>
  PORT_CS |= _BV(PIN_CS);
     90c:	c4 9a       	sbi	0x18, 4	; 24
  }
     90e:	08 95       	ret

00000910 <lcd_moveto_xy>:
/******************************************************************************
 * Moves the cursor to the given position
 * pages         - page to move to
 * columns       - column to move to
 */ 
void lcd_moveto_xy(uint8_t page, uint8_t column) {
     910:	0f 93       	push	r16
     912:	1f 93       	push	r17
     914:	08 2f       	mov	r16, r24
     916:	16 2f       	mov	r17, r22
  LCD_GOTO_ADDRESS(page,column);
     918:	8f 70       	andi	r24, 0x0F	; 15
     91a:	80 6b       	ori	r24, 0xB0	; 176
     91c:	0e 94 81 04 	call	0x902	; 0x902 <lcd_command>
     920:	81 2f       	mov	r24, r17
     922:	82 95       	swap	r24
     924:	8f 70       	andi	r24, 0x0F	; 15
     926:	80 61       	ori	r24, 0x10	; 16
     928:	0e 94 81 04 	call	0x902	; 0x902 <lcd_command>
     92c:	81 2f       	mov	r24, r17
     92e:	8f 70       	andi	r24, 0x0F	; 15
     930:	0e 94 81 04 	call	0x902	; 0x902 <lcd_command>
  lcd_current_column = column; 
     934:	10 93 70 00 	sts	0x0070, r17
  lcd_current_page = page;
     938:	00 93 6f 00 	sts	0x006F, r16
  }
     93c:	1f 91       	pop	r17
     93e:	0f 91       	pop	r16
     940:	08 95       	ret

00000942 <lcd_move_xy>:
/******************************************************************************
 * Moves the cursor relative to the current position
 * pages         - number of pages to move
 * columns       - number of columns to move
 */  
void lcd_move_xy(int8_t pages, int16_t columns) {
     942:	1f 93       	push	r17
/******************************************************************************
 * Changes the internal cursor by s pages
 * s             - number of pages to move
 */ 
uint8_t lcd_inc_page(int8_t s) {
  uint8_t p = lcd_current_page;
     944:	10 91 6f 00 	lds	r17, 0x006F
  p += s;
     948:	18 0f       	add	r17, r24
  p %= LCD_RAM_PAGES;    //all lcd have lcd_ram_pages which is power of two
     94a:	13 70       	andi	r17, 0x03	; 3
  lcd_current_page = p;
     94c:	10 93 6f 00 	sts	0x006F, r17
 * Moves the cursor relative to the current position
 * pages         - number of pages to move
 * columns       - number of columns to move
 */  
void lcd_move_xy(int8_t pages, int16_t columns) {
  lcd_moveto_xy(lcd_inc_page(pages),lcd_inc_column(columns));
     950:	cb 01       	movw	r24, r22
     952:	0e 94 58 04 	call	0x8b0	; 0x8b0 <lcd_inc_column>
     956:	68 2f       	mov	r22, r24
     958:	81 2f       	mov	r24, r17
     95a:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
  }
     95e:	1f 91       	pop	r17
     960:	08 95       	ret

00000962 <lcd_draw_image_P>:
 * progmem_image - prog_uint8_t array of columns aka the bitmap image
 * pages         - height of image in pages
 * columns       - width of image in pixels (or columns)
 * style         - Bit2: sets inverse mode
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
     962:	bf 92       	push	r11
     964:	cf 92       	push	r12
     966:	df 92       	push	r13
     968:	ef 92       	push	r14
     96a:	ff 92       	push	r15
     96c:	0f 93       	push	r16
     96e:	1f 93       	push	r17
     970:	cf 93       	push	r28
     972:	df 93       	push	r29
     974:	08 2f       	mov	r16, r24
     976:	e9 2f       	mov	r30, r25
     978:	b6 2e       	mov	r11, r22
     97a:	e4 2e       	mov	r14, r20
     97c:	f2 2e       	mov	r15, r18
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
     97e:	24 e0       	ldi	r18, 0x04	; 4
     980:	f2 22       	and	r15, r18
     982:	10 e0       	ldi	r17, 0x00	; 0
				lcd_data(tmp);
			else
				lcd_data(~tmp);
      }
    if(++j != pages)
      lcd_move_xy(1,-columns);
     984:	84 2f       	mov	r24, r20
     986:	90 e0       	ldi	r25, 0x00	; 0
     988:	cc 24       	eor	r12, r12
     98a:	dd 24       	eor	r13, r13
     98c:	c8 1a       	sub	r12, r24
     98e:	d9 0a       	sbc	r13, r25
     990:	18 c0       	rjmp	.+48     	; 0x9c2 <lcd_draw_image_P+0x60>
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++) {
      uint8_t tmp = pgm_read_byte(progmem_image++);
     992:	fe 01       	movw	r30, r28
     994:	84 91       	lpm	r24, Z+
			if(!inv)
     996:	f1 10       	cpse	r15, r1
				lcd_data(tmp);
			else
				lcd_data(~tmp);
     998:	80 95       	com	r24
     99a:	0e 94 76 04 	call	0x8ec	; 0x8ec <lcd_data>
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++) {
      uint8_t tmp = pgm_read_byte(progmem_image++);
     99e:	21 96       	adiw	r28, 0x01	; 1
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++) {
     9a0:	9e 01       	movw	r18, r28
     9a2:	20 1b       	sub	r18, r16
     9a4:	2e 15       	cp	r18, r14
     9a6:	20 f4       	brcc	.+8      	; 0x9b0 <lcd_draw_image_P+0x4e>
     9a8:	80 91 70 00 	lds	r24, 0x0070
     9ac:	84 38       	cpi	r24, 0x84	; 132
     9ae:	88 f3       	brcs	.-30     	; 0x992 <lcd_draw_image_P+0x30>
			if(!inv)
				lcd_data(tmp);
			else
				lcd_data(~tmp);
      }
    if(++j != pages)
     9b0:	1f 5f       	subi	r17, 0xFF	; 255
     9b2:	1b 15       	cp	r17, r11
     9b4:	21 f0       	breq	.+8      	; 0x9be <lcd_draw_image_P+0x5c>
      lcd_move_xy(1,-columns);
     9b6:	81 e0       	ldi	r24, 0x01	; 1
     9b8:	b6 01       	movw	r22, r12
     9ba:	0e 94 a1 04 	call	0x942	; 0x942 <lcd_move_xy>
     9be:	0c 2f       	mov	r16, r28
     9c0:	ed 2f       	mov	r30, r29
 * style         - Bit2: sets inverse mode
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
     9c2:	1b 15       	cp	r17, r11
     9c4:	48 f4       	brcc	.+18     	; 0x9d8 <lcd_draw_image_P+0x76>
     9c6:	80 91 6f 00 	lds	r24, 0x006F
     9ca:	84 30       	cpi	r24, 0x04	; 4
     9cc:	28 f4       	brcc	.+10     	; 0x9d8 <lcd_draw_image_P+0x76>
     9ce:	80 2f       	mov	r24, r16
     9d0:	9e 2f       	mov	r25, r30
     9d2:	fc 01       	movw	r30, r24
     9d4:	ef 01       	movw	r28, r30
     9d6:	e4 cf       	rjmp	.-56     	; 0x9a0 <lcd_draw_image_P+0x3e>
				lcd_data(~tmp);
      }
    if(++j != pages)
      lcd_move_xy(1,-columns);
    }
  }
     9d8:	df 91       	pop	r29
     9da:	cf 91       	pop	r28
     9dc:	1f 91       	pop	r17
     9de:	0f 91       	pop	r16
     9e0:	ff 90       	pop	r15
     9e2:	ef 90       	pop	r14
     9e4:	df 90       	pop	r13
     9e6:	cf 90       	pop	r12
     9e8:	bf 90       	pop	r11
     9ea:	08 95       	ret

000009ec <lcd_draw_image_xy_P>:
 * y             - y start coordinate on the screen (in pixel)
 * pages         - height of image in pages
 * columns       - width of image in pixels
 * style         - Bit2: sets inverse mode
 */
void lcd_draw_image_xy_P(PGM_P progmem_image, uint8_t x, uint8_t y, uint8_t pages, uint8_t columns, uint8_t style) {
     9ec:	2f 92       	push	r2
     9ee:	3f 92       	push	r3
     9f0:	4f 92       	push	r4
     9f2:	5f 92       	push	r5
     9f4:	6f 92       	push	r6
     9f6:	7f 92       	push	r7
     9f8:	8f 92       	push	r8
     9fa:	9f 92       	push	r9
     9fc:	af 92       	push	r10
     9fe:	bf 92       	push	r11
     a00:	cf 92       	push	r12
     a02:	df 92       	push	r13
     a04:	ef 92       	push	r14
     a06:	ff 92       	push	r15
     a08:	0f 93       	push	r16
     a0a:	1f 93       	push	r17
     a0c:	df 93       	push	r29
     a0e:	cf 93       	push	r28
     a10:	cd b7       	in	r28, 0x3d	; 61
     a12:	de b7       	in	r29, 0x3e	; 62
     a14:	28 97       	sbiw	r28, 0x08	; 8
     a16:	0f b6       	in	r0, 0x3f	; 63
     a18:	f8 94       	cli
     a1a:	de bf       	out	0x3e, r29	; 62
     a1c:	0f be       	out	0x3f, r0	; 63
     a1e:	cd bf       	out	0x3d, r28	; 61
     a20:	f8 2e       	mov	r15, r24
     a22:	d9 2e       	mov	r13, r25
     a24:	12 2f       	mov	r17, r18
     a26:	2e 2d       	mov	r18, r14
	uint16_t i,j;
  uint8_t data   = 0;
  uint8_t inv    = style & INVERT_BIT;
     a28:	24 70       	andi	r18, 0x04	; 4
     a2a:	2a 83       	std	Y+2, r18	; 0x02
	uint8_t offset = y & 0x7; //Optimized modulo 8
     a2c:	84 2f       	mov	r24, r20
     a2e:	87 70       	andi	r24, 0x07	; 7
     a30:	89 83       	std	Y+1, r24	; 0x01
	//If there is an offset, we must use an additional page
	if(offset)  
     a32:	81 11       	cpse	r24, r1
    pages++;
     a34:	1f 5f       	subi	r17, 0xFF	; 255


//Function to read the current position
extern uint8_t lcd_current_page;
extern uint8_t lcd_current_column;
static inline uint8_t lcd_get_position_page()   {return lcd_current_page;};
     a36:	50 91 6f 00 	lds	r21, 0x006F
  //If there is not enough vertical space -> cut image
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
     a3a:	21 2f       	mov	r18, r17
     a3c:	30 e0       	ldi	r19, 0x00	; 0
     a3e:	84 e0       	ldi	r24, 0x04	; 4
     a40:	90 e0       	ldi	r25, 0x00	; 0
     a42:	85 1b       	sub	r24, r21
     a44:	91 09       	sbc	r25, r1
     a46:	82 17       	cp	r24, r18
     a48:	93 07       	cpc	r25, r19
     a4a:	14 f4       	brge	.+4      	; 0xa50 <lcd_draw_image_xy_P+0x64>
    pages = LCD_RAM_PAGES - lcd_get_position_page();
     a4c:	14 e0       	ldi	r17, 0x04	; 4
     a4e:	15 1b       	sub	r17, r21
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
     a50:	84 2f       	mov	r24, r20
     a52:	86 95       	lsr	r24
     a54:	86 95       	lsr	r24
     a56:	86 95       	lsr	r24
     a58:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
     a5c:	80 2e       	mov	r8, r16
     a5e:	99 24       	eor	r9, r9
     a60:	8f 2d       	mov	r24, r15
     a62:	9d 2d       	mov	r25, r13
     a64:	5c 01       	movw	r10, r24
     a66:	88 27       	eor	r24, r24
     a68:	99 27       	eor	r25, r25
     a6a:	88 19       	sub	r24, r8
     a6c:	99 09       	sbc	r25, r9
     a6e:	15 01       	movw	r2, r10
     a70:	28 0e       	add	r2, r24
     a72:	39 1e       	adc	r3, r25
     a74:	18 86       	std	Y+8, r1	; 0x08
     a76:	1f 82       	std	Y+7, r1	; 0x07
	for (j=0; j<pages; j++) {
     a78:	61 2e       	mov	r6, r17
     a7a:	77 24       	eor	r7, r7
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
      data = 0;
      if (!offset || j+1 != pages)
        data = pgm_read_byte(&progmem_image[j*columns + i]) << offset;
			if(j > 0 && offset)
				data |= pgm_read_byte(&progmem_image[(j-1)*columns + i]) >> (8-offset);
     a7c:	28 e0       	ldi	r18, 0x08	; 8
     a7e:	42 2e       	mov	r4, r18
     a80:	51 2c       	mov	r5, r1
     a82:	e9 81       	ldd	r30, Y+1	; 0x01
     a84:	4e 1a       	sub	r4, r30
     a86:	51 08       	sbc	r5, r1
			if(inv)	lcd_data(~data);
      else 		lcd_data(data);
		  }
		if(j+1 != pages)
			lcd_move_xy(1,-columns);
     a88:	8d 83       	std	Y+5, r24	; 0x05
     a8a:	9e 83       	std	Y+6, r25	; 0x06
     a8c:	4c c0       	rjmp	.+152    	; 0xb26 <lcd_draw_image_xy_P+0x13a>
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
	for (j=0; j<pages; j++) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
      data = 0;
      if (!offset || j+1 != pages)
     a8e:	f9 81       	ldd	r31, Y+1	; 0x01
     a90:	ff 23       	and	r31, r31
     a92:	39 f0       	breq	.+14     	; 0xaa2 <lcd_draw_image_xy_P+0xb6>
     a94:	8b 81       	ldd	r24, Y+3	; 0x03
     a96:	9c 81       	ldd	r25, Y+4	; 0x04
     a98:	86 15       	cp	r24, r6
     a9a:	97 05       	cpc	r25, r7
     a9c:	11 f4       	brne	.+4      	; 0xaa2 <lcd_draw_image_xy_P+0xb6>
     a9e:	20 e0       	ldi	r18, 0x00	; 0
     aa0:	07 c0       	rjmp	.+14     	; 0xab0 <lcd_draw_image_xy_P+0xc4>
        data = pgm_read_byte(&progmem_image[j*columns + i]) << offset;
     aa2:	f7 01       	movw	r30, r14
     aa4:	24 91       	lpm	r18, Z+
     aa6:	09 80       	ldd	r0, Y+1	; 0x01
     aa8:	01 c0       	rjmp	.+2      	; 0xaac <lcd_draw_image_xy_P+0xc0>
     aaa:	22 0f       	add	r18, r18
     aac:	0a 94       	dec	r0
     aae:	ea f7       	brpl	.-6      	; 0xaaa <lcd_draw_image_xy_P+0xbe>
			if(j > 0 && offset)
     ab0:	8f 81       	ldd	r24, Y+7	; 0x07
     ab2:	98 85       	ldd	r25, Y+8	; 0x08
     ab4:	89 2b       	or	r24, r25
     ab6:	69 f0       	breq	.+26     	; 0xad2 <lcd_draw_image_xy_P+0xe6>
     ab8:	99 81       	ldd	r25, Y+1	; 0x01
     aba:	99 23       	and	r25, r25
     abc:	51 f0       	breq	.+20     	; 0xad2 <lcd_draw_image_xy_P+0xe6>
				data |= pgm_read_byte(&progmem_image[(j-1)*columns + i]) >> (8-offset);
     abe:	f6 01       	movw	r30, r12
     ac0:	84 91       	lpm	r24, Z+
     ac2:	90 e0       	ldi	r25, 0x00	; 0
     ac4:	04 2c       	mov	r0, r4
     ac6:	02 c0       	rjmp	.+4      	; 0xacc <lcd_draw_image_xy_P+0xe0>
     ac8:	95 95       	asr	r25
     aca:	87 95       	ror	r24
     acc:	0a 94       	dec	r0
     ace:	e2 f7       	brpl	.-8      	; 0xac8 <lcd_draw_image_xy_P+0xdc>
     ad0:	28 2b       	or	r18, r24
			if(inv)	lcd_data(~data);
     ad2:	fa 81       	ldd	r31, Y+2	; 0x02
     ad4:	ff 23       	and	r31, r31
     ad6:	19 f0       	breq	.+6      	; 0xade <lcd_draw_image_xy_P+0xf2>
     ad8:	82 2f       	mov	r24, r18
     ada:	80 95       	com	r24
     adc:	01 c0       	rjmp	.+2      	; 0xae0 <lcd_draw_image_xy_P+0xf4>
      else 		lcd_data(data);
     ade:	82 2f       	mov	r24, r18
     ae0:	0e 94 76 04 	call	0x8ec	; 0x8ec <lcd_data>
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
    pages = LCD_RAM_PAGES - lcd_get_position_page();
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
	for (j=0; j<pages; j++) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
     ae4:	0f 5f       	subi	r16, 0xFF	; 255
     ae6:	1f 4f       	sbci	r17, 0xFF	; 255
     ae8:	08 94       	sec
     aea:	c1 1c       	adc	r12, r1
     aec:	d1 1c       	adc	r13, r1
     aee:	08 94       	sec
     af0:	e1 1c       	adc	r14, r1
     af2:	f1 1c       	adc	r15, r1
     af4:	08 15       	cp	r16, r8
     af6:	19 05       	cpc	r17, r9
     af8:	28 f4       	brcc	.+10     	; 0xb04 <lcd_draw_image_xy_P+0x118>
     afa:	80 91 70 00 	lds	r24, 0x0070
     afe:	84 38       	cpi	r24, 0x84	; 132
     b00:	08 f4       	brcc	.+2      	; 0xb04 <lcd_draw_image_xy_P+0x118>
     b02:	c5 cf       	rjmp	.-118    	; 0xa8e <lcd_draw_image_xy_P+0xa2>
			if(j > 0 && offset)
				data |= pgm_read_byte(&progmem_image[(j-1)*columns + i]) >> (8-offset);
			if(inv)	lcd_data(~data);
      else 		lcd_data(data);
		  }
		if(j+1 != pages)
     b04:	8f 81       	ldd	r24, Y+7	; 0x07
     b06:	98 85       	ldd	r25, Y+8	; 0x08
     b08:	01 96       	adiw	r24, 0x01	; 1
     b0a:	98 87       	std	Y+8, r25	; 0x08
     b0c:	8f 83       	std	Y+7, r24	; 0x07
     b0e:	86 15       	cp	r24, r6
     b10:	97 05       	cpc	r25, r7
     b12:	29 f0       	breq	.+10     	; 0xb1e <lcd_draw_image_xy_P+0x132>
			lcd_move_xy(1,-columns);
     b14:	81 e0       	ldi	r24, 0x01	; 1
     b16:	6d 81       	ldd	r22, Y+5	; 0x05
     b18:	7e 81       	ldd	r23, Y+6	; 0x06
     b1a:	0e 94 a1 04 	call	0x942	; 0x942 <lcd_move_xy>
     b1e:	a8 0c       	add	r10, r8
     b20:	b9 1c       	adc	r11, r9
     b22:	28 0c       	add	r2, r8
     b24:	39 1c       	adc	r3, r9
  //If there is not enough vertical space -> cut image
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
    pages = LCD_RAM_PAGES - lcd_get_position_page();
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
	for (j=0; j<pages; j++) {
     b26:	ef 81       	ldd	r30, Y+7	; 0x07
     b28:	f8 85       	ldd	r31, Y+8	; 0x08
     b2a:	e6 15       	cp	r30, r6
     b2c:	f7 05       	cpc	r31, r7
     b2e:	40 f4       	brcc	.+16     	; 0xb40 <lcd_draw_image_xy_P+0x154>
     b30:	61 01       	movw	r12, r2
     b32:	75 01       	movw	r14, r10
     b34:	00 e0       	ldi	r16, 0x00	; 0
     b36:	10 e0       	ldi	r17, 0x00	; 0
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
      data = 0;
      if (!offset || j+1 != pages)
     b38:	31 96       	adiw	r30, 0x01	; 1
     b3a:	fc 83       	std	Y+4, r31	; 0x04
     b3c:	eb 83       	std	Y+3, r30	; 0x03
     b3e:	da cf       	rjmp	.-76     	; 0xaf4 <lcd_draw_image_xy_P+0x108>
      else 		lcd_data(data);
		  }
		if(j+1 != pages)
			lcd_move_xy(1,-columns);
	  }
  }
     b40:	28 96       	adiw	r28, 0x08	; 8
     b42:	0f b6       	in	r0, 0x3f	; 63
     b44:	f8 94       	cli
     b46:	de bf       	out	0x3e, r29	; 62
     b48:	0f be       	out	0x3f, r0	; 63
     b4a:	cd bf       	out	0x3d, r28	; 61
     b4c:	cf 91       	pop	r28
     b4e:	df 91       	pop	r29
     b50:	1f 91       	pop	r17
     b52:	0f 91       	pop	r16
     b54:	ff 90       	pop	r15
     b56:	ef 90       	pop	r14
     b58:	df 90       	pop	r13
     b5a:	cf 90       	pop	r12
     b5c:	bf 90       	pop	r11
     b5e:	af 90       	pop	r10
     b60:	9f 90       	pop	r9
     b62:	8f 90       	pop	r8
     b64:	7f 90       	pop	r7
     b66:	6f 90       	pop	r6
     b68:	5f 90       	pop	r5
     b6a:	4f 90       	pop	r4
     b6c:	3f 90       	pop	r3
     b6e:	2f 90       	pop	r2
     b70:	08 95       	ret

00000b72 <lcd_clear_area>:
 * pages         - height of area in pages
 * columns       - width of area in pixels
 * style         - Bit2: sets inverse mode
 * Cursor is moved to start of area after clear
 */
void lcd_clear_area(uint8_t pages, uint8_t columns, uint8_t style) {
     b72:	df 92       	push	r13
     b74:	ef 92       	push	r14
     b76:	ff 92       	push	r15
     b78:	0f 93       	push	r16
     b7a:	1f 93       	push	r17
     b7c:	cf 93       	push	r28
     b7e:	df 93       	push	r29
     b80:	38 2f       	mov	r19, r24
  uint8_t i,j,max;
  uint8_t inv = (style & INVERT_BIT)?0xFF:0;
     b82:	42 fd       	sbrc	r20, 2
     b84:	02 c0       	rjmp	.+4      	; 0xb8a <lcd_clear_area+0x18>
     b86:	dd 24       	eor	r13, r13
     b88:	02 c0       	rjmp	.+4      	; 0xb8e <lcd_clear_area+0x1c>
     b8a:	dd 24       	eor	r13, r13
     b8c:	da 94       	dec	r13
     b8e:	24 e0       	ldi	r18, 0x04	; 4
     b90:	80 91 6f 00 	lds	r24, 0x006F
     b94:	28 1b       	sub	r18, r24
     b96:	e3 2e       	mov	r14, r19
     b98:	23 17       	cp	r18, r19
     b9a:	08 f4       	brcc	.+2      	; 0xb9e <lcd_clear_area+0x2c>
     b9c:	e2 2e       	mov	r14, r18
     b9e:	24 e8       	ldi	r18, 0x84	; 132
     ba0:	80 91 70 00 	lds	r24, 0x0070
     ba4:	28 1b       	sub	r18, r24
     ba6:	06 2f       	mov	r16, r22
     ba8:	26 17       	cp	r18, r22
     baa:	08 f4       	brcc	.+2      	; 0xbae <lcd_clear_area+0x3c>
     bac:	02 2f       	mov	r16, r18
     bae:	ff 24       	eor	r15, r15
  
  for(j=0; j<pages; j++) {
    for(i=0; i<columns; i++) {
      lcd_data(inv);
      }
    lcd_move_xy(1,-columns);
     bb0:	80 2f       	mov	r24, r16
     bb2:	90 e0       	ldi	r25, 0x00	; 0
     bb4:	cc 27       	eor	r28, r28
     bb6:	dd 27       	eor	r29, r29
     bb8:	c8 1b       	sub	r28, r24
     bba:	d9 0b       	sbc	r29, r25
     bbc:	0b c0       	rjmp	.+22     	; 0xbd4 <lcd_clear_area+0x62>
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
    columns = max;
  
  for(j=0; j<pages; j++) {
    for(i=0; i<columns; i++) {
      lcd_data(inv);
     bbe:	8d 2d       	mov	r24, r13
     bc0:	0e 94 76 04 	call	0x8ec	; 0x8ec <lcd_data>
    pages = max;
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
    columns = max;
  
  for(j=0; j<pages; j++) {
    for(i=0; i<columns; i++) {
     bc4:	1f 5f       	subi	r17, 0xFF	; 255
     bc6:	10 17       	cp	r17, r16
     bc8:	d0 f3       	brcs	.-12     	; 0xbbe <lcd_clear_area+0x4c>
      lcd_data(inv);
      }
    lcd_move_xy(1,-columns);
     bca:	81 e0       	ldi	r24, 0x01	; 1
     bcc:	be 01       	movw	r22, r28
     bce:	0e 94 a1 04 	call	0x942	; 0x942 <lcd_move_xy>
  if(pages > (max = LCD_RAM_PAGES - lcd_get_position_page()))   
    pages = max;
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
    columns = max;
  
  for(j=0; j<pages; j++) {
     bd2:	f3 94       	inc	r15
     bd4:	fe 14       	cp	r15, r14
     bd6:	10 f4       	brcc	.+4      	; 0xbdc <lcd_clear_area+0x6a>
     bd8:	10 e0       	ldi	r17, 0x00	; 0
     bda:	f5 cf       	rjmp	.-22     	; 0xbc6 <lcd_clear_area+0x54>
    for(i=0; i<columns; i++) {
      lcd_data(inv);
      }
    lcd_move_xy(1,-columns);
    }
  lcd_move_xy(-pages,0);
     bdc:	8e 2d       	mov	r24, r14
     bde:	81 95       	neg	r24
     be0:	60 e0       	ldi	r22, 0x00	; 0
     be2:	70 e0       	ldi	r23, 0x00	; 0
     be4:	0e 94 a1 04 	call	0x942	; 0x942 <lcd_move_xy>
  }
     be8:	df 91       	pop	r29
     bea:	cf 91       	pop	r28
     bec:	1f 91       	pop	r17
     bee:	0f 91       	pop	r16
     bf0:	ff 90       	pop	r15
     bf2:	ef 90       	pop	r14
     bf4:	df 90       	pop	r13
     bf6:	08 95       	ret

00000bf8 <lcd_clear_area_xy>:
 * style         - style modifier
 * col           - column of upper left corner
 * page          - page of upper left corner
 * Cursor is moved to start of area after clear
 */
void lcd_clear_area_xy(uint8_t pages, uint8_t columns, uint8_t style, uint8_t col, uint8_t page) {
     bf8:	ef 92       	push	r14
     bfa:	ff 92       	push	r15
     bfc:	0f 93       	push	r16
     bfe:	1f 93       	push	r17
     c00:	18 2f       	mov	r17, r24
     c02:	f6 2e       	mov	r15, r22
     c04:	e4 2e       	mov	r14, r20
     c06:	82 2f       	mov	r24, r18
     c08:	60 2f       	mov	r22, r16
  lcd_moveto_xy(col,page);
     c0a:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
  lcd_clear_area(pages,columns,style);
     c0e:	81 2f       	mov	r24, r17
     c10:	6f 2d       	mov	r22, r15
     c12:	4e 2d       	mov	r20, r14
     c14:	0e 94 b9 05 	call	0xb72	; 0xb72 <lcd_clear_area>
  }
     c18:	1f 91       	pop	r17
     c1a:	0f 91       	pop	r16
     c1c:	ff 90       	pop	r15
     c1e:	ef 90       	pop	r14
     c20:	08 95       	ret

00000c22 <init_spi_lcd>:
  */
void init_spi_lcd() {
   
   
   //set MOSI and SCK as output pins
   DDRB |= (1<<PINB5)|(1<<PINB7);
     c22:	87 b3       	in	r24, 0x17	; 23
     c24:	80 6a       	ori	r24, 0xA0	; 160
     c26:	87 bb       	out	0x17, r24	; 23
   
   //set A0, LCD_Reset as outputs
   DDRA |= (1<<PINA5) | (1<<PINA4);
     c28:	8a b3       	in	r24, 0x1a	; 26
     c2a:	80 63       	ori	r24, 0x30	; 48
     c2c:	8a bb       	out	0x1a, r24	; 26
   
   //set SS` as an output pin
   DDRB |= (1<<PINB4);
     c2e:	bc 9a       	sbi	0x17, 4	; 23
		CPOL:   Clock Polarity -> leading edge  = falling edge
							   -> trailing edge = rising edge
		CPHA:	Clock Phase -> Leading edge  = setup
							   Trailing edge = sample
   */
   SPCR = (0<<SPIE) | (1<<SPE) | (0<<DORD) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (0<<SPR1) | (0<<SPR0);
     c30:	8c e5       	ldi	r24, 0x5C	; 92
     c32:	8d b9       	out	0x0d, r24	; 13
         
   
   
   //SPI status register
   //SPI2X: Double SPI Speed Bit -> minimum SCK period will be two CPU clock periods
   SPSR = (1<<SPI2X);
     c34:	81 e0       	ldi	r24, 0x01	; 1
     c36:	8e b9       	out	0x0e, r24	; 14

   SPDR = LCD_NOP; //Do not use 0 here, only LCD_NOP is allowed!
     c38:	83 ee       	ldi	r24, 0xE3	; 227
     c3a:	8f b9       	out	0x0f, r24	; 15
   

   
   }
     c3c:	08 95       	ret

00000c3e <lcd_init>:
/******************************************************************************
  * Initializes the display in 6 o'clock mode, 4x booster for 2.4-3.3V supply voltage
  * scheme according to datasheet
  * Suitable for all DOGS, DOGM and DOGL displays.
  */
void lcd_init() {
     c3e:	0f 93       	push	r16
     c40:	1f 93       	push	r17
  //for better understanding -> write macros in clear text


  //set outputs
  //LCD_SET_PIN_DIRECTIONS();
  DDR_A0 |= (1<<PIN_A0);
     c42:	d5 9a       	sbi	0x1a, 5	; 26
  DDR_RST |= (1<<PIN_RST);
     c44:	d4 9a       	sbi	0x1a, 4	; 26
  DDR_CS  |= (1<<PIN_CS);
     c46:	bc 9a       	sbi	0x17, 4	; 23
  
  
  //Initialize SPI Interface
  //LCD_INIT_SPI();   
  init_spi_lcd();
     c48:	0e 94 11 06 	call	0xc22	; 0xc22 <init_spi_lcd>
    
  
  //Apply Reset to the Display Controller
  //LCD_RESET();
  PORT_RST &= ~(1<<PIN_RST);
     c4c:	dc 98       	cbi	0x1b, 4	; 27
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     c4e:	00 ed       	ldi	r16, 0xD0	; 208
     c50:	17 e0       	ldi	r17, 0x07	; 7
     c52:	c8 01       	movw	r24, r16
     c54:	01 97       	sbiw	r24, 0x01	; 1
     c56:	f1 f7       	brne	.-4      	; 0xc54 <lcd_init+0x16>
  _delay_ms(1);
  PORT_RST |= (1<<PIN_RST);
     c58:	dc 9a       	sbi	0x1b, 4	; 27
  
    
  //Load settings
  
  //(2)
  LCD_SET_FIRST_LINE(0);              //first bit in RAM is on the first line of the LCD
     c5a:	80 e4       	ldi	r24, 0x40	; 64
     c5c:	0e 94 81 04 	call	0x902	; 0x902 <lcd_command>
     c60:	c8 01       	movw	r24, r16
     c62:	01 97       	sbiw	r24, 0x01	; 1
     c64:	f1 f7       	brne	.-4      	; 0xc62 <lcd_init+0x24>
  //without this delay the content is displayed mirror inverted
  _delay_ms(1); 


  //(8)     
  LCD_SET_BOTTOM_VIEW();              //6 o'clock mode, normal orientation
     c66:	81 ea       	ldi	r24, 0xA1	; 161
     c68:	0e 94 81 04 	call	0x902	; 0x902 <lcd_command>
  // |
  //  --> lcd_command(LCD_BOTTOMVIEW)
  //					-> LCD_BOTTOMVIEW = ADC reverse
  //_delay_ms(1);
  //(15)
  LCD_ORIENTATION_NORMAL();
     c6c:	80 ec       	ldi	r24, 0xC0	; 192
     c6e:	0e 94 81 04 	call	0x902	; 0x902 <lcd_command>
     c72:	c8 01       	movw	r24, r16
     c74:	01 97       	sbiw	r24, 0x01	; 1
     c76:	f1 f7       	brne	.-4      	; 0xc74 <lcd_init+0x36>
  // |
  //   --> lcd_command(LCD_SHOW_NORMAL)
  //					-> LCD_SHOW_NORMAL = display all points, normal display (10)
    
  //(9)	
  LCD_SET_MODE_POSITIVE();            //positive display
     c78:	86 ea       	ldi	r24, 0xA6	; 166
     c7a:	0e 94 81 04 	call	0x902	; 0x902 <lcd_command>
  //  --> lcd_command(LCD_DISPLAY_POSITIVE)
  //      				-> LCD_DISPLAY_POSITIVE = sets display normal (9)
   
  #if DISPLAY_TYPE == 132
    //(11)
    LCD_SET_BIAS_RATIO_1_9();           //bias 1/9
     c7e:	82 ea       	ldi	r24, 0xA2	; 162
     c80:	0e 94 81 04 	call	0x902	; 0x902 <lcd_command>
    // |
	//  --> lcd_command(LCD_BIAS_1_9)
	
    //(16)	
	LCD_SET_POWER_CONTROL(7);           //power control mode: all features on
     c84:	8f e2       	ldi	r24, 0x2F	; 47
     c86:	0e 94 81 04 	call	0x902	; 0x902 <lcd_command>
	//  --> lcd_command(LCD_POWER_CONTROL | ((i) & 0x07))  
	//						-> command 16 with operating mode = 0b111
	
	
	//(20) -> selbst eingefügtes macro
	LCD_SET_BOOSTER_RATIO();
     c8a:	80 e0       	ldi	r24, 0x00	; 0
     c8c:	0e 94 81 04 	call	0x902	; 0x902 <lcd_command>
	
	
	//(17)
	LCD_SET_BIAS_VOLTAGE(3);            //set voltage regulator R/R
     c90:	83 e2       	ldi	r24, 0x23	; 35
     c92:	0e 94 81 04 	call	0x902	; 0x902 <lcd_command>
	// |
	//   --> lcd_command(LCD_VOLTAGE | ((i) & 0x07))
	// 						-> command 17 with resistor ration 0b011
    
	//(18)
	LCD_SET_VOLUME_MODE(0x1F);          //volume mode set
     c96:	81 e8       	ldi	r24, 0x81	; 129
     c98:	0e 94 81 04 	call	0x902	; 0x902 <lcd_command>
     c9c:	8f e1       	ldi	r24, 0x1F	; 31
     c9e:	0e 94 81 04 	call	0x902	; 0x902 <lcd_command>
	//						-> standard command 18
	//  --> lcd_command(LCD_VOLUME_MODE_2 | ((i) & 0x3F))
	//						-> command 18 with electronic volume value 0b011111
	
	//(19)
	LCD_SET_INDICATOR_OFF();            //switch indicator off, no blinking
     ca2:	8c ea       	ldi	r24, 0xAC	; 172
     ca4:	0e 94 81 04 	call	0x902	; 0x902 <lcd_command>
     ca8:	80 e0       	ldi	r24, 0x00	; 0
     caa:	0e 94 81 04 	call	0x902	; 0x902 <lcd_command>
     cae:	10 e0       	ldi	r17, 0x00	; 0
  
  
  uint8_t i,j;                        //clear display content
 
 for(j=0;j<LCD_RAM_PAGES;j++) {
    lcd_moveto_xy(j,0);   // array (uint8_t page, uint8_t column)
     cb0:	81 2f       	mov	r24, r17
     cb2:	60 e0       	ldi	r22, 0x00	; 0
     cb4:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
     cb8:	00 e0       	ldi	r16, 0x00	; 0
    for (i=0;i<LCD_WIDTH;i++)
      lcd_data(0);
     cba:	80 e0       	ldi	r24, 0x00	; 0
     cbc:	0e 94 76 04 	call	0x8ec	; 0x8ec <lcd_data>
  
  uint8_t i,j;                        //clear display content
 
 for(j=0;j<LCD_RAM_PAGES;j++) {
    lcd_moveto_xy(j,0);   // array (uint8_t page, uint8_t column)
    for (i=0;i<LCD_WIDTH;i++)
     cc0:	0f 5f       	subi	r16, 0xFF	; 255
     cc2:	04 38       	cpi	r16, 0x84	; 132
     cc4:	d1 f7       	brne	.-12     	; 0xcba <lcd_init+0x7c>
  #endif
  
  
  uint8_t i,j;                        //clear display content
 
 for(j=0;j<LCD_RAM_PAGES;j++) {
     cc6:	1f 5f       	subi	r17, 0xFF	; 255
     cc8:	14 30       	cpi	r17, 0x04	; 4
     cca:	91 f7       	brne	.-28     	; 0xcb0 <lcd_init+0x72>
    lcd_moveto_xy(j,0);   // array (uint8_t page, uint8_t column)
    for (i=0;i<LCD_WIDTH;i++)
      lcd_data(0);
    }

  lcd_moveto_xy(0,0);                 //Set write pointer
     ccc:	80 e0       	ldi	r24, 0x00	; 0
     cce:	60 e0       	ldi	r22, 0x00	; 0
     cd0:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
  LCD_SWITCH_ON();                    //Switch display on (1)
     cd4:	8f ea       	ldi	r24, 0xAF	; 175
     cd6:	0e 94 81 04 	call	0x902	; 0x902 <lcd_command>
  return;
  }
     cda:	1f 91       	pop	r17
     cdc:	0f 91       	pop	r16
     cde:	08 95       	ret

00000ce0 <lcd_set_font>:
 * Stores the default font type and style in a global variable
 * font          - Font identifier
 * style         - Style Modifier
 */
inline void lcd_set_font(FONT_P font, uint8_t style){
  global_font_select = font;
     ce0:	90 93 73 00 	sts	0x0073, r25
     ce4:	80 93 72 00 	sts	0x0072, r24
  global_font_style = style;
     ce8:	60 93 71 00 	sts	0x0071, r22
}
     cec:	08 95       	ret

00000cee <font_data>:
 * Loads the pointer to the selected fonts data
 */
inline PGM_P font_data(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->data));
     cee:	fc 01       	movw	r30, r24
     cf0:	38 96       	adiw	r30, 0x08	; 8
     cf2:	25 91       	lpm	r18, Z+
     cf4:	34 91       	lpm	r19, Z+
  else
    memcpy_P((char*)&tmp,&(font->data),sizeof(tmp));
  return tmp;
  }
     cf6:	c9 01       	movw	r24, r18
     cf8:	08 95       	ret

00000cfa <font_widthtable>:
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     cfa:	fc 01       	movw	r30, r24
     cfc:	36 96       	adiw	r30, 0x06	; 6
     cfe:	25 91       	lpm	r18, Z+
     d00:	34 91       	lpm	r19, Z+
  else
    memcpy_P((char*)&tmp,&(font->widthtable),sizeof(tmp));
  return tmp;
  }
     d02:	c9 01       	movw	r24, r18
     d04:	08 95       	ret

00000d06 <font_get_height_bytes>:
/******************************************************************************
 * Loads the height (in bytes) of the given font
 */
inline uint8_t font_get_height_bytes(FONT_P font) {
  FONT_P tmp = font;
  uint8_t t = pgm_read_byte(&tmp->height);
     d06:	fc 01       	movw	r30, r24
     d08:	33 96       	adiw	r30, 0x03	; 3
     d0a:	e4 91       	lpm	r30, Z+
     d0c:	e1 50       	subi	r30, 0x01	; 1
     d0e:	e6 95       	lsr	r30
     d10:	e6 95       	lsr	r30
     d12:	e6 95       	lsr	r30
  return (((uint8_t)(t-1)>>3)+1);
  }
     d14:	8e 2f       	mov	r24, r30
     d16:	8f 5f       	subi	r24, 0xFF	; 255
     d18:	08 95       	ret

00000d1a <font_get_add_space>:
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     d1a:	fc 01       	movw	r30, r24
     d1c:	36 96       	adiw	r30, 0x06	; 6
     d1e:	85 91       	lpm	r24, Z+
     d20:	94 91       	lpm	r25, Z+
     d22:	20 e0       	ldi	r18, 0x00	; 0
     d24:	89 2b       	or	r24, r25
     d26:	09 f0       	breq	.+2      	; 0xd2a <font_get_add_space+0x10>
     d28:	21 e0       	ldi	r18, 0x01	; 1
  PGM_P type = font_widthtable(font);
  if ( type != 0 ) //if there is a width table, then it's a proportional font
    return 1;
  else
    return 0;
  }
     d2a:	82 2f       	mov	r24, r18
     d2c:	08 95       	ret

00000d2e <font_get_char_number>:


/******************************************************************************
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
     d2e:	fc 01       	movw	r30, r24
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
     d30:	35 96       	adiw	r30, 0x05	; 5
     d32:	84 91       	lpm	r24, Z+
     d34:	35 97       	sbiw	r30, 0x05	; 5
     d36:	86 17       	cp	r24, r22
     d38:	40 f0       	brcs	.+16     	; 0xd4a <font_get_char_number+0x1c>
    return -1;
  uint8_t first = pgm_read_byte(&tmp->firstchar);
     d3a:	34 96       	adiw	r30, 0x04	; 4
     d3c:	84 91       	lpm	r24, Z+
  if (character < first) 
     d3e:	68 17       	cp	r22, r24
     d40:	20 f0       	brcs	.+8      	; 0xd4a <font_get_char_number+0x1c>
    return -1;
  return character - first;
     d42:	70 e0       	ldi	r23, 0x00	; 0
     d44:	68 1b       	sub	r22, r24
     d46:	71 09       	sbc	r23, r1
     d48:	02 c0       	rjmp	.+4      	; 0xd4e <font_get_char_number+0x20>
     d4a:	6f ef       	ldi	r22, 0xFF	; 255
     d4c:	7f ef       	ldi	r23, 0xFF	; 255
  }
     d4e:	cb 01       	movw	r24, r22
     d50:	08 95       	ret

00000d52 <font_get_char_width>:


/******************************************************************************
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
     d52:	ac 01       	movw	r20, r24
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     d54:	06 96       	adiw	r24, 0x06	; 6
     d56:	fc 01       	movw	r30, r24
     d58:	25 91       	lpm	r18, Z+
     d5a:	34 91       	lpm	r19, Z+
/******************************************************************************
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
  PGM_P table = font_widthtable(font);
  if (table)
     d5c:	21 15       	cp	r18, r1
     d5e:	31 05       	cpc	r19, r1
     d60:	c9 f0       	breq	.+50     	; 0xd94 <font_get_char_width+0x42>
/******************************************************************************
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
     d62:	4b 5f       	subi	r20, 0xFB	; 251
     d64:	5f 4f       	sbci	r21, 0xFF	; 255
     d66:	fa 01       	movw	r30, r20
     d68:	84 91       	lpm	r24, Z+
     d6a:	45 50       	subi	r20, 0x05	; 5
     d6c:	50 40       	sbci	r21, 0x00	; 0
     d6e:	86 17       	cp	r24, r22
     d70:	50 f0       	brcs	.+20     	; 0xd86 <font_get_char_width+0x34>
    return -1;
  uint8_t first = pgm_read_byte(&tmp->firstchar);
     d72:	4c 5f       	subi	r20, 0xFC	; 252
     d74:	5f 4f       	sbci	r21, 0xFF	; 255
     d76:	fa 01       	movw	r30, r20
     d78:	84 91       	lpm	r24, Z+
  if (character < first) 
     d7a:	68 17       	cp	r22, r24
     d7c:	20 f0       	brcs	.+8      	; 0xd86 <font_get_char_width+0x34>
    return -1;
  return character - first;
     d7e:	70 e0       	ldi	r23, 0x00	; 0
     d80:	68 1b       	sub	r22, r24
     d82:	71 09       	sbc	r23, r1
     d84:	02 c0       	rjmp	.+4      	; 0xd8a <font_get_char_width+0x38>
     d86:	6f ef       	ldi	r22, 0xFF	; 255
     d88:	7f ef       	ldi	r23, 0xFF	; 255
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
  PGM_P table = font_widthtable(font);
  if (table)
    return pgm_read_byte(table+font_get_char_number(font,character));
     d8a:	26 0f       	add	r18, r22
     d8c:	37 1f       	adc	r19, r23
     d8e:	f9 01       	movw	r30, r18
     d90:	84 91       	lpm	r24, Z+
     d92:	08 95       	ret
  else
    return pgm_read_byte(&font->width);
     d94:	4e 5f       	subi	r20, 0xFE	; 254
     d96:	5f 4f       	sbci	r21, 0xFF	; 255
     d98:	fa 01       	movw	r30, r20
     d9a:	84 91       	lpm	r24, Z+
  }
     d9c:	08 95       	ret

00000d9e <font_get_char_position>:


/******************************************************************************
 * Calculate the pointer to the requested character inside the Flash ROM
 */
PGM_P font_get_char_position(FONT_P font, char character) {
     d9e:	ef 92       	push	r14
     da0:	ff 92       	push	r15
     da2:	0f 93       	push	r16
     da4:	1f 93       	push	r17
     da6:	9c 01       	movw	r18, r24
/******************************************************************************
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
     da8:	2b 5f       	subi	r18, 0xFB	; 251
     daa:	3f 4f       	sbci	r19, 0xFF	; 255
     dac:	f9 01       	movw	r30, r18
     dae:	84 91       	lpm	r24, Z+
     db0:	25 50       	subi	r18, 0x05	; 5
     db2:	30 40       	sbci	r19, 0x00	; 0
     db4:	86 17       	cp	r24, r22
     db6:	68 f0       	brcs	.+26     	; 0xdd2 <font_get_char_position+0x34>
    return -1;
  uint8_t first = pgm_read_byte(&tmp->firstchar);
     db8:	2c 5f       	subi	r18, 0xFC	; 252
     dba:	3f 4f       	sbci	r19, 0xFF	; 255
     dbc:	f9 01       	movw	r30, r18
     dbe:	44 91       	lpm	r20, Z+
     dc0:	24 50       	subi	r18, 0x04	; 4
     dc2:	30 40       	sbci	r19, 0x00	; 0
  if (character < first) 
     dc4:	64 17       	cp	r22, r20
     dc6:	28 f0       	brcs	.+10     	; 0xdd2 <font_get_char_position+0x34>
    return -1;
  return character - first;
     dc8:	86 2f       	mov	r24, r22
     dca:	90 e0       	ldi	r25, 0x00	; 0
     dcc:	84 1b       	sub	r24, r20
     dce:	91 09       	sbc	r25, r1
     dd0:	02 c0       	rjmp	.+4      	; 0xdd6 <font_get_char_position+0x38>
     dd2:	8f ef       	ldi	r24, 0xFF	; 255
     dd4:	9f ef       	ldi	r25, 0xFF	; 255
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     dd6:	f9 01       	movw	r30, r18
     dd8:	36 96       	adiw	r30, 0x06	; 6
     dda:	45 91       	lpm	r20, Z+
     ddc:	54 91       	lpm	r21, Z+
  uint16_t ret         = 0;
  int16_t  charnum_ret = font_get_char_number(font, character);
  uint8_t  charnum     = charnum_ret;
  PGM_P    base        = font_widthtable(font);

  if (charnum_ret < 0)     //char not found
     dde:	97 ff       	sbrs	r25, 7
     de0:	03 c0       	rjmp	.+6      	; 0xde8 <font_get_char_position+0x4a>
     de2:	40 e0       	ldi	r20, 0x00	; 0
     de4:	50 e0       	ldi	r21, 0x00	; 0
     de6:	4b c0       	rjmp	.+150    	; 0xe7e <font_get_char_position+0xe0>
 * Calculate the pointer to the requested character inside the Flash ROM
 */
PGM_P font_get_char_position(FONT_P font, char character) {
  uint16_t ret         = 0;
  int16_t  charnum_ret = font_get_char_number(font, character);
  uint8_t  charnum     = charnum_ret;
     de8:	08 2f       	mov	r16, r24
  PGM_P    base        = font_widthtable(font);

  if (charnum_ret < 0)     //char not found
    return 0;
  if(base == 0)            //fixed width
     dea:	41 15       	cp	r20, r1
     dec:	51 05       	cpc	r21, r1
     dee:	d9 f4       	brne	.+54     	; 0xe26 <font_get_char_position+0x88>
 * Loads the pointer to the selected fonts data
 */
inline PGM_P font_data(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->data));
     df0:	f9 01       	movw	r30, r18
     df2:	38 96       	adiw	r30, 0x08	; 8
     df4:	e5 90       	lpm	r14, Z+
     df6:	f4 90       	lpm	r15, Z+
/******************************************************************************
 * Loads the height (in bytes) of the given font
 */
inline uint8_t font_get_height_bytes(FONT_P font) {
  FONT_P tmp = font;
  uint8_t t = pgm_read_byte(&tmp->height);
     df8:	2d 5f       	subi	r18, 0xFD	; 253
     dfa:	3f 4f       	sbci	r19, 0xFF	; 255
     dfc:	f9 01       	movw	r30, r18
     dfe:	14 91       	lpm	r17, Z+
     e00:	23 50       	subi	r18, 0x03	; 3
     e02:	30 40       	sbci	r19, 0x00	; 0
  PGM_P    base        = font_widthtable(font);

  if (charnum_ret < 0)     //char not found
    return 0;
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
     e04:	c9 01       	movw	r24, r18
     e06:	0e 94 a9 06 	call	0xd52	; 0xd52 <font_get_char_width>
     e0a:	11 50       	subi	r17, 0x01	; 1
     e0c:	16 95       	lsr	r17
     e0e:	16 95       	lsr	r17
     e10:	16 95       	lsr	r17
     e12:	1f 5f       	subi	r17, 0xFF	; 255
     e14:	18 9f       	mul	r17, r24
     e16:	10 2d       	mov	r17, r0
     e18:	11 24       	eor	r1, r1
     e1a:	10 9f       	mul	r17, r16
     e1c:	a0 01       	movw	r20, r0
     e1e:	11 24       	eor	r1, r1
     e20:	4e 0d       	add	r20, r14
     e22:	5f 1d       	adc	r21, r15
     e24:	2c c0       	rjmp	.+88     	; 0xe7e <font_get_char_position+0xe0>
  if (charnum)             //proportional width
     e26:	88 23       	and	r24, r24
     e28:	19 f4       	brne	.+6      	; 0xe30 <font_get_char_position+0x92>
     e2a:	60 e0       	ldi	r22, 0x00	; 0
     e2c:	70 e0       	ldi	r23, 0x00	; 0
     e2e:	0f c0       	rjmp	.+30     	; 0xe4e <font_get_char_position+0xb0>
     e30:	60 e0       	ldi	r22, 0x00	; 0
     e32:	70 e0       	ldi	r23, 0x00	; 0
    while(charnum--)
     e34:	ca 01       	movw	r24, r20
     e36:	80 0f       	add	r24, r16
     e38:	91 1d       	adc	r25, r1
     e3a:	06 c0       	rjmp	.+12     	; 0xe48 <font_get_char_position+0xaa>

  if (charnum_ret < 0)     //char not found
    return 0;
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
  if (charnum)             //proportional width
     e3c:	fa 01       	movw	r30, r20
    while(charnum--)
      ret += pgm_read_byte(base++);
     e3e:	4f 5f       	subi	r20, 0xFF	; 255
     e40:	5f 4f       	sbci	r21, 0xFF	; 255
     e42:	e4 91       	lpm	r30, Z+
     e44:	6e 0f       	add	r22, r30
     e46:	71 1d       	adc	r23, r1
  if (charnum_ret < 0)     //char not found
    return 0;
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
  if (charnum)             //proportional width
    while(charnum--)
     e48:	48 17       	cp	r20, r24
     e4a:	59 07       	cpc	r21, r25
     e4c:	b9 f7       	brne	.-18     	; 0xe3c <font_get_char_position+0x9e>
 * Loads the pointer to the selected fonts data
 */
inline PGM_P font_data(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->data));
     e4e:	f9 01       	movw	r30, r18
     e50:	38 96       	adiw	r30, 0x08	; 8
     e52:	45 91       	lpm	r20, Z+
     e54:	54 91       	lpm	r21, Z+
/******************************************************************************
 * Loads the height (in bytes) of the given font
 */
inline uint8_t font_get_height_bytes(FONT_P font) {
  FONT_P tmp = font;
  uint8_t t = pgm_read_byte(&tmp->height);
     e56:	2d 5f       	subi	r18, 0xFD	; 253
     e58:	3f 4f       	sbci	r19, 0xFF	; 255
     e5a:	f9 01       	movw	r30, r18
     e5c:	84 91       	lpm	r24, Z+
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
  if (charnum)             //proportional width
    while(charnum--)
      ret += pgm_read_byte(base++);
  return (font_data(font))+ret*font_get_height_bytes(font);
     e5e:	81 50       	subi	r24, 0x01	; 1
     e60:	86 95       	lsr	r24
     e62:	86 95       	lsr	r24
     e64:	86 95       	lsr	r24
     e66:	8f 5f       	subi	r24, 0xFF	; 255
     e68:	90 e0       	ldi	r25, 0x00	; 0
     e6a:	9c 01       	movw	r18, r24
     e6c:	26 9f       	mul	r18, r22
     e6e:	c0 01       	movw	r24, r0
     e70:	27 9f       	mul	r18, r23
     e72:	90 0d       	add	r25, r0
     e74:	36 9f       	mul	r19, r22
     e76:	90 0d       	add	r25, r0
     e78:	11 24       	eor	r1, r1
     e7a:	48 0f       	add	r20, r24
     e7c:	59 1f       	adc	r21, r25
  }
     e7e:	ca 01       	movw	r24, r20
     e80:	1f 91       	pop	r17
     e82:	0f 91       	pop	r16
     e84:	ff 90       	pop	r15
     e86:	ef 90       	pop	r14
     e88:	08 95       	ret

00000e8a <lcd_put_char>:
 *****************************************************************************/

/******************************************************************************
 * Outputs a character on the display, using the given font and style
 */
uint8_t lcd_put_char(FONT_P font, uint8_t style, char character) {
     e8a:	2f 92       	push	r2
     e8c:	3f 92       	push	r3
     e8e:	4f 92       	push	r4
     e90:	5f 92       	push	r5
     e92:	6f 92       	push	r6
     e94:	7f 92       	push	r7
     e96:	8f 92       	push	r8
     e98:	9f 92       	push	r9
     e9a:	af 92       	push	r10
     e9c:	bf 92       	push	r11
     e9e:	cf 92       	push	r12
     ea0:	df 92       	push	r13
     ea2:	ef 92       	push	r14
     ea4:	ff 92       	push	r15
     ea6:	0f 93       	push	r16
     ea8:	1f 93       	push	r17
     eaa:	df 93       	push	r29
     eac:	cf 93       	push	r28
     eae:	cd b7       	in	r28, 0x3d	; 61
     eb0:	de b7       	in	r29, 0x3e	; 62
     eb2:	2b 97       	sbiw	r28, 0x0b	; 11
     eb4:	0f b6       	in	r0, 0x3f	; 63
     eb6:	f8 94       	cli
     eb8:	de bf       	out	0x3e, r29	; 62
     eba:	0f be       	out	0x3f, r0	; 63
     ebc:	cd bf       	out	0x3d, r28	; 61
     ebe:	5c 01       	movw	r10, r24
     ec0:	f4 2e       	mov	r15, r20
  int8_t  i;
  uint8_t row  = 0;                             //current row of char
  uint8_t hc   = (style & DOUBLE_HEIGHT)?1:0;   //height changed
     ec2:	33 24       	eor	r3, r3
     ec4:	33 94       	inc	r3
     ec6:	36 22       	and	r3, r22
  uint8_t wc   = (style & DOUBLE_WIDTH)?1:0;    //width changed
     ec8:	06 2f       	mov	r16, r22
     eca:	10 e0       	ldi	r17, 0x00	; 0
     ecc:	c8 01       	movw	r24, r16
     ece:	96 95       	lsr	r25
     ed0:	87 95       	ror	r24
     ed2:	28 2f       	mov	r18, r24
     ed4:	21 70       	andi	r18, 0x01	; 1
     ed6:	2c 83       	std	Y+4, r18	; 0x04
  uint8_t ul   = (style & UNDERLINE)?0x80:0x00; //underline
     ed8:	64 fd       	sbrc	r22, 4
     eda:	02 c0       	rjmp	.+4      	; 0xee0 <lcd_put_char+0x56>
     edc:	66 24       	eor	r6, r6
     ede:	02 c0       	rjmp	.+4      	; 0xee4 <lcd_put_char+0x5a>
     ee0:	80 e8       	ldi	r24, 0x80	; 128
     ee2:	68 2e       	mov	r6, r24
  uint8_t inv  = (style & INVERT)?0xFF:0;       //inverted
     ee4:	02 fd       	sbrc	r16, 2
     ee6:	02 c0       	rjmp	.+4      	; 0xeec <lcd_put_char+0x62>
     ee8:	77 24       	eor	r7, r7
     eea:	02 c0       	rjmp	.+4      	; 0xef0 <lcd_put_char+0x66>
     eec:	77 24       	eor	r7, r7
     eee:	7a 94       	dec	r7
  uint8_t tmp;

  //load information about character
   uint8_t char_width    = font_get_char_width(font,character); 
     ef0:	c5 01       	movw	r24, r10
     ef2:	6f 2d       	mov	r22, r15
     ef4:	0e 94 a9 06 	call	0xd52	; 0xd52 <font_get_char_width>
     ef8:	e8 2e       	mov	r14, r24
/******************************************************************************
 * Loads the height (in bytes) of the given font
 */
inline uint8_t font_get_height_bytes(FONT_P font) {
  FONT_P tmp = font;
  uint8_t t = pgm_read_byte(&tmp->height);
     efa:	83 e0       	ldi	r24, 0x03	; 3
     efc:	90 e0       	ldi	r25, 0x00	; 0
     efe:	a8 0e       	add	r10, r24
     f00:	b9 1e       	adc	r11, r25
     f02:	f5 01       	movw	r30, r10
     f04:	d4 90       	lpm	r13, Z+
     f06:	2d ef       	ldi	r18, 0xFD	; 253
     f08:	3f ef       	ldi	r19, 0xFF	; 255
     f0a:	a2 0e       	add	r10, r18
     f0c:	b3 1e       	adc	r11, r19
  return (((uint8_t)(t-1)>>3)+1);
     f0e:	da 94       	dec	r13
     f10:	d6 94       	lsr	r13
     f12:	d6 94       	lsr	r13
     f14:	d6 94       	lsr	r13
     f16:	d3 94       	inc	r13
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     f18:	f5 01       	movw	r30, r10
     f1a:	36 96       	adiw	r30, 0x06	; 6
     f1c:	85 91       	lpm	r24, Z+
     f1e:	94 91       	lpm	r25, Z+
     f20:	22 24       	eor	r2, r2
     f22:	89 2b       	or	r24, r25
     f24:	11 f0       	breq	.+4      	; 0xf2a <lcd_put_char+0xa0>
     f26:	22 24       	eor	r2, r2
     f28:	23 94       	inc	r2

  //load information about character
   uint8_t char_width    = font_get_char_width(font,character); 
   uint8_t font_height   = font_get_height_bytes(font);
   uint8_t free_space    = font_get_add_space(font,character);
   PGM_P   tableposition = font_get_char_position(font,character);
     f2a:	c5 01       	movw	r24, r10
     f2c:	6f 2d       	mov	r22, r15
     f2e:	0e 94 cf 06 	call	0xd9e	; 0xd9e <font_get_char_position>
     f32:	9b 83       	std	Y+3, r25	; 0x03
     f34:	8a 83       	std	Y+2, r24	; 0x02

  //final size of character
  uint8_t char_final_width  = (uint8_t)(char_width+free_space) << wc;
     f36:	c2 2c       	mov	r12, r2
     f38:	ce 0c       	add	r12, r14
     f3a:	0c 80       	ldd	r0, Y+4	; 0x04
     f3c:	01 c0       	rjmp	.+2      	; 0xf40 <lcd_put_char+0xb6>
     f3e:	cc 0c       	add	r12, r12
     f40:	0a 94       	dec	r0
     f42:	ea f7       	brpl	.-6      	; 0xf3e <lcd_put_char+0xb4>
  uint8_t char_final_height = (uint8_t)font_height << hc; 
     f44:	8d 2c       	mov	r8, r13
     f46:	99 24       	eor	r9, r9
     f48:	bd 2c       	mov	r11, r13
     f4a:	03 2c       	mov	r0, r3
     f4c:	01 c0       	rjmp	.+2      	; 0xf50 <lcd_put_char+0xc6>
     f4e:	bb 0c       	add	r11, r11
     f50:	0a 94       	dec	r0
     f52:	ea f7       	brpl	.-6      	; 0xf4e <lcd_put_char+0xc4>

  //check for avail. space on display
  if ((style & WRAP) && (LCD_CURRENT_COL() + char_final_width > LCD_WIDTH)) {
     f54:	03 ff       	sbrs	r16, 3
     f56:	13 c0       	rjmp	.+38     	; 0xf7e <lcd_put_char+0xf4>
     f58:	80 91 70 00 	lds	r24, 0x0070
     f5c:	90 e0       	ldi	r25, 0x00	; 0
     f5e:	8c 0d       	add	r24, r12
     f60:	91 1d       	adc	r25, r1
     f62:	85 38       	cpi	r24, 0x85	; 133
     f64:	91 05       	cpc	r25, r1
     f66:	5c f0       	brlt	.+22     	; 0xf7e <lcd_put_char+0xf4>
    LCD_MOVE_TO(LCD_CURRENT_PAGE()+char_final_height,0);
     f68:	80 91 6f 00 	lds	r24, 0x006F
     f6c:	8b 0d       	add	r24, r11
     f6e:	60 e0       	ldi	r22, 0x00	; 0
     f70:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
    if (character == ' ') return 0;
     f74:	30 e2       	ldi	r19, 0x20	; 32
     f76:	f3 16       	cp	r15, r19
     f78:	11 f4       	brne	.+4      	; 0xf7e <lcd_put_char+0xf4>
     f7a:	cc 24       	eor	r12, r12
     f7c:	8e c0       	rjmp	.+284    	; 0x109a <lcd_put_char+0x210>
    }
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
     f7e:	8e 2d       	mov	r24, r14
     f80:	90 e0       	ldi	r25, 0x00	; 0
     f82:	88 9e       	mul	r8, r24
     f84:	d0 01       	movw	r26, r0
     f86:	89 9e       	mul	r8, r25
     f88:	b0 0d       	add	r27, r0
     f8a:	98 9e       	mul	r9, r24
     f8c:	b0 0d       	add	r27, r0
     f8e:	11 24       	eor	r1, r1
     f90:	be 83       	std	Y+6, r27	; 0x06
     f92:	ad 83       	std	Y+5, r26	; 0x05
        LCD_WRITE(tmp);
      }
    if (free_space) {
      uint8_t c = inv;
      if(row == char_final_height-1) {
        c ^= ul; 
     f94:	b7 2d       	mov	r27, r7
     f96:	b6 25       	eor	r27, r6
     f98:	b9 83       	std	Y+1, r27	; 0x01
        if(hc)
          c ^= ul>>1;      
     f9a:	a6 2c       	mov	r10, r6
     f9c:	a6 94       	lsr	r10
     f9e:	ab 26       	eor	r10, r27
     fa0:	1b 86       	std	Y+11, r1	; 0x0b
     fa2:	1a 86       	std	Y+10, r1	; 0x0a
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
      tmp = pgm_read_byte(tableposition+i);
      if(row == char_final_height-1) 
     fa4:	eb 2c       	mov	r14, r11
     fa6:	ff 24       	eor	r15, r15
     fa8:	08 94       	sec
     faa:	e1 08       	sbc	r14, r1
     fac:	f1 08       	sbc	r15, r1
        }
      LCD_WRITE(c);
      if(wc) 
        LCD_WRITE(c);
      }
    LCD_MOVE(1,-char_final_width);
     fae:	4c 2c       	mov	r4, r12
     fb0:	55 24       	eor	r5, r5
     fb2:	ee 27       	eor	r30, r30
     fb4:	ff 27       	eor	r31, r31
     fb6:	e4 19       	sub	r30, r4
     fb8:	f5 09       	sbc	r31, r5
     fba:	f9 87       	std	Y+9, r31	; 0x09
     fbc:	e8 87       	std	Y+8, r30	; 0x08
    if (character == ' ') return 0;
    }
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
     fbe:	8a 84       	ldd	r8, Y+10	; 0x0a
     fc0:	9b 84       	ldd	r9, Y+11	; 0x0b
     fc2:	03 2c       	mov	r0, r3
     fc4:	02 c0       	rjmp	.+4      	; 0xfca <lcd_put_char+0x140>
     fc6:	95 94       	asr	r9
     fc8:	87 94       	ror	r8
     fca:	0a 94       	dec	r0
     fcc:	e2 f7       	brpl	.-8      	; 0xfc6 <lcd_put_char+0x13c>
     fce:	00 e0       	ldi	r16, 0x00	; 0
 * part = 1:  abcdefgh -> aabbccdd
 * Used for double height font
 */
inline unsigned char double_bits(uint8_t part, char c) {	
  char t = 0;
  if (part) c = c>>4;
     fd0:	fa 85       	ldd	r31, Y+10	; 0x0a
     fd2:	f1 70       	andi	r31, 0x01	; 1
     fd4:	ff 83       	std	Y+7, r31	; 0x07
     fd6:	2d c0       	rjmp	.+90     	; 0x1032 <lcd_put_char+0x1a8>
    }
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
      tmp = pgm_read_byte(tableposition+i);
     fd8:	2a 81       	ldd	r18, Y+2	; 0x02
     fda:	3b 81       	ldd	r19, Y+3	; 0x03
     fdc:	e2 0f       	add	r30, r18
     fde:	f3 1f       	adc	r31, r19
     fe0:	84 91       	lpm	r24, Z+
      if(row == char_final_height-1) 
     fe2:	aa 85       	ldd	r26, Y+10	; 0x0a
     fe4:	bb 85       	ldd	r27, Y+11	; 0x0b
     fe6:	ae 15       	cp	r26, r14
     fe8:	bf 05       	cpc	r27, r15
     fea:	11 f0       	breq	.+4      	; 0xff0 <lcd_put_char+0x166>
     fec:	18 2f       	mov	r17, r24
     fee:	02 c0       	rjmp	.+4      	; 0xff4 <lcd_put_char+0x16a>
        tmp |= ul;
     ff0:	18 2f       	mov	r17, r24
     ff2:	16 29       	or	r17, r6
      if(hc)
     ff4:	33 20       	and	r3, r3
     ff6:	89 f0       	breq	.+34     	; 0x101a <lcd_put_char+0x190>
 * part = 1:  abcdefgh -> aabbccdd
 * Used for double height font
 */
inline unsigned char double_bits(uint8_t part, char c) {	
  char t = 0;
  if (part) c = c>>4;
     ff8:	bf 81       	ldd	r27, Y+7	; 0x07
     ffa:	bb 23       	and	r27, r27
     ffc:	11 f0       	breq	.+4      	; 0x1002 <lcd_put_char+0x178>
     ffe:	12 95       	swap	r17
    1000:	1f 70       	andi	r17, 0x0F	; 15
  if (c & 0x08) t  = 0xC0;
    1002:	81 2f       	mov	r24, r17
    1004:	13 fd       	sbrc	r17, 3
    1006:	02 c0       	rjmp	.+4      	; 0x100c <lcd_put_char+0x182>
    1008:	10 e0       	ldi	r17, 0x00	; 0
    100a:	01 c0       	rjmp	.+2      	; 0x100e <lcd_put_char+0x184>
    100c:	10 ec       	ldi	r17, 0xC0	; 192
  if (c & 0x04) t |= 0x30;
    100e:	82 fd       	sbrc	r24, 2
    1010:	10 63       	ori	r17, 0x30	; 48
  if (c & 0x02) t |= 0x0C;
    1012:	81 fd       	sbrc	r24, 1
    1014:	1c 60       	ori	r17, 0x0C	; 12
  if (c & 0x01) t |= 0x03;
    1016:	80 fd       	sbrc	r24, 0
    1018:	13 60       	ori	r17, 0x03	; 3
      tmp = pgm_read_byte(tableposition+i);
      if(row == char_final_height-1) 
        tmp |= ul;
      if(hc)
        tmp = double_bits((row&1),tmp);
      if(inv)
    101a:	71 10       	cpse	r7, r1
        tmp = ~tmp;
    101c:	10 95       	com	r17
      LCD_WRITE(tmp);
    101e:	81 2f       	mov	r24, r17
    1020:	0e 94 76 04 	call	0x8ec	; 0x8ec <lcd_data>
      if(wc) 
    1024:	ec 81       	ldd	r30, Y+4	; 0x04
    1026:	ee 23       	and	r30, r30
    1028:	19 f0       	breq	.+6      	; 0x1030 <lcd_put_char+0x1a6>
        LCD_WRITE(tmp);
    102a:	81 2f       	mov	r24, r17
    102c:	0e 94 76 04 	call	0x8ec	; 0x8ec <lcd_data>
    1030:	0d 0d       	add	r16, r13
    1032:	80 2f       	mov	r24, r16
    1034:	88 0d       	add	r24, r8
    if (character == ' ') return 0;
    }
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
    1036:	e8 2f       	mov	r30, r24
    1038:	ff 27       	eor	r31, r31
    103a:	e7 fd       	sbrc	r30, 7
    103c:	f0 95       	com	r31
    103e:	2d 81       	ldd	r18, Y+5	; 0x05
    1040:	3e 81       	ldd	r19, Y+6	; 0x06
    1042:	e2 17       	cp	r30, r18
    1044:	f3 07       	cpc	r31, r19
    1046:	44 f2       	brlt	.-112    	; 0xfd8 <lcd_put_char+0x14e>
        tmp = ~tmp;
      LCD_WRITE(tmp);
      if(wc) 
        LCD_WRITE(tmp);
      }
    if (free_space) {
    1048:	22 20       	and	r2, r2
    104a:	a9 f0       	breq	.+42     	; 0x1076 <lcd_put_char+0x1ec>
      uint8_t c = inv;
      if(row == char_final_height-1) {
    104c:	8a 85       	ldd	r24, Y+10	; 0x0a
    104e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1050:	8e 15       	cp	r24, r14
    1052:	9f 05       	cpc	r25, r15
    1054:	11 f0       	breq	.+4      	; 0x105a <lcd_put_char+0x1d0>
    1056:	17 2d       	mov	r17, r7
    1058:	05 c0       	rjmp	.+10     	; 0x1064 <lcd_put_char+0x1da>
        c ^= ul; 
        if(hc)
    105a:	33 20       	and	r3, r3
    105c:	11 f4       	brne	.+4      	; 0x1062 <lcd_put_char+0x1d8>
    105e:	19 81       	ldd	r17, Y+1	; 0x01
    1060:	01 c0       	rjmp	.+2      	; 0x1064 <lcd_put_char+0x1da>
    1062:	1a 2d       	mov	r17, r10
          c ^= ul>>1;      
        }
      LCD_WRITE(c);
    1064:	81 2f       	mov	r24, r17
    1066:	0e 94 76 04 	call	0x8ec	; 0x8ec <lcd_data>
      if(wc) 
    106a:	9c 81       	ldd	r25, Y+4	; 0x04
    106c:	99 23       	and	r25, r25
    106e:	19 f0       	breq	.+6      	; 0x1076 <lcd_put_char+0x1ec>
        LCD_WRITE(c);
    1070:	81 2f       	mov	r24, r17
    1072:	0e 94 76 04 	call	0x8ec	; 0x8ec <lcd_data>
      }
    LCD_MOVE(1,-char_final_width);
    1076:	81 e0       	ldi	r24, 0x01	; 1
    1078:	68 85       	ldd	r22, Y+8	; 0x08
    107a:	79 85       	ldd	r23, Y+9	; 0x09
    107c:	0e 94 a1 04 	call	0x942	; 0x942 <lcd_move_xy>
    1080:	aa 85       	ldd	r26, Y+10	; 0x0a
    1082:	bb 85       	ldd	r27, Y+11	; 0x0b
    1084:	11 96       	adiw	r26, 0x01	; 1
    1086:	bb 87       	std	Y+11, r27	; 0x0b
    1088:	aa 87       	std	Y+10, r26	; 0x0a
    } while (++row < char_final_height);
    108a:	ab 15       	cp	r26, r11
    108c:	08 f4       	brcc	.+2      	; 0x1090 <lcd_put_char+0x206>
    108e:	97 cf       	rjmp	.-210    	; 0xfbe <lcd_put_char+0x134>

  //move cursor to upper right corner of character
  LCD_MOVE(-char_final_height,char_final_width);
    1090:	8b 2d       	mov	r24, r11
    1092:	81 95       	neg	r24
    1094:	b2 01       	movw	r22, r4
    1096:	0e 94 a1 04 	call	0x942	; 0x942 <lcd_move_xy>
  return char_final_width;
  }
    109a:	8c 2d       	mov	r24, r12
    109c:	2b 96       	adiw	r28, 0x0b	; 11
    109e:	0f b6       	in	r0, 0x3f	; 63
    10a0:	f8 94       	cli
    10a2:	de bf       	out	0x3e, r29	; 62
    10a4:	0f be       	out	0x3f, r0	; 63
    10a6:	cd bf       	out	0x3d, r28	; 61
    10a8:	cf 91       	pop	r28
    10aa:	df 91       	pop	r29
    10ac:	1f 91       	pop	r17
    10ae:	0f 91       	pop	r16
    10b0:	ff 90       	pop	r15
    10b2:	ef 90       	pop	r14
    10b4:	df 90       	pop	r13
    10b6:	cf 90       	pop	r12
    10b8:	bf 90       	pop	r11
    10ba:	af 90       	pop	r10
    10bc:	9f 90       	pop	r9
    10be:	8f 90       	pop	r8
    10c0:	7f 90       	pop	r7
    10c2:	6f 90       	pop	r6
    10c4:	5f 90       	pop	r5
    10c6:	4f 90       	pop	r4
    10c8:	3f 90       	pop	r3
    10ca:	2f 90       	pop	r2
    10cc:	08 95       	ret

000010ce <lcd_putc>:


/******************************************************************************
 * Outputs a character on the display, using the global font and style
 */ 
uint8_t  lcd_putc(char c) {
    10ce:	48 2f       	mov	r20, r24
  return lcd_put_char(global_font_select, global_font_style, c);
    10d0:	80 91 72 00 	lds	r24, 0x0072
    10d4:	90 91 73 00 	lds	r25, 0x0073
    10d8:	60 91 71 00 	lds	r22, 0x0071
    10dc:	0e 94 45 07 	call	0xe8a	; 0xe8a <lcd_put_char>
  }
    10e0:	08 95       	ret

000010e2 <lcd_put_char_xy>:
/******************************************************************************
 * Outputs a string on the display, using the given font and style, reading
 * the string from main memory. The position of the string on the display
 * is selected by page / col.
 */ 
uint8_t lcd_put_char_xy(FONT_P font, uint8_t style, char character, uint8_t page, uint8_t col) {
    10e2:	df 92       	push	r13
    10e4:	ef 92       	push	r14
    10e6:	ff 92       	push	r15
    10e8:	0f 93       	push	r16
    10ea:	1f 93       	push	r17
    10ec:	7c 01       	movw	r14, r24
    10ee:	16 2f       	mov	r17, r22
    10f0:	d4 2e       	mov	r13, r20
    10f2:	82 2f       	mov	r24, r18
    10f4:	60 2f       	mov	r22, r16
  LCD_MOVE_TO(page,col);
    10f6:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
  return lcd_put_char(font,style,character);
    10fa:	c7 01       	movw	r24, r14
    10fc:	61 2f       	mov	r22, r17
    10fe:	4d 2d       	mov	r20, r13
    1100:	0e 94 45 07 	call	0xe8a	; 0xe8a <lcd_put_char>
  }
    1104:	1f 91       	pop	r17
    1106:	0f 91       	pop	r16
    1108:	ff 90       	pop	r15
    110a:	ef 90       	pop	r14
    110c:	df 90       	pop	r13
    110e:	08 95       	ret

00001110 <lcd_putc_xy>:
  }

/******************************************************************************
 * Outputs a character on the display, using the global font and style
 */ 
uint8_t  lcd_putc_xy(char c, uint8_t page, uint8_t col) {
    1110:	0f 93       	push	r16
    1112:	38 2f       	mov	r19, r24
    1114:	26 2f       	mov	r18, r22
    1116:	04 2f       	mov	r16, r20
  return lcd_put_char_xy(global_font_select, global_font_style, c, page, col);
    1118:	80 91 72 00 	lds	r24, 0x0072
    111c:	90 91 73 00 	lds	r25, 0x0073
    1120:	60 91 71 00 	lds	r22, 0x0071
    1124:	43 2f       	mov	r20, r19
    1126:	0e 94 71 08 	call	0x10e2	; 0x10e2 <lcd_put_char_xy>
  }  
    112a:	0f 91       	pop	r16
    112c:	08 95       	ret

0000112e <lcd_put_string_length>:
  
/******************************************************************************
 * Outputs a string on the display, using the given font and style, reading
 * length characters from the memory
 */ 
uint16_t lcd_put_string_length(FONT_P font, uint8_t style, char* str, uint8_t length) {
    112e:	bf 92       	push	r11
    1130:	cf 92       	push	r12
    1132:	df 92       	push	r13
    1134:	ef 92       	push	r14
    1136:	ff 92       	push	r15
    1138:	0f 93       	push	r16
    113a:	1f 93       	push	r17
    113c:	cf 93       	push	r28
    113e:	df 93       	push	r29
    1140:	7c 01       	movw	r14, r24
    1142:	b6 2e       	mov	r11, r22
    1144:	d4 2e       	mov	r13, r20
    1146:	c2 2e       	mov	r12, r18
    1148:	24 2f       	mov	r18, r20
    114a:	35 2f       	mov	r19, r21
    114c:	c9 01       	movw	r24, r18
    114e:	8c 01       	movw	r16, r24
    1150:	c0 e0       	ldi	r28, 0x00	; 0
    1152:	d0 e0       	ldi	r29, 0x00	; 0
    1154:	09 c0       	rjmp	.+18     	; 0x1168 <lcd_put_string_length+0x3a>
  unsigned char t;
  uint16_t total_len = 0;
  for(t=0;t<length;t++)
    total_len += lcd_put_char(font,style,*str++);
    1156:	f8 01       	movw	r30, r16
    1158:	41 91       	ld	r20, Z+
    115a:	8f 01       	movw	r16, r30
    115c:	c7 01       	movw	r24, r14
    115e:	6b 2d       	mov	r22, r11
    1160:	0e 94 45 07 	call	0xe8a	; 0xe8a <lcd_put_char>
    1164:	c8 0f       	add	r28, r24
    1166:	d1 1d       	adc	r29, r1
 * length characters from the memory
 */ 
uint16_t lcd_put_string_length(FONT_P font, uint8_t style, char* str, uint8_t length) {
  unsigned char t;
  uint16_t total_len = 0;
  for(t=0;t<length;t++)
    1168:	80 2f       	mov	r24, r16
    116a:	8d 19       	sub	r24, r13
    116c:	8c 15       	cp	r24, r12
    116e:	98 f3       	brcs	.-26     	; 0x1156 <lcd_put_string_length+0x28>
    total_len += lcd_put_char(font,style,*str++);
  return total_len;
  }
    1170:	ce 01       	movw	r24, r28
    1172:	df 91       	pop	r29
    1174:	cf 91       	pop	r28
    1176:	1f 91       	pop	r17
    1178:	0f 91       	pop	r16
    117a:	ff 90       	pop	r15
    117c:	ef 90       	pop	r14
    117e:	df 90       	pop	r13
    1180:	cf 90       	pop	r12
    1182:	bf 90       	pop	r11
    1184:	08 95       	ret

00001186 <lcd_put_string>:

  
/******************************************************************************
 * Outputs a string on the display, using the given font and style
 */
uint16_t lcd_put_string(FONT_P font, uint8_t style, char* str) {
    1186:	df 92       	push	r13
    1188:	ef 92       	push	r14
    118a:	ff 92       	push	r15
    118c:	0f 93       	push	r16
    118e:	1f 93       	push	r17
    1190:	cf 93       	push	r28
    1192:	df 93       	push	r29
    1194:	7c 01       	movw	r14, r24
    1196:	d6 2e       	mov	r13, r22
    1198:	8a 01       	movw	r16, r20
    119a:	c0 e0       	ldi	r28, 0x00	; 0
    119c:	d0 e0       	ldi	r29, 0x00	; 0
    119e:	06 c0       	rjmp	.+12     	; 0x11ac <lcd_put_string+0x26>
  unsigned char t;
  uint16_t length = 0;
  while((t = *str++))
    length += lcd_put_char(font,style,t);
    11a0:	c7 01       	movw	r24, r14
    11a2:	6d 2d       	mov	r22, r13
    11a4:	0e 94 45 07 	call	0xe8a	; 0xe8a <lcd_put_char>
    11a8:	c8 0f       	add	r28, r24
    11aa:	d1 1d       	adc	r29, r1
 * Outputs a string on the display, using the given font and style
 */
uint16_t lcd_put_string(FONT_P font, uint8_t style, char* str) {
  unsigned char t;
  uint16_t length = 0;
  while((t = *str++))
    11ac:	f8 01       	movw	r30, r16
    11ae:	41 91       	ld	r20, Z+
    11b0:	8f 01       	movw	r16, r30
    11b2:	44 23       	and	r20, r20
    11b4:	a9 f7       	brne	.-22     	; 0x11a0 <lcd_put_string+0x1a>
    length += lcd_put_char(font,style,t);
  return length;
  }
    11b6:	ce 01       	movw	r24, r28
    11b8:	df 91       	pop	r29
    11ba:	cf 91       	pop	r28
    11bc:	1f 91       	pop	r17
    11be:	0f 91       	pop	r16
    11c0:	ff 90       	pop	r15
    11c2:	ef 90       	pop	r14
    11c4:	df 90       	pop	r13
    11c6:	08 95       	ret

000011c8 <lcd_put_short>:
  }  
  
/******************************************************************************
 * Outputs a 8bit signed integer on the display
 */   
uint16_t lcd_put_short (int8_t integer) {
    11c8:	0f 93       	push	r16
    11ca:	1f 93       	push	r17
    11cc:	df 93       	push	r29
    11ce:	cf 93       	push	r28
    11d0:	cd b7       	in	r28, 0x3d	; 61
    11d2:	de b7       	in	r29, 0x3e	; 62
    11d4:	2a 97       	sbiw	r28, 0x0a	; 10
    11d6:	0f b6       	in	r0, 0x3f	; 63
    11d8:	f8 94       	cli
    11da:	de bf       	out	0x3e, r29	; 62
    11dc:	0f be       	out	0x3f, r0	; 63
    11de:	cd bf       	out	0x3d, r28	; 61
  char buffer[10];
	itoa(integer, buffer, 10);
    11e0:	99 27       	eor	r25, r25
    11e2:	87 fd       	sbrc	r24, 7
    11e4:	90 95       	com	r25
    11e6:	8e 01       	movw	r16, r28
    11e8:	0f 5f       	subi	r16, 0xFF	; 255
    11ea:	1f 4f       	sbci	r17, 0xFF	; 255
    11ec:	b8 01       	movw	r22, r16
    11ee:	4a e0       	ldi	r20, 0x0A	; 10
    11f0:	50 e0       	ldi	r21, 0x00	; 0
    11f2:	0e 94 54 0d 	call	0x1aa8	; 0x1aa8 <itoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    11f6:	80 91 72 00 	lds	r24, 0x0072
    11fa:	90 91 73 00 	lds	r25, 0x0073
    11fe:	60 91 71 00 	lds	r22, 0x0071
    1202:	a8 01       	movw	r20, r16
    1204:	0e 94 c3 08 	call	0x1186	; 0x1186 <lcd_put_string>
  }    
    1208:	2a 96       	adiw	r28, 0x0a	; 10
    120a:	0f b6       	in	r0, 0x3f	; 63
    120c:	f8 94       	cli
    120e:	de bf       	out	0x3e, r29	; 62
    1210:	0f be       	out	0x3f, r0	; 63
    1212:	cd bf       	out	0x3d, r28	; 61
    1214:	cf 91       	pop	r28
    1216:	df 91       	pop	r29
    1218:	1f 91       	pop	r17
    121a:	0f 91       	pop	r16
    121c:	08 95       	ret

0000121e <lcd_put_uint>:

  
/******************************************************************************
 * Outputs a 16bit unsigned integer on the display // Added by Olli S.
 */   
uint16_t lcd_put_uint  (uint16_t integer) {
    121e:	0f 93       	push	r16
    1220:	1f 93       	push	r17
    1222:	df 93       	push	r29
    1224:	cf 93       	push	r28
    1226:	cd b7       	in	r28, 0x3d	; 61
    1228:	de b7       	in	r29, 0x3e	; 62
    122a:	2a 97       	sbiw	r28, 0x0a	; 10
    122c:	0f b6       	in	r0, 0x3f	; 63
    122e:	f8 94       	cli
    1230:	de bf       	out	0x3e, r29	; 62
    1232:	0f be       	out	0x3f, r0	; 63
    1234:	cd bf       	out	0x3d, r28	; 61
  char buffer[10];
	utoa(integer, buffer, 10);
    1236:	8e 01       	movw	r16, r28
    1238:	0f 5f       	subi	r16, 0xFF	; 255
    123a:	1f 4f       	sbci	r17, 0xFF	; 255
    123c:	b8 01       	movw	r22, r16
    123e:	4a e0       	ldi	r20, 0x0A	; 10
    1240:	50 e0       	ldi	r21, 0x00	; 0
    1242:	0e 94 a9 0d 	call	0x1b52	; 0x1b52 <utoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    1246:	80 91 72 00 	lds	r24, 0x0072
    124a:	90 91 73 00 	lds	r25, 0x0073
    124e:	60 91 71 00 	lds	r22, 0x0071
    1252:	a8 01       	movw	r20, r16
    1254:	0e 94 c3 08 	call	0x1186	; 0x1186 <lcd_put_string>
  }  
    1258:	2a 96       	adiw	r28, 0x0a	; 10
    125a:	0f b6       	in	r0, 0x3f	; 63
    125c:	f8 94       	cli
    125e:	de bf       	out	0x3e, r29	; 62
    1260:	0f be       	out	0x3f, r0	; 63
    1262:	cd bf       	out	0x3d, r28	; 61
    1264:	cf 91       	pop	r28
    1266:	df 91       	pop	r29
    1268:	1f 91       	pop	r17
    126a:	0f 91       	pop	r16
    126c:	08 95       	ret

0000126e <lcd_put_int>:

  
/******************************************************************************
 * Outputs a 16bit signed integer on the display // Added by Olli S.
 */   
uint16_t lcd_put_int (int16_t integer) {
    126e:	0f 93       	push	r16
    1270:	1f 93       	push	r17
    1272:	df 93       	push	r29
    1274:	cf 93       	push	r28
    1276:	cd b7       	in	r28, 0x3d	; 61
    1278:	de b7       	in	r29, 0x3e	; 62
    127a:	2a 97       	sbiw	r28, 0x0a	; 10
    127c:	0f b6       	in	r0, 0x3f	; 63
    127e:	f8 94       	cli
    1280:	de bf       	out	0x3e, r29	; 62
    1282:	0f be       	out	0x3f, r0	; 63
    1284:	cd bf       	out	0x3d, r28	; 61
  char buffer[10];
	itoa(integer, buffer, 10);
    1286:	8e 01       	movw	r16, r28
    1288:	0f 5f       	subi	r16, 0xFF	; 255
    128a:	1f 4f       	sbci	r17, 0xFF	; 255
    128c:	b8 01       	movw	r22, r16
    128e:	4a e0       	ldi	r20, 0x0A	; 10
    1290:	50 e0       	ldi	r21, 0x00	; 0
    1292:	0e 94 54 0d 	call	0x1aa8	; 0x1aa8 <itoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    1296:	80 91 72 00 	lds	r24, 0x0072
    129a:	90 91 73 00 	lds	r25, 0x0073
    129e:	60 91 71 00 	lds	r22, 0x0071
    12a2:	a8 01       	movw	r20, r16
    12a4:	0e 94 c3 08 	call	0x1186	; 0x1186 <lcd_put_string>
  }  
    12a8:	2a 96       	adiw	r28, 0x0a	; 10
    12aa:	0f b6       	in	r0, 0x3f	; 63
    12ac:	f8 94       	cli
    12ae:	de bf       	out	0x3e, r29	; 62
    12b0:	0f be       	out	0x3f, r0	; 63
    12b2:	cd bf       	out	0x3d, r28	; 61
    12b4:	cf 91       	pop	r28
    12b6:	df 91       	pop	r29
    12b8:	1f 91       	pop	r17
    12ba:	0f 91       	pop	r16
    12bc:	08 95       	ret

000012be <lcd_put_long>:

#if INCLUDE_INTEGER_OUTPUT == 1
/******************************************************************************
 * Outputs a 32bit signed integer on the display // Added by Olli S.
 */ 
uint16_t lcd_put_long  (int32_t integer) {
    12be:	0f 93       	push	r16
    12c0:	1f 93       	push	r17
    12c2:	df 93       	push	r29
    12c4:	cf 93       	push	r28
    12c6:	cd b7       	in	r28, 0x3d	; 61
    12c8:	de b7       	in	r29, 0x3e	; 62
    12ca:	2a 97       	sbiw	r28, 0x0a	; 10
    12cc:	0f b6       	in	r0, 0x3f	; 63
    12ce:	f8 94       	cli
    12d0:	de bf       	out	0x3e, r29	; 62
    12d2:	0f be       	out	0x3f, r0	; 63
    12d4:	cd bf       	out	0x3d, r28	; 61
  char buffer[10];
	ltoa(integer, buffer, 10);
    12d6:	8e 01       	movw	r16, r28
    12d8:	0f 5f       	subi	r16, 0xFF	; 255
    12da:	1f 4f       	sbci	r17, 0xFF	; 255
    12dc:	a8 01       	movw	r20, r16
    12de:	2a e0       	ldi	r18, 0x0A	; 10
    12e0:	30 e0       	ldi	r19, 0x00	; 0
    12e2:	0e 94 75 0d 	call	0x1aea	; 0x1aea <ltoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    12e6:	80 91 72 00 	lds	r24, 0x0072
    12ea:	90 91 73 00 	lds	r25, 0x0073
    12ee:	60 91 71 00 	lds	r22, 0x0071
    12f2:	a8 01       	movw	r20, r16
    12f4:	0e 94 c3 08 	call	0x1186	; 0x1186 <lcd_put_string>
  }
    12f8:	2a 96       	adiw	r28, 0x0a	; 10
    12fa:	0f b6       	in	r0, 0x3f	; 63
    12fc:	f8 94       	cli
    12fe:	de bf       	out	0x3e, r29	; 62
    1300:	0f be       	out	0x3f, r0	; 63
    1302:	cd bf       	out	0x3d, r28	; 61
    1304:	cf 91       	pop	r28
    1306:	df 91       	pop	r29
    1308:	1f 91       	pop	r17
    130a:	0f 91       	pop	r16
    130c:	08 95       	ret

0000130e <lcd_putstr>:
  
  
/******************************************************************************
 * Outputs a string on the display, using the global font and style
 */   
uint16_t lcd_putstr(char* str) {
    130e:	ac 01       	movw	r20, r24
  return lcd_put_string(global_font_select, global_font_style, str);
    1310:	80 91 72 00 	lds	r24, 0x0072
    1314:	90 91 73 00 	lds	r25, 0x0073
    1318:	60 91 71 00 	lds	r22, 0x0071
    131c:	0e 94 c3 08 	call	0x1186	; 0x1186 <lcd_put_string>
  }
    1320:	08 95       	ret

00001322 <lcd_put_string_P>:

/******************************************************************************
 * Outputs a string on the display, loading it from the program memory,
 * using the given font and style
 */
uint16_t lcd_put_string_P(FONT_P font, uint8_t style, PGM_P str) {
    1322:	df 92       	push	r13
    1324:	ef 92       	push	r14
    1326:	ff 92       	push	r15
    1328:	0f 93       	push	r16
    132a:	1f 93       	push	r17
    132c:	cf 93       	push	r28
    132e:	df 93       	push	r29
    1330:	7c 01       	movw	r14, r24
    1332:	d6 2e       	mov	r13, r22
    1334:	8a 01       	movw	r16, r20
    1336:	c0 e0       	ldi	r28, 0x00	; 0
    1338:	d0 e0       	ldi	r29, 0x00	; 0
    133a:	06 c0       	rjmp	.+12     	; 0x1348 <lcd_put_string_P+0x26>
  unsigned char t;
  uint16_t length = 0;
  while((t = pgm_read_byte(str++))) 
    length += lcd_put_char(font,style,t);
    133c:	c7 01       	movw	r24, r14
    133e:	6d 2d       	mov	r22, r13
    1340:	0e 94 45 07 	call	0xe8a	; 0xe8a <lcd_put_char>
    1344:	c8 0f       	add	r28, r24
    1346:	d1 1d       	adc	r29, r1
    1348:	f8 01       	movw	r30, r16
 * using the given font and style
 */
uint16_t lcd_put_string_P(FONT_P font, uint8_t style, PGM_P str) {
  unsigned char t;
  uint16_t length = 0;
  while((t = pgm_read_byte(str++))) 
    134a:	0f 5f       	subi	r16, 0xFF	; 255
    134c:	1f 4f       	sbci	r17, 0xFF	; 255
    134e:	44 91       	lpm	r20, Z+
    1350:	44 23       	and	r20, r20
    1352:	a1 f7       	brne	.-24     	; 0x133c <lcd_put_string_P+0x1a>
    length += lcd_put_char(font,style,t);
  return length;
  }
    1354:	ce 01       	movw	r24, r28
    1356:	df 91       	pop	r29
    1358:	cf 91       	pop	r28
    135a:	1f 91       	pop	r17
    135c:	0f 91       	pop	r16
    135e:	ff 90       	pop	r15
    1360:	ef 90       	pop	r14
    1362:	df 90       	pop	r13
    1364:	08 95       	ret

00001366 <lcd_putstr_P>:
  
/******************************************************************************
 * Outputs a string stored in program memory on the display, using the global 
 * font and style
 */   
uint16_t lcd_putstr_P(PGM_P str) {
    1366:	ac 01       	movw	r20, r24
  return lcd_put_string_P(global_font_select, global_font_style, str);
    1368:	80 91 72 00 	lds	r24, 0x0072
    136c:	90 91 73 00 	lds	r25, 0x0073
    1370:	60 91 71 00 	lds	r22, 0x0071
    1374:	0e 94 91 09 	call	0x1322	; 0x1322 <lcd_put_string_P>
  }
    1378:	08 95       	ret

0000137a <lcd_put_string_xy_P>:
/******************************************************************************
 * Outputs a string on the display, using the given font and style, reading
 * the string from program memory. The position of the string on the display
 * is selected by page / col.
 */ 
uint16_t lcd_put_string_xy_P(FONT_P font, uint8_t style, PGM_P str,uint8_t page, uint8_t col) {
    137a:	cf 92       	push	r12
    137c:	df 92       	push	r13
    137e:	ef 92       	push	r14
    1380:	ff 92       	push	r15
    1382:	0f 93       	push	r16
    1384:	1f 93       	push	r17
    1386:	7c 01       	movw	r14, r24
    1388:	16 2f       	mov	r17, r22
    138a:	6a 01       	movw	r12, r20
    138c:	82 2f       	mov	r24, r18
    138e:	60 2f       	mov	r22, r16
  LCD_MOVE_TO(page,col);
    1390:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
  return lcd_put_string_P(font,style,str);
    1394:	c7 01       	movw	r24, r14
    1396:	61 2f       	mov	r22, r17
    1398:	a6 01       	movw	r20, r12
    139a:	0e 94 91 09 	call	0x1322	; 0x1322 <lcd_put_string_P>
  }
    139e:	1f 91       	pop	r17
    13a0:	0f 91       	pop	r16
    13a2:	ff 90       	pop	r15
    13a4:	ef 90       	pop	r14
    13a6:	df 90       	pop	r13
    13a8:	cf 90       	pop	r12
    13aa:	08 95       	ret

000013ac <lcd_putstr_xy_P>:

/******************************************************************************
 * Outputs a string on the display, using the global font and style at the 
 * given position
 */   
uint16_t lcd_putstr_xy_P(PGM_P  str, uint8_t page, uint8_t col) {
    13ac:	0f 93       	push	r16
    13ae:	fc 01       	movw	r30, r24
    13b0:	26 2f       	mov	r18, r22
    13b2:	04 2f       	mov	r16, r20
  return lcd_put_string_xy_P(global_font_select, global_font_style, str, page, col);
    13b4:	80 91 72 00 	lds	r24, 0x0072
    13b8:	90 91 73 00 	lds	r25, 0x0073
    13bc:	60 91 71 00 	lds	r22, 0x0071
    13c0:	af 01       	movw	r20, r30
    13c2:	0e 94 bd 09 	call	0x137a	; 0x137a <lcd_put_string_xy_P>
  }  
    13c6:	0f 91       	pop	r16
    13c8:	08 95       	ret

000013ca <timer_init>:
#include "timerInit.h"

void timer_init(uint16_t compare)
{

	TCCR1B |= (1<<WGM12);	//CTC Mode:
    13ca:	2e b5       	in	r18, 0x2e	; 46
    13cc:	28 60       	ori	r18, 0x08	; 8
    13ce:	2e bd       	out	0x2e, r18	; 46
							//Timer1 zählt hoch, bei compare match wird er wieder zu 0 gesetzt

	TCCR1B |= (1<<CS10); //Prescaler nicht aktiviert - es liegt der Systemtakt an
    13d0:	2e b5       	in	r18, 0x2e	; 46
    13d2:	21 60       	ori	r18, 0x01	; 1
    13d4:	2e bd       	out	0x2e, r18	; 46
	1 	0 	1 	CK / 1024
	1 	1 	0 	Externer Pin 1, negative Flanke
	1 	1 	1 	Externer Pin 1, positive Flanke 
*/
	
	OCR1A=compare;	//Vergleichswert laden
    13d6:	9b bd       	out	0x2b, r25	; 43
    13d8:	8a bd       	out	0x2a, r24	; 42
	
	
}
    13da:	08 95       	ret

000013dc <adcInit>:
{
  
  uint16_t result;
 									
								
  ADMUX &= ~((1<<REFS1) | (1<<REFS0)); // externe Referenzspannung nutzen (typischerweise Vcc-Pegel)
    13dc:	87 b1       	in	r24, 0x07	; 7
    13de:	8f 73       	andi	r24, 0x3F	; 63
    13e0:	87 b9       	out	0x07, r24	; 7


  ADCSRA |= ((1<<ADEN) | (1<<ADPS2) | (1<<ADPS1));    	// ADC Prescaler wählen. BIT0 bis BII 2 in ADCSRA
    13e2:	86 b1       	in	r24, 0x06	; 6
    13e4:	86 68       	ori	r24, 0x86	; 134
    13e6:	86 b9       	out	0x06, r24	; 6
                               					    // UND ADC aktivieren



  //Erste conversion anstoßen, danach läuft der ADC im free run mode
  ADCSRA |= (1<<ADSC);	
    13e8:	36 9a       	sbi	0x06, 6	; 6
  

  //Auf Abschluss der Konvertierung warten
  //Das Register ADCSRA wird mit "1<<ADSC" maskiert. Da ADSC den Wert 6 hat, wartet das while 
  //also solange, bis das Bit6 von ADCSRA == 0 wird.
  while (ADCSRA & (1<<ADSC) ) {}
    13ea:	36 99       	sbic	0x06, 6	; 6
    13ec:	fe cf       	rjmp	.-4      	; 0x13ea <adcInit+0xe>
  	
  //ADCSRA |= (1<<ADIE);		// ADC - > Interrupt Enable		
  
  /* ADCW muss einmal gelesen werden, sonst wird Ergebnis der nächsten
     Wandlung nicht übernommen. */
  result = ADCW;		 
    13ee:	84 b1       	in	r24, 0x04	; 4
    13f0:	95 b1       	in	r25, 0x05	; 5
   
}
    13f2:	08 95       	ret

000013f4 <adcRead15>:
 15V	   1023						     1023


**************************************************************************************************************/
uint16_t adcRead15(uint8_t channel)
{
    13f4:	98 2f       	mov	r25, r24
	uint16_t result=0;
	
	// 	Kanal waehlen(durch Parameterübergabe)	
	//  Kanäle 4 bis 7 sind verfügbar
	if ((channel >= 4) && (channel <=7))
    13f6:	84 50       	subi	r24, 0x04	; 4
    13f8:	84 30       	cpi	r24, 0x04	; 4
    13fa:	08 f4       	brcc	.+2      	; 0x13fe <adcRead15+0xa>
 		ADMUX = channel;                  // 	Kanal waehlen(durch Parameterübergabe)
    13fc:	97 b9       	out	0x07, r25	; 7

	//Erste conversion anstoßen, danach läuft der ADC im free run mode
  	ADCSRA |= (1<<ADSC);	
    13fe:	36 9a       	sbi	0x06, 6	; 6
  

  	//Auf Abschluss der Konvertierung warten
	while (ADCSRA & (1<<ADSC) ) {}
    1400:	36 99       	sbic	0x06, 6	; 6
    1402:	fe cf       	rjmp	.-4      	; 0x1400 <adcRead15+0xc>
	
	//result in bit value
	result = ADCW;
    1404:	24 b1       	in	r18, 0x04	; 4
    1406:	35 b1       	in	r19, 0x05	; 5
	//convert result into voltage value
	//korrektes runden mit +(divisor>>1)
	//ohne die 16bit casts würde das zwischenergebnis auf die bitwertigkeit des
	//niedrigsten teil des terms reduziert (hier 8 bit von 100 oder 15)
	result = ((result * (uint16_t)15 * (int16_t)100)+(1023>>1)) / (uint16_t)1023;
    1408:	8c ed       	ldi	r24, 0xDC	; 220
    140a:	95 e0       	ldi	r25, 0x05	; 5
    140c:	ac 01       	movw	r20, r24
    140e:	24 9f       	mul	r18, r20
    1410:	c0 01       	movw	r24, r0
    1412:	25 9f       	mul	r18, r21
    1414:	90 0d       	add	r25, r0
    1416:	34 9f       	mul	r19, r20
    1418:	90 0d       	add	r25, r0
    141a:	11 24       	eor	r1, r1
    141c:	81 50       	subi	r24, 0x01	; 1
    141e:	9e 4f       	sbci	r25, 0xFE	; 254
    1420:	6f ef       	ldi	r22, 0xFF	; 255
    1422:	73 e0       	ldi	r23, 0x03	; 3
    1424:	0e 94 03 0d 	call	0x1a06	; 0x1a06 <__udivmodhi4>
    1428:	cb 01       	movw	r24, r22

	return result;
}
    142a:	08 95       	ret

0000142c <adcRead5>:
/**************************************************************************************
Die  gleich Funktion noch einmal mit 5V als Bezugs-Spannung
**************************************************************************************/
uint16_t adcRead5(uint8_t channel)
{
    142c:	98 2f       	mov	r25, r24
	uint16_t result=0;
	
	// 	Kanal waehlen(durch Parameterübergabe)	
	//  Kanäle 4 bis 7 sind verfügbar
	if ((channel >= 4) && (channel <=7))
    142e:	84 50       	subi	r24, 0x04	; 4
    1430:	84 30       	cpi	r24, 0x04	; 4
    1432:	08 f4       	brcc	.+2      	; 0x1436 <adcRead5+0xa>
 		ADMUX = channel;                  // 	Kanal waehlen(durch Parameterübergabe)
    1434:	97 b9       	out	0x07, r25	; 7

	//Erste conversion anstoßen, danach läuft der ADC im free run mode
  	ADCSRA |= (1<<ADSC);	
    1436:	36 9a       	sbi	0x06, 6	; 6
  

  	//Auf Abschluss der Konvertierung warten
	while (ADCSRA & (1<<ADSC) ) {}
    1438:	36 99       	sbic	0x06, 6	; 6
    143a:	fe cf       	rjmp	.-4      	; 0x1438 <adcRead5+0xc>
	
	//result in bit value
	result = ADCW;
    143c:	24 b1       	in	r18, 0x04	; 4
    143e:	35 b1       	in	r19, 0x05	; 5
	//convert result into voltage value
	//korrektes runden mit +(divisor>>1)
	//ohne die 16bit casts würde das zwischenergebnis auf die bitwertigkeit des
	//niedrigsten teil des terms reduziert (hier 8 bit von 100 oder 15)
	result = ((result * (uint16_t)5 * (uint16_t)100) + (1023>>1)) / (uint16_t)1023;
    1440:	84 ef       	ldi	r24, 0xF4	; 244
    1442:	91 e0       	ldi	r25, 0x01	; 1
    1444:	ac 01       	movw	r20, r24
    1446:	24 9f       	mul	r18, r20
    1448:	c0 01       	movw	r24, r0
    144a:	25 9f       	mul	r18, r21
    144c:	90 0d       	add	r25, r0
    144e:	34 9f       	mul	r19, r20
    1450:	90 0d       	add	r25, r0
    1452:	11 24       	eor	r1, r1
    1454:	81 50       	subi	r24, 0x01	; 1
    1456:	9e 4f       	sbci	r25, 0xFE	; 254
    1458:	6f ef       	ldi	r22, 0xFF	; 255
    145a:	73 e0       	ldi	r23, 0x03	; 3
    145c:	0e 94 03 0d 	call	0x1a06	; 0x1a06 <__udivmodhi4>
    1460:	cb 01       	movw	r24, r22

	return result;

}
    1462:	08 95       	ret

00001464 <myInit>:
	//set_sleep_mode(SLEEP_MODE_PWR_DOWN);


	//für dogm display
	//initialize lcd-display
	lcd_init();
    1464:	0e 94 1f 06 	call	0xc3e	; 0xc3e <lcd_init>
	
	
	
	//cpu status led
	DDRA |= (1<<PINA7);
    1468:	d7 9a       	sbi	0x1a, 7	; 26
	PORTA &= ~(1<<PINA7);
    146a:	df 98       	cbi	0x1b, 7	; 27
	
	DDRA |= (1<<PINA0);
    146c:	d0 9a       	sbi	0x1a, 0	; 26
	
	DDRA |= (1<<PINA1);
    146e:	d1 9a       	sbi	0x1a, 1	; 26
	//Enable interrupts for INT0, INT1, INT2	
	//GICR  |= (1<<BIT7) | (1<<BIT6) | (1<<BIT5); 
	GICR |= (1<<BIT5); //only INT2

*/
}
    1470:	08 95       	ret

00001472 <pwmInit>:

#include "pwmInit.h"

void pwmInit(uint16_t compare)
{
	DDRD |= (1<<BIT4) | (1<<BIT5);		//D.4&5 als Ausgänge definieren
    1472:	21 b3       	in	r18, 0x11	; 17
    1474:	20 63       	ori	r18, 0x30	; 48
    1476:	21 bb       	out	0x11, r18	; 17
	
	//PWM, Phase Correct with ICR1 as TOP value
	//TOP: 625
	TCCR1A |= (1<<WGM11);	
    1478:	2f b5       	in	r18, 0x2f	; 47
    147a:	22 60       	ori	r18, 0x02	; 2
    147c:	2f bd       	out	0x2f, r18	; 47
	TCCR1A &= ~(1<<WGM10);	
    147e:	2f b5       	in	r18, 0x2f	; 47
    1480:	2e 7f       	andi	r18, 0xFE	; 254
    1482:	2f bd       	out	0x2f, r18	; 47

	TCCR1B |= (1<<WGM13);
    1484:	2e b5       	in	r18, 0x2e	; 46
    1486:	20 61       	ori	r18, 0x10	; 16
    1488:	2e bd       	out	0x2e, r18	; 46
	TCCR1B &= ~(1<<WGM12);
    148a:	2e b5       	in	r18, 0x2e	; 46
    148c:	27 7f       	andi	r18, 0xF7	; 247
    148e:	2e bd       	out	0x2e, r18	; 46

	ICR1 = 625;
    1490:	21 e7       	ldi	r18, 0x71	; 113
    1492:	32 e0       	ldi	r19, 0x02	; 2
    1494:	37 bd       	out	0x27, r19	; 39
    1496:	26 bd       	out	0x26, r18	; 38
	

	//Nicht invertierende PWM, KanalA -> auf Pin D.5
	//- Clear OC1A/OC1B on Compare Match when up-counting. 
	//- Set OC1A/OC1B on Compare Match when downcounting.
	TCCR1A |= (1<<COM1A1); 	
    1498:	2f b5       	in	r18, 0x2f	; 47
    149a:	20 68       	ori	r18, 0x80	; 128
    149c:	2f bd       	out	0x2f, r18	; 47
	TCCR1A &= ~(1<<COM1A0);
    149e:	2f b5       	in	r18, 0x2f	; 47
    14a0:	2f 7b       	andi	r18, 0xBF	; 191
    14a2:	2f bd       	out	0x2f, r18	; 47

	//Prescaler = 64
	TCCR1B |= (1<<CS10) | (1<<CS11);
    14a4:	2e b5       	in	r18, 0x2e	; 46
    14a6:	23 60       	ori	r18, 0x03	; 3
    14a8:	2e bd       	out	0x2e, r18	; 46
	TCCR1B |= ~(1<<CS12); 
    14aa:	2e b5       	in	r18, 0x2e	; 46
    14ac:	2b 6f       	ori	r18, 0xFB	; 251
    14ae:	2e bd       	out	0x2e, r18	; 46
		1 	1 	0 	Externer Pin 1, negative Flanke
		1 	1 	1 	Externer Pin 1, positive Flanke 
	*/
	
	//OCR1A->16bit register
	OCR1A=compare;	//Vergleichswert laden
    14b0:	9b bd       	out	0x2b, r25	; 43
    14b2:	8a bd       	out	0x2a, r24	; 42
	
	
}
    14b4:	08 95       	ret

000014b6 <pwmUpdate>:


void pwmUpdate(uint16_t compare)
{
	OCR1A=compare;	
    14b6:	9b bd       	out	0x2b, r25	; 43
    14b8:	8a bd       	out	0x2a, r24	; 42
}
    14ba:	08 95       	ret

000014bc <bmp085_readInternalRegister>:
	
	read an internal 16 bit register of the bmp085

************************************************************************************************/
uint16_t bmp085_readInternalRegister(unsigned char registerAddress)
{
    14bc:	0f 93       	push	r16
    14be:	1f 93       	push	r17
    14c0:	df 93       	push	r29
    14c2:	cf 93       	push	r28
    14c4:	00 d0       	rcall	.+0      	; 0x14c6 <bmp085_readInternalRegister+0xa>
    14c6:	cd b7       	in	r28, 0x3d	; 61
    14c8:	de b7       	in	r29, 0x3e	; 62
	uint16_t msb, lsb;
	uint16_t data;
	
	//prepare message for i2c transmission
	//1st byte: -> module address write
	msgBuf[0] = (barometricSensorAddress<<TWI_ADR_BITS) |  (FALSE<<TWI_READ_BIT);
    14ca:	90 91 61 00 	lds	r25, 0x0061
    14ce:	99 0f       	add	r25, r25
    14d0:	99 83       	std	Y+1, r25	; 0x01
	//2nd byte: -> target register´s address for reading
	msgBuf[1] = registerAddress;
    14d2:	8a 83       	std	Y+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( msgBuf, 2 );
    14d4:	8e 01       	movw	r16, r28
    14d6:	0f 5f       	subi	r16, 0xFF	; 255
    14d8:	1f 4f       	sbci	r17, 0xFF	; 255
    14da:	c8 01       	movw	r24, r16
    14dc:	62 e0       	ldi	r22, 0x02	; 2
    14de:	0e 94 98 03 	call	0x730	; 0x730 <TWI_Start_Transceiver_With_Data>
	//-> read the value out of selected register result register
	//-> send an address_write and the register address that should be read
	
	//send a restart condition -> just start a new message
	//1st byte: -> module address read
	msgBuf[0] = (barometricSensorAddress<<TWI_ADR_BITS) |  (TRUE<<TWI_READ_BIT);
    14e2:	80 91 61 00 	lds	r24, 0x0061
    14e6:	90 91 62 00 	lds	r25, 0x0062
    14ea:	88 0f       	add	r24, r24
    14ec:	99 1f       	adc	r25, r25
    14ee:	81 60       	ori	r24, 0x01	; 1
    14f0:	89 83       	std	Y+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( msgBuf, 1 );
    14f2:	c8 01       	movw	r24, r16
    14f4:	61 e0       	ldi	r22, 0x01	; 1
    14f6:	0e 94 98 03 	call	0x730	; 0x730 <TWI_Start_Transceiver_With_Data>

	//the sensor sends first the 8 msb, then the 8 lsb
	TWI_Get_Data_From_Transceiver(msgBuf,2);
    14fa:	c8 01       	movw	r24, r16
    14fc:	62 e0       	ldi	r22, 0x02	; 2
    14fe:	0e 94 c3 03 	call	0x786	; 0x786 <TWI_Get_Data_From_Transceiver>
    1502:	39 81       	ldd	r19, Y+1	; 0x01
    1504:	20 e0       	ldi	r18, 0x00	; 0
    1506:	8a 81       	ldd	r24, Y+2	; 0x02
    1508:	28 0f       	add	r18, r24
    150a:	31 1d       	adc	r19, r1
	while(!Wire.available()); // wait until data available
	msb = Wire.read();
	while(!Wire.available()); // wait until data available
	lsb = Wire.read();
	return (((int)msb<<8) + ((int)lsb));*/
}
    150c:	c9 01       	movw	r24, r18
    150e:	0f 90       	pop	r0
    1510:	0f 90       	pop	r0
    1512:	cf 91       	pop	r28
    1514:	df 91       	pop	r29
    1516:	1f 91       	pop	r17
    1518:	0f 91       	pop	r16
    151a:	08 95       	ret

0000151c <bmp085_readUncompensatedTemp>:
	Reads the uncompensated temperature value out of the bmp085 sensor.
	Uncompensated temperature is a unsigned 16bit value.

************************************************************************************************/
int32_t bmp085_readUncompensatedTemp(void)
{
    151c:	df 93       	push	r29
    151e:	cf 93       	push	r28
    1520:	00 d0       	rcall	.+0      	; 0x1522 <bmp085_readUncompensatedTemp+0x6>
    1522:	cd b7       	in	r28, 0x3d	; 61
    1524:	de b7       	in	r29, 0x3e	; 62
	//-> start temperature measurement -> start the adc conversion
	//-> write 0x2E into the control register (address 0xF4)
	
	//prepare message for i2c transmission
	//1st byte: -> module address write
	msgBuf[0] = (barometricSensorAddress<<TWI_ADR_BITS) |  (FALSE<<TWI_READ_BIT);
    1526:	80 91 61 00 	lds	r24, 0x0061
    152a:	88 0f       	add	r24, r24
    152c:	89 83       	std	Y+1, r24	; 0x01
	//2nd byte: -> target register´s address to write into
	msgBuf[1] = 0xF4;
    152e:	84 ef       	ldi	r24, 0xF4	; 244
    1530:	8a 83       	std	Y+2, r24	; 0x02
	//3rd byte: -> the value that should be written into the register 
	msgBuf[2] = 0x2E;
    1532:	8e e2       	ldi	r24, 0x2E	; 46
    1534:	8b 83       	std	Y+3, r24	; 0x03
	TWI_Start_Transceiver_With_Data( msgBuf, 3 );
    1536:	ce 01       	movw	r24, r28
    1538:	01 96       	adiw	r24, 0x01	; 1
    153a:	63 e0       	ldi	r22, 0x03	; 3
    153c:	0e 94 98 03 	call	0x730	; 0x730 <TWI_Start_Transceiver_With_Data>
    1540:	80 e2       	ldi	r24, 0x20	; 32
    1542:	9e e4       	ldi	r25, 0x4E	; 78
    1544:	01 97       	sbiw	r24, 0x01	; 1
    1546:	f1 f7       	brne	.-4      	; 0x1544 <bmp085_readUncompensatedTemp+0x28>
	
	//wait the sensor conversion time 
	_delay_ms(10);
	
	ut = (int32_t) bmp085_readInternalRegister(0xF6);
    1548:	86 ef       	ldi	r24, 0xF6	; 246
    154a:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <bmp085_readInternalRegister>
    154e:	a0 e0       	ldi	r26, 0x00	; 0
    1550:	b0 e0       	ldi	r27, 0x00	; 0
    1552:	80 93 88 00 	sts	0x0088, r24
    1556:	90 93 89 00 	sts	0x0089, r25
    155a:	a0 93 8a 00 	sts	0x008A, r26
    155e:	b0 93 8b 00 	sts	0x008B, r27
	lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("ut:  "));
	lcd_put_uint(ut);
	while(1);
	*/
	
	return ut;
    1562:	20 91 88 00 	lds	r18, 0x0088
    1566:	30 91 89 00 	lds	r19, 0x0089
    156a:	40 91 8a 00 	lds	r20, 0x008A
    156e:	50 91 8b 00 	lds	r21, 0x008B
	// Wait at least 4.5ms
	delay(5);
	// Read two bytes from registers 0xF6 and 0xF7
	ut = bmp085ReadInt(0xF6);
	return ut;*/	
}
    1572:	b9 01       	movw	r22, r18
    1574:	ca 01       	movw	r24, r20
    1576:	0f 90       	pop	r0
    1578:	0f 90       	pop	r0
    157a:	cf 91       	pop	r28
    157c:	df 91       	pop	r29
    157e:	08 95       	ret

00001580 <bmp085_readTemp>:
	At first the function calls the function to get the uncompensated temperature value.
	Then the calibration coefficients are used to calculate the real temperature value in 

************************************************************************************************/
int32_t bmp085_readTemp(void)
{
    1580:	ef 92       	push	r14
    1582:	ff 92       	push	r15
    1584:	0f 93       	push	r16
    1586:	1f 93       	push	r17
    1588:	df 93       	push	r29
    158a:	cf 93       	push	r28
    158c:	cd b7       	in	r28, 0x3d	; 61
    158e:	de b7       	in	r29, 0x3e	; 62
    1590:	60 97       	sbiw	r28, 0x10	; 16
    1592:	0f b6       	in	r0, 0x3f	; 63
    1594:	f8 94       	cli
    1596:	de bf       	out	0x3e, r29	; 62
    1598:	0f be       	out	0x3f, r0	; 63
    159a:	cd bf       	out	0x3d, r28	; 61
	*/
	//ut=61430;
	
		
	//read uncompensated temperature
	ut = bmp085_readUncompensatedTemp();
    159c:	0e 94 8e 0a 	call	0x151c	; 0x151c <bmp085_readUncompensatedTemp>
    15a0:	60 93 88 00 	sts	0x0088, r22
    15a4:	70 93 89 00 	sts	0x0089, r23
    15a8:	80 93 8a 00 	sts	0x008A, r24
    15ac:	90 93 8b 00 	sts	0x008B, r25
	
	x1 = ((int32_t)ut - ac6) * ac5 >> 15;
    15b0:	60 91 88 00 	lds	r22, 0x0088
    15b4:	70 91 89 00 	lds	r23, 0x0089
    15b8:	80 91 8a 00 	lds	r24, 0x008A
    15bc:	90 91 8b 00 	lds	r25, 0x008B
    15c0:	e0 90 7c 00 	lds	r14, 0x007C
    15c4:	f0 90 7d 00 	lds	r15, 0x007D
    15c8:	20 91 7e 00 	lds	r18, 0x007E
    15cc:	30 91 7f 00 	lds	r19, 0x007F
    15d0:	00 e0       	ldi	r16, 0x00	; 0
    15d2:	10 e0       	ldi	r17, 0x00	; 0
    15d4:	6e 19       	sub	r22, r14
    15d6:	7f 09       	sbc	r23, r15
    15d8:	80 0b       	sbc	r24, r16
    15da:	91 0b       	sbc	r25, r17
    15dc:	40 e0       	ldi	r20, 0x00	; 0
    15de:	50 e0       	ldi	r21, 0x00	; 0
    15e0:	0e 94 e4 0c 	call	0x19c8	; 0x19c8 <__mulsi3>
    15e4:	5f e0       	ldi	r21, 0x0F	; 15
    15e6:	95 95       	asr	r25
    15e8:	87 95       	ror	r24
    15ea:	77 95       	ror	r23
    15ec:	67 95       	ror	r22
    15ee:	5a 95       	dec	r21
    15f0:	d1 f7       	brne	.-12     	; 0x15e6 <bmp085_readTemp+0x66>
    15f2:	69 83       	std	Y+1, r22	; 0x01
    15f4:	7a 83       	std	Y+2, r23	; 0x02
    15f6:	8b 83       	std	Y+3, r24	; 0x03
    15f8:	9c 83       	std	Y+4, r25	; 0x04
	
	x2 = ((int32_t) mc << 11) / (x1 + md);
    15fa:	60 91 86 00 	lds	r22, 0x0086
    15fe:	70 91 87 00 	lds	r23, 0x0087
    1602:	e9 80       	ldd	r14, Y+1	; 0x01
    1604:	fa 80       	ldd	r15, Y+2	; 0x02
    1606:	0b 81       	ldd	r16, Y+3	; 0x03
    1608:	1c 81       	ldd	r17, Y+4	; 0x04
    160a:	20 91 82 00 	lds	r18, 0x0082
    160e:	30 91 83 00 	lds	r19, 0x0083
    1612:	88 27       	eor	r24, r24
    1614:	77 fd       	sbrc	r23, 7
    1616:	80 95       	com	r24
    1618:	98 2f       	mov	r25, r24
    161a:	4b e0       	ldi	r20, 0x0B	; 11
    161c:	66 0f       	add	r22, r22
    161e:	77 1f       	adc	r23, r23
    1620:	88 1f       	adc	r24, r24
    1622:	99 1f       	adc	r25, r25
    1624:	4a 95       	dec	r20
    1626:	d1 f7       	brne	.-12     	; 0x161c <bmp085_readTemp+0x9c>
    1628:	44 27       	eor	r20, r20
    162a:	37 fd       	sbrc	r19, 7
    162c:	40 95       	com	r20
    162e:	54 2f       	mov	r21, r20
    1630:	2e 0d       	add	r18, r14
    1632:	3f 1d       	adc	r19, r15
    1634:	40 1f       	adc	r20, r16
    1636:	51 1f       	adc	r21, r17
    1638:	0e 94 17 0d 	call	0x1a2e	; 0x1a2e <__divmodsi4>
    163c:	c9 01       	movw	r24, r18
    163e:	da 01       	movw	r26, r20
    1640:	8d 83       	std	Y+5, r24	; 0x05
    1642:	9e 83       	std	Y+6, r25	; 0x06
    1644:	af 83       	std	Y+7, r26	; 0x07
    1646:	b8 87       	std	Y+8, r27	; 0x08
	
	b5 = x1 + x2;
    1648:	29 81       	ldd	r18, Y+1	; 0x01
    164a:	3a 81       	ldd	r19, Y+2	; 0x02
    164c:	4b 81       	ldd	r20, Y+3	; 0x03
    164e:	5c 81       	ldd	r21, Y+4	; 0x04
    1650:	8d 81       	ldd	r24, Y+5	; 0x05
    1652:	9e 81       	ldd	r25, Y+6	; 0x06
    1654:	af 81       	ldd	r26, Y+7	; 0x07
    1656:	b8 85       	ldd	r27, Y+8	; 0x08
    1658:	82 0f       	add	r24, r18
    165a:	93 1f       	adc	r25, r19
    165c:	a4 1f       	adc	r26, r20
    165e:	b5 1f       	adc	r27, r21
    1660:	89 87       	std	Y+9, r24	; 0x09
    1662:	9a 87       	std	Y+10, r25	; 0x0a
    1664:	ab 87       	std	Y+11, r26	; 0x0b
    1666:	bc 87       	std	Y+12, r27	; 0x0c
	
	temp=((b5 + 8)>>4);
    1668:	89 85       	ldd	r24, Y+9	; 0x09
    166a:	9a 85       	ldd	r25, Y+10	; 0x0a
    166c:	ab 85       	ldd	r26, Y+11	; 0x0b
    166e:	bc 85       	ldd	r27, Y+12	; 0x0c
    1670:	08 96       	adiw	r24, 0x08	; 8
    1672:	a1 1d       	adc	r26, r1
    1674:	b1 1d       	adc	r27, r1
    1676:	34 e0       	ldi	r19, 0x04	; 4
    1678:	b5 95       	asr	r27
    167a:	a7 95       	ror	r26
    167c:	97 95       	ror	r25
    167e:	87 95       	ror	r24
    1680:	3a 95       	dec	r19
    1682:	d1 f7       	brne	.-12     	; 0x1678 <bmp085_readTemp+0xf8>
    1684:	8d 87       	std	Y+13, r24	; 0x0d
    1686:	9e 87       	std	Y+14, r25	; 0x0e
    1688:	af 87       	std	Y+15, r26	; 0x0f
    168a:	b8 8b       	std	Y+16, r27	; 0x10
	//lcd_put_int(temp);
	
	//while(1);
	
	
	return temp;
    168c:	2d 85       	ldd	r18, Y+13	; 0x0d
    168e:	3e 85       	ldd	r19, Y+14	; 0x0e
    1690:	4f 85       	ldd	r20, Y+15	; 0x0f
    1692:	58 89       	ldd	r21, Y+16	; 0x10
	
}
    1694:	b9 01       	movw	r22, r18
    1696:	ca 01       	movw	r24, r20
    1698:	60 96       	adiw	r28, 0x10	; 16
    169a:	0f b6       	in	r0, 0x3f	; 63
    169c:	f8 94       	cli
    169e:	de bf       	out	0x3e, r29	; 62
    16a0:	0f be       	out	0x3f, r0	; 63
    16a2:	cd bf       	out	0x3d, r28	; 61
    16a4:	cf 91       	pop	r28
    16a6:	df 91       	pop	r29
    16a8:	1f 91       	pop	r17
    16aa:	0f 91       	pop	r16
    16ac:	ff 90       	pop	r15
    16ae:	ef 90       	pop	r14
    16b0:	08 95       	ret

000016b2 <bmp085_getCalibrationData>:

************************************************************************************************/
void  bmp085_getCalibrationData() 
{	

	ac1 = bmp085_readInternalRegister(0xAA);
    16b2:	8a ea       	ldi	r24, 0xAA	; 170
    16b4:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <bmp085_readInternalRegister>
    16b8:	90 93 79 00 	sts	0x0079, r25
    16bc:	80 93 78 00 	sts	0x0078, r24
    16c0:	88 ee       	ldi	r24, 0xE8	; 232
    16c2:	93 e0       	ldi	r25, 0x03	; 3
    16c4:	28 ec       	ldi	r18, 0xC8	; 200
    16c6:	30 e0       	ldi	r19, 0x00	; 0
    16c8:	f9 01       	movw	r30, r18
    16ca:	31 97       	sbiw	r30, 0x01	; 1
    16cc:	f1 f7       	brne	.-4      	; 0x16ca <bmp085_getCalibrationData+0x18>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    16ce:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    16d0:	d9 f7       	brne	.-10     	; 0x16c8 <bmp085_getCalibrationData+0x16>
	
	_delay_ms(100);
	
	ac2 = bmp085_readInternalRegister(0xAC);
    16d2:	8c ea       	ldi	r24, 0xAC	; 172
    16d4:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <bmp085_readInternalRegister>
    16d8:	90 93 81 00 	sts	0x0081, r25
    16dc:	80 93 80 00 	sts	0x0080, r24
    16e0:	88 ee       	ldi	r24, 0xE8	; 232
    16e2:	93 e0       	ldi	r25, 0x03	; 3
    16e4:	28 ec       	ldi	r18, 0xC8	; 200
    16e6:	30 e0       	ldi	r19, 0x00	; 0
    16e8:	f9 01       	movw	r30, r18
    16ea:	31 97       	sbiw	r30, 0x01	; 1
    16ec:	f1 f7       	brne	.-4      	; 0x16ea <bmp085_getCalibrationData+0x38>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    16ee:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    16f0:	d9 f7       	brne	.-10     	; 0x16e8 <bmp085_getCalibrationData+0x36>
	
	_delay_ms(100);

	ac3 = bmp085_readInternalRegister(0xAE);
    16f2:	8e ea       	ldi	r24, 0xAE	; 174
    16f4:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <bmp085_readInternalRegister>
    16f8:	90 93 8d 00 	sts	0x008D, r25
    16fc:	80 93 8c 00 	sts	0x008C, r24
    1700:	88 ee       	ldi	r24, 0xE8	; 232
    1702:	93 e0       	ldi	r25, 0x03	; 3
    1704:	28 ec       	ldi	r18, 0xC8	; 200
    1706:	30 e0       	ldi	r19, 0x00	; 0
    1708:	f9 01       	movw	r30, r18
    170a:	31 97       	sbiw	r30, 0x01	; 1
    170c:	f1 f7       	brne	.-4      	; 0x170a <bmp085_getCalibrationData+0x58>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    170e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1710:	d9 f7       	brne	.-10     	; 0x1708 <bmp085_getCalibrationData+0x56>

	_delay_ms(100);

	ac4 = bmp085_readInternalRegister(0xB0);
    1712:	80 eb       	ldi	r24, 0xB0	; 176
    1714:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <bmp085_readInternalRegister>
    1718:	90 93 85 00 	sts	0x0085, r25
    171c:	80 93 84 00 	sts	0x0084, r24
    1720:	88 ee       	ldi	r24, 0xE8	; 232
    1722:	93 e0       	ldi	r25, 0x03	; 3
    1724:	28 ec       	ldi	r18, 0xC8	; 200
    1726:	30 e0       	ldi	r19, 0x00	; 0
    1728:	f9 01       	movw	r30, r18
    172a:	31 97       	sbiw	r30, 0x01	; 1
    172c:	f1 f7       	brne	.-4      	; 0x172a <bmp085_getCalibrationData+0x78>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    172e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1730:	d9 f7       	brne	.-10     	; 0x1728 <bmp085_getCalibrationData+0x76>

	_delay_ms(100);

	ac5 = bmp085_readInternalRegister(0xB2);
    1732:	82 eb       	ldi	r24, 0xB2	; 178
    1734:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <bmp085_readInternalRegister>
    1738:	90 93 7f 00 	sts	0x007F, r25
    173c:	80 93 7e 00 	sts	0x007E, r24
    1740:	88 ee       	ldi	r24, 0xE8	; 232
    1742:	93 e0       	ldi	r25, 0x03	; 3
    1744:	28 ec       	ldi	r18, 0xC8	; 200
    1746:	30 e0       	ldi	r19, 0x00	; 0
    1748:	f9 01       	movw	r30, r18
    174a:	31 97       	sbiw	r30, 0x01	; 1
    174c:	f1 f7       	brne	.-4      	; 0x174a <bmp085_getCalibrationData+0x98>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    174e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1750:	d9 f7       	brne	.-10     	; 0x1748 <bmp085_getCalibrationData+0x96>

	_delay_ms(100);

	ac6 = bmp085_readInternalRegister(0xB4);
    1752:	84 eb       	ldi	r24, 0xB4	; 180
    1754:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <bmp085_readInternalRegister>
    1758:	90 93 7d 00 	sts	0x007D, r25
    175c:	80 93 7c 00 	sts	0x007C, r24
    1760:	88 ee       	ldi	r24, 0xE8	; 232
    1762:	93 e0       	ldi	r25, 0x03	; 3
    1764:	28 ec       	ldi	r18, 0xC8	; 200
    1766:	30 e0       	ldi	r19, 0x00	; 0
    1768:	f9 01       	movw	r30, r18
    176a:	31 97       	sbiw	r30, 0x01	; 1
    176c:	f1 f7       	brne	.-4      	; 0x176a <bmp085_getCalibrationData+0xb8>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    176e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1770:	d9 f7       	brne	.-10     	; 0x1768 <bmp085_getCalibrationData+0xb6>

	_delay_ms(100);

	b1 = bmp085_readInternalRegister(0xB6);
    1772:	86 eb       	ldi	r24, 0xB6	; 182
    1774:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <bmp085_readInternalRegister>
    1778:	90 93 7b 00 	sts	0x007B, r25
    177c:	80 93 7a 00 	sts	0x007A, r24
    1780:	88 ee       	ldi	r24, 0xE8	; 232
    1782:	93 e0       	ldi	r25, 0x03	; 3
    1784:	28 ec       	ldi	r18, 0xC8	; 200
    1786:	30 e0       	ldi	r19, 0x00	; 0
    1788:	f9 01       	movw	r30, r18
    178a:	31 97       	sbiw	r30, 0x01	; 1
    178c:	f1 f7       	brne	.-4      	; 0x178a <bmp085_getCalibrationData+0xd8>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    178e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1790:	d9 f7       	brne	.-10     	; 0x1788 <bmp085_getCalibrationData+0xd6>

	_delay_ms(100);

	b2 = bmp085_readInternalRegister(0xB8);
    1792:	88 eb       	ldi	r24, 0xB8	; 184
    1794:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <bmp085_readInternalRegister>
    1798:	90 93 75 00 	sts	0x0075, r25
    179c:	80 93 74 00 	sts	0x0074, r24
    17a0:	88 ee       	ldi	r24, 0xE8	; 232
    17a2:	93 e0       	ldi	r25, 0x03	; 3
    17a4:	28 ec       	ldi	r18, 0xC8	; 200
    17a6:	30 e0       	ldi	r19, 0x00	; 0
    17a8:	f9 01       	movw	r30, r18
    17aa:	31 97       	sbiw	r30, 0x01	; 1
    17ac:	f1 f7       	brne	.-4      	; 0x17aa <bmp085_getCalibrationData+0xf8>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    17ae:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    17b0:	d9 f7       	brne	.-10     	; 0x17a8 <bmp085_getCalibrationData+0xf6>

	_delay_ms(100);

	mb = bmp085_readInternalRegister(0xBA);
    17b2:	8a eb       	ldi	r24, 0xBA	; 186
    17b4:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <bmp085_readInternalRegister>
    17b8:	90 93 77 00 	sts	0x0077, r25
    17bc:	80 93 76 00 	sts	0x0076, r24
    17c0:	88 ee       	ldi	r24, 0xE8	; 232
    17c2:	93 e0       	ldi	r25, 0x03	; 3
    17c4:	28 ec       	ldi	r18, 0xC8	; 200
    17c6:	30 e0       	ldi	r19, 0x00	; 0
    17c8:	f9 01       	movw	r30, r18
    17ca:	31 97       	sbiw	r30, 0x01	; 1
    17cc:	f1 f7       	brne	.-4      	; 0x17ca <bmp085_getCalibrationData+0x118>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    17ce:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    17d0:	d9 f7       	brne	.-10     	; 0x17c8 <bmp085_getCalibrationData+0x116>

	_delay_ms(100);

	mc = bmp085_readInternalRegister(0xBC);
    17d2:	8c eb       	ldi	r24, 0xBC	; 188
    17d4:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <bmp085_readInternalRegister>
    17d8:	90 93 87 00 	sts	0x0087, r25
    17dc:	80 93 86 00 	sts	0x0086, r24
    17e0:	88 ee       	ldi	r24, 0xE8	; 232
    17e2:	93 e0       	ldi	r25, 0x03	; 3
    17e4:	28 ec       	ldi	r18, 0xC8	; 200
    17e6:	30 e0       	ldi	r19, 0x00	; 0
    17e8:	f9 01       	movw	r30, r18
    17ea:	31 97       	sbiw	r30, 0x01	; 1
    17ec:	f1 f7       	brne	.-4      	; 0x17ea <bmp085_getCalibrationData+0x138>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    17ee:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    17f0:	d9 f7       	brne	.-10     	; 0x17e8 <bmp085_getCalibrationData+0x136>

	_delay_ms(100);

	md = bmp085_readInternalRegister(0xBE);
    17f2:	8e eb       	ldi	r24, 0xBE	; 190
    17f4:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <bmp085_readInternalRegister>
    17f8:	90 93 83 00 	sts	0x0083, r25
    17fc:	80 93 82 00 	sts	0x0082, r24

}
    1800:	08 95       	ret

00001802 <bmp085_setupSensor>:
		Initialisation for the barometric sensor bmp085.

************************************************************************************************/
void bmp085_setupSensor()
{    
	bmp085_getCalibrationData();
    1802:	0e 94 59 0b 	call	0x16b2	; 0x16b2 <bmp085_getCalibrationData>
}
    1806:	08 95       	ret

00001808 <bmp085_displayCalibrationData>:
		the bmp085 sensor without jtag debugger hardware.
		Therefore all calibration values are displayed in an infinite loop on the lcd.

************************************************************************************************/
void bmp085_displayCalibrationData(void)
{
    1808:	cf 93       	push	r28
    180a:	df 93       	push	r29
    180c:	c8 ec       	ldi	r28, 0xC8	; 200
    180e:	d0 e0       	ldi	r29, 0x00	; 0
	while(1)
	{
		lcd_moveto_xy  (0, 0);		
    1810:	80 e0       	ldi	r24, 0x00	; 0
    1812:	60 e0       	ldi	r22, 0x00	; 0
    1814:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
		lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("ac1: "));
    1818:	84 e5       	ldi	r24, 0x54	; 84
    181a:	96 e0       	ldi	r25, 0x06	; 6
    181c:	60 e0       	ldi	r22, 0x00	; 0
    181e:	48 ea       	ldi	r20, 0xA8	; 168
    1820:	56 e0       	ldi	r21, 0x06	; 6
    1822:	0e 94 91 09 	call	0x1322	; 0x1322 <lcd_put_string_P>
		lcd_put_int(ac1);
    1826:	80 91 78 00 	lds	r24, 0x0078
    182a:	90 91 79 00 	lds	r25, 0x0079
    182e:	0e 94 37 09 	call	0x126e	; 0x126e <lcd_put_int>
		lcd_moveto_xy  (1, 0);
    1832:	81 e0       	ldi	r24, 0x01	; 1
    1834:	60 e0       	ldi	r22, 0x00	; 0
    1836:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
		lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("ac2: "));		
    183a:	84 e5       	ldi	r24, 0x54	; 84
    183c:	96 e0       	ldi	r25, 0x06	; 6
    183e:	60 e0       	ldi	r22, 0x00	; 0
    1840:	42 ea       	ldi	r20, 0xA2	; 162
    1842:	56 e0       	ldi	r21, 0x06	; 6
    1844:	0e 94 91 09 	call	0x1322	; 0x1322 <lcd_put_string_P>
		lcd_put_int(ac2);
    1848:	80 91 80 00 	lds	r24, 0x0080
    184c:	90 91 81 00 	lds	r25, 0x0081
    1850:	0e 94 37 09 	call	0x126e	; 0x126e <lcd_put_int>
		lcd_moveto_xy  (2, 0);
    1854:	82 e0       	ldi	r24, 0x02	; 2
    1856:	60 e0       	ldi	r22, 0x00	; 0
    1858:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
		lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("ac3: "));		
    185c:	84 e5       	ldi	r24, 0x54	; 84
    185e:	96 e0       	ldi	r25, 0x06	; 6
    1860:	60 e0       	ldi	r22, 0x00	; 0
    1862:	4c e9       	ldi	r20, 0x9C	; 156
    1864:	56 e0       	ldi	r21, 0x06	; 6
    1866:	0e 94 91 09 	call	0x1322	; 0x1322 <lcd_put_string_P>
		lcd_put_int(ac3);
    186a:	80 91 8c 00 	lds	r24, 0x008C
    186e:	90 91 8d 00 	lds	r25, 0x008D
    1872:	0e 94 37 09 	call	0x126e	; 0x126e <lcd_put_int>
		lcd_moveto_xy  (3, 0);
    1876:	83 e0       	ldi	r24, 0x03	; 3
    1878:	60 e0       	ldi	r22, 0x00	; 0
    187a:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
		lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("ac4: "));		
    187e:	84 e5       	ldi	r24, 0x54	; 84
    1880:	96 e0       	ldi	r25, 0x06	; 6
    1882:	60 e0       	ldi	r22, 0x00	; 0
    1884:	46 e9       	ldi	r20, 0x96	; 150
    1886:	56 e0       	ldi	r21, 0x06	; 6
    1888:	0e 94 91 09 	call	0x1322	; 0x1322 <lcd_put_string_P>
		lcd_put_uint(ac4);
    188c:	80 91 84 00 	lds	r24, 0x0084
    1890:	90 91 85 00 	lds	r25, 0x0085
    1894:	0e 94 0f 09 	call	0x121e	; 0x121e <lcd_put_uint>
    1898:	80 e6       	ldi	r24, 0x60	; 96
    189a:	9a ee       	ldi	r25, 0xEA	; 234
    189c:	fe 01       	movw	r30, r28
    189e:	31 97       	sbiw	r30, 0x01	; 1
    18a0:	f1 f7       	brne	.-4      	; 0x189e <bmp085_displayCalibrationData+0x96>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    18a2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    18a4:	d9 f7       	brne	.-10     	; 0x189c <bmp085_displayCalibrationData+0x94>
		
		_delay_ms(6000);
		
		lcd_moveto_xy  (0, 0);		
    18a6:	80 e0       	ldi	r24, 0x00	; 0
    18a8:	60 e0       	ldi	r22, 0x00	; 0
    18aa:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
		lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("ac5: "));
    18ae:	84 e5       	ldi	r24, 0x54	; 84
    18b0:	96 e0       	ldi	r25, 0x06	; 6
    18b2:	60 e0       	ldi	r22, 0x00	; 0
    18b4:	40 e9       	ldi	r20, 0x90	; 144
    18b6:	56 e0       	ldi	r21, 0x06	; 6
    18b8:	0e 94 91 09 	call	0x1322	; 0x1322 <lcd_put_string_P>
		lcd_put_uint(ac5);
    18bc:	80 91 7e 00 	lds	r24, 0x007E
    18c0:	90 91 7f 00 	lds	r25, 0x007F
    18c4:	0e 94 0f 09 	call	0x121e	; 0x121e <lcd_put_uint>
		lcd_moveto_xy  (1, 0);
    18c8:	81 e0       	ldi	r24, 0x01	; 1
    18ca:	60 e0       	ldi	r22, 0x00	; 0
    18cc:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
		lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("ac6: "));		
    18d0:	84 e5       	ldi	r24, 0x54	; 84
    18d2:	96 e0       	ldi	r25, 0x06	; 6
    18d4:	60 e0       	ldi	r22, 0x00	; 0
    18d6:	4a e8       	ldi	r20, 0x8A	; 138
    18d8:	56 e0       	ldi	r21, 0x06	; 6
    18da:	0e 94 91 09 	call	0x1322	; 0x1322 <lcd_put_string_P>
		lcd_put_uint(ac6);
    18de:	80 91 7c 00 	lds	r24, 0x007C
    18e2:	90 91 7d 00 	lds	r25, 0x007D
    18e6:	0e 94 0f 09 	call	0x121e	; 0x121e <lcd_put_uint>
		lcd_moveto_xy  (2, 0);
    18ea:	82 e0       	ldi	r24, 0x02	; 2
    18ec:	60 e0       	ldi	r22, 0x00	; 0
    18ee:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
		lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("b1:  "));		
    18f2:	84 e5       	ldi	r24, 0x54	; 84
    18f4:	96 e0       	ldi	r25, 0x06	; 6
    18f6:	60 e0       	ldi	r22, 0x00	; 0
    18f8:	44 e8       	ldi	r20, 0x84	; 132
    18fa:	56 e0       	ldi	r21, 0x06	; 6
    18fc:	0e 94 91 09 	call	0x1322	; 0x1322 <lcd_put_string_P>
		lcd_put_int(b1);
    1900:	80 91 7a 00 	lds	r24, 0x007A
    1904:	90 91 7b 00 	lds	r25, 0x007B
    1908:	0e 94 37 09 	call	0x126e	; 0x126e <lcd_put_int>
		lcd_moveto_xy  (3, 0);
    190c:	83 e0       	ldi	r24, 0x03	; 3
    190e:	60 e0       	ldi	r22, 0x00	; 0
    1910:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
		lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("b2:  "));		
    1914:	84 e5       	ldi	r24, 0x54	; 84
    1916:	96 e0       	ldi	r25, 0x06	; 6
    1918:	60 e0       	ldi	r22, 0x00	; 0
    191a:	4e e7       	ldi	r20, 0x7E	; 126
    191c:	56 e0       	ldi	r21, 0x06	; 6
    191e:	0e 94 91 09 	call	0x1322	; 0x1322 <lcd_put_string_P>
		lcd_put_int(b2);
    1922:	80 91 74 00 	lds	r24, 0x0074
    1926:	90 91 75 00 	lds	r25, 0x0075
    192a:	0e 94 37 09 	call	0x126e	; 0x126e <lcd_put_int>
    192e:	80 e6       	ldi	r24, 0x60	; 96
    1930:	9a ee       	ldi	r25, 0xEA	; 234
    1932:	fe 01       	movw	r30, r28
    1934:	31 97       	sbiw	r30, 0x01	; 1
    1936:	f1 f7       	brne	.-4      	; 0x1934 <bmp085_displayCalibrationData+0x12c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1938:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    193a:	d9 f7       	brne	.-10     	; 0x1932 <bmp085_displayCalibrationData+0x12a>
		
		_delay_ms(6000);
				
		lcd_moveto_xy  (0, 0);		
    193c:	80 e0       	ldi	r24, 0x00	; 0
    193e:	60 e0       	ldi	r22, 0x00	; 0
    1940:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
		lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("mb:  "));
    1944:	84 e5       	ldi	r24, 0x54	; 84
    1946:	96 e0       	ldi	r25, 0x06	; 6
    1948:	60 e0       	ldi	r22, 0x00	; 0
    194a:	48 e7       	ldi	r20, 0x78	; 120
    194c:	56 e0       	ldi	r21, 0x06	; 6
    194e:	0e 94 91 09 	call	0x1322	; 0x1322 <lcd_put_string_P>
		lcd_put_int(mb);
    1952:	80 91 76 00 	lds	r24, 0x0076
    1956:	90 91 77 00 	lds	r25, 0x0077
    195a:	0e 94 37 09 	call	0x126e	; 0x126e <lcd_put_int>
		lcd_moveto_xy  (1, 0);
    195e:	81 e0       	ldi	r24, 0x01	; 1
    1960:	60 e0       	ldi	r22, 0x00	; 0
    1962:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
		lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("mc:  "));		
    1966:	84 e5       	ldi	r24, 0x54	; 84
    1968:	96 e0       	ldi	r25, 0x06	; 6
    196a:	60 e0       	ldi	r22, 0x00	; 0
    196c:	42 e7       	ldi	r20, 0x72	; 114
    196e:	56 e0       	ldi	r21, 0x06	; 6
    1970:	0e 94 91 09 	call	0x1322	; 0x1322 <lcd_put_string_P>
		lcd_put_int(mc);
    1974:	80 91 86 00 	lds	r24, 0x0086
    1978:	90 91 87 00 	lds	r25, 0x0087
    197c:	0e 94 37 09 	call	0x126e	; 0x126e <lcd_put_int>
		lcd_moveto_xy  (2, 0);
    1980:	82 e0       	ldi	r24, 0x02	; 2
    1982:	60 e0       	ldi	r22, 0x00	; 0
    1984:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
		lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("md:  "));		
    1988:	84 e5       	ldi	r24, 0x54	; 84
    198a:	96 e0       	ldi	r25, 0x06	; 6
    198c:	60 e0       	ldi	r22, 0x00	; 0
    198e:	4c e6       	ldi	r20, 0x6C	; 108
    1990:	56 e0       	ldi	r21, 0x06	; 6
    1992:	0e 94 91 09 	call	0x1322	; 0x1322 <lcd_put_string_P>
		lcd_put_int(md);
    1996:	80 91 82 00 	lds	r24, 0x0082
    199a:	90 91 83 00 	lds	r25, 0x0083
    199e:	0e 94 37 09 	call	0x126e	; 0x126e <lcd_put_int>
		lcd_moveto_xy  (3, 0);
    19a2:	83 e0       	ldi	r24, 0x03	; 3
    19a4:	60 e0       	ldi	r22, 0x00	; 0
    19a6:	0e 94 88 04 	call	0x910	; 0x910 <lcd_moveto_xy>
		lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("last one     "));		
    19aa:	84 e5       	ldi	r24, 0x54	; 84
    19ac:	96 e0       	ldi	r25, 0x06	; 6
    19ae:	60 e0       	ldi	r22, 0x00	; 0
    19b0:	4e e5       	ldi	r20, 0x5E	; 94
    19b2:	56 e0       	ldi	r21, 0x06	; 6
    19b4:	0e 94 91 09 	call	0x1322	; 0x1322 <lcd_put_string_P>
    19b8:	80 e6       	ldi	r24, 0x60	; 96
    19ba:	9a ee       	ldi	r25, 0xEA	; 234
    19bc:	fe 01       	movw	r30, r28
    19be:	31 97       	sbiw	r30, 0x01	; 1
    19c0:	f1 f7       	brne	.-4      	; 0x19be <bmp085_displayCalibrationData+0x1b6>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    19c2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    19c4:	d9 f7       	brne	.-10     	; 0x19bc <bmp085_displayCalibrationData+0x1b4>
    19c6:	24 cf       	rjmp	.-440    	; 0x1810 <bmp085_displayCalibrationData+0x8>

000019c8 <__mulsi3>:
    19c8:	62 9f       	mul	r22, r18
    19ca:	d0 01       	movw	r26, r0
    19cc:	73 9f       	mul	r23, r19
    19ce:	f0 01       	movw	r30, r0
    19d0:	82 9f       	mul	r24, r18
    19d2:	e0 0d       	add	r30, r0
    19d4:	f1 1d       	adc	r31, r1
    19d6:	64 9f       	mul	r22, r20
    19d8:	e0 0d       	add	r30, r0
    19da:	f1 1d       	adc	r31, r1
    19dc:	92 9f       	mul	r25, r18
    19de:	f0 0d       	add	r31, r0
    19e0:	83 9f       	mul	r24, r19
    19e2:	f0 0d       	add	r31, r0
    19e4:	74 9f       	mul	r23, r20
    19e6:	f0 0d       	add	r31, r0
    19e8:	65 9f       	mul	r22, r21
    19ea:	f0 0d       	add	r31, r0
    19ec:	99 27       	eor	r25, r25
    19ee:	72 9f       	mul	r23, r18
    19f0:	b0 0d       	add	r27, r0
    19f2:	e1 1d       	adc	r30, r1
    19f4:	f9 1f       	adc	r31, r25
    19f6:	63 9f       	mul	r22, r19
    19f8:	b0 0d       	add	r27, r0
    19fa:	e1 1d       	adc	r30, r1
    19fc:	f9 1f       	adc	r31, r25
    19fe:	bd 01       	movw	r22, r26
    1a00:	cf 01       	movw	r24, r30
    1a02:	11 24       	eor	r1, r1
    1a04:	08 95       	ret

00001a06 <__udivmodhi4>:
    1a06:	aa 1b       	sub	r26, r26
    1a08:	bb 1b       	sub	r27, r27
    1a0a:	51 e1       	ldi	r21, 0x11	; 17
    1a0c:	07 c0       	rjmp	.+14     	; 0x1a1c <__udivmodhi4_ep>

00001a0e <__udivmodhi4_loop>:
    1a0e:	aa 1f       	adc	r26, r26
    1a10:	bb 1f       	adc	r27, r27
    1a12:	a6 17       	cp	r26, r22
    1a14:	b7 07       	cpc	r27, r23
    1a16:	10 f0       	brcs	.+4      	; 0x1a1c <__udivmodhi4_ep>
    1a18:	a6 1b       	sub	r26, r22
    1a1a:	b7 0b       	sbc	r27, r23

00001a1c <__udivmodhi4_ep>:
    1a1c:	88 1f       	adc	r24, r24
    1a1e:	99 1f       	adc	r25, r25
    1a20:	5a 95       	dec	r21
    1a22:	a9 f7       	brne	.-22     	; 0x1a0e <__udivmodhi4_loop>
    1a24:	80 95       	com	r24
    1a26:	90 95       	com	r25
    1a28:	bc 01       	movw	r22, r24
    1a2a:	cd 01       	movw	r24, r26
    1a2c:	08 95       	ret

00001a2e <__divmodsi4>:
    1a2e:	97 fb       	bst	r25, 7
    1a30:	09 2e       	mov	r0, r25
    1a32:	05 26       	eor	r0, r21
    1a34:	0e d0       	rcall	.+28     	; 0x1a52 <__divmodsi4_neg1>
    1a36:	57 fd       	sbrc	r21, 7
    1a38:	04 d0       	rcall	.+8      	; 0x1a42 <__divmodsi4_neg2>
    1a3a:	14 d0       	rcall	.+40     	; 0x1a64 <__udivmodsi4>
    1a3c:	0a d0       	rcall	.+20     	; 0x1a52 <__divmodsi4_neg1>
    1a3e:	00 1c       	adc	r0, r0
    1a40:	38 f4       	brcc	.+14     	; 0x1a50 <__divmodsi4_exit>

00001a42 <__divmodsi4_neg2>:
    1a42:	50 95       	com	r21
    1a44:	40 95       	com	r20
    1a46:	30 95       	com	r19
    1a48:	21 95       	neg	r18
    1a4a:	3f 4f       	sbci	r19, 0xFF	; 255
    1a4c:	4f 4f       	sbci	r20, 0xFF	; 255
    1a4e:	5f 4f       	sbci	r21, 0xFF	; 255

00001a50 <__divmodsi4_exit>:
    1a50:	08 95       	ret

00001a52 <__divmodsi4_neg1>:
    1a52:	f6 f7       	brtc	.-4      	; 0x1a50 <__divmodsi4_exit>
    1a54:	90 95       	com	r25
    1a56:	80 95       	com	r24
    1a58:	70 95       	com	r23
    1a5a:	61 95       	neg	r22
    1a5c:	7f 4f       	sbci	r23, 0xFF	; 255
    1a5e:	8f 4f       	sbci	r24, 0xFF	; 255
    1a60:	9f 4f       	sbci	r25, 0xFF	; 255
    1a62:	08 95       	ret

00001a64 <__udivmodsi4>:
    1a64:	a1 e2       	ldi	r26, 0x21	; 33
    1a66:	1a 2e       	mov	r1, r26
    1a68:	aa 1b       	sub	r26, r26
    1a6a:	bb 1b       	sub	r27, r27
    1a6c:	fd 01       	movw	r30, r26
    1a6e:	0d c0       	rjmp	.+26     	; 0x1a8a <__udivmodsi4_ep>

00001a70 <__udivmodsi4_loop>:
    1a70:	aa 1f       	adc	r26, r26
    1a72:	bb 1f       	adc	r27, r27
    1a74:	ee 1f       	adc	r30, r30
    1a76:	ff 1f       	adc	r31, r31
    1a78:	a2 17       	cp	r26, r18
    1a7a:	b3 07       	cpc	r27, r19
    1a7c:	e4 07       	cpc	r30, r20
    1a7e:	f5 07       	cpc	r31, r21
    1a80:	20 f0       	brcs	.+8      	; 0x1a8a <__udivmodsi4_ep>
    1a82:	a2 1b       	sub	r26, r18
    1a84:	b3 0b       	sbc	r27, r19
    1a86:	e4 0b       	sbc	r30, r20
    1a88:	f5 0b       	sbc	r31, r21

00001a8a <__udivmodsi4_ep>:
    1a8a:	66 1f       	adc	r22, r22
    1a8c:	77 1f       	adc	r23, r23
    1a8e:	88 1f       	adc	r24, r24
    1a90:	99 1f       	adc	r25, r25
    1a92:	1a 94       	dec	r1
    1a94:	69 f7       	brne	.-38     	; 0x1a70 <__udivmodsi4_loop>
    1a96:	60 95       	com	r22
    1a98:	70 95       	com	r23
    1a9a:	80 95       	com	r24
    1a9c:	90 95       	com	r25
    1a9e:	9b 01       	movw	r18, r22
    1aa0:	ac 01       	movw	r20, r24
    1aa2:	bd 01       	movw	r22, r26
    1aa4:	cf 01       	movw	r24, r30
    1aa6:	08 95       	ret

00001aa8 <itoa>:
    1aa8:	fb 01       	movw	r30, r22
    1aaa:	9f 01       	movw	r18, r30
    1aac:	e8 94       	clt
    1aae:	42 30       	cpi	r20, 0x02	; 2
    1ab0:	c4 f0       	brlt	.+48     	; 0x1ae2 <itoa+0x3a>
    1ab2:	45 32       	cpi	r20, 0x25	; 37
    1ab4:	b4 f4       	brge	.+44     	; 0x1ae2 <itoa+0x3a>
    1ab6:	4a 30       	cpi	r20, 0x0A	; 10
    1ab8:	29 f4       	brne	.+10     	; 0x1ac4 <itoa+0x1c>
    1aba:	97 fb       	bst	r25, 7
    1abc:	1e f4       	brtc	.+6      	; 0x1ac4 <itoa+0x1c>
    1abe:	90 95       	com	r25
    1ac0:	81 95       	neg	r24
    1ac2:	9f 4f       	sbci	r25, 0xFF	; 255
    1ac4:	64 2f       	mov	r22, r20
    1ac6:	77 27       	eor	r23, r23
    1ac8:	0e 94 03 0d 	call	0x1a06	; 0x1a06 <__udivmodhi4>
    1acc:	80 5d       	subi	r24, 0xD0	; 208
    1ace:	8a 33       	cpi	r24, 0x3A	; 58
    1ad0:	0c f0       	brlt	.+2      	; 0x1ad4 <itoa+0x2c>
    1ad2:	89 5d       	subi	r24, 0xD9	; 217
    1ad4:	81 93       	st	Z+, r24
    1ad6:	cb 01       	movw	r24, r22
    1ad8:	00 97       	sbiw	r24, 0x00	; 0
    1ada:	a1 f7       	brne	.-24     	; 0x1ac4 <itoa+0x1c>
    1adc:	16 f4       	brtc	.+4      	; 0x1ae2 <itoa+0x3a>
    1ade:	5d e2       	ldi	r21, 0x2D	; 45
    1ae0:	51 93       	st	Z+, r21
    1ae2:	10 82       	st	Z, r1
    1ae4:	c9 01       	movw	r24, r18
    1ae6:	0c 94 bf 0d 	jmp	0x1b7e	; 0x1b7e <strrev>

00001aea <ltoa>:
    1aea:	fa 01       	movw	r30, r20
    1aec:	cf 93       	push	r28
    1aee:	ff 93       	push	r31
    1af0:	ef 93       	push	r30
    1af2:	22 30       	cpi	r18, 0x02	; 2
    1af4:	44 f1       	brlt	.+80     	; 0x1b46 <ltoa+0x5c>
    1af6:	25 32       	cpi	r18, 0x25	; 37
    1af8:	34 f5       	brge	.+76     	; 0x1b46 <ltoa+0x5c>
    1afa:	c2 2f       	mov	r28, r18
    1afc:	e8 94       	clt
    1afe:	ca 30       	cpi	r28, 0x0A	; 10
    1b00:	49 f4       	brne	.+18     	; 0x1b14 <ltoa+0x2a>
    1b02:	97 fb       	bst	r25, 7
    1b04:	3e f4       	brtc	.+14     	; 0x1b14 <ltoa+0x2a>
    1b06:	90 95       	com	r25
    1b08:	80 95       	com	r24
    1b0a:	70 95       	com	r23
    1b0c:	61 95       	neg	r22
    1b0e:	7f 4f       	sbci	r23, 0xFF	; 255
    1b10:	8f 4f       	sbci	r24, 0xFF	; 255
    1b12:	9f 4f       	sbci	r25, 0xFF	; 255
    1b14:	2c 2f       	mov	r18, r28
    1b16:	33 27       	eor	r19, r19
    1b18:	44 27       	eor	r20, r20
    1b1a:	55 27       	eor	r21, r21
    1b1c:	ff 93       	push	r31
    1b1e:	ef 93       	push	r30
    1b20:	0e 94 32 0d 	call	0x1a64	; 0x1a64 <__udivmodsi4>
    1b24:	ef 91       	pop	r30
    1b26:	ff 91       	pop	r31
    1b28:	60 5d       	subi	r22, 0xD0	; 208
    1b2a:	6a 33       	cpi	r22, 0x3A	; 58
    1b2c:	0c f0       	brlt	.+2      	; 0x1b30 <ltoa+0x46>
    1b2e:	69 5d       	subi	r22, 0xD9	; 217
    1b30:	61 93       	st	Z+, r22
    1b32:	b9 01       	movw	r22, r18
    1b34:	ca 01       	movw	r24, r20
    1b36:	60 50       	subi	r22, 0x00	; 0
    1b38:	70 40       	sbci	r23, 0x00	; 0
    1b3a:	80 40       	sbci	r24, 0x00	; 0
    1b3c:	90 40       	sbci	r25, 0x00	; 0
    1b3e:	51 f7       	brne	.-44     	; 0x1b14 <ltoa+0x2a>
    1b40:	16 f4       	brtc	.+4      	; 0x1b46 <ltoa+0x5c>
    1b42:	cd e2       	ldi	r28, 0x2D	; 45
    1b44:	c1 93       	st	Z+, r28
    1b46:	10 82       	st	Z, r1
    1b48:	8f 91       	pop	r24
    1b4a:	9f 91       	pop	r25
    1b4c:	cf 91       	pop	r28
    1b4e:	0c 94 bf 0d 	jmp	0x1b7e	; 0x1b7e <strrev>

00001b52 <utoa>:
    1b52:	fb 01       	movw	r30, r22
    1b54:	9f 01       	movw	r18, r30
    1b56:	42 30       	cpi	r20, 0x02	; 2
    1b58:	74 f0       	brlt	.+28     	; 0x1b76 <utoa+0x24>
    1b5a:	45 32       	cpi	r20, 0x25	; 37
    1b5c:	64 f4       	brge	.+24     	; 0x1b76 <utoa+0x24>
    1b5e:	64 2f       	mov	r22, r20
    1b60:	77 27       	eor	r23, r23
    1b62:	0e 94 03 0d 	call	0x1a06	; 0x1a06 <__udivmodhi4>
    1b66:	80 5d       	subi	r24, 0xD0	; 208
    1b68:	8a 33       	cpi	r24, 0x3A	; 58
    1b6a:	0c f0       	brlt	.+2      	; 0x1b6e <utoa+0x1c>
    1b6c:	89 5d       	subi	r24, 0xD9	; 217
    1b6e:	81 93       	st	Z+, r24
    1b70:	cb 01       	movw	r24, r22
    1b72:	00 97       	sbiw	r24, 0x00	; 0
    1b74:	a1 f7       	brne	.-24     	; 0x1b5e <utoa+0xc>
    1b76:	10 82       	st	Z, r1
    1b78:	c9 01       	movw	r24, r18
    1b7a:	0c 94 bf 0d 	jmp	0x1b7e	; 0x1b7e <strrev>

00001b7e <strrev>:
    1b7e:	dc 01       	movw	r26, r24
    1b80:	fc 01       	movw	r30, r24
    1b82:	67 2f       	mov	r22, r23
    1b84:	71 91       	ld	r23, Z+
    1b86:	77 23       	and	r23, r23
    1b88:	e1 f7       	brne	.-8      	; 0x1b82 <strrev+0x4>
    1b8a:	32 97       	sbiw	r30, 0x02	; 2
    1b8c:	04 c0       	rjmp	.+8      	; 0x1b96 <strrev+0x18>
    1b8e:	7c 91       	ld	r23, X
    1b90:	6d 93       	st	X+, r22
    1b92:	70 83       	st	Z, r23
    1b94:	62 91       	ld	r22, -Z
    1b96:	ae 17       	cp	r26, r30
    1b98:	bf 07       	cpc	r27, r31
    1b9a:	c8 f3       	brcs	.-14     	; 0x1b8e <strrev+0x10>
    1b9c:	08 95       	ret

00001b9e <_exit>:
    1b9e:	f8 94       	cli

00001ba0 <__stop_program>:
    1ba0:	ff cf       	rjmp	.-2      	; 0x1ba0 <__stop_program>
