
femtoOsTest.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002004  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000008  00800060  00002004  00002098  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000000a8  00800068  00800068  000020a0  2**0
                  ALLOC
  3 .stab         00000d14  00000000  00000000  000020a0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000219  00000000  00000000  00002db4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000180  00000000  00000000  00002fcd  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000830  00000000  00000000  0000314d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000406f  00000000  00000000  0000397d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001208  00000000  00000000  000079ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002d6e  00000000  00000000  00008bf4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000590  00000000  00000000  0000b964  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000e9f  00000000  00000000  0000bef4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000028e0  00000000  00000000  0000cd93  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 000004bd  00000000  00000000  0000f673  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00000178  00000000  00000000  0000fb30  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 45 03 	jmp	0x68a	; 0x68a <__ctors_end>
       4:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__vector_1>
       8:	0c 94 74 04 	jmp	0x8e8	; 0x8e8 <__vector_2>
       c:	0c 94 7e 04 	jmp	0x8fc	; 0x8fc <__vector_3>
      10:	0c 94 62 03 	jmp	0x6c4	; 0x6c4 <__bad_interrupt>
      14:	0c 94 62 03 	jmp	0x6c4	; 0x6c4 <__bad_interrupt>
      18:	0c 94 62 03 	jmp	0x6c4	; 0x6c4 <__bad_interrupt>
      1c:	0c 94 62 03 	jmp	0x6c4	; 0x6c4 <__bad_interrupt>
      20:	0c 94 62 03 	jmp	0x6c4	; 0x6c4 <__bad_interrupt>
      24:	0c 94 62 03 	jmp	0x6c4	; 0x6c4 <__bad_interrupt>
      28:	0c 94 55 0d 	jmp	0x1aaa	; 0x1aaa <__vector_10>
      2c:	0c 94 62 03 	jmp	0x6c4	; 0x6c4 <__bad_interrupt>
      30:	0c 94 62 03 	jmp	0x6c4	; 0x6c4 <__bad_interrupt>
      34:	0c 94 62 03 	jmp	0x6c4	; 0x6c4 <__bad_interrupt>
      38:	0c 94 62 03 	jmp	0x6c4	; 0x6c4 <__bad_interrupt>
      3c:	0c 94 62 03 	jmp	0x6c4	; 0x6c4 <__bad_interrupt>
      40:	0c 94 62 03 	jmp	0x6c4	; 0x6c4 <__bad_interrupt>
      44:	0c 94 62 03 	jmp	0x6c4	; 0x6c4 <__bad_interrupt>
      48:	0c 94 62 03 	jmp	0x6c4	; 0x6c4 <__bad_interrupt>
      4c:	0c 94 d0 0e 	jmp	0x1da0	; 0x1da0 <__vector_19>
      50:	0c 94 62 03 	jmp	0x6c4	; 0x6c4 <__bad_interrupt>

00000054 <HelloWorldStr>:
      54:	48 65 6c 6c 6f 20 57 6f 72 6c 64 2e 00              Hello World..

00000061 <__c.2234>:
      61:	49 6e 69 74 20 2e 2e 2e 20 64 6f 6e 65 21 00        Init ... done!.

00000070 <font_fixed_8px_data>:
      70:	00 00 00 00 00 00 00 3e 45 51 45 3e 00 3e 6b 6f     .......>EQE>.>ko
      80:	6b 3e 00 1c 3e 7c 3e 1c 00 18 3c 7e 3c 18 00 30     k>..>|>...<~<..0
      90:	36 7f 36 30 00 18 5c 7e 5c 18 00 00 00 00 00 00     6.60..\~\.......
	...
      b0:	00 00 00 30 48 4a 36 0e 00 06 29 79 29 06 00 00     ...0HJ6...)y)...
      c0:	00 00 00 00 00 60 7e 0a 35 3f 00 2a 1c 36 1c 2a     .....`~.5?.*.6.*
      d0:	00 00 7f 3e 1c 08 00 08 1c 3e 7f 00 00 14 36 7f     ...>.....>....6.
      e0:	36 14 00 00 5f 00 5f 00 00 06 09 7f 01 7f 00 22     6..._._........"
      f0:	4d 55 59 22 00 60 60 60 60 00 00 14 b6 ff b6 14     MUY".````.......
     100:	00 04 06 7f 06 04 00 10 30 7f 30 10 00 08 08 3e     ........0.0....>
     110:	1c 08 00 08 1c 3e 08 08 00 78 40 40 40 40 00 08     .....>...x@@@@..
     120:	3e 08 3e 08 00 30 3c 3f 3c 30 00 03 0f 3f 0f 03     >.>..0<?<0...?..
	...
     138:	06 5f 06 00 00 07 03 00 07 03 00 24 7e 24 7e 24     ._.........$~$~$
     148:	00 24 2b 6a 12 00 00 63 13 08 64 63 00 36 49 56     .$+j...c..dc.6IV
     158:	20 50 00 00 07 03 00 00 00 00 3e 41 00 00 00 00      P........>A....
     168:	41 3e 00 00 00 08 3e 1c 3e 08 00 08 08 3e 08 08     A>....>.>....>..
     178:	00 00 e0 60 00 00 00 08 08 08 08 08 00 00 60 60     ...`..........``
     188:	00 00 00 20 10 08 04 02 00 3e 51 49 45 3e 00 00     ... .....>QIE>..
     198:	42 7f 40 00 00 62 51 49 49 46 00 22 49 49 49 36     B.@..bQIIF."III6
     1a8:	00 18 14 12 7f 10 00 2f 49 49 49 31 00 3c 4a 49     ......./III1.<JI
     1b8:	49 30 00 01 71 09 05 03 00 36 49 49 49 36 00 06     I0..q....6III6..
     1c8:	49 49 29 1e 00 00 6c 6c 00 00 00 00 ec 6c 00 00     II)...ll.....l..
     1d8:	00 08 14 22 41 00 00 24 24 24 24 24 00 00 41 22     ..."A..$$$$$..A"
     1e8:	14 08 00 02 01 59 09 06 00 3e 41 5d 55 1e 00 7e     .....Y...>A]U..~
     1f8:	11 11 11 7e 00 7f 49 49 49 36 00 3e 41 41 41 22     ...~..III6.>AAA"
     208:	00 7f 41 41 41 3e 00 7f 49 49 49 41 00 7f 09 09     ..AAA>..IIIA....
     218:	09 01 00 3e 41 49 49 7a 00 7f 08 08 08 7f 00 00     ...>AIIz........
     228:	41 7f 41 00 00 30 40 40 40 3f 00 7f 08 14 22 41     A.A..0@@@?...."A
     238:	00 7f 40 40 40 40 00 7f 02 04 02 7f 00 7f 02 04     ..@@@@..........
     248:	08 7f 00 3e 41 41 41 3e 00 7f 09 09 09 06 00 3e     ...>AAA>.......>
     258:	41 51 21 5e 00 7f 09 09 19 66 00 26 49 49 49 32     AQ!^.....f.&III2
     268:	00 01 01 7f 01 01 00 3f 40 40 40 3f 00 1f 20 40     .......?@@@?.. @
     278:	20 1f 00 3f 40 3c 40 3f 00 63 14 08 14 63 00 07      ..?@<@?.c...c..
     288:	08 70 08 07 00 71 49 45 43 00 00 00 7f 41 41 00     .p...qIEC....AA.
     298:	00 02 04 08 10 20 00 00 41 41 7f 00 00 04 02 01     ..... ..AA......
     2a8:	02 04 80 80 80 80 80 80 00 00 03 07 00 00 00 20     ............... 
     2b8:	54 54 54 78 00 7f 44 44 44 38 00 38 44 44 44 28     TTTx..DDD8.8DDD(
     2c8:	00 38 44 44 44 7f 00 38 54 54 54 08 00 08 7e 09     .8DDD..8TTT...~.
     2d8:	09 00 00 18 a4 a4 a4 7c 00 7f 04 04 78 00 00 00     .......|....x...
     2e8:	00 7d 40 00 00 40 80 84 7d 00 00 7f 10 28 44 00     .}@..@..}....(D.
     2f8:	00 00 00 7f 40 00 00 7c 04 18 04 78 00 7c 04 04     ....@..|...x.|..
     308:	78 00 00 38 44 44 44 38 00 fc 44 44 44 38 00 38     x..8DDD8..DDD8.8
     318:	44 44 44 fc 00 44 78 44 04 08 00 08 54 54 54 20     DDD..DxD....TTT 
     328:	00 04 3e 44 24 00 00 3c 40 20 7c 00 00 1c 20 40     ..>D$..<@ |... @
     338:	20 1c 00 3c 60 30 60 3c 00 6c 10 10 6c 00 00 9c      ..<`0`<.l..l...
     348:	a0 60 3c 00 00 64 54 54 4c 00 00 08 3e 41 41 00     .`<..dTTL...>AA.
     358:	00 00 00 77 00 00 00 00 41 41 3e 08 00 02 01 02     ...w....AA>.....
     368:	01 00 00 3c 26 23 26 3c 00 1e a1 e1 21 12 00 3d     ...<&#&<....!..=
     378:	40 20 7d 00 00 38 54 54 55 09 00 20 55 55 55 78     @ }..8TTU.. UUUx
     388:	00 20 55 54 55 78 00 20 55 55 54 78 00 20 57 55     . UTUx. UUTx. WU
     398:	57 78 00 1c a2 e2 22 14 00 38 55 55 55 08 00 38     Wx...."..8UUU..8
     3a8:	55 54 55 08 00 38 55 55 54 08 00 00 01 7c 41 00     UTU..8UUT....|A.
     3b8:	00 00 01 7d 41 00 00 00 01 7c 40 00 00 70 29 24     ...}A....|@..p)$
     3c8:	29 70 00 78 2f 25 2f 78 00 7c 54 54 55 45 00 34     )p.x/%/x.|TTUE.4
     3d8:	54 7c 54 58 00 7e 09 7f 49 49 00 38 45 45 39 00     T|TX.~..II.8EE9.
     3e8:	00 38 45 44 39 00 00 39 45 44 38 00 00 3c 41 21     .8ED9..9ED8..<A!
     3f8:	7d 00 00 3d 41 20 7c 00 00 9c a1 60 3d 00 00 3d     }..=A |....`=..=
     408:	42 42 3d 00 00 3c 41 40 3d 00 80 70 68 58 38 04     BB=..<A@=..phX8.
     418:	00 48 3e 49 49 62 00 7e 61 5d 43 3f 00 22 14 08     .H>IIb.~a]C?."..
     428:	14 22 00 40 88 7e 09 02 00 20 54 55 55 78 00 00     .".@.~... TUUx..
     438:	00 7d 41 00 00 38 44 45 39 00 00 3c 40 21 7d 00     .}A..8DE9..<@!}.
     448:	00 7a 09 0a 71 00 00 7a 11 22 79 00 00 08 55 55     .z..q..z."y...UU
     458:	55 5e 00 4e 51 51 4e 00 00 30 48 4d 40 20 3e 41     U^.NQQN..0HM@ >A
     468:	5d 4b 55 3e 04 04 04 04 04 1c 00 17 08 4c 6a 50     ]KU>.........LjP
     478:	00 17 08 34 2a 78 00 00 30 7d 30 00 00 08 14 00     ...4*x..0}0.....
     488:	08 14 00 14 08 00 14 08 44 11 44 11 44 11 aa 55     ........D.D.D..U
     498:	aa 55 aa 55 bb ee bb ee bb ee 00 00 00 ff 00 00     .U.U............
     4a8:	08 08 08 ff 00 00 00 70 28 25 29 70 00 70 29 25     .......p(%)p.p)%
     4b8:	29 70 00 70 29 25 28 70 3e 41 5d 55 41 3e 0a fb     )p.p)%(p>A]UA>..
     4c8:	00 ff 00 00 00 ff 00 ff 00 00 0a fa 02 fe 00 00     ................
     4d8:	0a 0b 08 0f 00 00 00 18 24 66 24 00 00 29 2a 7c     ........$f$..)*|
     4e8:	2a 29 08 08 08 f8 00 00 00 00 00 0f 08 08 08 08     *)..............
     4f8:	08 0f 08 08 08 08 08 f8 08 08 00 00 00 ff 08 08     ................
     508:	08 08 08 08 08 08 08 08 08 ff 08 08 00 20 56 55     ............. VU
     518:	56 79 00 70 2a 25 2a 71 00 0f 08 0b 0a 0a 00 fe     Vy.p*%*q........
     528:	02 fa 0a 0a 0a 0b 08 0b 0a 0a 0a fa 02 fa 0a 0a     ................
     538:	00 ff 00 fb 0a 0a 0a 0a 0a 0a 0a 0a 0a fb 00 fb     ................
     548:	0a 0a 00 5d 22 22 22 5d 00 22 55 59 30 00 00 08     ...]"""]."UY0...
     558:	7f 49 41 3e 00 7c 55 55 55 44 00 7c 55 54 55 44     .IA>.|UUUD.|UTUD
     568:	00 7c 55 55 54 44 00 00 00 07 00 00 00 00 44 7d     .|UUTD........D}
     578:	45 00 00 00 45 7d 45 00 00 00 45 7c 45 00 08 08     E...E}E...E|E...
     588:	08 0f 00 00 00 00 00 f8 08 08 ff ff ff ff ff ff     ................
     598:	f0 f0 f0 f0 f0 f0 00 00 00 77 00 00 00 00 45 7d     .........w....E}
     5a8:	44 00 0f 0f 0f 0f 0f 0f 00 3c 42 43 3d 00 00 fe     D........<BC=...
     5b8:	4a 4a 34 00 00 3c 43 43 3d 00 00 3d 43 42 3c 00     JJ4..<CC=..=CB<.
     5c8:	00 32 49 4a 31 00 00 3a 45 46 39 00 00 fc 20 20     .2IJ1..:EF9...  
     5d8:	1c 00 00 fe aa 28 10 00 00 ff a5 24 18 00 00 3c     .....(.....$...<
     5e8:	40 41 3d 00 00 3c 41 41 3d 00 00 3d 41 40 3c 00     @A=..<AA=..=A@<.
     5f8:	00 9c a0 61 3d 00 00 04 08 71 09 04 00 00 02 02     ...a=....q......
     608:	02 00 00 00 07 03 00 00 00 00 08 08 08 00 00 00     ................
     618:	24 2e 24 00 00 24 24 24 24 24 05 17 0a 34 2a 78     $.$..$$$$$...4*x
     628:	00 06 09 7f 01 7f 00 22 4d 55 59 22 00 08 08 2a     ......."MUY"...*
     638:	08 08 00 00 08 18 18 00 00 06 09 09 06 00 00 00     ................
     648:	08 00 08 00 00 00 08 00 00 00 00 02 0f 00 00 00     ................
     658:	00 09 0f 05 00 00 00 09 0d 0a 00 00 00 3c 3c 3c     .............<<<
     668:	3c 00 00 00 00 00 00 00                             <.......

00000670 <font_fixed_8px>:
     670:	00 06 06 08 00 ff 00 00 70 00                       ........p.

0000067a <tdb00>:
     67a:	b6 00                                               ..

0000067c <tdb01>:
     67c:	e4 00                                               ..

0000067e <pxTCBlist>:
     67e:	05 01 0c 01                                         ....

00000682 <pxTDBlist>:
     682:	7a 06 7c 06                                         z.|.

00000686 <pxLooplist>:
     686:	fc 03 14 04                                         ....

0000068a <__ctors_end>:
     68a:	11 24       	eor	r1, r1
     68c:	1f be       	out	0x3f, r1	; 63
     68e:	cf e5       	ldi	r28, 0x5F	; 95
     690:	d8 e0       	ldi	r29, 0x08	; 8
     692:	de bf       	out	0x3e, r29	; 62
     694:	cd bf       	out	0x3d, r28	; 61

00000696 <__do_copy_data>:
     696:	10 e0       	ldi	r17, 0x00	; 0
     698:	a0 e6       	ldi	r26, 0x60	; 96
     69a:	b0 e0       	ldi	r27, 0x00	; 0
     69c:	e4 e0       	ldi	r30, 0x04	; 4
     69e:	f0 e2       	ldi	r31, 0x20	; 32
     6a0:	02 c0       	rjmp	.+4      	; 0x6a6 <__do_copy_data+0x10>
     6a2:	05 90       	lpm	r0, Z+
     6a4:	0d 92       	st	X+, r0
     6a6:	a8 36       	cpi	r26, 0x68	; 104
     6a8:	b1 07       	cpc	r27, r17
     6aa:	d9 f7       	brne	.-10     	; 0x6a2 <__do_copy_data+0xc>

000006ac <__do_clear_bss>:
     6ac:	11 e0       	ldi	r17, 0x01	; 1
     6ae:	a8 e6       	ldi	r26, 0x68	; 104
     6b0:	b0 e0       	ldi	r27, 0x00	; 0
     6b2:	01 c0       	rjmp	.+2      	; 0x6b6 <.do_clear_bss_start>

000006b4 <.do_clear_bss_loop>:
     6b4:	1d 92       	st	X+, r1

000006b6 <.do_clear_bss_start>:
     6b6:	a0 31       	cpi	r26, 0x10	; 16
     6b8:	b1 07       	cpc	r27, r17
     6ba:	e1 f7       	brne	.-8      	; 0x6b4 <.do_clear_bss_loop>
     6bc:	0e 94 8b 0c 	call	0x1916	; 0x1916 <main>
     6c0:	0c 94 00 10 	jmp	0x2000	; 0x2000 <_exit>

000006c4 <__bad_interrupt>:
     6c4:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006c8 <readInternalRegister>:
	
	read an internal 16 bit register of the bmp085

************************************************************************************************/
uint16_t readInternalRegister(unsigned char registerAddress)
{
     6c8:	0f 93       	push	r16
     6ca:	1f 93       	push	r17
     6cc:	df 93       	push	r29
     6ce:	cf 93       	push	r28
     6d0:	00 d0       	rcall	.+0      	; 0x6d2 <readInternalRegister+0xa>
     6d2:	cd b7       	in	r28, 0x3d	; 61
     6d4:	de b7       	in	r29, 0x3e	; 62
	unsigned char msgBuf[2];
	unsigned char msb, lsb;
	
	//prepare message for i2c transmission
	//1st byte: -> module address write
	msgBuf[0] = (barometricSensorAddress<<TWI_ADR_BITS) |  (FALSE<<TWI_READ_BIT);
     6d6:	90 91 60 00 	lds	r25, 0x0060
     6da:	99 0f       	add	r25, r25
     6dc:	99 83       	std	Y+1, r25	; 0x01
	//2nd byte: -> target register´s address for reading
	msgBuf[1] = registerAddress;
     6de:	8a 83       	std	Y+2, r24	; 0x02
	TWI_Start_Transceiver_With_Data( msgBuf, 2 );
     6e0:	8e 01       	movw	r16, r28
     6e2:	0f 5f       	subi	r16, 0xFF	; 255
     6e4:	1f 4f       	sbci	r17, 0xFF	; 255
     6e6:	c8 01       	movw	r24, r16
     6e8:	62 e0       	ldi	r22, 0x02	; 2
     6ea:	0e 94 75 0e 	call	0x1cea	; 0x1cea <TWI_Start_Transceiver_With_Data>
	
	//send a restart condition -> just start a new message
	//1st byte: -> module address read
	msgBuf[0] = (barometricSensorAddress<<TWI_ADR_BITS) |  (TRUE<<TWI_READ_BIT);
     6ee:	80 91 60 00 	lds	r24, 0x0060
     6f2:	90 91 61 00 	lds	r25, 0x0061
     6f6:	88 0f       	add	r24, r24
     6f8:	99 1f       	adc	r25, r25
     6fa:	81 60       	ori	r24, 0x01	; 1
     6fc:	89 83       	std	Y+1, r24	; 0x01
	TWI_Start_Transceiver_With_Data( msgBuf, 1 );
     6fe:	c8 01       	movw	r24, r16
     700:	61 e0       	ldi	r22, 0x01	; 1
     702:	0e 94 75 0e 	call	0x1cea	; 0x1cea <TWI_Start_Transceiver_With_Data>
	
	//the sensor sends first the 8 msb, then the 8 lsb
	TWI_Get_Data_From_Transceiver(msgBuf,2);
     706:	c8 01       	movw	r24, r16
     708:	62 e0       	ldi	r22, 0x02	; 2
     70a:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <TWI_Get_Data_From_Transceiver>
	msb=msgBuf[0];
	lsb=msgBuf[1];
	
	
		
	return (((uint16_t)msb<<8) | ((uint16_t)lsb));
     70e:	99 81       	ldd	r25, Y+1	; 0x01
     710:	80 e0       	ldi	r24, 0x00	; 0
     712:	2a 81       	ldd	r18, Y+2	; 0x02
     714:	30 e0       	ldi	r19, 0x00	; 0
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
	while(!Wire.available()); // wait until data available
	msb = Wire.read();
	while(!Wire.available()); // wait until data available
	lsb = Wire.read();
	return (((int)msb<<8) | ((int)lsb));*/
     71a:	82 2f       	mov	r24, r18
     71c:	93 2f       	mov	r25, r19
     71e:	0f 90       	pop	r0
     720:	0f 90       	pop	r0
     722:	cf 91       	pop	r28
     724:	df 91       	pop	r29
     726:	1f 91       	pop	r17
     728:	0f 91       	pop	r16
     72a:	08 95       	ret

0000072c <getCalibrationData>:

************************************************************************************************/
void  getCalibrationData() 
{	

	ac1 = readInternalRegister(0xAA);
     72c:	8a ea       	ldi	r24, 0xAA	; 170
     72e:	0e 94 64 03 	call	0x6c8	; 0x6c8 <readInternalRegister>
     732:	90 93 f1 00 	sts	0x00F1, r25
     736:	80 93 f0 00 	sts	0x00F0, r24
	
	ac2 = readInternalRegister(0xAC);
     73a:	8c ea       	ldi	r24, 0xAC	; 172
     73c:	0e 94 64 03 	call	0x6c8	; 0x6c8 <readInternalRegister>
     740:	90 93 f9 00 	sts	0x00F9, r25
     744:	80 93 f8 00 	sts	0x00F8, r24

	ac3 = readInternalRegister(0xAE);
     748:	8e ea       	ldi	r24, 0xAE	; 174
     74a:	0e 94 64 03 	call	0x6c8	; 0x6c8 <readInternalRegister>
     74e:	90 93 01 01 	sts	0x0101, r25
     752:	80 93 00 01 	sts	0x0100, r24

	ac4 = readInternalRegister(0xB0);
     756:	80 eb       	ldi	r24, 0xB0	; 176
     758:	0e 94 64 03 	call	0x6c8	; 0x6c8 <readInternalRegister>
     75c:	90 93 fd 00 	sts	0x00FD, r25
     760:	80 93 fc 00 	sts	0x00FC, r24

	ac5 = readInternalRegister(0xB2);
     764:	82 eb       	ldi	r24, 0xB2	; 178
     766:	0e 94 64 03 	call	0x6c8	; 0x6c8 <readInternalRegister>
     76a:	90 93 f7 00 	sts	0x00F7, r25
     76e:	80 93 f6 00 	sts	0x00F6, r24

	ac6 = readInternalRegister(0xB4);
     772:	84 eb       	ldi	r24, 0xB4	; 180
     774:	0e 94 64 03 	call	0x6c8	; 0x6c8 <readInternalRegister>
     778:	90 93 f5 00 	sts	0x00F5, r25
     77c:	80 93 f4 00 	sts	0x00F4, r24

	b1 = readInternalRegister(0xB6);
     780:	86 eb       	ldi	r24, 0xB6	; 182
     782:	0e 94 64 03 	call	0x6c8	; 0x6c8 <readInternalRegister>
     786:	90 93 f3 00 	sts	0x00F3, r25
     78a:	80 93 f2 00 	sts	0x00F2, r24

	b2 = readInternalRegister(0xB8);
     78e:	88 eb       	ldi	r24, 0xB8	; 184
     790:	0e 94 64 03 	call	0x6c8	; 0x6c8 <readInternalRegister>
     794:	90 93 ed 00 	sts	0x00ED, r25
     798:	80 93 ec 00 	sts	0x00EC, r24

	mb = readInternalRegister(0xBA);
     79c:	8a eb       	ldi	r24, 0xBA	; 186
     79e:	0e 94 64 03 	call	0x6c8	; 0x6c8 <readInternalRegister>
     7a2:	90 93 ef 00 	sts	0x00EF, r25
     7a6:	80 93 ee 00 	sts	0x00EE, r24

	mc = readInternalRegister(0xBC);
     7aa:	8c eb       	ldi	r24, 0xBC	; 188
     7ac:	0e 94 64 03 	call	0x6c8	; 0x6c8 <readInternalRegister>
     7b0:	90 93 ff 00 	sts	0x00FF, r25
     7b4:	80 93 fe 00 	sts	0x00FE, r24

	md = readInternalRegister(0xBE);
     7b8:	8e eb       	ldi	r24, 0xBE	; 190
     7ba:	0e 94 64 03 	call	0x6c8	; 0x6c8 <readInternalRegister>
     7be:	90 93 fb 00 	sts	0x00FB, r25
     7c2:	80 93 fa 00 	sts	0x00FA, r24

}
     7c6:	08 95       	ret

000007c8 <setupBarometricSensor>:
		Initialisation for the barometric sensor bmp085.

************************************************************************************************/
void setupBarometricSensor()
{    
	getCalibrationData();
     7c8:	0e 94 96 03 	call	0x72c	; 0x72c <getCalibrationData>
}
     7cc:	08 95       	ret

000007ce <appBoot>:


//function is called at system start-up
//-> initialisation can be done here
void appBoot(void)
{ 
     7ce:	cf 93       	push	r28
     7d0:	df 93       	push	r29
	//devLedDRR    = 0xFF;	
	//devLedPORT   = 0xFF;
	//devSwitchDRR = 0x00; 
	myInit();
     7d2:	0e 94 88 04 	call	0x910	; 0x910 <myInit>
	
	TWI_Master_Initialise();
     7d6:	0e 94 64 0e 	call	0x1cc8	; 0x1cc8 <TWI_Master_Initialise>
	//pwmInit(100);
	
	lcd_set_font(FONT_FIXED_8,NORMAL);
     7da:	c0 e7       	ldi	r28, 0x70	; 112
     7dc:	d6 e0       	ldi	r29, 0x06	; 6
     7de:	ce 01       	movw	r24, r28
     7e0:	60 e0       	ldi	r22, 0x00	; 0
     7e2:	0e 94 1f 07 	call	0xe3e	; 0xe3e <lcd_set_font>
	lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("Init ... done!"));
     7e6:	ce 01       	movw	r24, r28
     7e8:	60 e0       	ldi	r22, 0x00	; 0
     7ea:	41 e6       	ldi	r20, 0x61	; 97
     7ec:	50 e0       	ldi	r21, 0x00	; 0
     7ee:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <lcd_put_string_P>
		
	

}
     7f2:	df 91       	pop	r29
     7f4:	cf 91       	pop	r28
     7f6:	08 95       	ret

000007f8 <appLoop_Display>:

void appLoop_Display(void)
{ 
	uint16_t const1;
	
	speed = 64;
     7f8:	80 e4       	ldi	r24, 0x40	; 64
     7fa:	80 93 6e 00 	sts	0x006E, r24
		lcd_moveto_xy  (2, 0);		
		//lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("Task1"));		
		lcd_put_uint(const1);
		
		
		PORTA ^= (1<<PINA0);
     7fe:	11 e0       	ldi	r17, 0x01	; 1
			
  		//lcd_moveto_xy  (1, 0);
		//lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("Task1"));
		//lcd_moveto_xy  (2, 0);
		//lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("************")); 
		const1 = readInternalRegister(0xAA);
     800:	8a ea       	ldi	r24, 0xAA	; 170
     802:	90 e0       	ldi	r25, 0x00	; 0
     804:	0e 94 64 03 	call	0x6c8	; 0x6c8 <readInternalRegister>
		const1=999;
		lcd_moveto_xy  (2, 0);		
     808:	82 e0       	ldi	r24, 0x02	; 2
     80a:	60 e0       	ldi	r22, 0x00	; 0
     80c:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <lcd_moveto_xy>
		//lcd_put_string_P(FONT_FIXED_8, NORMAL, PSTR("Task1"));		
		lcd_put_uint(const1);
     810:	87 ee       	ldi	r24, 0xE7	; 231
     812:	93 e0       	ldi	r25, 0x03	; 3
     814:	0e 94 ae 0a 	call	0x155c	; 0x155c <lcd_put_uint>
		
		
		PORTA ^= (1<<PINA0);
     818:	8b b3       	in	r24, 0x1b	; 27
     81a:	81 27       	eor	r24, r17
     81c:	8b bb       	out	0x1b, r24	; 27
		

		taskDelayFromNow(1); 
     81e:	81 e0       	ldi	r24, 0x01	; 1
     820:	90 e0       	ldi	r25, 0x00	; 0
     822:	0e 94 c3 0c 	call	0x1986	; 0x1986 <taskDelayFromNow>
     826:	ec cf       	rjmp	.-40     	; 0x800 <appLoop_Display+0x8>

00000828 <appLoop_Speed>:
		{ 
			speed += 64; 
		}
		*/
		_delay_ms(500);	
		PORTA ^= (1<<PINA1);
     828:	12 e0       	ldi	r17, 0x02	; 2
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     82a:	8f ef       	ldi	r24, 0xFF	; 255
     82c:	94 e3       	ldi	r25, 0x34	; 52
     82e:	ac e0       	ldi	r26, 0x0C	; 12
     830:	81 50       	subi	r24, 0x01	; 1
     832:	90 40       	sbci	r25, 0x00	; 0
     834:	a0 40       	sbci	r26, 0x00	; 0
     836:	e1 f7       	brne	.-8      	; 0x830 <appLoop_Speed+0x8>
     838:	00 c0       	rjmp	.+0      	; 0x83a <appLoop_Speed+0x12>
     83a:	00 00       	nop
     83c:	8b b3       	in	r24, 0x1b	; 27
     83e:	81 27       	eor	r24, r17
     840:	8b bb       	out	0x1b, r24	; 27
			
		taskDelayFromNow(1); 
     842:	81 e0       	ldi	r24, 0x01	; 1
     844:	90 e0       	ldi	r25, 0x00	; 0
     846:	0e 94 c3 0c 	call	0x1986	; 0x1986 <taskDelayFromNow>
     84a:	ef cf       	rjmp	.-34     	; 0x82a <appLoop_Speed+0x2>

0000084c <adcInit>:
{
  
  uint16_t result;
 									
								
  ADMUX &= ~((1<<REFS1) | (1<<REFS0)); // externe Referenzspannung nutzen (typischerweise Vcc-Pegel)
     84c:	87 b1       	in	r24, 0x07	; 7
     84e:	8f 73       	andi	r24, 0x3F	; 63
     850:	87 b9       	out	0x07, r24	; 7


  ADCSRA |= ((1<<ADEN) | (1<<ADPS2) | (1<<ADPS1));    	// ADC Prescaler wählen. BIT0 bis BII 2 in ADCSRA
     852:	86 b1       	in	r24, 0x06	; 6
     854:	86 68       	ori	r24, 0x86	; 134
     856:	86 b9       	out	0x06, r24	; 6
                               					    // UND ADC aktivieren



  //Erste conversion anstoßen, danach läuft der ADC im free run mode
  ADCSRA |= (1<<ADSC);	
     858:	36 9a       	sbi	0x06, 6	; 6
  

  //Auf Abschluss der Konvertierung warten
  //Das Register ADCSRA wird mit "1<<ADSC" maskiert. Da ADSC den Wert 6 hat, wartet das while 
  //also solange, bis das Bit6 von ADCSRA == 0 wird.
  while (ADCSRA & (1<<ADSC) ) {}
     85a:	36 99       	sbic	0x06, 6	; 6
     85c:	fe cf       	rjmp	.-4      	; 0x85a <adcInit+0xe>
  	
  //ADCSRA |= (1<<ADIE);		// ADC - > Interrupt Enable		
  
  /* ADCW muss einmal gelesen werden, sonst wird Ergebnis der nächsten
     Wandlung nicht übernommen. */
  result = ADCW;		 
     85e:	84 b1       	in	r24, 0x04	; 4
     860:	95 b1       	in	r25, 0x05	; 5
   
}
     862:	08 95       	ret

00000864 <adcRead15>:
{
	uint16_t result=0;
	
	// 	Kanal waehlen(durch Parameterübergabe)	
	//  Kanäle 4 bis 7 sind verfügbar
	if ((channel >= 4) && (channel <=7))
     864:	98 2f       	mov	r25, r24
     866:	94 50       	subi	r25, 0x04	; 4
     868:	94 30       	cpi	r25, 0x04	; 4
     86a:	08 f4       	brcc	.+2      	; 0x86e <adcRead15+0xa>
 		ADMUX = channel;                  // 	Kanal waehlen(durch Parameterübergabe)
     86c:	87 b9       	out	0x07, r24	; 7

	//Erste conversion anstoßen, danach läuft der ADC im free run mode
  	ADCSRA |= (1<<ADSC);	
     86e:	36 9a       	sbi	0x06, 6	; 6
  

  	//Auf Abschluss der Konvertierung warten
	while (ADCSRA & (1<<ADSC) ) {}
     870:	36 99       	sbic	0x06, 6	; 6
     872:	fe cf       	rjmp	.-4      	; 0x870 <adcRead15+0xc>
	
	//result in bit value
	result = ADCW;
     874:	44 b1       	in	r20, 0x04	; 4
     876:	55 b1       	in	r21, 0x05	; 5
	//convert result into voltage value
	//korrektes runden mit +(divisor>>1)
	//ohne die 16bit casts würde das zwischenergebnis auf die bitwertigkeit des
	//niedrigsten teil des terms reduziert (hier 8 bit von 100 oder 15)
	result = ((result * (uint16_t)15 * (int16_t)100)+(1023>>1)) / (uint16_t)1023;
     878:	2c ed       	ldi	r18, 0xDC	; 220
     87a:	35 e0       	ldi	r19, 0x05	; 5
     87c:	42 9f       	mul	r20, r18
     87e:	c0 01       	movw	r24, r0
     880:	43 9f       	mul	r20, r19
     882:	90 0d       	add	r25, r0
     884:	52 9f       	mul	r21, r18
     886:	90 0d       	add	r25, r0
     888:	11 24       	eor	r1, r1
     88a:	81 50       	subi	r24, 0x01	; 1
     88c:	9e 4f       	sbci	r25, 0xFE	; 254
     88e:	6f ef       	ldi	r22, 0xFF	; 255
     890:	73 e0       	ldi	r23, 0x03	; 3
     892:	0e 94 4f 0f 	call	0x1e9e	; 0x1e9e <__udivmodhi4>

	return result;
}
     896:	86 2f       	mov	r24, r22
     898:	97 2f       	mov	r25, r23
     89a:	08 95       	ret

0000089c <adcRead5>:
{
	uint16_t result=0;
	
	// 	Kanal waehlen(durch Parameterübergabe)	
	//  Kanäle 4 bis 7 sind verfügbar
	if ((channel >= 4) && (channel <=7))
     89c:	98 2f       	mov	r25, r24
     89e:	94 50       	subi	r25, 0x04	; 4
     8a0:	94 30       	cpi	r25, 0x04	; 4
     8a2:	08 f4       	brcc	.+2      	; 0x8a6 <adcRead5+0xa>
 		ADMUX = channel;                  // 	Kanal waehlen(durch Parameterübergabe)
     8a4:	87 b9       	out	0x07, r24	; 7

	//Erste conversion anstoßen, danach läuft der ADC im free run mode
  	ADCSRA |= (1<<ADSC);	
     8a6:	36 9a       	sbi	0x06, 6	; 6
  

  	//Auf Abschluss der Konvertierung warten
	while (ADCSRA & (1<<ADSC) ) {}
     8a8:	36 99       	sbic	0x06, 6	; 6
     8aa:	fe cf       	rjmp	.-4      	; 0x8a8 <adcRead5+0xc>
	
	//result in bit value
	result = ADCW;
     8ac:	44 b1       	in	r20, 0x04	; 4
     8ae:	55 b1       	in	r21, 0x05	; 5
	//convert result into voltage value
	//korrektes runden mit +(divisor>>1)
	//ohne die 16bit casts würde das zwischenergebnis auf die bitwertigkeit des
	//niedrigsten teil des terms reduziert (hier 8 bit von 100 oder 15)
	result = ((result * (uint16_t)5 * (uint16_t)100) + (1023>>1)) / (uint16_t)1023;
     8b0:	24 ef       	ldi	r18, 0xF4	; 244
     8b2:	31 e0       	ldi	r19, 0x01	; 1
     8b4:	42 9f       	mul	r20, r18
     8b6:	c0 01       	movw	r24, r0
     8b8:	43 9f       	mul	r20, r19
     8ba:	90 0d       	add	r25, r0
     8bc:	52 9f       	mul	r21, r18
     8be:	90 0d       	add	r25, r0
     8c0:	11 24       	eor	r1, r1
     8c2:	81 50       	subi	r24, 0x01	; 1
     8c4:	9e 4f       	sbci	r25, 0xFE	; 254
     8c6:	6f ef       	ldi	r22, 0xFF	; 255
     8c8:	73 e0       	ldi	r23, 0x03	; 3
     8ca:	0e 94 4f 0f 	call	0x1e9e	; 0x1e9e <__udivmodhi4>

	return result;

}
     8ce:	86 2f       	mov	r24, r22
     8d0:	97 2f       	mov	r25, r23
     8d2:	08 95       	ret

000008d4 <__vector_1>:



//bei Button "warm" (button ganz rechts), läuft durch wenn fallende Flanke auf INT0 (PD.2)
ISR(INT0_vect) 
{
     8d4:	1f 92       	push	r1
     8d6:	0f 92       	push	r0
     8d8:	0f b6       	in	r0, 0x3f	; 63
     8da:	0f 92       	push	r0
     8dc:	11 24       	eor	r1, r1

}
     8de:	0f 90       	pop	r0
     8e0:	0f be       	out	0x3f, r0	; 63
     8e2:	0f 90       	pop	r0
     8e4:	1f 90       	pop	r1
     8e6:	18 95       	reti

000008e8 <__vector_2>:

//----------------------------------------------------------------------------------------------

//bei Button "kalt" (button in der Mitte), läuft durch wenn fallende Flanke auf INT1 (PD.3)
ISR(INT1_vect) 
{
     8e8:	1f 92       	push	r1
     8ea:	0f 92       	push	r0
     8ec:	0f b6       	in	r0, 0x3f	; 63
     8ee:	0f 92       	push	r0
     8f0:	11 24       	eor	r1, r1

}
     8f2:	0f 90       	pop	r0
     8f4:	0f be       	out	0x3f, r0	; 63
     8f6:	0f 90       	pop	r0
     8f8:	1f 90       	pop	r1
     8fa:	18 95       	reti

000008fc <__vector_3>:

//----------------------------------------------------------------------------------------------

//ISR läuft durch, wenn fallende Flanke auf INT2 (PB.2)
ISR(INT2_vect)
{	
     8fc:	1f 92       	push	r1
     8fe:	0f 92       	push	r0
     900:	0f b6       	in	r0, 0x3f	; 63
     902:	0f 92       	push	r0
     904:	11 24       	eor	r1, r1



	//sleep_disable();	

}
     906:	0f 90       	pop	r0
     908:	0f be       	out	0x3f, r0	; 63
     90a:	0f 90       	pop	r0
     90c:	1f 90       	pop	r1
     90e:	18 95       	reti

00000910 <myInit>:
	//set_sleep_mode(SLEEP_MODE_PWR_DOWN);


	//für dogm display
	//initialize lcd-display
	lcd_init();
     910:	0e 94 c2 06 	call	0xd84	; 0xd84 <lcd_init>
	
	
	
	//cpu status led
	DDRA |= (1<<PINA7);
     914:	d7 9a       	sbi	0x1a, 7	; 26
	PORTA |= (1<<PINA7);
     916:	df 9a       	sbi	0x1b, 7	; 27
	
	DDRA |= (1<<PINA0);
     918:	d0 9a       	sbi	0x1a, 0	; 26
	
	DDRA |= (1<<PINA1);
     91a:	d1 9a       	sbi	0x1a, 1	; 26
	//Enable interrupts for INT0, INT1, INT2	
	//GICR  |= (1<<BIT7) | (1<<BIT6) | (1<<BIT5); 
	GICR |= (1<<BIT5); //only INT2

*/
}
     91c:	08 95       	ret

0000091e <pwmInit>:

#include "pwmInit.h"

void pwmInit(uint16_t compare)
{
	DDRD |= (1<<BIT4) | (1<<BIT5);		//D.4&5 als Ausgänge definieren
     91e:	21 b3       	in	r18, 0x11	; 17
     920:	20 63       	ori	r18, 0x30	; 48
     922:	21 bb       	out	0x11, r18	; 17
	
	//PWM, Phase Correct with ICR1 as TOP value
	//TOP: 625
	TCCR1A |= (1<<WGM11);	
     924:	2f b5       	in	r18, 0x2f	; 47
     926:	22 60       	ori	r18, 0x02	; 2
     928:	2f bd       	out	0x2f, r18	; 47
	TCCR1A &= ~(1<<WGM10);	
     92a:	2f b5       	in	r18, 0x2f	; 47
     92c:	2e 7f       	andi	r18, 0xFE	; 254
     92e:	2f bd       	out	0x2f, r18	; 47

	TCCR1B |= (1<<WGM13);
     930:	2e b5       	in	r18, 0x2e	; 46
     932:	20 61       	ori	r18, 0x10	; 16
     934:	2e bd       	out	0x2e, r18	; 46
	TCCR1B &= ~(1<<WGM12);
     936:	2e b5       	in	r18, 0x2e	; 46
     938:	27 7f       	andi	r18, 0xF7	; 247
     93a:	2e bd       	out	0x2e, r18	; 46

	ICR1 = 625;
     93c:	21 e7       	ldi	r18, 0x71	; 113
     93e:	32 e0       	ldi	r19, 0x02	; 2
     940:	37 bd       	out	0x27, r19	; 39
     942:	26 bd       	out	0x26, r18	; 38
	

	//Nicht invertierende PWM, KanalA -> auf Pin D.5
	//- Clear OC1A/OC1B on Compare Match when up-counting. 
	//- Set OC1A/OC1B on Compare Match when downcounting.
	TCCR1A |= (1<<COM1A1); 	
     944:	2f b5       	in	r18, 0x2f	; 47
     946:	20 68       	ori	r18, 0x80	; 128
     948:	2f bd       	out	0x2f, r18	; 47
	TCCR1A &= ~(1<<COM1A0);
     94a:	2f b5       	in	r18, 0x2f	; 47
     94c:	2f 7b       	andi	r18, 0xBF	; 191
     94e:	2f bd       	out	0x2f, r18	; 47

	//Prescaler = 64
	TCCR1B |= (1<<CS10) | (1<<CS11);
     950:	2e b5       	in	r18, 0x2e	; 46
     952:	23 60       	ori	r18, 0x03	; 3
     954:	2e bd       	out	0x2e, r18	; 46
	TCCR1B |= ~(1<<CS12); 
     956:	2e b5       	in	r18, 0x2e	; 46
     958:	2b 6f       	ori	r18, 0xFB	; 251
     95a:	2e bd       	out	0x2e, r18	; 46
		1 	1 	0 	Externer Pin 1, negative Flanke
		1 	1 	1 	Externer Pin 1, positive Flanke 
	*/
	
	//OCR1A->16bit register
	OCR1A=compare;	//Vergleichswert laden
     95c:	9b bd       	out	0x2b, r25	; 43
     95e:	8a bd       	out	0x2a, r24	; 42
	
	
}
     960:	08 95       	ret

00000962 <pwmUpdate>:


void pwmUpdate(uint16_t compare)
{
	OCR1A=compare;	
     962:	9b bd       	out	0x2b, r25	; 43
     964:	8a bd       	out	0x2a, r24	; 42
}
     966:	08 95       	ret

00000968 <timer_init>:
#include "timerInit.h"

void timer_init(uint16_t compare)
{

	TCCR1B |= (1<<WGM12);	//CTC Mode:
     968:	2e b5       	in	r18, 0x2e	; 46
     96a:	28 60       	ori	r18, 0x08	; 8
     96c:	2e bd       	out	0x2e, r18	; 46
							//Timer1 zählt hoch, bei compare match wird er wieder zu 0 gesetzt

	TCCR1B |= (1<<CS10); //Prescaler nicht aktiviert - es liegt der Systemtakt an
     96e:	2e b5       	in	r18, 0x2e	; 46
     970:	21 60       	ori	r18, 0x01	; 1
     972:	2e bd       	out	0x2e, r18	; 46
	1 	0 	1 	CK / 1024
	1 	1 	0 	Externer Pin 1, negative Flanke
	1 	1 	1 	Externer Pin 1, positive Flanke 
*/
	
	OCR1A=compare;	//Vergleichswert laden
     974:	9b bd       	out	0x2b, r25	; 43
     976:	8a bd       	out	0x2a, r24	; 42
	
	
}
     978:	08 95       	ret

0000097a <lcd_inc_page>:
/******************************************************************************
 * Changes the internal cursor by s pages
 * s             - number of pages to move
 */ 
uint8_t lcd_inc_page(int8_t s) {
  uint8_t p = lcd_current_page;
     97a:	90 91 6f 00 	lds	r25, 0x006F
  p += s;
     97e:	89 0f       	add	r24, r25
  p %= LCD_RAM_PAGES;    //all lcd have lcd_ram_pages which is power of two
     980:	83 70       	andi	r24, 0x03	; 3
  lcd_current_page = p;
     982:	80 93 6f 00 	sts	0x006F, r24
  return p;
  }
     986:	08 95       	ret

00000988 <lcd_inc_column>:

/******************************************************************************
 * Changes the internal cursor by s columns, including wrapping (if selected)
 * s             - number of columns to move
 */ 
uint8_t lcd_inc_column(int16_t s) {
     988:	0f 93       	push	r16
     98a:	1f 93       	push	r17
     98c:	cf 93       	push	r28
     98e:	df 93       	push	r29
     990:	8c 01       	movw	r16, r24
  uint16_t c = lcd_current_column;
     992:	80 91 70 00 	lds	r24, 0x0070
  c += s;
     996:	e8 01       	movw	r28, r16
     998:	c8 0f       	add	r28, r24
     99a:	d1 1d       	adc	r29, r1
#if LCD_WRAP_AROUND == 1
  while (c >= LCD_WIDTH) {
     99c:	c4 38       	cpi	r28, 0x84	; 132
     99e:	d1 05       	cpc	r29, r1
     9a0:	88 f0       	brcs	.+34     	; 0x9c4 <lcd_inc_column+0x3c>
    if (s > 0) lcd_inc_page(1);
     9a2:	10 16       	cp	r1, r16
     9a4:	11 06       	cpc	r1, r17
     9a6:	34 f4       	brge	.+12     	; 0x9b4 <lcd_inc_column+0x2c>
     9a8:	81 e0       	ldi	r24, 0x01	; 1
     9aa:	0e 94 bd 04 	call	0x97a	; 0x97a <lcd_inc_page>
    else       lcd_inc_page(-1);
    if (s > 0) c -= LCD_WIDTH;
     9ae:	c4 58       	subi	r28, 0x84	; 132
     9b0:	d0 40       	sbci	r29, 0x00	; 0
     9b2:	05 c0       	rjmp	.+10     	; 0x9be <lcd_inc_column+0x36>
  uint16_t c = lcd_current_column;
  c += s;
#if LCD_WRAP_AROUND == 1
  while (c >= LCD_WIDTH) {
    if (s > 0) lcd_inc_page(1);
    else       lcd_inc_page(-1);
     9b4:	8f ef       	ldi	r24, 0xFF	; 255
     9b6:	0e 94 bd 04 	call	0x97a	; 0x97a <lcd_inc_page>
    if (s > 0) c -= LCD_WIDTH;
    else       c += LCD_WIDTH;
     9ba:	cc 57       	subi	r28, 0x7C	; 124
     9bc:	df 4f       	sbci	r29, 0xFF	; 255
 */ 
uint8_t lcd_inc_column(int16_t s) {
  uint16_t c = lcd_current_column;
  c += s;
#if LCD_WRAP_AROUND == 1
  while (c >= LCD_WIDTH) {
     9be:	c4 38       	cpi	r28, 0x84	; 132
     9c0:	d1 05       	cpc	r29, r1
     9c2:	78 f7       	brcc	.-34     	; 0x9a2 <lcd_inc_column+0x1a>
    else       lcd_inc_page(-1);
    if (s > 0) c -= LCD_WIDTH;
    else       c += LCD_WIDTH;
    }
#endif
  lcd_current_column = c;
     9c4:	c0 93 70 00 	sts	0x0070, r28
  return c;
  }
     9c8:	8c 2f       	mov	r24, r28
     9ca:	df 91       	pop	r29
     9cc:	cf 91       	pop	r28
     9ce:	1f 91       	pop	r17
     9d0:	0f 91       	pop	r16
     9d2:	08 95       	ret

000009d4 <lcd_data>:
/******************************************************************************
 * Writes one data byte
 * data          - the data byte
 */
void lcd_data(uint8_t data) {
  LCD_SELECT();
     9d4:	c4 98       	cbi	0x18, 4	; 24
  LCD_DRAM();
     9d6:	dd 9a       	sbi	0x1b, 5	; 27
  spi_write(data);
     9d8:	8f b9       	out	0x0f, r24	; 15
  LCD_UNSELECT();
     9da:	77 9b       	sbis	0x0e, 7	; 14
     9dc:	fe cf       	rjmp	.-4      	; 0x9da <lcd_data+0x6>
     9de:	c4 9a       	sbi	0x18, 4	; 24
  lcd_inc_column(1);
     9e0:	81 e0       	ldi	r24, 0x01	; 1
     9e2:	90 e0       	ldi	r25, 0x00	; 0
     9e4:	0e 94 c4 04 	call	0x988	; 0x988 <lcd_inc_column>
  }
     9e8:	08 95       	ret

000009ea <lcd_command>:
/******************************************************************************
 * Writes one command byte
 * cmd           - the command byte
 */
void lcd_command(uint8_t cmd) {
  LCD_SELECT();
     9ea:	c4 98       	cbi	0x18, 4	; 24
  LCD_CMD();
     9ec:	dd 98       	cbi	0x1b, 5	; 27
   
  spi_write(cmd);
     9ee:	8f b9       	out	0x0f, r24	; 15
  
  
  //LCD_UNSELECT();
  while(!(SPSR & (1<<SPIF)));
     9f0:	77 9b       	sbis	0x0e, 7	; 14
     9f2:	fe cf       	rjmp	.-4      	; 0x9f0 <lcd_command+0x6>
  PORT_CS |= _BV(PIN_CS);
     9f4:	c4 9a       	sbi	0x18, 4	; 24
  }
     9f6:	08 95       	ret

000009f8 <lcd_moveto_xy>:
/******************************************************************************
 * Moves the cursor to the given position
 * pages         - page to move to
 * columns       - column to move to
 */ 
void lcd_moveto_xy(uint8_t page, uint8_t column) {
     9f8:	0f 93       	push	r16
     9fa:	1f 93       	push	r17
     9fc:	08 2f       	mov	r16, r24
     9fe:	16 2f       	mov	r17, r22
  LCD_GOTO_ADDRESS(page,column);
     a00:	8f 70       	andi	r24, 0x0F	; 15
     a02:	80 6b       	ori	r24, 0xB0	; 176
     a04:	0e 94 f5 04 	call	0x9ea	; 0x9ea <lcd_command>
     a08:	81 2f       	mov	r24, r17
     a0a:	82 95       	swap	r24
     a0c:	8f 70       	andi	r24, 0x0F	; 15
     a0e:	80 61       	ori	r24, 0x10	; 16
     a10:	0e 94 f5 04 	call	0x9ea	; 0x9ea <lcd_command>
     a14:	81 2f       	mov	r24, r17
     a16:	8f 70       	andi	r24, 0x0F	; 15
     a18:	0e 94 f5 04 	call	0x9ea	; 0x9ea <lcd_command>
  lcd_current_column = column; 
     a1c:	10 93 70 00 	sts	0x0070, r17
  lcd_current_page = page;
     a20:	00 93 6f 00 	sts	0x006F, r16
  }
     a24:	1f 91       	pop	r17
     a26:	0f 91       	pop	r16
     a28:	08 95       	ret

00000a2a <lcd_move_xy>:
/******************************************************************************
 * Moves the cursor relative to the current position
 * pages         - number of pages to move
 * columns       - number of columns to move
 */  
void lcd_move_xy(int8_t pages, int16_t columns) {
     a2a:	1f 93       	push	r17
     a2c:	cf 93       	push	r28
     a2e:	df 93       	push	r29
     a30:	eb 01       	movw	r28, r22
  lcd_moveto_xy(lcd_inc_page(pages),lcd_inc_column(columns));
     a32:	0e 94 bd 04 	call	0x97a	; 0x97a <lcd_inc_page>
     a36:	18 2f       	mov	r17, r24
     a38:	ce 01       	movw	r24, r28
     a3a:	0e 94 c4 04 	call	0x988	; 0x988 <lcd_inc_column>
     a3e:	68 2f       	mov	r22, r24
     a40:	81 2f       	mov	r24, r17
     a42:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <lcd_moveto_xy>
  }
     a46:	df 91       	pop	r29
     a48:	cf 91       	pop	r28
     a4a:	1f 91       	pop	r17
     a4c:	08 95       	ret

00000a4e <lcd_draw_image_P>:
 * progmem_image - prog_uint8_t array of columns aka the bitmap image
 * pages         - height of image in pages
 * columns       - width of image in pixels (or columns)
 * style         - Bit2: sets inverse mode
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
     a4e:	8f 92       	push	r8
     a50:	9f 92       	push	r9
     a52:	af 92       	push	r10
     a54:	bf 92       	push	r11
     a56:	cf 92       	push	r12
     a58:	df 92       	push	r13
     a5a:	ef 92       	push	r14
     a5c:	ff 92       	push	r15
     a5e:	0f 93       	push	r16
     a60:	1f 93       	push	r17
     a62:	cf 93       	push	r28
     a64:	df 93       	push	r29
     a66:	18 2f       	mov	r17, r24
     a68:	d9 2e       	mov	r13, r25
     a6a:	c6 2e       	mov	r12, r22
     a6c:	04 2f       	mov	r16, r20
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
     a6e:	ff 24       	eor	r15, r15
     a70:	68 94       	set
     a72:	f2 f8       	bld	r15, 2
     a74:	f2 22       	and	r15, r18
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
     a76:	66 23       	and	r22, r22
     a78:	09 f4       	brne	.+2      	; 0xa7c <lcd_draw_image_P+0x2e>
     a7a:	40 c0       	rjmp	.+128    	; 0xafc <lcd_draw_image_P+0xae>
     a7c:	80 91 6f 00 	lds	r24, 0x006F
     a80:	84 30       	cpi	r24, 0x04	; 4
     a82:	70 f1       	brcs	.+92     	; 0xae0 <lcd_draw_image_P+0x92>
     a84:	3b c0       	rjmp	.+118    	; 0xafc <lcd_draw_image_P+0xae>
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++) {
     a86:	81 2e       	mov	r8, r17
     a88:	e4 01       	movw	r28, r8
     a8a:	4e 01       	movw	r8, r28
     a8c:	9d 2c       	mov	r9, r13
     a8e:	e4 01       	movw	r28, r8
 * style         - Bit2: sets inverse mode
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
     a90:	fe 01       	movw	r30, r28
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++) {
      uint8_t tmp = pgm_read_byte(progmem_image++);
     a92:	21 96       	adiw	r28, 0x01	; 1
     a94:	84 91       	lpm	r24, Z+
			if(!inv)
     a96:	ff 20       	and	r15, r15
     a98:	19 f4       	brne	.+6      	; 0xaa0 <lcd_draw_image_P+0x52>
				lcd_data(tmp);
     a9a:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <lcd_data>
     a9e:	03 c0       	rjmp	.+6      	; 0xaa6 <lcd_draw_image_P+0x58>
			else
				lcd_data(~tmp);
     aa0:	80 95       	com	r24
     aa2:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <lcd_data>
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++) {
     aa6:	4e 01       	movw	r8, r28
     aa8:	81 1a       	sub	r8, r17
     aaa:	80 16       	cp	r8, r16
     aac:	40 f4       	brcc	.+16     	; 0xabe <lcd_draw_image_P+0x70>
     aae:	80 91 70 00 	lds	r24, 0x0070
     ab2:	84 38       	cpi	r24, 0x84	; 132
     ab4:	68 f3       	brcs	.-38     	; 0xa90 <lcd_draw_image_P+0x42>
      uint8_t tmp = pgm_read_byte(progmem_image++);
     ab6:	9e 01       	movw	r18, r28
     ab8:	1c 2f       	mov	r17, r28
     aba:	d3 2e       	mov	r13, r19
     abc:	03 c0       	rjmp	.+6      	; 0xac4 <lcd_draw_image_P+0x76>
     abe:	9e 01       	movw	r18, r28
     ac0:	1c 2f       	mov	r17, r28
     ac2:	d3 2e       	mov	r13, r19
			if(!inv)
				lcd_data(tmp);
			else
				lcd_data(~tmp);
      }
    if(++j != pages)
     ac4:	e3 94       	inc	r14
     ac6:	ec 14       	cp	r14, r12
     ac8:	c9 f0       	breq	.+50     	; 0xafc <lcd_draw_image_P+0xae>
      lcd_move_xy(1,-columns);
     aca:	81 e0       	ldi	r24, 0x01	; 1
     acc:	b5 01       	movw	r22, r10
     ace:	0e 94 15 05 	call	0xa2a	; 0xa2a <lcd_move_xy>
 * style         - Bit2: sets inverse mode
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
     ad2:	ec 14       	cp	r14, r12
     ad4:	98 f4       	brcc	.+38     	; 0xafc <lcd_draw_image_P+0xae>
     ad6:	80 91 6f 00 	lds	r24, 0x006F
     ada:	84 30       	cpi	r24, 0x04	; 4
     adc:	40 f0       	brcs	.+16     	; 0xaee <lcd_draw_image_P+0xa0>
     ade:	0e c0       	rjmp	.+28     	; 0xafc <lcd_draw_image_P+0xae>
 * pages         - height of image in pages
 * columns       - width of image in pixels (or columns)
 * style         - Bit2: sets inverse mode
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
     ae0:	ee 24       	eor	r14, r14
				lcd_data(tmp);
			else
				lcd_data(~tmp);
      }
    if(++j != pages)
      lcd_move_xy(1,-columns);
     ae2:	a4 2e       	mov	r10, r20
     ae4:	bb 24       	eor	r11, r11
     ae6:	b0 94       	com	r11
     ae8:	a1 94       	neg	r10
     aea:	b1 08       	sbc	r11, r1
     aec:	b3 94       	inc	r11
 */  
void lcd_draw_image_P(PGM_P progmem_image, uint8_t pages, uint8_t columns, uint8_t style) {
	uint8_t i,j = 0;
  uint8_t inv = (style & INVERT_BIT);
	while(j<pages && (lcd_get_position_page() < LCD_RAM_PAGES)) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++) {
     aee:	00 23       	and	r16, r16
     af0:	49 f3       	breq	.-46     	; 0xac4 <lcd_draw_image_P+0x76>
     af2:	80 91 70 00 	lds	r24, 0x0070
     af6:	84 38       	cpi	r24, 0x84	; 132
     af8:	30 f2       	brcs	.-116    	; 0xa86 <lcd_draw_image_P+0x38>
     afa:	e4 cf       	rjmp	.-56     	; 0xac4 <lcd_draw_image_P+0x76>
				lcd_data(~tmp);
      }
    if(++j != pages)
      lcd_move_xy(1,-columns);
    }
  }
     afc:	df 91       	pop	r29
     afe:	cf 91       	pop	r28
     b00:	1f 91       	pop	r17
     b02:	0f 91       	pop	r16
     b04:	ff 90       	pop	r15
     b06:	ef 90       	pop	r14
     b08:	df 90       	pop	r13
     b0a:	cf 90       	pop	r12
     b0c:	bf 90       	pop	r11
     b0e:	af 90       	pop	r10
     b10:	9f 90       	pop	r9
     b12:	8f 90       	pop	r8
     b14:	08 95       	ret

00000b16 <lcd_draw_image_xy_P>:
 * y             - y start coordinate on the screen (in pixel)
 * pages         - height of image in pages
 * columns       - width of image in pixels
 * style         - Bit2: sets inverse mode
 */
void lcd_draw_image_xy_P(PGM_P progmem_image, uint8_t x, uint8_t y, uint8_t pages, uint8_t columns, uint8_t style) {
     b16:	2f 92       	push	r2
     b18:	3f 92       	push	r3
     b1a:	4f 92       	push	r4
     b1c:	5f 92       	push	r5
     b1e:	6f 92       	push	r6
     b20:	7f 92       	push	r7
     b22:	8f 92       	push	r8
     b24:	9f 92       	push	r9
     b26:	af 92       	push	r10
     b28:	bf 92       	push	r11
     b2a:	cf 92       	push	r12
     b2c:	df 92       	push	r13
     b2e:	ef 92       	push	r14
     b30:	ff 92       	push	r15
     b32:	0f 93       	push	r16
     b34:	1f 93       	push	r17
     b36:	df 93       	push	r29
     b38:	cf 93       	push	r28
     b3a:	cd b7       	in	r28, 0x3d	; 61
     b3c:	de b7       	in	r29, 0x3e	; 62
     b3e:	28 97       	sbiw	r28, 0x08	; 8
     b40:	0f b6       	in	r0, 0x3f	; 63
     b42:	f8 94       	cli
     b44:	de bf       	out	0x3e, r29	; 62
     b46:	0f be       	out	0x3f, r0	; 63
     b48:	cd bf       	out	0x3d, r28	; 61
     b4a:	6c 01       	movw	r12, r24
     b4c:	62 2e       	mov	r6, r18
	uint16_t i,j;
  uint8_t data   = 0;
  uint8_t inv    = style & INVERT_BIT;
     b4e:	24 e0       	ldi	r18, 0x04	; 4
     b50:	e2 22       	and	r14, r18
	uint8_t offset = y & 0x7; //Optimized modulo 8
     b52:	0f 2e       	mov	r0, r31
     b54:	f7 e0       	ldi	r31, 0x07	; 7
     b56:	ff 2e       	mov	r15, r31
     b58:	f0 2d       	mov	r31, r0
     b5a:	f4 22       	and	r15, r20
	//If there is an offset, we must use an additional page
	if(offset)  
     b5c:	09 f0       	breq	.+2      	; 0xb60 <lcd_draw_image_xy_P+0x4a>
    pages++;
     b5e:	63 94       	inc	r6


//Function to read the current position
extern uint8_t lcd_current_page;
extern uint8_t lcd_current_column;
static inline uint8_t lcd_get_position_page()   {return lcd_current_page;};
     b60:	80 91 6f 00 	lds	r24, 0x006F
  //If there is not enough vertical space -> cut image
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
     b64:	e6 2d       	mov	r30, r6
     b66:	f0 e0       	ldi	r31, 0x00	; 0
     b68:	24 e0       	ldi	r18, 0x04	; 4
     b6a:	30 e0       	ldi	r19, 0x00	; 0
     b6c:	28 1b       	sub	r18, r24
     b6e:	31 09       	sbc	r19, r1
     b70:	2e 17       	cp	r18, r30
     b72:	3f 07       	cpc	r19, r31
     b74:	24 f4       	brge	.+8      	; 0xb7e <lcd_draw_image_xy_P+0x68>
    pages = LCD_RAM_PAGES - lcd_get_position_page();
     b76:	66 24       	eor	r6, r6
     b78:	68 94       	set
     b7a:	62 f8       	bld	r6, 2
     b7c:	68 1a       	sub	r6, r24
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
     b7e:	84 2f       	mov	r24, r20
     b80:	86 95       	lsr	r24
     b82:	86 95       	lsr	r24
     b84:	86 95       	lsr	r24
     b86:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <lcd_moveto_xy>
 * y             - y start coordinate on the screen (in pixel)
 * pages         - height of image in pages
 * columns       - width of image in pixels
 * style         - Bit2: sets inverse mode
 */
void lcd_draw_image_xy_P(PGM_P progmem_image, uint8_t x, uint8_t y, uint8_t pages, uint8_t columns, uint8_t style) {
     b8a:	80 2e       	mov	r8, r16
     b8c:	99 24       	eor	r9, r9
     b8e:	16 01       	movw	r2, r12
     b90:	28 18       	sub	r2, r8
     b92:	39 08       	sbc	r3, r9
     b94:	da 82       	std	Y+2, r13	; 0x02
     b96:	c9 82       	std	Y+1, r12	; 0x01
  //If there is not enough vertical space -> cut image
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
    pages = LCD_RAM_PAGES - lcd_get_position_page();
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
	for (j=0; j<pages; j++) {
     b98:	aa 24       	eor	r10, r10
     b9a:	bb 24       	eor	r11, r11
     b9c:	77 24       	eor	r7, r7
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
      data = 0;
      if (!offset || j+1 != pages)
        data = pgm_read_byte(&progmem_image[j*columns + i]) << offset;
			if(j > 0 && offset)
				data |= pgm_read_byte(&progmem_image[(j-1)*columns + i]) >> (8-offset);
     b9e:	88 e0       	ldi	r24, 0x08	; 8
     ba0:	90 e0       	ldi	r25, 0x00	; 0
     ba2:	fc 01       	movw	r30, r24
     ba4:	ef 19       	sub	r30, r15
     ba6:	f1 09       	sbc	r31, r1
     ba8:	fc 83       	std	Y+4, r31	; 0x04
     baa:	eb 83       	std	Y+3, r30	; 0x03
			if(inv)	lcd_data(~data);
      else 		lcd_data(data);
		  }
		if(j+1 != pages)
			lcd_move_xy(1,-columns);
     bac:	c4 01       	movw	r24, r8
     bae:	22 27       	eor	r18, r18
     bb0:	33 27       	eor	r19, r19
     bb2:	28 1b       	sub	r18, r24
     bb4:	39 0b       	sbc	r19, r25
     bb6:	3e 83       	std	Y+6, r19	; 0x06
     bb8:	2d 83       	std	Y+5, r18	; 0x05
  //If there is not enough vertical space -> cut image
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
    pages = LCD_RAM_PAGES - lcd_get_position_page();
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
	for (j=0; j<pages; j++) {
     bba:	53 c0       	rjmp	.+166    	; 0xc62 <lcd_draw_image_xy_P+0x14c>
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
     bbc:	09 81       	ldd	r16, Y+1	; 0x01
     bbe:	1a 81       	ldd	r17, Y+2	; 0x02
     bc0:	61 01       	movw	r12, r2
     bc2:	18 86       	std	Y+8, r1	; 0x08
     bc4:	1f 82       	std	Y+7, r1	; 0x07
      data = 0;
      if (!offset || j+1 != pages)
     bc6:	25 01       	movw	r4, r10
     bc8:	08 94       	sec
     bca:	41 1c       	adc	r4, r1
     bcc:	51 1c       	adc	r5, r1
     bce:	ff 20       	and	r15, r15
     bd0:	19 f0       	breq	.+6      	; 0xbd8 <lcd_draw_image_xy_P+0xc2>
     bd2:	64 14       	cp	r6, r4
     bd4:	75 04       	cpc	r7, r5
     bd6:	41 f0       	breq	.+16     	; 0xbe8 <lcd_draw_image_xy_P+0xd2>
        data = pgm_read_byte(&progmem_image[j*columns + i]) << offset;
     bd8:	f8 01       	movw	r30, r16
     bda:	84 91       	lpm	r24, Z+
     bdc:	0f 2c       	mov	r0, r15
     bde:	01 c0       	rjmp	.+2      	; 0xbe2 <lcd_draw_image_xy_P+0xcc>
     be0:	88 0f       	add	r24, r24
     be2:	0a 94       	dec	r0
     be4:	ea f7       	brpl	.-6      	; 0xbe0 <lcd_draw_image_xy_P+0xca>
     be6:	01 c0       	rjmp	.+2      	; 0xbea <lcd_draw_image_xy_P+0xd4>
    pages = LCD_RAM_PAGES - lcd_get_position_page();
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
	for (j=0; j<pages; j++) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
      data = 0;
     be8:	80 e0       	ldi	r24, 0x00	; 0
      if (!offset || j+1 != pages)
        data = pgm_read_byte(&progmem_image[j*columns + i]) << offset;
			if(j > 0 && offset)
     bea:	a1 14       	cp	r10, r1
     bec:	b1 04       	cpc	r11, r1
     bee:	61 f0       	breq	.+24     	; 0xc08 <lcd_draw_image_xy_P+0xf2>
     bf0:	ff 20       	and	r15, r15
     bf2:	51 f0       	breq	.+20     	; 0xc08 <lcd_draw_image_xy_P+0xf2>
				data |= pgm_read_byte(&progmem_image[(j-1)*columns + i]) >> (8-offset);
     bf4:	f6 01       	movw	r30, r12
     bf6:	24 91       	lpm	r18, Z+
     bf8:	30 e0       	ldi	r19, 0x00	; 0
     bfa:	0b 80       	ldd	r0, Y+3	; 0x03
     bfc:	02 c0       	rjmp	.+4      	; 0xc02 <lcd_draw_image_xy_P+0xec>
     bfe:	35 95       	asr	r19
     c00:	27 95       	ror	r18
     c02:	0a 94       	dec	r0
     c04:	e2 f7       	brpl	.-8      	; 0xbfe <lcd_draw_image_xy_P+0xe8>
     c06:	82 2b       	or	r24, r18
			if(inv)	lcd_data(~data);
     c08:	ee 20       	and	r14, r14
     c0a:	21 f0       	breq	.+8      	; 0xc14 <lcd_draw_image_xy_P+0xfe>
     c0c:	80 95       	com	r24
     c0e:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <lcd_data>
     c12:	02 c0       	rjmp	.+4      	; 0xc18 <lcd_draw_image_xy_P+0x102>
      else 		lcd_data(data);
     c14:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <lcd_data>
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
    pages = LCD_RAM_PAGES - lcd_get_position_page();
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
	for (j=0; j<pages; j++) {
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
     c18:	2f 81       	ldd	r18, Y+7	; 0x07
     c1a:	38 85       	ldd	r19, Y+8	; 0x08
     c1c:	2f 5f       	subi	r18, 0xFF	; 255
     c1e:	3f 4f       	sbci	r19, 0xFF	; 255
     c20:	38 87       	std	Y+8, r19	; 0x08
     c22:	2f 83       	std	Y+7, r18	; 0x07
     c24:	28 15       	cp	r18, r8
     c26:	39 05       	cpc	r19, r9
     c28:	48 f4       	brcc	.+18     	; 0xc3c <lcd_draw_image_xy_P+0x126>
     c2a:	08 94       	sec
     c2c:	c1 1c       	adc	r12, r1
     c2e:	d1 1c       	adc	r13, r1
     c30:	0f 5f       	subi	r16, 0xFF	; 255
     c32:	1f 4f       	sbci	r17, 0xFF	; 255
     c34:	80 91 70 00 	lds	r24, 0x0070
     c38:	84 38       	cpi	r24, 0x84	; 132
     c3a:	48 f2       	brcs	.-110    	; 0xbce <lcd_draw_image_xy_P+0xb8>
			if(j > 0 && offset)
				data |= pgm_read_byte(&progmem_image[(j-1)*columns + i]) >> (8-offset);
			if(inv)	lcd_data(~data);
      else 		lcd_data(data);
		  }
		if(j+1 != pages)
     c3c:	08 94       	sec
     c3e:	a1 1c       	adc	r10, r1
     c40:	b1 1c       	adc	r11, r1
     c42:	6a 14       	cp	r6, r10
     c44:	7b 04       	cpc	r7, r11
     c46:	29 f0       	breq	.+10     	; 0xc52 <lcd_draw_image_xy_P+0x13c>
			lcd_move_xy(1,-columns);
     c48:	81 e0       	ldi	r24, 0x01	; 1
     c4a:	6d 81       	ldd	r22, Y+5	; 0x05
     c4c:	7e 81       	ldd	r23, Y+6	; 0x06
     c4e:	0e 94 15 05 	call	0xa2a	; 0xa2a <lcd_move_xy>
     c52:	28 0c       	add	r2, r8
     c54:	39 1c       	adc	r3, r9
     c56:	89 81       	ldd	r24, Y+1	; 0x01
     c58:	9a 81       	ldd	r25, Y+2	; 0x02
     c5a:	88 0d       	add	r24, r8
     c5c:	99 1d       	adc	r25, r9
     c5e:	9a 83       	std	Y+2, r25	; 0x02
     c60:	89 83       	std	Y+1, r24	; 0x01
  //If there is not enough vertical space -> cut image
  if(pages > LCD_RAM_PAGES - lcd_get_position_page())   
    pages = LCD_RAM_PAGES - lcd_get_position_page();
  //Goto starting point and draw
	lcd_moveto_xy((y>>3), x);
	for (j=0; j<pages; j++) {
     c62:	a6 14       	cp	r10, r6
     c64:	b7 04       	cpc	r11, r7
     c66:	48 f4       	brcc	.+18     	; 0xc7a <lcd_draw_image_xy_P+0x164>
		for (i=0; i<columns && (lcd_get_position_column() < LCD_WIDTH); i++){
     c68:	81 14       	cp	r8, r1
     c6a:	91 04       	cpc	r9, r1
     c6c:	39 f3       	breq	.-50     	; 0xc3c <lcd_draw_image_xy_P+0x126>
     c6e:	80 91 70 00 	lds	r24, 0x0070
     c72:	84 38       	cpi	r24, 0x84	; 132
     c74:	08 f4       	brcc	.+2      	; 0xc78 <lcd_draw_image_xy_P+0x162>
     c76:	a2 cf       	rjmp	.-188    	; 0xbbc <lcd_draw_image_xy_P+0xa6>
     c78:	e1 cf       	rjmp	.-62     	; 0xc3c <lcd_draw_image_xy_P+0x126>
      else 		lcd_data(data);
		  }
		if(j+1 != pages)
			lcd_move_xy(1,-columns);
	  }
  }
     c7a:	28 96       	adiw	r28, 0x08	; 8
     c7c:	0f b6       	in	r0, 0x3f	; 63
     c7e:	f8 94       	cli
     c80:	de bf       	out	0x3e, r29	; 62
     c82:	0f be       	out	0x3f, r0	; 63
     c84:	cd bf       	out	0x3d, r28	; 61
     c86:	cf 91       	pop	r28
     c88:	df 91       	pop	r29
     c8a:	1f 91       	pop	r17
     c8c:	0f 91       	pop	r16
     c8e:	ff 90       	pop	r15
     c90:	ef 90       	pop	r14
     c92:	df 90       	pop	r13
     c94:	cf 90       	pop	r12
     c96:	bf 90       	pop	r11
     c98:	af 90       	pop	r10
     c9a:	9f 90       	pop	r9
     c9c:	8f 90       	pop	r8
     c9e:	7f 90       	pop	r7
     ca0:	6f 90       	pop	r6
     ca2:	5f 90       	pop	r5
     ca4:	4f 90       	pop	r4
     ca6:	3f 90       	pop	r3
     ca8:	2f 90       	pop	r2
     caa:	08 95       	ret

00000cac <lcd_clear_area>:
 * pages         - height of area in pages
 * columns       - width of area in pixels
 * style         - Bit2: sets inverse mode
 * Cursor is moved to start of area after clear
 */
void lcd_clear_area(uint8_t pages, uint8_t columns, uint8_t style) {
     cac:	cf 92       	push	r12
     cae:	df 92       	push	r13
     cb0:	ef 92       	push	r14
     cb2:	ff 92       	push	r15
     cb4:	0f 93       	push	r16
     cb6:	1f 93       	push	r17
     cb8:	cf 93       	push	r28
     cba:	df 93       	push	r29
  uint8_t i,j,max;
  uint8_t inv = (style & INVERT_BIT)?0xFF:0;
     cbc:	42 ff       	sbrs	r20, 2
     cbe:	03 c0       	rjmp	.+6      	; 0xcc6 <lcd_clear_area+0x1a>
     cc0:	ff 24       	eor	r15, r15
     cc2:	fa 94       	dec	r15
     cc4:	01 c0       	rjmp	.+2      	; 0xcc8 <lcd_clear_area+0x1c>
     cc6:	ff 24       	eor	r15, r15
  
  if(pages > (max = LCD_RAM_PAGES - lcd_get_position_page()))   
     cc8:	20 91 6f 00 	lds	r18, 0x006F
     ccc:	94 e0       	ldi	r25, 0x04	; 4
     cce:	92 1b       	sub	r25, r18
 * style         - Bit2: sets inverse mode
 * Cursor is moved to start of area after clear
 */
void lcd_clear_area(uint8_t pages, uint8_t columns, uint8_t style) {
  uint8_t i,j,max;
  uint8_t inv = (style & INVERT_BIT)?0xFF:0;
     cd0:	d8 2e       	mov	r13, r24
     cd2:	98 17       	cp	r25, r24
     cd4:	08 f4       	brcc	.+2      	; 0xcd8 <lcd_clear_area+0x2c>
     cd6:	d9 2e       	mov	r13, r25
  
  if(pages > (max = LCD_RAM_PAGES - lcd_get_position_page()))   
    pages = max;
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
     cd8:	90 91 70 00 	lds	r25, 0x0070
     cdc:	84 e8       	ldi	r24, 0x84	; 132
     cde:	89 1b       	sub	r24, r25
 * style         - Bit2: sets inverse mode
 * Cursor is moved to start of area after clear
 */
void lcd_clear_area(uint8_t pages, uint8_t columns, uint8_t style) {
  uint8_t i,j,max;
  uint8_t inv = (style & INVERT_BIT)?0xFF:0;
     ce0:	06 2f       	mov	r16, r22
     ce2:	86 17       	cp	r24, r22
     ce4:	08 f4       	brcc	.+2      	; 0xce8 <lcd_clear_area+0x3c>
     ce6:	08 2f       	mov	r16, r24
  if(pages > (max = LCD_RAM_PAGES - lcd_get_position_page()))   
    pages = max;
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
    columns = max;
  
  for(j=0; j<pages; j++) {
     ce8:	dd 20       	and	r13, r13
     cea:	81 f4       	brne	.+32     	; 0xd0c <lcd_clear_area+0x60>
     cec:	19 c0       	rjmp	.+50     	; 0xd20 <lcd_clear_area+0x74>
    for(i=0; i<columns; i++) {
     cee:	1c 2d       	mov	r17, r12
      lcd_data(inv);
     cf0:	8f 2d       	mov	r24, r15
     cf2:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <lcd_data>
    pages = max;
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
    columns = max;
  
  for(j=0; j<pages; j++) {
    for(i=0; i<columns; i++) {
     cf6:	1f 5f       	subi	r17, 0xFF	; 255
     cf8:	10 17       	cp	r17, r16
     cfa:	d0 f3       	brcs	.-12     	; 0xcf0 <lcd_clear_area+0x44>
      lcd_data(inv);
      }
    lcd_move_xy(1,-columns);
     cfc:	81 e0       	ldi	r24, 0x01	; 1
     cfe:	be 01       	movw	r22, r28
     d00:	0e 94 15 05 	call	0xa2a	; 0xa2a <lcd_move_xy>
  if(pages > (max = LCD_RAM_PAGES - lcd_get_position_page()))   
    pages = max;
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
    columns = max;
  
  for(j=0; j<pages; j++) {
     d04:	e3 94       	inc	r14
     d06:	ed 14       	cp	r14, r13
     d08:	40 f0       	brcs	.+16     	; 0xd1a <lcd_clear_area+0x6e>
     d0a:	0a c0       	rjmp	.+20     	; 0xd20 <lcd_clear_area+0x74>
     d0c:	ee 24       	eor	r14, r14
    for(i=0; i<columns; i++) {
     d0e:	cc 24       	eor	r12, r12
      lcd_data(inv);
      }
    lcd_move_xy(1,-columns);
     d10:	c0 2f       	mov	r28, r16
     d12:	d0 e0       	ldi	r29, 0x00	; 0
     d14:	d0 95       	com	r29
     d16:	c1 95       	neg	r28
     d18:	df 4f       	sbci	r29, 0xFF	; 255
    pages = max;
  if(columns > (max = LCD_WIDTH - lcd_get_position_column()))   
    columns = max;
  
  for(j=0; j<pages; j++) {
    for(i=0; i<columns; i++) {
     d1a:	00 23       	and	r16, r16
     d1c:	41 f7       	brne	.-48     	; 0xcee <lcd_clear_area+0x42>
     d1e:	ee cf       	rjmp	.-36     	; 0xcfc <lcd_clear_area+0x50>
      lcd_data(inv);
      }
    lcd_move_xy(1,-columns);
    }
  lcd_move_xy(-pages,0);
     d20:	8d 2d       	mov	r24, r13
     d22:	81 95       	neg	r24
     d24:	60 e0       	ldi	r22, 0x00	; 0
     d26:	70 e0       	ldi	r23, 0x00	; 0
     d28:	0e 94 15 05 	call	0xa2a	; 0xa2a <lcd_move_xy>
  }
     d2c:	df 91       	pop	r29
     d2e:	cf 91       	pop	r28
     d30:	1f 91       	pop	r17
     d32:	0f 91       	pop	r16
     d34:	ff 90       	pop	r15
     d36:	ef 90       	pop	r14
     d38:	df 90       	pop	r13
     d3a:	cf 90       	pop	r12
     d3c:	08 95       	ret

00000d3e <lcd_clear_area_xy>:
 * style         - style modifier
 * col           - column of upper left corner
 * page          - page of upper left corner
 * Cursor is moved to start of area after clear
 */
void lcd_clear_area_xy(uint8_t pages, uint8_t columns, uint8_t style, uint8_t col, uint8_t page) {
     d3e:	ef 92       	push	r14
     d40:	ff 92       	push	r15
     d42:	0f 93       	push	r16
     d44:	1f 93       	push	r17
     d46:	f8 2e       	mov	r15, r24
     d48:	16 2f       	mov	r17, r22
     d4a:	e4 2e       	mov	r14, r20
     d4c:	82 2f       	mov	r24, r18
     d4e:	60 2f       	mov	r22, r16
  lcd_moveto_xy(col,page);
     d50:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <lcd_moveto_xy>
  lcd_clear_area(pages,columns,style);
     d54:	8f 2d       	mov	r24, r15
     d56:	61 2f       	mov	r22, r17
     d58:	4e 2d       	mov	r20, r14
     d5a:	0e 94 56 06 	call	0xcac	; 0xcac <lcd_clear_area>
  }
     d5e:	1f 91       	pop	r17
     d60:	0f 91       	pop	r16
     d62:	ff 90       	pop	r15
     d64:	ef 90       	pop	r14
     d66:	08 95       	ret

00000d68 <init_spi_lcd>:
  */
void init_spi_lcd() {
   
   
   //set MOSI and SCK as output pins
   DDRB |= (1<<PINB5)|(1<<PINB7);
     d68:	87 b3       	in	r24, 0x17	; 23
     d6a:	80 6a       	ori	r24, 0xA0	; 160
     d6c:	87 bb       	out	0x17, r24	; 23
   
   //set A0, LCD_Reset as outputs
   DDRA |= (1<<PINA5) | (1<<PINA4);
     d6e:	8a b3       	in	r24, 0x1a	; 26
     d70:	80 63       	ori	r24, 0x30	; 48
     d72:	8a bb       	out	0x1a, r24	; 26
   
   //set SS` as an output pin
   DDRB |= (1<<PINB4);
     d74:	bc 9a       	sbi	0x17, 4	; 23
		CPOL:   Clock Polarity -> leading edge  = falling edge
							   -> trailing edge = rising edge
		CPHA:	Clock Phase -> Leading edge  = setup
							   Trailing edge = sample
   */
   SPCR = (0<<SPIE) | (1<<SPE) | (0<<DORD) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA) | (0<<SPR1) | (0<<SPR0);
     d76:	8c e5       	ldi	r24, 0x5C	; 92
     d78:	8d b9       	out	0x0d, r24	; 13
         
   
   
   //SPI status register
   //SPI2X: Double SPI Speed Bit -> minimum SCK period will be two CPU clock periods
   SPSR = (1<<SPI2X);
     d7a:	81 e0       	ldi	r24, 0x01	; 1
     d7c:	8e b9       	out	0x0e, r24	; 14

   SPDR = LCD_NOP; //Do not use 0 here, only LCD_NOP is allowed!
     d7e:	83 ee       	ldi	r24, 0xE3	; 227
     d80:	8f b9       	out	0x0f, r24	; 15
   

   
   }
     d82:	08 95       	ret

00000d84 <lcd_init>:
/******************************************************************************
  * Initializes the display in 6 o'clock mode, 4x booster for 2.4-3.3V supply voltage
  * scheme according to datasheet
  * Suitable for all DOGS, DOGM and DOGL displays.
  */
void lcd_init() {
     d84:	ff 92       	push	r15
     d86:	0f 93       	push	r16
     d88:	1f 93       	push	r17
  //for better understanding -> write macros in clear text


  //set outputs
  //LCD_SET_PIN_DIRECTIONS();
  DDR_A0 |= (1<<PIN_A0);
     d8a:	d5 9a       	sbi	0x1a, 5	; 26
  DDR_RST |= (1<<PIN_RST);
     d8c:	d4 9a       	sbi	0x1a, 4	; 26
  DDR_CS  |= (1<<PIN_CS);
     d8e:	bc 9a       	sbi	0x17, 4	; 23
  
  
  //Initialize SPI Interface
  //LCD_INIT_SPI();   
  init_spi_lcd();
     d90:	0e 94 b4 06 	call	0xd68	; 0xd68 <init_spi_lcd>
    
  
  //Apply Reset to the Display Controller
  //LCD_RESET();
  PORT_RST &= ~(1<<PIN_RST);
     d94:	dc 98       	cbi	0x1b, 4	; 27
     d96:	8f ec       	ldi	r24, 0xCF	; 207
     d98:	97 e0       	ldi	r25, 0x07	; 7
     d9a:	01 97       	sbiw	r24, 0x01	; 1
     d9c:	f1 f7       	brne	.-4      	; 0xd9a <lcd_init+0x16>
     d9e:	00 c0       	rjmp	.+0      	; 0xda0 <lcd_init+0x1c>
     da0:	00 00       	nop
  _delay_ms(1);
  PORT_RST |= (1<<PIN_RST);
     da2:	dc 9a       	sbi	0x1b, 4	; 27
  
    
  //Load settings
  
  //(2)
  LCD_SET_FIRST_LINE(0);              //first bit in RAM is on the first line of the LCD
     da4:	80 e4       	ldi	r24, 0x40	; 64
     da6:	0e 94 f5 04 	call	0x9ea	; 0x9ea <lcd_command>
     daa:	8f ec       	ldi	r24, 0xCF	; 207
     dac:	97 e0       	ldi	r25, 0x07	; 7
     dae:	01 97       	sbiw	r24, 0x01	; 1
     db0:	f1 f7       	brne	.-4      	; 0xdae <lcd_init+0x2a>
     db2:	00 c0       	rjmp	.+0      	; 0xdb4 <lcd_init+0x30>
     db4:	00 00       	nop
  //without this delay the content is displayed mirror inverted
  _delay_ms(1); 


  //(8)     
  LCD_SET_BOTTOM_VIEW();              //6 o'clock mode, normal orientation
     db6:	81 ea       	ldi	r24, 0xA1	; 161
     db8:	0e 94 f5 04 	call	0x9ea	; 0x9ea <lcd_command>
  // |
  //  --> lcd_command(LCD_BOTTOMVIEW)
  //					-> LCD_BOTTOMVIEW = ADC reverse
  //_delay_ms(1);
  //(15)
  LCD_ORIENTATION_NORMAL();
     dbc:	80 ec       	ldi	r24, 0xC0	; 192
     dbe:	0e 94 f5 04 	call	0x9ea	; 0x9ea <lcd_command>
     dc2:	8f ec       	ldi	r24, 0xCF	; 207
     dc4:	97 e0       	ldi	r25, 0x07	; 7
     dc6:	01 97       	sbiw	r24, 0x01	; 1
     dc8:	f1 f7       	brne	.-4      	; 0xdc6 <lcd_init+0x42>
     dca:	00 c0       	rjmp	.+0      	; 0xdcc <lcd_init+0x48>
     dcc:	00 00       	nop
  // |
  //   --> lcd_command(LCD_SHOW_NORMAL)
  //					-> LCD_SHOW_NORMAL = display all points, normal display (10)
    
  //(9)	
  LCD_SET_MODE_POSITIVE();            //positive display
     dce:	86 ea       	ldi	r24, 0xA6	; 166
     dd0:	0e 94 f5 04 	call	0x9ea	; 0x9ea <lcd_command>
  //  --> lcd_command(LCD_DISPLAY_POSITIVE)
  //      				-> LCD_DISPLAY_POSITIVE = sets display normal (9)
   
  #if DISPLAY_TYPE == 132
    //(11)
    LCD_SET_BIAS_RATIO_1_9();           //bias 1/9
     dd4:	82 ea       	ldi	r24, 0xA2	; 162
     dd6:	0e 94 f5 04 	call	0x9ea	; 0x9ea <lcd_command>
    // |
	//  --> lcd_command(LCD_BIAS_1_9)
	
    //(16)	
	LCD_SET_POWER_CONTROL(7);           //power control mode: all features on
     dda:	8f e2       	ldi	r24, 0x2F	; 47
     ddc:	0e 94 f5 04 	call	0x9ea	; 0x9ea <lcd_command>
	//  --> lcd_command(LCD_POWER_CONTROL | ((i) & 0x07))  
	//						-> command 16 with operating mode = 0b111
	
	
	//(20) -> selbst eingefügtes macro
	LCD_SET_BOOSTER_RATIO();
     de0:	80 e0       	ldi	r24, 0x00	; 0
     de2:	0e 94 f5 04 	call	0x9ea	; 0x9ea <lcd_command>
	
	
	//(17)
	LCD_SET_BIAS_VOLTAGE(3);            //set voltage regulator R/R
     de6:	83 e2       	ldi	r24, 0x23	; 35
     de8:	0e 94 f5 04 	call	0x9ea	; 0x9ea <lcd_command>
	// |
	//   --> lcd_command(LCD_VOLTAGE | ((i) & 0x07))
	// 						-> command 17 with resistor ration 0b011
    
	//(18)
	LCD_SET_VOLUME_MODE(0x1F);          //volume mode set
     dec:	81 e8       	ldi	r24, 0x81	; 129
     dee:	0e 94 f5 04 	call	0x9ea	; 0x9ea <lcd_command>
     df2:	8f e1       	ldi	r24, 0x1F	; 31
     df4:	0e 94 f5 04 	call	0x9ea	; 0x9ea <lcd_command>
	//						-> standard command 18
	//  --> lcd_command(LCD_VOLUME_MODE_2 | ((i) & 0x3F))
	//						-> command 18 with electronic volume value 0b011111
	
	//(19)
	LCD_SET_INDICATOR_OFF();            //switch indicator off, no blinking
     df8:	8c ea       	ldi	r24, 0xAC	; 172
     dfa:	0e 94 f5 04 	call	0x9ea	; 0x9ea <lcd_command>
     dfe:	80 e0       	ldi	r24, 0x00	; 0
     e00:	0e 94 f5 04 	call	0x9ea	; 0x9ea <lcd_command>
  #endif
  
  
  uint8_t i,j;                        //clear display content
 
 for(j=0;j<LCD_RAM_PAGES;j++) {
     e04:	00 e0       	ldi	r16, 0x00	; 0
    lcd_moveto_xy(j,0);   // array (uint8_t page, uint8_t column)
     e06:	0f 2e       	mov	r0, r31
     e08:	f4 e8       	ldi	r31, 0x84	; 132
     e0a:	ff 2e       	mov	r15, r31
     e0c:	f0 2d       	mov	r31, r0
     e0e:	80 2f       	mov	r24, r16
     e10:	60 e0       	ldi	r22, 0x00	; 0
     e12:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <lcd_moveto_xy>
     e16:	1f 2d       	mov	r17, r15
    for (i=0;i<LCD_WIDTH;i++)
      lcd_data(0);
     e18:	80 e0       	ldi	r24, 0x00	; 0
     e1a:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <lcd_data>
     e1e:	11 50       	subi	r17, 0x01	; 1
  
  uint8_t i,j;                        //clear display content
 
 for(j=0;j<LCD_RAM_PAGES;j++) {
    lcd_moveto_xy(j,0);   // array (uint8_t page, uint8_t column)
    for (i=0;i<LCD_WIDTH;i++)
     e20:	d9 f7       	brne	.-10     	; 0xe18 <lcd_init+0x94>
  #endif
  
  
  uint8_t i,j;                        //clear display content
 
 for(j=0;j<LCD_RAM_PAGES;j++) {
     e22:	0f 5f       	subi	r16, 0xFF	; 255
     e24:	04 30       	cpi	r16, 0x04	; 4
     e26:	99 f7       	brne	.-26     	; 0xe0e <lcd_init+0x8a>
    lcd_moveto_xy(j,0);   // array (uint8_t page, uint8_t column)
    for (i=0;i<LCD_WIDTH;i++)
      lcd_data(0);
    }

  lcd_moveto_xy(0,0);                 //Set write pointer
     e28:	80 e0       	ldi	r24, 0x00	; 0
     e2a:	60 e0       	ldi	r22, 0x00	; 0
     e2c:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <lcd_moveto_xy>
  LCD_SWITCH_ON();                    //Switch display on (1)
     e30:	8f ea       	ldi	r24, 0xAF	; 175
     e32:	0e 94 f5 04 	call	0x9ea	; 0x9ea <lcd_command>
  return;
  }
     e36:	1f 91       	pop	r17
     e38:	0f 91       	pop	r16
     e3a:	ff 90       	pop	r15
     e3c:	08 95       	ret

00000e3e <lcd_set_font>:
 * Stores the default font type and style in a global variable
 * font          - Font identifier
 * style         - Style Modifier
 */
inline void lcd_set_font(FONT_P font, uint8_t style){
  global_font_select = font;
     e3e:	90 93 04 01 	sts	0x0104, r25
     e42:	80 93 03 01 	sts	0x0103, r24
  global_font_style = style;
     e46:	60 93 02 01 	sts	0x0102, r22
}
     e4a:	08 95       	ret

00000e4c <font_data>:
 * Loads the pointer to the selected fonts data
 */
inline PGM_P font_data(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->data));
     e4c:	fc 01       	movw	r30, r24
     e4e:	38 96       	adiw	r30, 0x08	; 8
     e50:	25 91       	lpm	r18, Z+
     e52:	34 91       	lpm	r19, Z+
  else
    memcpy_P((char*)&tmp,&(font->data),sizeof(tmp));
  return tmp;
  }
     e54:	82 2f       	mov	r24, r18
     e56:	93 2f       	mov	r25, r19
     e58:	08 95       	ret

00000e5a <font_widthtable>:
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     e5a:	fc 01       	movw	r30, r24
     e5c:	36 96       	adiw	r30, 0x06	; 6
     e5e:	25 91       	lpm	r18, Z+
     e60:	34 91       	lpm	r19, Z+
  else
    memcpy_P((char*)&tmp,&(font->widthtable),sizeof(tmp));
  return tmp;
  }
     e62:	82 2f       	mov	r24, r18
     e64:	93 2f       	mov	r25, r19
     e66:	08 95       	ret

00000e68 <font_get_height_bytes>:
/******************************************************************************
 * Loads the height (in bytes) of the given font
 */
inline uint8_t font_get_height_bytes(FONT_P font) {
  FONT_P tmp = font;
  uint8_t t = pgm_read_byte(&tmp->height);
     e68:	fc 01       	movw	r30, r24
     e6a:	33 96       	adiw	r30, 0x03	; 3
     e6c:	84 91       	lpm	r24, Z+
  return (((uint8_t)(t-1)>>3)+1);
     e6e:	81 50       	subi	r24, 0x01	; 1
     e70:	86 95       	lsr	r24
     e72:	86 95       	lsr	r24
     e74:	86 95       	lsr	r24
  }
     e76:	8f 5f       	subi	r24, 0xFF	; 255
     e78:	08 95       	ret

00000e7a <font_get_add_space>:
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     e7a:	fc 01       	movw	r30, r24
     e7c:	36 96       	adiw	r30, 0x06	; 6
     e7e:	25 91       	lpm	r18, Z+
     e80:	34 91       	lpm	r19, Z+
 * Decides if an additional space to the right of the character is needed
 */
inline uint8_t font_get_add_space(FONT_P font, char character) {
  PGM_P type = font_widthtable(font);
  if ( type != 0 ) //if there is a width table, then it's a proportional font
    return 1;
     e82:	81 e0       	ldi	r24, 0x01	; 1
     e84:	21 15       	cp	r18, r1
     e86:	31 05       	cpc	r19, r1
     e88:	09 f4       	brne	.+2      	; 0xe8c <font_get_add_space+0x12>
     e8a:	80 e0       	ldi	r24, 0x00	; 0
  else
    return 0;
  }
     e8c:	08 95       	ret

00000e8e <font_get_char_number>:
/******************************************************************************
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
     e8e:	fc 01       	movw	r30, r24
     e90:	35 96       	adiw	r30, 0x05	; 5
     e92:	e4 91       	lpm	r30, Z+
     e94:	e6 17       	cp	r30, r22
     e96:	50 f0       	brcs	.+20     	; 0xeac <font_get_char_number+0x1e>
    return -1;
  uint8_t first = pgm_read_byte(&tmp->firstchar);
     e98:	04 96       	adiw	r24, 0x04	; 4
     e9a:	fc 01       	movw	r30, r24
     e9c:	84 91       	lpm	r24, Z+
  if (character < first) 
     e9e:	68 17       	cp	r22, r24
     ea0:	40 f0       	brcs	.+16     	; 0xeb2 <font_get_char_number+0x24>
    return -1;
  return character - first;
     ea2:	26 2f       	mov	r18, r22
     ea4:	30 e0       	ldi	r19, 0x00	; 0
     ea6:	28 1b       	sub	r18, r24
     ea8:	31 09       	sbc	r19, r1
     eaa:	05 c0       	rjmp	.+10     	; 0xeb6 <font_get_char_number+0x28>
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
    return -1;
     eac:	2f ef       	ldi	r18, 0xFF	; 255
     eae:	3f ef       	ldi	r19, 0xFF	; 255
     eb0:	02 c0       	rjmp	.+4      	; 0xeb6 <font_get_char_number+0x28>
  uint8_t first = pgm_read_byte(&tmp->firstchar);
  if (character < first) 
    return -1;
     eb2:	2f ef       	ldi	r18, 0xFF	; 255
     eb4:	3f ef       	ldi	r19, 0xFF	; 255
  return character - first;
  }
     eb6:	82 2f       	mov	r24, r18
     eb8:	93 2f       	mov	r25, r19
     eba:	08 95       	ret

00000ebc <font_get_char_width>:
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     ebc:	fc 01       	movw	r30, r24
     ebe:	36 96       	adiw	r30, 0x06	; 6
     ec0:	25 91       	lpm	r18, Z+
     ec2:	34 91       	lpm	r19, Z+
/******************************************************************************
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
  PGM_P table = font_widthtable(font);
  if (table)
     ec4:	21 15       	cp	r18, r1
     ec6:	31 05       	cpc	r19, r1
     ec8:	c9 f0       	breq	.+50     	; 0xefc <font_get_char_width+0x40>
/******************************************************************************
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
     eca:	fc 01       	movw	r30, r24
     ecc:	35 96       	adiw	r30, 0x05	; 5
     ece:	e4 91       	lpm	r30, Z+
     ed0:	e6 17       	cp	r30, r22
     ed2:	50 f0       	brcs	.+20     	; 0xee8 <font_get_char_width+0x2c>
    return -1;
  uint8_t first = pgm_read_byte(&tmp->firstchar);
     ed4:	fc 01       	movw	r30, r24
     ed6:	34 96       	adiw	r30, 0x04	; 4
     ed8:	e4 91       	lpm	r30, Z+
  if (character < first) 
     eda:	6e 17       	cp	r22, r30
     edc:	40 f0       	brcs	.+16     	; 0xeee <font_get_char_width+0x32>
    return -1;
  return character - first;
     ede:	86 2f       	mov	r24, r22
     ee0:	90 e0       	ldi	r25, 0x00	; 0
     ee2:	8e 1b       	sub	r24, r30
     ee4:	91 09       	sbc	r25, r1
     ee6:	05 c0       	rjmp	.+10     	; 0xef2 <font_get_char_width+0x36>
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
    return -1;
     ee8:	8f ef       	ldi	r24, 0xFF	; 255
     eea:	9f ef       	ldi	r25, 0xFF	; 255
     eec:	02 c0       	rjmp	.+4      	; 0xef2 <font_get_char_width+0x36>
  uint8_t first = pgm_read_byte(&tmp->firstchar);
  if (character < first) 
    return -1;
     eee:	8f ef       	ldi	r24, 0xFF	; 255
     ef0:	9f ef       	ldi	r25, 0xFF	; 255
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
  PGM_P table = font_widthtable(font);
  if (table)
    return pgm_read_byte(table+font_get_char_number(font,character));
     ef2:	28 0f       	add	r18, r24
     ef4:	39 1f       	adc	r19, r25
     ef6:	f9 01       	movw	r30, r18
     ef8:	84 91       	lpm	r24, Z+
     efa:	08 95       	ret
  else
    return pgm_read_byte(&font->width);
     efc:	02 96       	adiw	r24, 0x02	; 2
     efe:	fc 01       	movw	r30, r24
     f00:	84 91       	lpm	r24, Z+
  }
     f02:	08 95       	ret

00000f04 <font_get_char_position>:


/******************************************************************************
 * Calculate the pointer to the requested character inside the Flash ROM
 */
PGM_P font_get_char_position(FONT_P font, char character) {
     f04:	cf 92       	push	r12
     f06:	df 92       	push	r13
     f08:	ef 92       	push	r14
     f0a:	ff 92       	push	r15
     f0c:	0f 93       	push	r16
     f0e:	1f 93       	push	r17
     f10:	cf 93       	push	r28
     f12:	df 93       	push	r29
/******************************************************************************
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
     f14:	ac 01       	movw	r20, r24
     f16:	4b 5f       	subi	r20, 0xFB	; 251
     f18:	5f 4f       	sbci	r21, 0xFF	; 255
     f1a:	fa 01       	movw	r30, r20
     f1c:	24 91       	lpm	r18, Z+
     f1e:	26 17       	cp	r18, r22
     f20:	08 f4       	brcc	.+2      	; 0xf24 <font_get_char_position+0x20>
     f22:	94 c0       	rjmp	.+296    	; 0x104c <font_get_char_position+0x148>
    return -1;
  uint8_t first = pgm_read_byte(&tmp->firstchar);
     f24:	ec 01       	movw	r28, r24
     f26:	24 96       	adiw	r28, 0x04	; 4
     f28:	fe 01       	movw	r30, r28
     f2a:	24 91       	lpm	r18, Z+
  if (character < first) 
     f2c:	62 17       	cp	r22, r18
     f2e:	08 f4       	brcc	.+2      	; 0xf32 <font_get_char_position+0x2e>
     f30:	8d c0       	rjmp	.+282    	; 0x104c <font_get_char_position+0x148>
    return -1;
  return character - first;
     f32:	e6 2e       	mov	r14, r22
     f34:	ff 24       	eor	r15, r15
     f36:	f7 01       	movw	r30, r14
     f38:	e2 1b       	sub	r30, r18
     f3a:	f1 09       	sbc	r31, r1
     f3c:	9f 01       	movw	r18, r30
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     f3e:	8c 01       	movw	r16, r24
     f40:	0a 5f       	subi	r16, 0xFA	; 250
     f42:	1f 4f       	sbci	r17, 0xFF	; 255
     f44:	f8 01       	movw	r30, r16
     f46:	a5 91       	lpm	r26, Z+
     f48:	b4 91       	lpm	r27, Z+
  uint16_t ret         = 0;
  int16_t  charnum_ret = font_get_char_number(font, character);
  uint8_t  charnum     = charnum_ret;
  PGM_P    base        = font_widthtable(font);

  if (charnum_ret < 0)     //char not found
     f4a:	33 23       	and	r19, r19
     f4c:	0c f4       	brge	.+2      	; 0xf50 <font_get_char_position+0x4c>
     f4e:	71 c0       	rjmp	.+226    	; 0x1032 <font_get_char_position+0x12e>
 * Calculate the pointer to the requested character inside the Flash ROM
 */
PGM_P font_get_char_position(FONT_P font, char character) {
  uint16_t ret         = 0;
  int16_t  charnum_ret = font_get_char_number(font, character);
  uint8_t  charnum     = charnum_ret;
     f50:	72 2f       	mov	r23, r18
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     f52:	9d 01       	movw	r18, r26
  uint8_t  charnum     = charnum_ret;
  PGM_P    base        = font_widthtable(font);

  if (charnum_ret < 0)     //char not found
    return 0;
  if(base == 0)            //fixed width
     f54:	10 97       	sbiw	r26, 0x00	; 0
     f56:	09 f0       	breq	.+2      	; 0xf5a <font_get_char_position+0x56>
     f58:	3e c0       	rjmp	.+124    	; 0xfd6 <font_get_char_position+0xd2>
 * Loads the pointer to the selected fonts data
 */
inline PGM_P font_data(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->data));
     f5a:	fc 01       	movw	r30, r24
     f5c:	38 96       	adiw	r30, 0x08	; 8
     f5e:	a5 91       	lpm	r26, Z+
     f60:	b4 91       	lpm	r27, Z+
     f62:	ca 2e       	mov	r12, r26
     f64:	db 2e       	mov	r13, r27
  PGM_P    base        = font_widthtable(font);

  if (charnum_ret < 0)     //char not found
    return 0;
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
     f66:	a7 2f       	mov	r26, r23
     f68:	b0 e0       	ldi	r27, 0x00	; 0
/******************************************************************************
 * Loads the height (in bytes) of the given font
 */
inline uint8_t font_get_height_bytes(FONT_P font) {
  FONT_P tmp = font;
  uint8_t t = pgm_read_byte(&tmp->height);
     f6a:	fc 01       	movw	r30, r24
     f6c:	33 96       	adiw	r30, 0x03	; 3
     f6e:	74 91       	lpm	r23, Z+
  return (((uint8_t)(t-1)>>3)+1);
     f70:	71 50       	subi	r23, 0x01	; 1
     f72:	76 95       	lsr	r23
     f74:	76 95       	lsr	r23
     f76:	76 95       	lsr	r23
     f78:	7f 5f       	subi	r23, 0xFF	; 255
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
     f7a:	f8 01       	movw	r30, r16
     f7c:	25 91       	lpm	r18, Z+
     f7e:	34 91       	lpm	r19, Z+
/******************************************************************************
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
  PGM_P table = font_widthtable(font);
  if (table)
     f80:	21 15       	cp	r18, r1
     f82:	31 05       	cpc	r19, r1
     f84:	b9 f0       	breq	.+46     	; 0xfb4 <font_get_char_position+0xb0>
/******************************************************************************
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
     f86:	fa 01       	movw	r30, r20
     f88:	44 91       	lpm	r20, Z+
     f8a:	46 17       	cp	r20, r22
     f8c:	48 f0       	brcs	.+18     	; 0xfa0 <font_get_char_position+0x9c>
    return -1;
  uint8_t first = pgm_read_byte(&tmp->firstchar);
     f8e:	fe 01       	movw	r30, r28
     f90:	84 91       	lpm	r24, Z+
  if (character < first) 
     f92:	68 17       	cp	r22, r24
     f94:	40 f0       	brcs	.+16     	; 0xfa6 <font_get_char_position+0xa2>
    return -1;
  return character - first;
     f96:	a7 01       	movw	r20, r14
     f98:	48 1b       	sub	r20, r24
     f9a:	51 09       	sbc	r21, r1
     f9c:	ca 01       	movw	r24, r20
     f9e:	05 c0       	rjmp	.+10     	; 0xfaa <font_get_char_position+0xa6>
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
    return -1;
     fa0:	8f ef       	ldi	r24, 0xFF	; 255
     fa2:	9f ef       	ldi	r25, 0xFF	; 255
     fa4:	02 c0       	rjmp	.+4      	; 0xfaa <font_get_char_position+0xa6>
  uint8_t first = pgm_read_byte(&tmp->firstchar);
  if (character < first) 
    return -1;
     fa6:	8f ef       	ldi	r24, 0xFF	; 255
     fa8:	9f ef       	ldi	r25, 0xFF	; 255
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
  PGM_P table = font_widthtable(font);
  if (table)
    return pgm_read_byte(table+font_get_char_number(font,character));
     faa:	28 0f       	add	r18, r24
     fac:	39 1f       	adc	r19, r25
     fae:	f9 01       	movw	r30, r18
     fb0:	84 91       	lpm	r24, Z+
     fb2:	03 c0       	rjmp	.+6      	; 0xfba <font_get_char_position+0xb6>
  else
    return pgm_read_byte(&font->width);
     fb4:	02 96       	adiw	r24, 0x02	; 2
     fb6:	fc 01       	movw	r30, r24
     fb8:	84 91       	lpm	r24, Z+
  PGM_P    base        = font_widthtable(font);

  if (charnum_ret < 0)     //char not found
    return 0;
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
     fba:	87 9f       	mul	r24, r23
     fbc:	80 2d       	mov	r24, r0
     fbe:	11 24       	eor	r1, r1
     fc0:	90 e0       	ldi	r25, 0x00	; 0
     fc2:	8a 9f       	mul	r24, r26
     fc4:	90 01       	movw	r18, r0
     fc6:	8b 9f       	mul	r24, r27
     fc8:	30 0d       	add	r19, r0
     fca:	9a 9f       	mul	r25, r26
     fcc:	30 0d       	add	r19, r0
     fce:	11 24       	eor	r1, r1
     fd0:	2c 0d       	add	r18, r12
     fd2:	3d 1d       	adc	r19, r13
     fd4:	30 c0       	rjmp	.+96     	; 0x1036 <font_get_char_position+0x132>
  if (charnum)             //proportional width
     fd6:	77 23       	and	r23, r23
     fd8:	99 f0       	breq	.+38     	; 0x1000 <font_get_char_position+0xfc>
    while(charnum--)
     fda:	71 50       	subi	r23, 0x01	; 1


/******************************************************************************
 * Calculate the pointer to the requested character inside the Flash ROM
 */
PGM_P font_get_char_position(FONT_P font, char character) {
     fdc:	47 2f       	mov	r20, r23
     fde:	50 e0       	ldi	r21, 0x00	; 0
     fe0:	4f 5f       	subi	r20, 0xFF	; 255
     fe2:	5f 4f       	sbci	r21, 0xFF	; 255
     fe4:	a4 0f       	add	r26, r20
     fe6:	b5 1f       	adc	r27, r21
     fe8:	40 e0       	ldi	r20, 0x00	; 0
     fea:	50 e0       	ldi	r21, 0x00	; 0
     fec:	f9 01       	movw	r30, r18
    return 0;
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
  if (charnum)             //proportional width
    while(charnum--)
      ret += pgm_read_byte(base++);
     fee:	2f 5f       	subi	r18, 0xFF	; 255
     ff0:	3f 4f       	sbci	r19, 0xFF	; 255
     ff2:	e4 91       	lpm	r30, Z+
     ff4:	4e 0f       	add	r20, r30
     ff6:	51 1d       	adc	r21, r1
  if (charnum_ret < 0)     //char not found
    return 0;
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
  if (charnum)             //proportional width
    while(charnum--)
     ff8:	2a 17       	cp	r18, r26
     ffa:	3b 07       	cpc	r19, r27
     ffc:	b9 f7       	brne	.-18     	; 0xfec <font_get_char_position+0xe8>
     ffe:	02 c0       	rjmp	.+4      	; 0x1004 <font_get_char_position+0x100>

/******************************************************************************
 * Calculate the pointer to the requested character inside the Flash ROM
 */
PGM_P font_get_char_position(FONT_P font, char character) {
  uint16_t ret         = 0;
    1000:	40 e0       	ldi	r20, 0x00	; 0
    1002:	50 e0       	ldi	r21, 0x00	; 0
 * Loads the pointer to the selected fonts data
 */
inline PGM_P font_data(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->data));
    1004:	fc 01       	movw	r30, r24
    1006:	38 96       	adiw	r30, 0x08	; 8
    1008:	25 91       	lpm	r18, Z+
    100a:	34 91       	lpm	r19, Z+
/******************************************************************************
 * Loads the height (in bytes) of the given font
 */
inline uint8_t font_get_height_bytes(FONT_P font) {
  FONT_P tmp = font;
  uint8_t t = pgm_read_byte(&tmp->height);
    100c:	03 96       	adiw	r24, 0x03	; 3
    100e:	fc 01       	movw	r30, r24
    1010:	84 91       	lpm	r24, Z+
  return (((uint8_t)(t-1)>>3)+1);
    1012:	81 50       	subi	r24, 0x01	; 1
    1014:	86 95       	lsr	r24
    1016:	86 95       	lsr	r24
    1018:	86 95       	lsr	r24
    101a:	8f 5f       	subi	r24, 0xFF	; 255
  if(base == 0)            //fixed width
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
  if (charnum)             //proportional width
    while(charnum--)
      ret += pgm_read_byte(base++);
  return (font_data(font))+ret*font_get_height_bytes(font);
    101c:	90 e0       	ldi	r25, 0x00	; 0
    101e:	84 9f       	mul	r24, r20
    1020:	60 01       	movw	r12, r0
    1022:	85 9f       	mul	r24, r21
    1024:	d0 0c       	add	r13, r0
    1026:	94 9f       	mul	r25, r20
    1028:	d0 0c       	add	r13, r0
    102a:	11 24       	eor	r1, r1
    102c:	2c 0d       	add	r18, r12
    102e:	3d 1d       	adc	r19, r13
    1030:	02 c0       	rjmp	.+4      	; 0x1036 <font_get_char_position+0x132>
  int16_t  charnum_ret = font_get_char_number(font, character);
  uint8_t  charnum     = charnum_ret;
  PGM_P    base        = font_widthtable(font);

  if (charnum_ret < 0)     //char not found
    return 0;
    1032:	20 e0       	ldi	r18, 0x00	; 0
    1034:	30 e0       	ldi	r19, 0x00	; 0
    return font_data(font) + (uint16_t)charnum * (uint8_t)(font_get_height_bytes(font) * font_get_char_width(font,character));
  if (charnum)             //proportional width
    while(charnum--)
      ret += pgm_read_byte(base++);
  return (font_data(font))+ret*font_get_height_bytes(font);
  }
    1036:	82 2f       	mov	r24, r18
    1038:	93 2f       	mov	r25, r19
    103a:	df 91       	pop	r29
    103c:	cf 91       	pop	r28
    103e:	1f 91       	pop	r17
    1040:	0f 91       	pop	r16
    1042:	ff 90       	pop	r15
    1044:	ef 90       	pop	r14
    1046:	df 90       	pop	r13
    1048:	cf 90       	pop	r12
    104a:	08 95       	ret
  int16_t  charnum_ret = font_get_char_number(font, character);
  uint8_t  charnum     = charnum_ret;
  PGM_P    base        = font_widthtable(font);

  if (charnum_ret < 0)     //char not found
    return 0;
    104c:	20 e0       	ldi	r18, 0x00	; 0
    104e:	30 e0       	ldi	r19, 0x00	; 0
    1050:	f2 cf       	rjmp	.-28     	; 0x1036 <font_get_char_position+0x132>

00001052 <lcd_put_char>:
 *****************************************************************************/

/******************************************************************************
 * Outputs a character on the display, using the given font and style
 */
uint8_t lcd_put_char(FONT_P font, uint8_t style, char character) {
    1052:	2f 92       	push	r2
    1054:	3f 92       	push	r3
    1056:	4f 92       	push	r4
    1058:	5f 92       	push	r5
    105a:	6f 92       	push	r6
    105c:	7f 92       	push	r7
    105e:	8f 92       	push	r8
    1060:	9f 92       	push	r9
    1062:	af 92       	push	r10
    1064:	bf 92       	push	r11
    1066:	cf 92       	push	r12
    1068:	df 92       	push	r13
    106a:	ef 92       	push	r14
    106c:	ff 92       	push	r15
    106e:	0f 93       	push	r16
    1070:	1f 93       	push	r17
    1072:	df 93       	push	r29
    1074:	cf 93       	push	r28
    1076:	cd b7       	in	r28, 0x3d	; 61
    1078:	de b7       	in	r29, 0x3e	; 62
    107a:	2d 97       	sbiw	r28, 0x0d	; 13
    107c:	0f b6       	in	r0, 0x3f	; 63
    107e:	f8 94       	cli
    1080:	de bf       	out	0x3e, r29	; 62
    1082:	0f be       	out	0x3f, r0	; 63
    1084:	cd bf       	out	0x3d, r28	; 61
    1086:	04 2f       	mov	r16, r20
  int8_t  i;
  uint8_t row  = 0;                             //current row of char
  uint8_t hc   = (style & DOUBLE_HEIGHT)?1:0;   //height changed
    1088:	88 24       	eor	r8, r8
    108a:	83 94       	inc	r8
    108c:	86 22       	and	r8, r22
  uint8_t wc   = (style & DOUBLE_WIDTH)?1:0;    //width changed
    108e:	16 2f       	mov	r17, r22
    1090:	99 24       	eor	r9, r9
    1092:	93 94       	inc	r9
    1094:	61 ff       	sbrs	r22, 1
    1096:	99 24       	eor	r9, r9
  uint8_t ul   = (style & UNDERLINE)?0x80:0x00; //underline
    1098:	14 ff       	sbrs	r17, 4
    109a:	05 c0       	rjmp	.+10     	; 0x10a6 <lcd_put_char+0x54>
    109c:	0f 2e       	mov	r0, r31
    109e:	f0 e8       	ldi	r31, 0x80	; 128
    10a0:	4f 2e       	mov	r4, r31
    10a2:	f0 2d       	mov	r31, r0
    10a4:	01 c0       	rjmp	.+2      	; 0x10a8 <lcd_put_char+0x56>
    10a6:	44 24       	eor	r4, r4
  uint8_t inv  = (style & INVERT)?0xFF:0;       //inverted
    10a8:	12 ff       	sbrs	r17, 2
    10aa:	03 c0       	rjmp	.+6      	; 0x10b2 <lcd_put_char+0x60>
    10ac:	77 24       	eor	r7, r7
    10ae:	7a 94       	dec	r7
    10b0:	01 c0       	rjmp	.+2      	; 0x10b4 <lcd_put_char+0x62>
    10b2:	77 24       	eor	r7, r7
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
    10b4:	9c 01       	movw	r18, r24
    10b6:	2a 5f       	subi	r18, 0xFA	; 250
    10b8:	3f 4f       	sbci	r19, 0xFF	; 255
    10ba:	f9 01       	movw	r30, r18
    10bc:	45 91       	lpm	r20, Z+
    10be:	54 91       	lpm	r21, Z+
/******************************************************************************
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
  PGM_P table = font_widthtable(font);
  if (table)
    10c0:	41 15       	cp	r20, r1
    10c2:	51 05       	cpc	r21, r1
    10c4:	c9 f0       	breq	.+50     	; 0x10f8 <lcd_put_char+0xa6>
/******************************************************************************
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
    10c6:	fc 01       	movw	r30, r24
    10c8:	35 96       	adiw	r30, 0x05	; 5
    10ca:	e4 91       	lpm	r30, Z+
    10cc:	e0 17       	cp	r30, r16
    10ce:	50 f0       	brcs	.+20     	; 0x10e4 <lcd_put_char+0x92>
    return -1;
  uint8_t first = pgm_read_byte(&tmp->firstchar);
    10d0:	fc 01       	movw	r30, r24
    10d2:	34 96       	adiw	r30, 0x04	; 4
    10d4:	e4 91       	lpm	r30, Z+
  if (character < first) 
    10d6:	0e 17       	cp	r16, r30
    10d8:	40 f0       	brcs	.+16     	; 0x10ea <lcd_put_char+0x98>
    return -1;
  return character - first;
    10da:	60 2f       	mov	r22, r16
    10dc:	70 e0       	ldi	r23, 0x00	; 0
    10de:	6e 1b       	sub	r22, r30
    10e0:	71 09       	sbc	r23, r1
    10e2:	05 c0       	rjmp	.+10     	; 0x10ee <lcd_put_char+0x9c>
 * Get the number of the character in the given font
 */
inline int16_t font_get_char_number(FONT_P font, char character) {
  FONT_P tmp = font;
  if (character > pgm_read_byte(&tmp->lastchar)) 
    return -1;
    10e4:	6f ef       	ldi	r22, 0xFF	; 255
    10e6:	7f ef       	ldi	r23, 0xFF	; 255
    10e8:	02 c0       	rjmp	.+4      	; 0x10ee <lcd_put_char+0x9c>
  uint8_t first = pgm_read_byte(&tmp->firstchar);
  if (character < first) 
    return -1;
    10ea:	6f ef       	ldi	r22, 0xFF	; 255
    10ec:	7f ef       	ldi	r23, 0xFF	; 255
 * Read the width of the selected character from the font width table
 */
inline uint8_t font_get_char_width(FONT_P font, char character) {
  PGM_P table = font_widthtable(font);
  if (table)
    return pgm_read_byte(table+font_get_char_number(font,character));
    10ee:	46 0f       	add	r20, r22
    10f0:	57 1f       	adc	r21, r23
    10f2:	fa 01       	movw	r30, r20
    10f4:	e4 90       	lpm	r14, Z+
    10f6:	03 c0       	rjmp	.+6      	; 0x10fe <lcd_put_char+0xac>
  else
    return pgm_read_byte(&font->width);
    10f8:	fc 01       	movw	r30, r24
    10fa:	32 96       	adiw	r30, 0x02	; 2
    10fc:	e4 90       	lpm	r14, Z+
/******************************************************************************
 * Loads the height (in bytes) of the given font
 */
inline uint8_t font_get_height_bytes(FONT_P font) {
  FONT_P tmp = font;
  uint8_t t = pgm_read_byte(&tmp->height);
    10fe:	fc 01       	movw	r30, r24
    1100:	33 96       	adiw	r30, 0x03	; 3
    1102:	64 90       	lpm	r6, Z+
  return (((uint8_t)(t-1)>>3)+1);
    1104:	6a 94       	dec	r6
    1106:	66 94       	lsr	r6
    1108:	66 94       	lsr	r6
    110a:	66 94       	lsr	r6
    110c:	63 94       	inc	r6
 * Loads the pointer to the width table for the selected font
 */
inline PGM_P font_widthtable(FONT_P font) {
  PGM_P tmp;
  if (sizeof(tmp) == 2)
    tmp = (PGM_P)pgm_read_word(&(font->widthtable));
    110e:	f9 01       	movw	r30, r18
    1110:	25 91       	lpm	r18, Z+
    1112:	34 91       	lpm	r19, Z+
 * Decides if an additional space to the right of the character is needed
 */
inline uint8_t font_get_add_space(FONT_P font, char character) {
  PGM_P type = font_widthtable(font);
  if ( type != 0 ) //if there is a width table, then it's a proportional font
    return 1;
    1114:	f1 e0       	ldi	r31, 0x01	; 1
    1116:	fa 83       	std	Y+2, r31	; 0x02
    1118:	21 15       	cp	r18, r1
    111a:	31 05       	cpc	r19, r1
    111c:	09 f4       	brne	.+2      	; 0x1120 <lcd_put_char+0xce>
    111e:	1a 82       	std	Y+2, r1	; 0x02

  //load information about character
   uint8_t char_width    = font_get_char_width(font,character); 
   uint8_t font_height   = font_get_height_bytes(font);
   uint8_t free_space    = font_get_add_space(font,character);
   PGM_P   tableposition = font_get_char_position(font,character);
    1120:	60 2f       	mov	r22, r16
    1122:	0e 94 82 07 	call	0xf04	; 0xf04 <font_get_char_position>
    1126:	5c 01       	movw	r10, r24

  //final size of character
  uint8_t char_final_width  = (uint8_t)(char_width+free_space) << wc;
    1128:	8a 81       	ldd	r24, Y+2	; 0x02
    112a:	8e 0d       	add	r24, r14
    112c:	09 2c       	mov	r0, r9
    112e:	01 c0       	rjmp	.+2      	; 0x1132 <lcd_put_char+0xe0>
    1130:	88 0f       	add	r24, r24
    1132:	0a 94       	dec	r0
    1134:	ea f7       	brpl	.-6      	; 0x1130 <lcd_put_char+0xde>
    1136:	88 87       	std	Y+8, r24	; 0x08
  uint8_t char_final_height = (uint8_t)font_height << hc; 
    1138:	c6 2c       	mov	r12, r6
    113a:	dd 24       	eor	r13, r13
    113c:	8d 82       	std	Y+5, r8	; 0x05
    113e:	26 2d       	mov	r18, r6
    1140:	08 2c       	mov	r0, r8
    1142:	01 c0       	rjmp	.+2      	; 0x1146 <lcd_put_char+0xf4>
    1144:	22 0f       	add	r18, r18
    1146:	0a 94       	dec	r0
    1148:	ea f7       	brpl	.-6      	; 0x1144 <lcd_put_char+0xf2>
    114a:	29 83       	std	Y+1, r18	; 0x01

  //check for avail. space on display
  if ((style & WRAP) && (LCD_CURRENT_COL() + char_final_width > LCD_WIDTH)) {
    114c:	13 ff       	sbrs	r17, 3
    114e:	12 c0       	rjmp	.+36     	; 0x1174 <lcd_put_char+0x122>
    1150:	80 91 70 00 	lds	r24, 0x0070
    1154:	90 e0       	ldi	r25, 0x00	; 0
    1156:	48 85       	ldd	r20, Y+8	; 0x08
    1158:	84 0f       	add	r24, r20
    115a:	91 1d       	adc	r25, r1
    115c:	85 38       	cpi	r24, 0x85	; 133
    115e:	91 05       	cpc	r25, r1
    1160:	4c f0       	brlt	.+18     	; 0x1174 <lcd_put_char+0x122>
    LCD_MOVE_TO(LCD_CURRENT_PAGE()+char_final_height,0);
    1162:	80 91 6f 00 	lds	r24, 0x006F
    1166:	82 0f       	add	r24, r18
    1168:	60 e0       	ldi	r22, 0x00	; 0
    116a:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <lcd_moveto_xy>
    if (character == ' ') return 0;
    116e:	00 32       	cpi	r16, 0x20	; 32
    1170:	09 f4       	brne	.+2      	; 0x1174 <lcd_put_char+0x122>
    1172:	95 c0       	rjmp	.+298    	; 0x129e <lcd_put_char+0x24c>
    }
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
    1174:	8e 2d       	mov	r24, r14
    1176:	90 e0       	ldi	r25, 0x00	; 0
    1178:	c8 9e       	mul	r12, r24
    117a:	70 01       	movw	r14, r0
    117c:	c9 9e       	mul	r12, r25
    117e:	f0 0c       	add	r15, r0
    1180:	d8 9e       	mul	r13, r24
    1182:	f0 0c       	add	r15, r0
    1184:	11 24       	eor	r1, r1
        LCD_WRITE(tmp);
      }
    if (free_space) {
      uint8_t c = inv;
      if(row == char_final_height-1) {
        c ^= ul; 
    1186:	87 2d       	mov	r24, r7
    1188:	84 25       	eor	r24, r4
        if(hc)
          c ^= ul>>1;      
    118a:	94 2d       	mov	r25, r4
    118c:	96 95       	lsr	r25
    118e:	22 24       	eor	r2, r2
    1190:	33 24       	eor	r3, r3
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
      tmp = pgm_read_byte(tableposition+i);
      if(row == char_final_height-1) 
    1192:	e9 81       	ldd	r30, Y+1	; 0x01
    1194:	ce 2e       	mov	r12, r30
    1196:	dd 24       	eor	r13, r13
    1198:	08 94       	sec
    119a:	c1 08       	sbc	r12, r1
    119c:	d1 08       	sbc	r13, r1
      LCD_WRITE(tmp);
      if(wc) 
        LCD_WRITE(tmp);
      }
    if (free_space) {
      uint8_t c = inv;
    119e:	79 86       	std	Y+9, r7	; 0x09
      if(row == char_final_height-1) {
        c ^= ul; 
    11a0:	8a 87       	std	Y+10, r24	; 0x0a
        if(hc)
          c ^= ul>>1;      
    11a2:	89 27       	eor	r24, r25
    11a4:	8b 87       	std	Y+11, r24	; 0x0b
        }
      LCD_WRITE(c);
      if(wc) 
        LCD_WRITE(c);
      }
    LCD_MOVE(1,-char_final_width);
    11a6:	98 85       	ldd	r25, Y+8	; 0x08
    11a8:	89 2f       	mov	r24, r25
    11aa:	90 e0       	ldi	r25, 0x00	; 0
    11ac:	9c 83       	std	Y+4, r25	; 0x04
    11ae:	8b 83       	std	Y+3, r24	; 0x03
    11b0:	90 95       	com	r25
    11b2:	81 95       	neg	r24
    11b4:	9f 4f       	sbci	r25, 0xFF	; 255
    11b6:	9f 83       	std	Y+7, r25	; 0x07
    11b8:	8e 83       	std	Y+6, r24	; 0x06
    if (free_space) {
      uint8_t c = inv;
      if(row == char_final_height-1) {
        c ^= ul; 
        if(hc)
          c ^= ul>>1;      
    11ba:	3d 86       	std	Y+13, r3	; 0x0d
    11bc:	2c 86       	std	Y+12, r2	; 0x0c
    if (character == ' ') return 0;
    }
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
    11be:	81 01       	movw	r16, r2
    11c0:	0d 80       	ldd	r0, Y+5	; 0x05
    11c2:	02 c0       	rjmp	.+4      	; 0x11c8 <lcd_put_char+0x176>
    11c4:	15 95       	asr	r17
    11c6:	07 95       	ror	r16
    11c8:	0a 94       	dec	r0
    11ca:	e2 f7       	brpl	.-8      	; 0x11c4 <lcd_put_char+0x172>
    11cc:	80 2f       	mov	r24, r16
    11ce:	99 27       	eor	r25, r25
    11d0:	87 fd       	sbrc	r24, 7
    11d2:	90 95       	com	r25
    11d4:	8e 15       	cp	r24, r14
    11d6:	9f 05       	cpc	r25, r15
    11d8:	a4 f5       	brge	.+104    	; 0x1242 <lcd_put_char+0x1f0>
      tmp = pgm_read_byte(tableposition+i);
      if(row == char_final_height-1) 
        tmp |= ul;
      if(hc)
        tmp = double_bits((row&1),tmp);
    11da:	55 24       	eor	r5, r5
    11dc:	53 94       	inc	r5
    11de:	52 20       	and	r5, r2
    }
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
      tmp = pgm_read_byte(tableposition+i);
    11e0:	e0 2f       	mov	r30, r16
    11e2:	ff 27       	eor	r31, r31
    11e4:	e7 fd       	sbrc	r30, 7
    11e6:	f0 95       	com	r31
    11e8:	ea 0d       	add	r30, r10
    11ea:	fb 1d       	adc	r31, r11
    11ec:	14 91       	lpm	r17, Z+
      if(row == char_final_height-1) 
    11ee:	8c 85       	ldd	r24, Y+12	; 0x0c
    11f0:	9d 85       	ldd	r25, Y+13	; 0x0d
    11f2:	c8 16       	cp	r12, r24
    11f4:	d9 06       	cpc	r13, r25
    11f6:	09 f4       	brne	.+2      	; 0x11fa <lcd_put_char+0x1a8>
        tmp |= ul;
    11f8:	14 29       	or	r17, r4
      if(hc)
    11fa:	88 20       	and	r8, r8
    11fc:	81 f0       	breq	.+32     	; 0x121e <lcd_put_char+0x1cc>
 * part = 1:  abcdefgh -> aabbccdd
 * Used for double height font
 */
inline unsigned char double_bits(uint8_t part, char c) {
  char t = 0;
  if (part) c = c>>4;
    11fe:	55 20       	and	r5, r5
    1200:	11 f0       	breq	.+4      	; 0x1206 <lcd_put_char+0x1b4>
    1202:	12 95       	swap	r17
    1204:	1f 70       	andi	r17, 0x0F	; 15
  if (c & 0x08) t  = 0xC0;
    1206:	81 2f       	mov	r24, r17
    1208:	13 fd       	sbrc	r17, 3
    120a:	02 c0       	rjmp	.+4      	; 0x1210 <lcd_put_char+0x1be>
 * part = 0:  abcdefgh -> eeffgghh
 * part = 1:  abcdefgh -> aabbccdd
 * Used for double height font
 */
inline unsigned char double_bits(uint8_t part, char c) {
  char t = 0;
    120c:	10 e0       	ldi	r17, 0x00	; 0
    120e:	01 c0       	rjmp	.+2      	; 0x1212 <lcd_put_char+0x1c0>
  if (part) c = c>>4;
  if (c & 0x08) t  = 0xC0;
    1210:	10 ec       	ldi	r17, 0xC0	; 192
  if (c & 0x04) t |= 0x30;
    1212:	82 fd       	sbrc	r24, 2
    1214:	10 63       	ori	r17, 0x30	; 48
  if (c & 0x02) t |= 0x0C;
    1216:	81 fd       	sbrc	r24, 1
    1218:	1c 60       	ori	r17, 0x0C	; 12
  if (c & 0x01) t |= 0x03;
    121a:	80 fd       	sbrc	r24, 0
    121c:	13 60       	ori	r17, 0x03	; 3
      tmp = pgm_read_byte(tableposition+i);
      if(row == char_final_height-1) 
        tmp |= ul;
      if(hc)
        tmp = double_bits((row&1),tmp);
      if(inv)
    121e:	71 10       	cpse	r7, r1
        tmp = ~tmp;
    1220:	10 95       	com	r17
      LCD_WRITE(tmp);
    1222:	81 2f       	mov	r24, r17
    1224:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <lcd_data>
      if(wc) 
    1228:	99 20       	and	r9, r9
    122a:	19 f0       	breq	.+6      	; 0x1232 <lcd_put_char+0x1e0>
        LCD_WRITE(tmp);
    122c:	81 2f       	mov	r24, r17
    122e:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <lcd_data>
 *****************************************************************************/

/******************************************************************************
 * Outputs a character on the display, using the given font and style
 */
uint8_t lcd_put_char(FONT_P font, uint8_t style, char character) {
    1232:	06 0d       	add	r16, r6
    if (character == ' ') return 0;
    }
  
  //write chracter
  do {
    for(i=(row>>hc); i<char_width*font_height; i+=font_height) {
    1234:	80 2f       	mov	r24, r16
    1236:	99 27       	eor	r25, r25
    1238:	87 fd       	sbrc	r24, 7
    123a:	90 95       	com	r25
    123c:	8e 15       	cp	r24, r14
    123e:	9f 05       	cpc	r25, r15
    1240:	7c f2       	brlt	.-98     	; 0x11e0 <lcd_put_char+0x18e>
        tmp = ~tmp;
      LCD_WRITE(tmp);
      if(wc) 
        LCD_WRITE(tmp);
      }
    if (free_space) {
    1242:	fa 81       	ldd	r31, Y+2	; 0x02
    1244:	ff 23       	and	r31, r31
    1246:	a1 f0       	breq	.+40     	; 0x1270 <lcd_put_char+0x21e>
      uint8_t c = inv;
      if(row == char_final_height-1) {
    1248:	8c 85       	ldd	r24, Y+12	; 0x0c
    124a:	9d 85       	ldd	r25, Y+13	; 0x0d
    124c:	c8 16       	cp	r12, r24
    124e:	d9 06       	cpc	r13, r25
    1250:	21 f4       	brne	.+8      	; 0x125a <lcd_put_char+0x208>
        c ^= ul; 
        if(hc)
    1252:	88 20       	and	r8, r8
    1254:	21 f0       	breq	.+8      	; 0x125e <lcd_put_char+0x20c>
          c ^= ul>>1;      
    1256:	1b 85       	ldd	r17, Y+11	; 0x0b
    1258:	03 c0       	rjmp	.+6      	; 0x1260 <lcd_put_char+0x20e>
      LCD_WRITE(tmp);
      if(wc) 
        LCD_WRITE(tmp);
      }
    if (free_space) {
      uint8_t c = inv;
    125a:	19 85       	ldd	r17, Y+9	; 0x09
    125c:	01 c0       	rjmp	.+2      	; 0x1260 <lcd_put_char+0x20e>
      if(row == char_final_height-1) {
        c ^= ul; 
    125e:	1a 85       	ldd	r17, Y+10	; 0x0a
        if(hc)
          c ^= ul>>1;      
        }
      LCD_WRITE(c);
    1260:	81 2f       	mov	r24, r17
    1262:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <lcd_data>
      if(wc) 
    1266:	99 20       	and	r9, r9
    1268:	19 f0       	breq	.+6      	; 0x1270 <lcd_put_char+0x21e>
        LCD_WRITE(c);
    126a:	81 2f       	mov	r24, r17
    126c:	0e 94 ea 04 	call	0x9d4	; 0x9d4 <lcd_data>
      }
    LCD_MOVE(1,-char_final_width);
    1270:	8b 81       	ldd	r24, Y+3	; 0x03
    1272:	9c 81       	ldd	r25, Y+4	; 0x04
    1274:	08 2f       	mov	r16, r24
    1276:	19 2f       	mov	r17, r25
    1278:	81 e0       	ldi	r24, 0x01	; 1
    127a:	6e 81       	ldd	r22, Y+6	; 0x06
    127c:	7f 81       	ldd	r23, Y+7	; 0x07
    127e:	0e 94 15 05 	call	0xa2a	; 0xa2a <lcd_move_xy>
    1282:	08 94       	sec
    1284:	21 1c       	adc	r2, r1
    1286:	31 1c       	adc	r3, r1
    } while (++row < char_final_height);
    1288:	99 81       	ldd	r25, Y+1	; 0x01
    128a:	29 16       	cp	r2, r25
    128c:	08 f4       	brcc	.+2      	; 0x1290 <lcd_put_char+0x23e>
    128e:	95 cf       	rjmp	.-214    	; 0x11ba <lcd_put_char+0x168>

  //move cursor to upper right corner of character
  LCD_MOVE(-char_final_height,char_final_width);
    1290:	89 2f       	mov	r24, r25
    1292:	81 95       	neg	r24
    1294:	60 2f       	mov	r22, r16
    1296:	71 2f       	mov	r23, r17
    1298:	0e 94 15 05 	call	0xa2a	; 0xa2a <lcd_move_xy>
  return char_final_width;
    129c:	01 c0       	rjmp	.+2      	; 0x12a0 <lcd_put_char+0x24e>
  uint8_t char_final_height = (uint8_t)font_height << hc; 

  //check for avail. space on display
  if ((style & WRAP) && (LCD_CURRENT_COL() + char_final_width > LCD_WIDTH)) {
    LCD_MOVE_TO(LCD_CURRENT_PAGE()+char_final_height,0);
    if (character == ' ') return 0;
    129e:	18 86       	std	Y+8, r1	; 0x08
    } while (++row < char_final_height);

  //move cursor to upper right corner of character
  LCD_MOVE(-char_final_height,char_final_width);
  return char_final_width;
  }
    12a0:	88 85       	ldd	r24, Y+8	; 0x08
    12a2:	2d 96       	adiw	r28, 0x0d	; 13
    12a4:	0f b6       	in	r0, 0x3f	; 63
    12a6:	f8 94       	cli
    12a8:	de bf       	out	0x3e, r29	; 62
    12aa:	0f be       	out	0x3f, r0	; 63
    12ac:	cd bf       	out	0x3d, r28	; 61
    12ae:	cf 91       	pop	r28
    12b0:	df 91       	pop	r29
    12b2:	1f 91       	pop	r17
    12b4:	0f 91       	pop	r16
    12b6:	ff 90       	pop	r15
    12b8:	ef 90       	pop	r14
    12ba:	df 90       	pop	r13
    12bc:	cf 90       	pop	r12
    12be:	bf 90       	pop	r11
    12c0:	af 90       	pop	r10
    12c2:	9f 90       	pop	r9
    12c4:	8f 90       	pop	r8
    12c6:	7f 90       	pop	r7
    12c8:	6f 90       	pop	r6
    12ca:	5f 90       	pop	r5
    12cc:	4f 90       	pop	r4
    12ce:	3f 90       	pop	r3
    12d0:	2f 90       	pop	r2
    12d2:	08 95       	ret

000012d4 <lcd_put_string_P>:

/******************************************************************************
 * Outputs a string on the display, loading it from the program memory,
 * using the given font and style
 */
uint16_t lcd_put_string_P(FONT_P font, uint8_t style, PGM_P str) {
    12d4:	df 92       	push	r13
    12d6:	ef 92       	push	r14
    12d8:	ff 92       	push	r15
    12da:	0f 93       	push	r16
    12dc:	1f 93       	push	r17
    12de:	cf 93       	push	r28
    12e0:	df 93       	push	r29
    12e2:	7c 01       	movw	r14, r24
    12e4:	d6 2e       	mov	r13, r22
    12e6:	ea 01       	movw	r28, r20
  unsigned char t;
  uint16_t length = 0;
  while((t = pgm_read_byte(str++))) 
    12e8:	fa 01       	movw	r30, r20
    12ea:	44 91       	lpm	r20, Z+
    12ec:	44 23       	and	r20, r20
    12ee:	79 f0       	breq	.+30     	; 0x130e <lcd_put_string_P+0x3a>
    12f0:	21 96       	adiw	r28, 0x01	; 1
 * Outputs a string on the display, loading it from the program memory,
 * using the given font and style
 */
uint16_t lcd_put_string_P(FONT_P font, uint8_t style, PGM_P str) {
  unsigned char t;
  uint16_t length = 0;
    12f2:	00 e0       	ldi	r16, 0x00	; 0
    12f4:	10 e0       	ldi	r17, 0x00	; 0
  while((t = pgm_read_byte(str++))) 
    length += lcd_put_char(font,style,t);
    12f6:	c7 01       	movw	r24, r14
    12f8:	6d 2d       	mov	r22, r13
    12fa:	0e 94 29 08 	call	0x1052	; 0x1052 <lcd_put_char>
    12fe:	08 0f       	add	r16, r24
    1300:	11 1d       	adc	r17, r1
    1302:	fe 01       	movw	r30, r28
 * using the given font and style
 */
uint16_t lcd_put_string_P(FONT_P font, uint8_t style, PGM_P str) {
  unsigned char t;
  uint16_t length = 0;
  while((t = pgm_read_byte(str++))) 
    1304:	21 96       	adiw	r28, 0x01	; 1
    1306:	44 91       	lpm	r20, Z+
    1308:	44 23       	and	r20, r20
    130a:	a9 f7       	brne	.-22     	; 0x12f6 <lcd_put_string_P+0x22>
    130c:	02 c0       	rjmp	.+4      	; 0x1312 <lcd_put_string_P+0x3e>
 * Outputs a string on the display, loading it from the program memory,
 * using the given font and style
 */
uint16_t lcd_put_string_P(FONT_P font, uint8_t style, PGM_P str) {
  unsigned char t;
  uint16_t length = 0;
    130e:	00 e0       	ldi	r16, 0x00	; 0
    1310:	10 e0       	ldi	r17, 0x00	; 0
  while((t = pgm_read_byte(str++))) 
    length += lcd_put_char(font,style,t);
  return length;
  }
    1312:	80 2f       	mov	r24, r16
    1314:	91 2f       	mov	r25, r17
    1316:	df 91       	pop	r29
    1318:	cf 91       	pop	r28
    131a:	1f 91       	pop	r17
    131c:	0f 91       	pop	r16
    131e:	ff 90       	pop	r15
    1320:	ef 90       	pop	r14
    1322:	df 90       	pop	r13
    1324:	08 95       	ret

00001326 <lcd_put_string>:

  
/******************************************************************************
 * Outputs a string on the display, using the given font and style
 */
uint16_t lcd_put_string(FONT_P font, uint8_t style, char* str) {
    1326:	df 92       	push	r13
    1328:	ef 92       	push	r14
    132a:	ff 92       	push	r15
    132c:	0f 93       	push	r16
    132e:	1f 93       	push	r17
    1330:	cf 93       	push	r28
    1332:	df 93       	push	r29
    1334:	7c 01       	movw	r14, r24
    1336:	d6 2e       	mov	r13, r22
    1338:	fa 01       	movw	r30, r20
  unsigned char t;
  uint16_t length = 0;
  while((t = *str++))
    133a:	40 81       	ld	r20, Z
    133c:	44 23       	and	r20, r20
    133e:	89 f0       	breq	.+34     	; 0x1362 <lcd_put_string+0x3c>
    1340:	8f 01       	movw	r16, r30
    1342:	0f 5f       	subi	r16, 0xFF	; 255
    1344:	1f 4f       	sbci	r17, 0xFF	; 255
/******************************************************************************
 * Outputs a string on the display, using the given font and style
 */
uint16_t lcd_put_string(FONT_P font, uint8_t style, char* str) {
  unsigned char t;
  uint16_t length = 0;
    1346:	c0 e0       	ldi	r28, 0x00	; 0
    1348:	d0 e0       	ldi	r29, 0x00	; 0
  while((t = *str++))
    length += lcd_put_char(font,style,t);
    134a:	c7 01       	movw	r24, r14
    134c:	6d 2d       	mov	r22, r13
    134e:	0e 94 29 08 	call	0x1052	; 0x1052 <lcd_put_char>
    1352:	c8 0f       	add	r28, r24
    1354:	d1 1d       	adc	r29, r1
 * Outputs a string on the display, using the given font and style
 */
uint16_t lcd_put_string(FONT_P font, uint8_t style, char* str) {
  unsigned char t;
  uint16_t length = 0;
  while((t = *str++))
    1356:	f8 01       	movw	r30, r16
    1358:	41 91       	ld	r20, Z+
    135a:	8f 01       	movw	r16, r30
    135c:	44 23       	and	r20, r20
    135e:	a9 f7       	brne	.-22     	; 0x134a <lcd_put_string+0x24>
    1360:	02 c0       	rjmp	.+4      	; 0x1366 <lcd_put_string+0x40>
/******************************************************************************
 * Outputs a string on the display, using the given font and style
 */
uint16_t lcd_put_string(FONT_P font, uint8_t style, char* str) {
  unsigned char t;
  uint16_t length = 0;
    1362:	c0 e0       	ldi	r28, 0x00	; 0
    1364:	d0 e0       	ldi	r29, 0x00	; 0
  while((t = *str++))
    length += lcd_put_char(font,style,t);
  return length;
  }
    1366:	7e 01       	movw	r14, r28
    1368:	8c 2f       	mov	r24, r28
    136a:	9f 2d       	mov	r25, r15
    136c:	df 91       	pop	r29
    136e:	cf 91       	pop	r28
    1370:	1f 91       	pop	r17
    1372:	0f 91       	pop	r16
    1374:	ff 90       	pop	r15
    1376:	ef 90       	pop	r14
    1378:	df 90       	pop	r13
    137a:	08 95       	ret

0000137c <lcd_put_string_length>:
  
/******************************************************************************
 * Outputs a string on the display, using the given font and style, reading
 * length characters from the memory
 */ 
uint16_t lcd_put_string_length(FONT_P font, uint8_t style, char* str, uint8_t length) {
    137c:	8f 92       	push	r8
    137e:	9f 92       	push	r9
    1380:	bf 92       	push	r11
    1382:	cf 92       	push	r12
    1384:	df 92       	push	r13
    1386:	ef 92       	push	r14
    1388:	ff 92       	push	r15
    138a:	0f 93       	push	r16
    138c:	1f 93       	push	r17
    138e:	cf 93       	push	r28
    1390:	df 93       	push	r29
    1392:	6c 01       	movw	r12, r24
    1394:	b6 2e       	mov	r11, r22
    1396:	f4 2e       	mov	r15, r20
    1398:	e2 2e       	mov	r14, r18
  unsigned char t;
  uint16_t total_len = 0;
  for(t=0;t<length;t++)
    139a:	22 23       	and	r18, r18
    139c:	99 f0       	breq	.+38     	; 0x13c4 <lcd_put_string_length+0x48>
    139e:	84 2e       	mov	r8, r20
    13a0:	e4 01       	movw	r28, r8
    13a2:	4e 01       	movw	r8, r28
    13a4:	95 2e       	mov	r9, r21
    13a6:	e4 01       	movw	r28, r8
 * Outputs a string on the display, using the given font and style, reading
 * length characters from the memory
 */ 
uint16_t lcd_put_string_length(FONT_P font, uint8_t style, char* str, uint8_t length) {
  unsigned char t;
  uint16_t total_len = 0;
    13a8:	00 e0       	ldi	r16, 0x00	; 0
    13aa:	10 e0       	ldi	r17, 0x00	; 0
  for(t=0;t<length;t++)
    total_len += lcd_put_char(font,style,*str++);
    13ac:	49 91       	ld	r20, Y+
    13ae:	c6 01       	movw	r24, r12
    13b0:	6b 2d       	mov	r22, r11
    13b2:	0e 94 29 08 	call	0x1052	; 0x1052 <lcd_put_char>
    13b6:	08 0f       	add	r16, r24
    13b8:	11 1d       	adc	r17, r1
 * length characters from the memory
 */ 
uint16_t lcd_put_string_length(FONT_P font, uint8_t style, char* str, uint8_t length) {
  unsigned char t;
  uint16_t total_len = 0;
  for(t=0;t<length;t++)
    13ba:	4e 01       	movw	r8, r28
    13bc:	8f 18       	sub	r8, r15
    13be:	8e 14       	cp	r8, r14
    13c0:	a8 f3       	brcs	.-22     	; 0x13ac <lcd_put_string_length+0x30>
    13c2:	02 c0       	rjmp	.+4      	; 0x13c8 <lcd_put_string_length+0x4c>
 * Outputs a string on the display, using the given font and style, reading
 * length characters from the memory
 */ 
uint16_t lcd_put_string_length(FONT_P font, uint8_t style, char* str, uint8_t length) {
  unsigned char t;
  uint16_t total_len = 0;
    13c4:	00 e0       	ldi	r16, 0x00	; 0
    13c6:	10 e0       	ldi	r17, 0x00	; 0
  for(t=0;t<length;t++)
    total_len += lcd_put_char(font,style,*str++);
  return total_len;
  }
    13c8:	80 2f       	mov	r24, r16
    13ca:	91 2f       	mov	r25, r17
    13cc:	df 91       	pop	r29
    13ce:	cf 91       	pop	r28
    13d0:	1f 91       	pop	r17
    13d2:	0f 91       	pop	r16
    13d4:	ff 90       	pop	r15
    13d6:	ef 90       	pop	r14
    13d8:	df 90       	pop	r13
    13da:	cf 90       	pop	r12
    13dc:	bf 90       	pop	r11
    13de:	9f 90       	pop	r9
    13e0:	8f 90       	pop	r8
    13e2:	08 95       	ret

000013e4 <lcd_put_string_xy_P>:
/******************************************************************************
 * Outputs a string on the display, using the given font and style, reading
 * the string from program memory. The position of the string on the display
 * is selected by page / col.
 */ 
uint16_t lcd_put_string_xy_P(FONT_P font, uint8_t style, PGM_P str,uint8_t page, uint8_t col) {
    13e4:	ef 92       	push	r14
    13e6:	ff 92       	push	r15
    13e8:	0f 93       	push	r16
    13ea:	1f 93       	push	r17
    13ec:	cf 93       	push	r28
    13ee:	df 93       	push	r29
    13f0:	ec 01       	movw	r28, r24
    13f2:	16 2f       	mov	r17, r22
    13f4:	7a 01       	movw	r14, r20
    13f6:	82 2f       	mov	r24, r18
    13f8:	60 2f       	mov	r22, r16
  LCD_MOVE_TO(page,col);
    13fa:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <lcd_moveto_xy>
  return lcd_put_string_P(font,style,str);
    13fe:	ce 01       	movw	r24, r28
    1400:	61 2f       	mov	r22, r17
    1402:	a7 01       	movw	r20, r14
    1404:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <lcd_put_string_P>
  }
    1408:	df 91       	pop	r29
    140a:	cf 91       	pop	r28
    140c:	1f 91       	pop	r17
    140e:	0f 91       	pop	r16
    1410:	ff 90       	pop	r15
    1412:	ef 90       	pop	r14
    1414:	08 95       	ret

00001416 <lcd_put_char_xy>:
/******************************************************************************
 * Outputs a string on the display, using the given font and style, reading
 * the string from main memory. The position of the string on the display
 * is selected by page / col.
 */ 
uint8_t lcd_put_char_xy(FONT_P font, uint8_t style, char character, uint8_t page, uint8_t col) {
    1416:	ff 92       	push	r15
    1418:	0f 93       	push	r16
    141a:	1f 93       	push	r17
    141c:	cf 93       	push	r28
    141e:	df 93       	push	r29
    1420:	ec 01       	movw	r28, r24
    1422:	f6 2e       	mov	r15, r22
    1424:	14 2f       	mov	r17, r20
    1426:	82 2f       	mov	r24, r18
    1428:	60 2f       	mov	r22, r16
  LCD_MOVE_TO(page,col);
    142a:	0e 94 fc 04 	call	0x9f8	; 0x9f8 <lcd_moveto_xy>
  return lcd_put_char(font,style,character);
    142e:	ce 01       	movw	r24, r28
    1430:	6f 2d       	mov	r22, r15
    1432:	41 2f       	mov	r20, r17
    1434:	0e 94 29 08 	call	0x1052	; 0x1052 <lcd_put_char>
  }
    1438:	df 91       	pop	r29
    143a:	cf 91       	pop	r28
    143c:	1f 91       	pop	r17
    143e:	0f 91       	pop	r16
    1440:	ff 90       	pop	r15
    1442:	08 95       	ret

00001444 <lcd_putc>:


/******************************************************************************
 * Outputs a character on the display, using the global font and style
 */ 
uint8_t  lcd_putc(char c) {
    1444:	48 2f       	mov	r20, r24
  return lcd_put_char(global_font_select, global_font_style, c);
    1446:	80 91 03 01 	lds	r24, 0x0103
    144a:	90 91 04 01 	lds	r25, 0x0104
    144e:	60 91 02 01 	lds	r22, 0x0102
    1452:	0e 94 29 08 	call	0x1052	; 0x1052 <lcd_put_char>
  }
    1456:	08 95       	ret

00001458 <lcd_putc_xy>:

/******************************************************************************
 * Outputs a character on the display, using the global font and style
 */ 
uint8_t  lcd_putc_xy(char c, uint8_t page, uint8_t col) {
    1458:	0f 93       	push	r16
    145a:	38 2f       	mov	r19, r24
    145c:	26 2f       	mov	r18, r22
    145e:	04 2f       	mov	r16, r20
  return lcd_put_char_xy(global_font_select, global_font_style, c, page, col);
    1460:	80 91 03 01 	lds	r24, 0x0103
    1464:	90 91 04 01 	lds	r25, 0x0104
    1468:	60 91 02 01 	lds	r22, 0x0102
    146c:	43 2f       	mov	r20, r19
    146e:	0e 94 0b 0a 	call	0x1416	; 0x1416 <lcd_put_char_xy>
  }  
    1472:	0f 91       	pop	r16
    1474:	08 95       	ret

00001476 <lcd_putstr>:
  
  
/******************************************************************************
 * Outputs a string on the display, using the global font and style
 */   
uint16_t lcd_putstr(char* str) {
    1476:	ac 01       	movw	r20, r24
  return lcd_put_string(global_font_select, global_font_style, str);
    1478:	80 91 03 01 	lds	r24, 0x0103
    147c:	90 91 04 01 	lds	r25, 0x0104
    1480:	60 91 02 01 	lds	r22, 0x0102
    1484:	0e 94 93 09 	call	0x1326	; 0x1326 <lcd_put_string>
  }
    1488:	08 95       	ret

0000148a <lcd_putstr_P>:
  
/******************************************************************************
 * Outputs a string stored in program memory on the display, using the global 
 * font and style
 */   
uint16_t lcd_putstr_P(PGM_P str) {
    148a:	ac 01       	movw	r20, r24
  return lcd_put_string_P(global_font_select, global_font_style, str);
    148c:	80 91 03 01 	lds	r24, 0x0103
    1490:	90 91 04 01 	lds	r25, 0x0104
    1494:	60 91 02 01 	lds	r22, 0x0102
    1498:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <lcd_put_string_P>
  }
    149c:	08 95       	ret

0000149e <lcd_putstr_xy_P>:

/******************************************************************************
 * Outputs a string on the display, using the global font and style at the 
 * given position
 */   
uint16_t lcd_putstr_xy_P(PGM_P  str, uint8_t page, uint8_t col) {
    149e:	0f 93       	push	r16
    14a0:	fc 01       	movw	r30, r24
    14a2:	26 2f       	mov	r18, r22
    14a4:	04 2f       	mov	r16, r20
  return lcd_put_string_xy_P(global_font_select, global_font_style, str, page, col);
    14a6:	80 91 03 01 	lds	r24, 0x0103
    14aa:	90 91 04 01 	lds	r25, 0x0104
    14ae:	60 91 02 01 	lds	r22, 0x0102
    14b2:	af 01       	movw	r20, r30
    14b4:	0e 94 f2 09 	call	0x13e4	; 0x13e4 <lcd_put_string_xy_P>
  }  
    14b8:	0f 91       	pop	r16
    14ba:	08 95       	ret

000014bc <lcd_put_long>:

#if INCLUDE_INTEGER_OUTPUT == 1
/******************************************************************************
 * Outputs a 32bit signed integer on the display // Added by Olli S.
 */ 
uint16_t lcd_put_long  (int32_t integer) {
    14bc:	0f 93       	push	r16
    14be:	1f 93       	push	r17
    14c0:	df 93       	push	r29
    14c2:	cf 93       	push	r28
    14c4:	cd b7       	in	r28, 0x3d	; 61
    14c6:	de b7       	in	r29, 0x3e	; 62
    14c8:	2a 97       	sbiw	r28, 0x0a	; 10
    14ca:	0f b6       	in	r0, 0x3f	; 63
    14cc:	f8 94       	cli
    14ce:	de bf       	out	0x3e, r29	; 62
    14d0:	0f be       	out	0x3f, r0	; 63
    14d2:	cd bf       	out	0x3d, r28	; 61
  char buffer[10];
	ltoa(integer, buffer, 10);
    14d4:	8e 01       	movw	r16, r28
    14d6:	0f 5f       	subi	r16, 0xFF	; 255
    14d8:	1f 4f       	sbci	r17, 0xFF	; 255
    14da:	a8 01       	movw	r20, r16
    14dc:	2a e0       	ldi	r18, 0x0A	; 10
    14de:	30 e0       	ldi	r19, 0x00	; 0
    14e0:	0e 94 84 0f 	call	0x1f08	; 0x1f08 <ltoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    14e4:	80 91 03 01 	lds	r24, 0x0103
    14e8:	90 91 04 01 	lds	r25, 0x0104
    14ec:	60 91 02 01 	lds	r22, 0x0102
    14f0:	a8 01       	movw	r20, r16
    14f2:	0e 94 93 09 	call	0x1326	; 0x1326 <lcd_put_string>
  }
    14f6:	2a 96       	adiw	r28, 0x0a	; 10
    14f8:	0f b6       	in	r0, 0x3f	; 63
    14fa:	f8 94       	cli
    14fc:	de bf       	out	0x3e, r29	; 62
    14fe:	0f be       	out	0x3f, r0	; 63
    1500:	cd bf       	out	0x3d, r28	; 61
    1502:	cf 91       	pop	r28
    1504:	df 91       	pop	r29
    1506:	1f 91       	pop	r17
    1508:	0f 91       	pop	r16
    150a:	08 95       	ret

0000150c <lcd_put_int>:

  
/******************************************************************************
 * Outputs a 16bit signed integer on the display // Added by Olli S.
 */   
uint16_t lcd_put_int (int16_t integer) {
    150c:	0f 93       	push	r16
    150e:	1f 93       	push	r17
    1510:	df 93       	push	r29
    1512:	cf 93       	push	r28
    1514:	cd b7       	in	r28, 0x3d	; 61
    1516:	de b7       	in	r29, 0x3e	; 62
    1518:	2a 97       	sbiw	r28, 0x0a	; 10
    151a:	0f b6       	in	r0, 0x3f	; 63
    151c:	f8 94       	cli
    151e:	de bf       	out	0x3e, r29	; 62
    1520:	0f be       	out	0x3f, r0	; 63
    1522:	cd bf       	out	0x3d, r28	; 61
  char buffer[10];
	itoa(integer, buffer, 10);
    1524:	8e 01       	movw	r16, r28
    1526:	0f 5f       	subi	r16, 0xFF	; 255
    1528:	1f 4f       	sbci	r17, 0xFF	; 255
    152a:	b8 01       	movw	r22, r16
    152c:	4a e0       	ldi	r20, 0x0A	; 10
    152e:	50 e0       	ldi	r21, 0x00	; 0
    1530:	0e 94 63 0f 	call	0x1ec6	; 0x1ec6 <itoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    1534:	80 91 03 01 	lds	r24, 0x0103
    1538:	90 91 04 01 	lds	r25, 0x0104
    153c:	60 91 02 01 	lds	r22, 0x0102
    1540:	a8 01       	movw	r20, r16
    1542:	0e 94 93 09 	call	0x1326	; 0x1326 <lcd_put_string>
  }  
    1546:	2a 96       	adiw	r28, 0x0a	; 10
    1548:	0f b6       	in	r0, 0x3f	; 63
    154a:	f8 94       	cli
    154c:	de bf       	out	0x3e, r29	; 62
    154e:	0f be       	out	0x3f, r0	; 63
    1550:	cd bf       	out	0x3d, r28	; 61
    1552:	cf 91       	pop	r28
    1554:	df 91       	pop	r29
    1556:	1f 91       	pop	r17
    1558:	0f 91       	pop	r16
    155a:	08 95       	ret

0000155c <lcd_put_uint>:

  
/******************************************************************************
 * Outputs a 16bit unsigned integer on the display // Added by Olli S.
 */   
uint16_t lcd_put_uint  (uint16_t integer) {
    155c:	0f 93       	push	r16
    155e:	1f 93       	push	r17
    1560:	df 93       	push	r29
    1562:	cf 93       	push	r28
    1564:	cd b7       	in	r28, 0x3d	; 61
    1566:	de b7       	in	r29, 0x3e	; 62
    1568:	2a 97       	sbiw	r28, 0x0a	; 10
    156a:	0f b6       	in	r0, 0x3f	; 63
    156c:	f8 94       	cli
    156e:	de bf       	out	0x3e, r29	; 62
    1570:	0f be       	out	0x3f, r0	; 63
    1572:	cd bf       	out	0x3d, r28	; 61
  char buffer[10];
	utoa(integer, buffer, 10);
    1574:	8e 01       	movw	r16, r28
    1576:	0f 5f       	subi	r16, 0xFF	; 255
    1578:	1f 4f       	sbci	r17, 0xFF	; 255
    157a:	b8 01       	movw	r22, r16
    157c:	4a e0       	ldi	r20, 0x0A	; 10
    157e:	50 e0       	ldi	r21, 0x00	; 0
    1580:	0e 94 b8 0f 	call	0x1f70	; 0x1f70 <utoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    1584:	80 91 03 01 	lds	r24, 0x0103
    1588:	90 91 04 01 	lds	r25, 0x0104
    158c:	60 91 02 01 	lds	r22, 0x0102
    1590:	a8 01       	movw	r20, r16
    1592:	0e 94 93 09 	call	0x1326	; 0x1326 <lcd_put_string>
  }  
    1596:	2a 96       	adiw	r28, 0x0a	; 10
    1598:	0f b6       	in	r0, 0x3f	; 63
    159a:	f8 94       	cli
    159c:	de bf       	out	0x3e, r29	; 62
    159e:	0f be       	out	0x3f, r0	; 63
    15a0:	cd bf       	out	0x3d, r28	; 61
    15a2:	cf 91       	pop	r28
    15a4:	df 91       	pop	r29
    15a6:	1f 91       	pop	r17
    15a8:	0f 91       	pop	r16
    15aa:	08 95       	ret

000015ac <lcd_put_short>:
  
/******************************************************************************
 * Outputs a 8bit signed integer on the display
 */   
uint16_t lcd_put_short (int8_t integer) {
    15ac:	0f 93       	push	r16
    15ae:	1f 93       	push	r17
    15b0:	df 93       	push	r29
    15b2:	cf 93       	push	r28
    15b4:	cd b7       	in	r28, 0x3d	; 61
    15b6:	de b7       	in	r29, 0x3e	; 62
    15b8:	2a 97       	sbiw	r28, 0x0a	; 10
    15ba:	0f b6       	in	r0, 0x3f	; 63
    15bc:	f8 94       	cli
    15be:	de bf       	out	0x3e, r29	; 62
    15c0:	0f be       	out	0x3f, r0	; 63
    15c2:	cd bf       	out	0x3d, r28	; 61
  char buffer[10];
	itoa(integer, buffer, 10);
    15c4:	99 27       	eor	r25, r25
    15c6:	87 fd       	sbrc	r24, 7
    15c8:	90 95       	com	r25
    15ca:	8e 01       	movw	r16, r28
    15cc:	0f 5f       	subi	r16, 0xFF	; 255
    15ce:	1f 4f       	sbci	r17, 0xFF	; 255
    15d0:	b8 01       	movw	r22, r16
    15d2:	4a e0       	ldi	r20, 0x0A	; 10
    15d4:	50 e0       	ldi	r21, 0x00	; 0
    15d6:	0e 94 63 0f 	call	0x1ec6	; 0x1ec6 <itoa>
	return lcd_put_string(global_font_select, global_font_style, buffer);
    15da:	80 91 03 01 	lds	r24, 0x0103
    15de:	90 91 04 01 	lds	r25, 0x0104
    15e2:	60 91 02 01 	lds	r22, 0x0102
    15e6:	a8 01       	movw	r20, r16
    15e8:	0e 94 93 09 	call	0x1326	; 0x1326 <lcd_put_string>
  }    
    15ec:	2a 96       	adiw	r28, 0x0a	; 10
    15ee:	0f b6       	in	r0, 0x3f	; 63
    15f0:	f8 94       	cli
    15f2:	de bf       	out	0x3e, r29	; 62
    15f4:	0f be       	out	0x3f, r0	; 63
    15f6:	cd bf       	out	0x3d, r28	; 61
    15f8:	cf 91       	pop	r28
    15fa:	df 91       	pop	r29
    15fc:	1f 91       	pop	r17
    15fe:	0f 91       	pop	r16
    1600:	08 95       	ret

00001602 <privTcbList>:
static TtaskControlBlock * privTcbList(Tuint08 uiTaskNumber)
{ /* This method may not be called with defCurrentTaskNumber any longer. Unfortunately we
   * cannot check if we violate that, because that may corrupt stack in privInitOs().
   * The location of the task control block is stored in flash, be careful, use the correct
   * instructions to retrieve it. */
  return portFlashReadWord(TtaskControlBlock *,pxTCBlist[uiTaskNumber]); }
    1602:	e8 2f       	mov	r30, r24
    1604:	f0 e0       	ldi	r31, 0x00	; 0
    1606:	ee 0f       	add	r30, r30
    1608:	ff 1f       	adc	r31, r31
    160a:	e2 58       	subi	r30, 0x82	; 130
    160c:	f9 4f       	sbci	r31, 0xF9	; 249
    160e:	25 91       	lpm	r18, Z+
    1610:	34 91       	lpm	r19, Z+
    1612:	82 2f       	mov	r24, r18
    1614:	93 2f       	mov	r25, r19
    1616:	08 95       	ret

00001618 <privTaskNumber>:


static Tuint08 privTaskNumber(Tuint08 uiTaskNumber)
{ /* Check if we are interested in the current task */
  if ((uiTaskNumber & defCurrentTaskMask) == defCurrentTaskNumber)
    1618:	88 23       	and	r24, r24
    161a:	1c f4       	brge	.+6      	; 0x1622 <privTaskNumber+0xa>
  { /* If yes, replace the uiTaskNumber with the current task number. */
    uiTaskNumber = (uiOsStatus & defTaskNumberGetMask) >> defOsTaskNumberShift; }
    161c:	80 91 0b 01 	lds	r24, 0x010B
    1620:	8f 70       	andi	r24, 0x0F	; 15
  return uiTaskNumber; }
    1622:	08 95       	ret

00001624 <privEnterOS>:
   * action parameter states the intention of the caller. It contains whether or not we should
   * switch the task, and if a tick occurred.
   * Report that we are starting OS specific actions */
  privTrace(traceOsStart);
  /* Now is the time to permanently set the status of the system to OS. */
  uiOsStatus = ((uiOsStatus & defContextSetMask) | defContextStateOs);
    1624:	20 91 0b 01 	lds	r18, 0x010B
    1628:	2f 73       	andi	r18, 0x3F	; 63
    162a:	20 93 0b 01 	sts	0x010B, r18
  #endif
  /* If we do not want to switch, we are quickly done. Note that time measurement is also
   * skipped, so, we may not skip this to often, often being a full round of the subticktimer.
   * Normally however, this is a one time action, because a regular entry over here due to
   * an interrupt will not skip this section. */
  if ((uiAction & defActionTaskGetMask) == defActionTaskStateSwitch)
    162e:	80 ff       	sbrs	r24, 0
    1630:	76 c0       	rjmp	.+236    	; 0x171e <privEnterOS+0xfa>
          uiIdleLoadCollect += uiTaskTime; }
      #endif
      /* Here we arrive at the first instruction when all checks are off. We increment the tick counter
       * if a timer interrupt has taken place. This is indicated the the uiAction parameter. Most times
       * we arrive here it is namely due to a yield of delay or so, and we can skip that step. */
      if ((uiAction & defActionTickStateTick) == defActionTickStateTick) { privIncrementTick(); }
    1632:	81 ff       	sbrs	r24, 1
    1634:	35 c0       	rjmp	.+106    	; 0x16a0 <privEnterOS+0x7c>
      uxTickCount.SubByte -= cfgSysSubTicksPerFullTick;
    #endif
    /* Every time we arrive here we must increase the tick counter by one. Or we arrived here because
     * subbyte overflowed the cfgSysSubTicksPerFullTick or we arrived here because we were send here
     * from a tick interrupt. */
    ++uxTickCount.LowByte;
    1636:	80 91 09 01 	lds	r24, 0x0109
    163a:	8f 5f       	subi	r24, 0xFF	; 255
    163c:	80 93 09 01 	sts	0x0109, r24
    #if (callAppTick00 == cfgTrue)
      appTick00();
    #endif

    /* if the low byte overflows ... */
    if (uxTickCount.LowByte == 0 )
    1640:	88 23       	and	r24, r24
    1642:	41 f4       	brne	.+16     	; 0x1654 <privEnterOS+0x30>
    { /* ... Increase the high byte */
      ++uxTickCount.HighByte;
    1644:	80 91 0a 01 	lds	r24, 0x010A
    1648:	8f 5f       	subi	r24, 0xFF	; 255
    164a:	80 93 0a 01 	sts	0x010A, r24
      #if (callAppTick16 == cfgTrue)
        if (uxTickCount.HighByte == 0) { appTick16(); }
      #endif
      /* On every cross of the low byte boundary, new tasks may have entered the near wake
       * state, thus we must set the corresponding bit. */
      uiOsStatus = ((uiOsStatus & defNearWakeStateSetMask) | defNearWakeStatePresent);
    164e:	20 62       	ori	r18, 0x20	; 32
    1650:	20 93 0b 01 	sts	0x010B, r18
    #endif
    #if (defUseDelay == cfgTrue)
      /* Now we must check if we must wake some delayed tasks, this only is the case when we
       * have near wakes. The mechanism of near wakes is made in order not to have to check all
       * tasks on every tick */
      if ((uiOsStatus & defNearWakeStateGetMask) == defNearWakeStatePresent)
    1654:	80 91 0b 01 	lds	r24, 0x010B
    1658:	85 ff       	sbrs	r24, 5
    165a:	22 c0       	rjmp	.+68     	; 0x16a0 <privEnterOS+0x7c>
            if (loopTCB->uxDelay.HighByte == uxTickCount.HighByte)
            { /* if it matches, we assume that the task must be waked, since we do not allow so long delays that the
               * end time is, after overflow, just before the current time in the same block. (The need for this has
               * several reasons, one of which is that this allows us to skip ticks within a tick block. It is needed
               * for recovery from low power sleep too. The former facility is not really used right now */
              if (loopTCB->uxDelay.LowByte <= uxTickCount.LowByte)
    165c:	e0 90 09 01 	lds	r14, 0x0109
    1660:	00 e0       	ldi	r16, 0x00	; 0
    1662:	10 e0       	ldi	r17, 0x00	; 0
          /* We check if the task is delayed. Note that it need not to be running. If the task was suspended or
           * sleeping while delayed, this delay simply ends, but the task remains suspended/sleeping. The same
           * applies for killed tasks. Tasks that are blocked may have a timeout, so this must be checked as well. */
          if ((loopTCB->uiTaskStatus & defBaseDelayStateGetMask) == defBaseDelayStateDelayed)
          { /* a task from which the high byte does not much is not near wake */
            if (loopTCB->uxDelay.HighByte == uxTickCount.HighByte)
    1664:	ca e0       	ldi	r28, 0x0A	; 10
    1666:	d1 e0       	ldi	r29, 0x01	; 1
      if ((uiOsStatus & defNearWakeStateGetMask) == defNearWakeStatePresent)
      { Tuint08 uiNearWakeCount = 0;
        Tuint08 uiLoopTask;
        /* we must find out which tasks are near wake, thus we must check all tasks */
        for (uiLoopTask=defTaskNumberDelayBegin; uiLoopTask<defTaskNumberDelayEnd; uiLoopTask++)
        { TtaskControlBlock * loopTCB = privTcbList(uiLoopTask);
    1668:	81 2f       	mov	r24, r17
    166a:	0e 94 01 0b 	call	0x1602	; 0x1602 <privTcbList>
    166e:	fc 01       	movw	r30, r24
          /* We check if the task is delayed. Note that it need not to be running. If the task was suspended or
           * sleeping while delayed, this delay simply ends, but the task remains suspended/sleeping. The same
           * applies for killed tasks. Tasks that are blocked may have a timeout, so this must be checked as well. */
          if ((loopTCB->uiTaskStatus & defBaseDelayStateGetMask) == defBaseDelayStateDelayed)
    1670:	81 81       	ldd	r24, Z+1	; 0x01
    1672:	84 fd       	sbrc	r24, 4
    1674:	0b c0       	rjmp	.+22     	; 0x168c <privEnterOS+0x68>
          { /* a task from which the high byte does not much is not near wake */
            if (loopTCB->uxDelay.HighByte == uxTickCount.HighByte)
    1676:	23 81       	ldd	r18, Z+3	; 0x03
    1678:	98 81       	ld	r25, Y
    167a:	29 17       	cp	r18, r25
    167c:	39 f4       	brne	.+14     	; 0x168c <privEnterOS+0x68>
            { /* if it matches, we assume that the task must be waked, since we do not allow so long delays that the
               * end time is, after overflow, just before the current time in the same block. (The need for this has
               * several reasons, one of which is that this allows us to skip ticks within a tick block. It is needed
               * for recovery from low power sleep too. The former facility is not really used right now */
              if (loopTCB->uxDelay.LowByte <= uxTickCount.LowByte)
    167e:	92 81       	ldd	r25, Z+2	; 0x02
    1680:	e9 16       	cp	r14, r25
    1682:	18 f0       	brcs	.+6      	; 0x168a <privEnterOS+0x66>
        privUnblockTask(uiTaskNumber | defParaLockStateUnlock | defParaRetStateFalse); }
      /* The unblocking above also wakes the task so we may skip it here. */
      else
   #endif
   /* wake the task */
   { taskTCB->uiTaskStatus = (taskTCB->uiTaskStatus & defBaseDelayStateSetMask) | defBaseDelayStateWake; } }
    1684:	80 61       	ori	r24, 0x10	; 16
    1686:	81 83       	std	Z+1, r24	; 0x01
    1688:	01 c0       	rjmp	.+2      	; 0x168c <privEnterOS+0x68>
              { /* We have a winner, we may give a wakeup call, but first we check synchronization */
                privWakeupFromDelay(uiLoopTask,loopTCB); }
              else
              { /* arriving here means the particular task has a wake time in the near future, thus we may
                 * increase the near wake counter. */
                ++uiNearWakeCount; } } } }
    168a:	0f 5f       	subi	r16, 0xFF	; 255
       * tasks on every tick */
      if ((uiOsStatus & defNearWakeStateGetMask) == defNearWakeStatePresent)
      { Tuint08 uiNearWakeCount = 0;
        Tuint08 uiLoopTask;
        /* we must find out which tasks are near wake, thus we must check all tasks */
        for (uiLoopTask=defTaskNumberDelayBegin; uiLoopTask<defTaskNumberDelayEnd; uiLoopTask++)
    168c:	1f 5f       	subi	r17, 0xFF	; 255
    168e:	12 30       	cpi	r17, 0x02	; 2
    1690:	59 f7       	brne	.-42     	; 0x1668 <privEnterOS+0x44>
                 * increase the near wake counter. */
                ++uiNearWakeCount; } } } }
        /* If we had no more near wakes we may clear the near wake bit. If we do not do this, it remains set, as
         * it was for certain when arriving here. If we clear the bit will be set again when we enter the
         * next tick block. */
        if (uiNearWakeCount==0) { uiOsStatus = ((uiOsStatus & defNearWakeStateSetMask) | defNearWakeStateAbsent); } }
    1692:	00 23       	and	r16, r16
    1694:	29 f4       	brne	.+10     	; 0x16a0 <privEnterOS+0x7c>
    1696:	80 91 0b 01 	lds	r24, 0x010B
    169a:	8f 7d       	andi	r24, 0xDF	; 223
    169c:	80 93 0b 01 	sts	0x010B, r24
   * priority information is just before the bit 0, which determines the run state, all
   * tasks with equal priority are issued round robin. Tasks with a status below defRunableTask
   * will never be started, they are typically the blocked, delayed suspended, error or
   * sleeping tasks. */
  for (uiLoopTask=uiLoopStart; uiLoopTask<uiLoopEnd; uiLoopTask++)
  { TtaskControlBlock * loopTCB = privTcbList(uiLoopTask);
    16a0:	80 e0       	ldi	r24, 0x00	; 0
    16a2:	0e 94 01 0b 	call	0x1602	; 0x1602 <privTcbList>
    16a6:	7c 01       	movw	r14, r24
    Tuint08 uiCompareStatus = loopTCB->uiTaskStatus ^ uiFlipMask;
    16a8:	dc 01       	movw	r26, r24
    16aa:	11 96       	adiw	r26, 0x01	; 1
    16ac:	0c 91       	ld	r16, X
    16ae:	11 97       	sbiw	r26, 0x01	; 1
    16b0:	1f ee       	ldi	r17, 0xEF	; 239
    16b2:	10 17       	cp	r17, r16
    16b4:	08 f4       	brcc	.+2      	; 0x16b8 <privEnterOS+0x94>
    16b6:	10 2f       	mov	r17, r16
   * priority information is just before the bit 0, which determines the run state, all
   * tasks with equal priority are issued round robin. Tasks with a status below defRunableTask
   * will never be started, they are typically the blocked, delayed suspended, error or
   * sleeping tasks. */
  for (uiLoopTask=uiLoopStart; uiLoopTask<uiLoopEnd; uiLoopTask++)
  { TtaskControlBlock * loopTCB = privTcbList(uiLoopTask);
    16b8:	81 e0       	ldi	r24, 0x01	; 1
    16ba:	0e 94 01 0b 	call	0x1602	; 0x1602 <privTcbList>
    16be:	ec 01       	movw	r28, r24
    Tuint08 uiCompareStatus = loopTCB->uiTaskStatus ^ uiFlipMask;
    16c0:	89 81       	ldd	r24, Y+1	; 0x01
    /* The 'smaller sign' is important here, only if the priority exceeds the smallest possible
     * runnable task a replacement must take place. */
    if (result.MaxStatus < uiCompareStatus)
    16c2:	18 17       	cp	r17, r24
    16c4:	18 f0       	brcs	.+6      	; 0x16cc <privEnterOS+0xa8>
    16c6:	81 2f       	mov	r24, r17
    16c8:	10 e0       	ldi	r17, 0x00	; 0
    16ca:	01 c0       	rjmp	.+2      	; 0x16ce <privEnterOS+0xaa>
    16cc:	11 e0       	ldi	r17, 0x01	; 1
      Tselect uiExecute = uiShareSelect;
    #else
      /* If there are also standard tasks, we must make a new selection about which task to run. */
      Tselect uiExecute = privSelectTask(0x00,0,defNumberOfTasks);
    #endif
    if (uiExecute.MaxStatus == (defBaseRunningTask - 1))
    16ce:	8f 3e       	cpi	r24, 0xEF	; 239
    16d0:	c9 f0       	breq	.+50     	; 0x1704 <privEnterOS+0xe0>
    else
    { /* If you arrive here, then there is a task to be run. There are two possibilities. If all tasks
       * run in the shared mode, then there can only one task be active, so we do not need to select any
       * more, the only task must be the one, otherwise the task was selected in the selection process
       * thereafter. */
      TtaskControlBlock * runTCB = privTcbList(uiExecute.MaxTask);
    16d2:	81 2f       	mov	r24, r17
    16d4:	0e 94 01 0b 	call	0x1602	; 0x1602 <privTcbList>
    16d8:	fc 01       	movw	r30, r24
      #if (defAllSharedStack == cfgFalse)
      /* If not, it could be that all tasks in the current priority have already run,
       * so that we selected a task in the state defRunStateDone. If this is the case
       * then we know vice versa that all tasks in that priority have that state,
       * for otherwise it would have been selected due to the higher value of the status byte. */
        if ((runTCB->uiTaskStatus & defBaseDressGetMask) == defBaseDressDone)
    16da:	81 81       	ldd	r24, Z+1	; 0x01
    16dc:	80 fd       	sbrc	r24, 0
    16de:	08 c0       	rjmp	.+16     	; 0x16f0 <privEnterOS+0xcc>
        #if (cfgUseHierarchicalRoundRobin == cfgTrue)
        /* We may only reset those tasks in the requested priority. (Note we test the shifted priority because it
         * is faster on this side and on the callers side.) */
        if ((loopTCB->uiTaskStatus & defBasePrioGetMask) == uiPriority)
        #endif
        { loopTCB->uiTaskStatus = (loopTCB->uiTaskStatus & defBaseDressSetMask) | defBaseDressRunable; } } } }
    16e0:	01 60       	ori	r16, 0x01	; 1
    16e2:	d7 01       	movw	r26, r14
    16e4:	11 96       	adiw	r26, 0x01	; 1
    16e6:	0c 93       	st	X, r16
    16e8:	11 97       	sbiw	r26, 0x01	; 1
    16ea:	89 81       	ldd	r24, Y+1	; 0x01
    16ec:	81 60       	ori	r24, 0x01	; 1
    16ee:	89 83       	std	Y+1, r24	; 0x01
          #endif
        }
      #endif
      /* The state immediately needs to be set to the done state, to prohibit indefinite running, since,
       * when the dress bit is set this indicates a dominant mode. */
      runTCB->uiTaskStatus = (runTCB->uiTaskStatus & defBaseDressSetMask) | defBaseDressDone;
    16f0:	81 81       	ldd	r24, Z+1	; 0x01
    16f2:	8e 7f       	andi	r24, 0xFE	; 254
    16f4:	81 83       	std	Z+1, r24	; 0x01
      /* Having selected a new state to run, let us put in the status register. From
       * now on, that is the current task.  */
      uiOsStatus = (uiOsStatus & defTaskNumberSetMask) | (uiExecute.MaxTask << defOsTaskNumberShift);  } }
    16f6:	80 91 0b 01 	lds	r24, 0x010B
    16fa:	80 7f       	andi	r24, 0xF0	; 240
    16fc:	18 2b       	or	r17, r24
    16fe:	10 93 0b 01 	sts	0x010B, r17
    1702:	0d c0       	rjmp	.+26     	; 0x171e <privEnterOS+0xfa>
  /* Timer interrupts are switch on (or must be on) in the idle mode
   * because we must return from idle due to a timer interrupt.
   * however, that is the responsibility of the portIdle implementation
   * Notify the OS that we enter the idle state now. This is needed at
   * return, cause we don't need to save any context then. */
  uiOsStatus = ((uiOsStatus & defContextSetMask) | defContextStateIdle);
    1704:	80 91 0b 01 	lds	r24, 0x010B
    1708:	8f 73       	andi	r24, 0x3F	; 63
    170a:	80 68       	ori	r24, 0x80	; 128
    170c:	80 93 0b 01 	sts	0x010B, r24
  /* Say that we are ready to start the idle task. */
  privTrace(traceIdleStart);
  /* Reset the stack, so we maximal space in portIdle. */
  privSetStack(&xOS.StackOS[OSstackInit]);
    1710:	88 e8       	ldi	r24, 0x88	; 136
    1712:	90 e0       	ldi	r25, 0x00	; 0
    1714:	8d bf       	out	0x3d, r24	; 61
    1716:	9e bf       	out	0x3e, r25	; 62
  /* Interrupts on of course, otherwise the timer interrupt cannot work, and
   * we are ready with the stack switch. */
  privEnableGlobalInterrupts();
    1718:	78 94       	sei
  /* Before we enter the idle state the there may be some work to do */
  #if (callAppEnterIdle == cfgTrue)
    appEnterIdle();
  #endif
  /* Done, we goto (not call!) the portIdle. Thus, we do not return here. ;-) */
  portJump(portIdle); }
    171a:	0c 94 47 0d 	jmp	0x1a8e	; 0x1a8e <portIdle>
   * state of the task. Therefore, we keep (default situation) tick interrupts disabled
   * here. If we have OS protection, the interrupts are already off. If not, we must take
   * care of that. */
  /* Notify the OS that we enter a task state now. This is needed at
   * return, cause we must save the context then. */
  uiOsStatus = ((uiOsStatus & defContextSetMask) | defContextStateTask);
    171e:	10 91 0b 01 	lds	r17, 0x010B
    1722:	1f 73       	andi	r17, 0x3F	; 63
    1724:	10 64       	ori	r17, 0x40	; 64
    1726:	10 93 0b 01 	sts	0x010B, r17
  /* Get the number of the task we are going to run (a call to privTaskNumber takes more bytes) */
  Tuint08 uiTaskNumber = (uiOsStatus & defTaskNumberGetMask) >> defOsTaskNumberShift;
    172a:	1f 70       	andi	r17, 0x0F	; 15
  /* Get the task control block of the current task also */
  TtaskControlBlock * curTCB = privTcbList(uiTaskNumber);
    172c:	81 2f       	mov	r24, r17
    172e:	0e 94 01 0b 	call	0x1602	; 0x1602 <privTcbList>
    1732:	dc 01       	movw	r26, r24
   * variables. The stack should not be used any more. I am not 100% sure this is sufficient, but
   * i think i have no other means at my disposal other than assembly, which we cannot use here. */
  portBarrier();
  /* If we make use of register compression with constant registers, we now fill the background
   * variable with the correct value. */
   xOS.pxSave.uiRegisterUse = uiRegisterUse;
    1734:	8f ef       	ldi	r24, 0xFF	; 255
    1736:	80 93 75 00 	sts	0x0075, r24
  /* If we check the use of registers we may not want to check all registers, even if they are used. Here we may
   * want to check for all tasks the same registers so ...*/
  #if (cfgCheckRegisters == cfgTrue)
    #if (defRegisterCheckConstant == cfgTrue)
      /* ... we can use the constant value */
      xOS.pxSave.uiRegisterCheck = defRegisterCheckCollect;
    173a:	80 93 76 00 	sts	0x0076, r24
    #endif
  #endif
  /* At saveContext we need to know where the stack starts, but since getting this info
   * may overflow the stack at that time, we get it here and save it on the OS stack which
   * is used as background storage for the task. */
  xOS.pxSave.pcStackOffset = portFlashReadStruc(TtaskDefinitionBlock,pxTDBlist[uiTaskNumber],Taddress,pcStackOffset);
    173e:	e1 2f       	mov	r30, r17
    1740:	f0 e0       	ldi	r31, 0x00	; 0
    1742:	ee 0f       	add	r30, r30
    1744:	ff 1f       	adc	r31, r31
    1746:	ee 57       	subi	r30, 0x7E	; 126
    1748:	f9 4f       	sbci	r31, 0xF9	; 249
    174a:	85 91       	lpm	r24, Z+
    174c:	94 91       	lpm	r25, Z+
    174e:	e8 2f       	mov	r30, r24
    1750:	f9 2f       	mov	r31, r25
    1752:	25 91       	lpm	r18, Z+
    1754:	34 91       	lpm	r19, Z+
    1756:	30 93 79 00 	sts	0x0079, r19
    175a:	20 93 78 00 	sts	0x0078, r18
    #else
      /* Note that the limit is calculated taking StackSavety into account. Thus, it is an error
       * to pass this limit, although the stack is not yet corrupted at that point. This is
       * intentional, so that we can stop the task rather than experiencing bizarre results,
       * when experimenting with the stack size. The +1 represents the status register.*/
      xOS.pxSave.pcStackLimit = uiRegCount+xOS.pxSave.pcStackOffset+StackSafety-uiStackSize+1;
    175e:	c9 01       	movw	r24, r18
    1760:	09 97       	sbiw	r24, 0x09	; 9
    1762:	90 93 7d 00 	sts	0x007D, r25
    1766:	80 93 7c 00 	sts	0x007C, r24
     * protected region of the code. Good that we noticed it! */
    if ((curTCB->uiStackMax)<(uiStackSize)) { curTCB->uiStackMax = uiStackSize; }
  #endif
 /* Recall the address stack level, and put it in the background variables. Thus this
    * variable gets accessible from the portSave/portContext routines. */
   xOS.pxSave.pcStackLevel = (Taddress) &(curTCB->pcStackLevel);
    176a:	b0 93 7b 00 	sts	0x007B, r27
    176e:	a0 93 7a 00 	sts	0x007A, r26
   /* Now, switch to the task stack */
   #if (cfgSysStackGrowthUp == cfgTrue)
     privSetStack( (Taddress) ((Tuint16) xOS.pxSave.pcStackOffset + (Tuint16) curTCB->pcStackLevel) );
   #else
     privSetStack( (Taddress) ((Tuint16) xOS.pxSave.pcStackOffset - (Tuint16) curTCB->pcStackLevel) );
    1772:	8c 91       	ld	r24, X
    1774:	28 1b       	sub	r18, r24
    1776:	31 09       	sbc	r19, r1
    1778:	2d bf       	out	0x3d, r18	; 61
    177a:	3e bf       	out	0x3e, r19	; 62
   #endif
 /* We need not to activate the interrupts right here, since that is done in the
  * portRestoreContext at the end by the 'reti'. Jump to the routine that restores
  * the context for the task at hand. */
  portJump(portRestoreContext); }
    177c:	0c 94 15 0e 	jmp	0x1c2a	; 0x1c2a <portRestoreContext>
      /* Here we are done, the next thing is to enter the privEnterTask, in order to run
       * the task chosen */
   #endif
  }
  /* make it so */
  privEnterTask(); }
    1780:	08 95       	ret

00001782 <privShowError>:


#if (defCheckReportingError == cfgTrue)

static void privShowError(Tuint08 uiMessage, Tuint08 uiCallId, Tuint08 uiInfo)
{ /* We may arrive here from OS space, isr or task space. In the latter case is important we do
    1782:	cf 92       	push	r12
    1784:	df 92       	push	r13
    1786:	ef 92       	push	r14
    1788:	ff 92       	push	r15
    178a:	0f 93       	push	r16
    178c:	1f 93       	push	r17
    178e:	e8 2e       	mov	r14, r24
    1790:	14 2f       	mov	r17, r20
   *
   * One extra note. Errors reporting an incorrect task number must be fatal since this
   * routine assumes that, when the error is not fatal, the task number represents the
   * failing task.
   */
  privDisableGlobalInterrupts();
    1792:	f8 94       	cli
  /* Strip the error type information from the message */
  Tuint08 uiBareMessage = (uiMessage & errMessageGetMask);
    1794:	08 2f       	mov	r16, r24
    1796:	0f 73       	andi	r16, 0x3F	; 63
    const Tbool bReturn = false;
  #else
    /* uiWorkStatus represents the status we will use upon which we decide what to do. */
    Tuint08 uiWorkStatus;
    /* See if we must use the uiOsStatus as a basis (standard) or the given by the uiCallId. */
    if ((uiMessage & errOsStateGetMask) == errOsStateAsIs)
    1798:	86 fd       	sbrc	r24, 6
    179a:	04 c0       	rjmp	.+8      	; 0x17a4 <privShowError+0x22>
    { /* Extract the upper two bits  containing the status info from the standard status. */
      uiWorkStatus = uiOsStatus & defContextGetMask; }
    179c:	80 91 0b 01 	lds	r24, 0x010B
    17a0:	80 7c       	andi	r24, 0xC0	; 192
    17a2:	01 c0       	rjmp	.+2      	; 0x17a6 <privShowError+0x24>
    else
    { /* Use the StateOs as forced status (i.e. assume we are in the OS state) */
      uiWorkStatus = defContextStateOs; }
    17a4:	80 e0       	ldi	r24, 0x00	; 0
    /* We first calculate when we have a fatal error. That is the case is the error in itself is
     * fatal, or if we arrive here from an isr. */
    const Tbool bFatal = (uiBareMessage >= errFatalError) || (uiWorkStatus == defContextStateIsr);
    17a6:	00 32       	cpi	r16, 0x20	; 32
    17a8:	c0 f5       	brcc	.+112    	; 0x181a <privShowError+0x98>
    17aa:	dd 24       	eor	r13, r13
    17ac:	d3 94       	inc	r13
    17ae:	80 3c       	cpi	r24, 0xC0	; 192
    17b0:	09 f0       	breq	.+2      	; 0x17b4 <privShowError+0x32>
    17b2:	dd 24       	eor	r13, r13
    /* We may normally return only in one special case. Of course the error may not be fatal, and we must come
     * here from the OS itself, (or we must be told we come from the OS itself) */
    const Tbool bReturn = !bFatal && (uiWorkStatus == defContextStateOs);
    17b4:	dd 20       	and	r13, r13
    17b6:	99 f5       	brne	.+102    	; 0x181e <privShowError+0x9c>
    17b8:	88 23       	and	r24, r24
    17ba:	89 f5       	brne	.+98     	; 0x181e <privShowError+0x9c>
  #endif
  /* Strip the error type information from the call Id */
  Tuint08 uiBareCallId = (uiCallId & errCallIdGetMask);
    17bc:	0f 2e       	mov	r0, r31
    17be:	ff e3       	ldi	r31, 0x3F	; 63
    17c0:	ff 2e       	mov	r15, r31
    17c2:	f0 2d       	mov	r31, r0
    17c4:	f6 22       	and	r15, r22
    /* We first calculate when we have a fatal error. That is the case is the error in itself is
     * fatal, or if we arrive here from an isr. */
    const Tbool bFatal = (uiBareMessage >= errFatalError) || (uiWorkStatus == defContextStateIsr);
    /* We may normally return only in one special case. Of course the error may not be fatal, and we must come
     * here from the OS itself, (or we must be told we come from the OS itself) */
    const Tbool bReturn = !bFatal && (uiWorkStatus == defContextStateOs);
    17c6:	cc 24       	eor	r12, r12
    17c8:	c3 94       	inc	r12
   * Pushed variables are not important when we no not return. */
  if (!bReturn) { privSetStack(&xOS.StackOS[OSstackInit]); }
  /* We disable tick interrupts, needed to be deactivated in case we should return. We do that here, after a possible
   * stack transplant since this call may make use of the stack. It must be done before global interrupts are
   * activated again. */
  privDisableTickInterrupts();
    17ca:	0e 94 57 0d 	call	0x1aae	; 0x1aae <portDisableTickInterrupts>
  /* Now determine the task number. */
  Tuint08 uiTaskNumber;
  /* Test if we must use the given task number by uiInfo or the current one. This flag is used because
   * from a lot of places its much sorter to set the flag than to calculate the current task number.
   * Do not use the privTaskNumber() method, for we do not want to introduce stack use here. */
  if ((uiMessage & errTaskStateGetMask) == errTaskStateCurrent)
    17ce:	ee 20       	and	r14, r14
    17d0:	54 f4       	brge	.+20     	; 0x17e6 <privShowError+0x64>
  { /* Deduce the current task number from the Status */
    uiTaskNumber = (uiOsStatus & defTaskNumberGetMask) >> defOsTaskNumberShift;
    17d2:	80 91 0b 01 	lds	r24, 0x010B
    17d6:	0f 2e       	mov	r0, r31
    17d8:	ff e0       	ldi	r31, 0x0F	; 15
    17da:	ef 2e       	mov	r14, r31
    17dc:	f0 2d       	mov	r31, r0
    17de:	e8 22       	and	r14, r24
    /* Reconstruct the uiInfo byte, that will be send to the error method later on */
    uiInfo = (uiInfo & errTaskNumberSetMask) | (uiTaskNumber << errTaskNumberShift); }
    17e0:	10 7f       	andi	r17, 0xF0	; 240
    17e2:	1e 29       	or	r17, r14
    17e4:	05 c0       	rjmp	.+10     	; 0x17f0 <privShowError+0x6e>
  else
  { /* Read the task number from the given byte, probably the current task is not the one giving problems */
    uiTaskNumber = (uiInfo & errTaskNumberGetMask) >> errTaskNumberShift ; }
    17e6:	0f 2e       	mov	r0, r31
    17e8:	ff e0       	ldi	r31, 0x0F	; 15
    17ea:	ef 2e       	mov	r14, r31
    17ec:	f0 2d       	mov	r31, r0
    17ee:	e1 22       	and	r14, r17
  /* Now, show the error,  if we had a fatal error it makes no sense to continue operations,
   * so the only thing we can do is show the error again*/
  do { portShowError(uiBareMessage,uiBareCallId,uiInfo); } while (bFatal);
    17f0:	80 2f       	mov	r24, r16
    17f2:	6f 2d       	mov	r22, r15
    17f4:	41 2f       	mov	r20, r17
    17f6:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <portShowError>
    17fa:	dd 20       	and	r13, r13
    17fc:	d9 f4       	brne	.+54     	; 0x1834 <privShowError+0xb2>
  /* In case we had a normal error we want to continue, but since it is reasonable to assume that it
   * may have taken some time, the user has probably stop the timer, if he did not misused the timer
   * to make some leds blink. In any case its best to restart the timer. We have to live with the
   * fact that real time and timer ticks are out of sync anyway. Note that the user may use the timer,
   * but may not activate the interrupt. */
  portSetupTimerInterrupt();
    17fe:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <portSetupTimerInterrupt>
  #if (cfgIntOsProtected == cfgFalse)
    privEnableGlobalInterrupts();
  #endif
  /* All errors not being fatal at least must stop the current or requested task and put it in error mode.
   * (This cannot be an isr anymore, and all non fatal Os errors are about some task.) */
  TtaskControlBlock * taskTCB = privTcbList(uiTaskNumber);
    1802:	8e 2d       	mov	r24, r14
    1804:	0e 94 01 0b 	call	0x1602	; 0x1602 <privTcbList>
  /* Note that the task is terminated, but it's locks are not removed, since this is an error
   * condition, it is unclear what the result would be, so that this cannot be compared with
   * a normal terminate, in which case the user can take precautions for released blocks etc. */
  taskTCB->uiTaskStatus = defBaseTerminatedTask;
    1808:	20 e1       	ldi	r18, 0x10	; 16
    180a:	fc 01       	movw	r30, r24
    180c:	21 83       	std	Z+1, r18	; 0x01
  #endif
  /* If we are at a task, or at some operations within the OS that handle a specific task,
   * we can leave this method by asking for a task switch. This is not a normal return.
   * Note that in this case the AuxRegBit (if used) can be set. Here, that is not a problem
   * for there are no switching interrupts that can take place. */
  if (!bReturn) { privEnterOS(defActionTaskStateSwitch); }
    180e:	cc 20       	and	r12, r12
    1810:	b9 f4       	brne	.+46     	; 0x1840 <privShowError+0xbe>
    1812:	81 e0       	ldi	r24, 0x01	; 1
    1814:	0e 94 12 0b 	call	0x1624	; 0x1624 <privEnterOS>
    1818:	13 c0       	rjmp	.+38     	; 0x1840 <privShowError+0xbe>
    else
    { /* Use the StateOs as forced status (i.e. assume we are in the OS state) */
      uiWorkStatus = defContextStateOs; }
    /* We first calculate when we have a fatal error. That is the case is the error in itself is
     * fatal, or if we arrive here from an isr. */
    const Tbool bFatal = (uiBareMessage >= errFatalError) || (uiWorkStatus == defContextStateIsr);
    181a:	dd 24       	eor	r13, r13
    181c:	d3 94       	inc	r13
    /* We may normally return only in one special case. Of course the error may not be fatal, and we must come
     * here from the OS itself, (or we must be told we come from the OS itself) */
    const Tbool bReturn = !bFatal && (uiWorkStatus == defContextStateOs);
  #endif
  /* Strip the error type information from the call Id */
  Tuint08 uiBareCallId = (uiCallId & errCallIdGetMask);
    181e:	0f 2e       	mov	r0, r31
    1820:	ff e3       	ldi	r31, 0x3F	; 63
    1822:	ff 2e       	mov	r15, r31
    1824:	f0 2d       	mov	r31, r0
    1826:	f6 22       	and	r15, r22
  /* If we do not return we reset the stack to prevent stack overflow when handling the error code.
   * We don't need the preserve stack anymore. Note, that we should note have a stack frame present.
   * Pushed variables are not important when we no not return. */
  if (!bReturn) { privSetStack(&xOS.StackOS[OSstackInit]); }
    1828:	88 e8       	ldi	r24, 0x88	; 136
    182a:	90 e0       	ldi	r25, 0x00	; 0
    182c:	8d bf       	out	0x3d, r24	; 61
    182e:	9e bf       	out	0x3e, r25	; 62
    /* We first calculate when we have a fatal error. That is the case is the error in itself is
     * fatal, or if we arrive here from an isr. */
    const Tbool bFatal = (uiBareMessage >= errFatalError) || (uiWorkStatus == defContextStateIsr);
    /* We may normally return only in one special case. Of course the error may not be fatal, and we must come
     * here from the OS itself, (or we must be told we come from the OS itself) */
    const Tbool bReturn = !bFatal && (uiWorkStatus == defContextStateOs);
    1830:	cc 24       	eor	r12, r12
    1832:	cb cf       	rjmp	.-106    	; 0x17ca <privShowError+0x48>
  else
  { /* Read the task number from the given byte, probably the current task is not the one giving problems */
    uiTaskNumber = (uiInfo & errTaskNumberGetMask) >> errTaskNumberShift ; }
  /* Now, show the error,  if we had a fatal error it makes no sense to continue operations,
   * so the only thing we can do is show the error again*/
  do { portShowError(uiBareMessage,uiBareCallId,uiInfo); } while (bFatal);
    1834:	80 2f       	mov	r24, r16
    1836:	6f 2d       	mov	r22, r15
    1838:	41 2f       	mov	r20, r17
    183a:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <portShowError>
    183e:	fa cf       	rjmp	.-12     	; 0x1834 <privShowError+0xb2>
  /* If we are at a task, or at some operations within the OS that handle a specific task,
   * we can leave this method by asking for a task switch. This is not a normal return.
   * Note that in this case the AuxRegBit (if used) can be set. Here, that is not a problem
   * for there are no switching interrupts that can take place. */
  if (!bReturn) { privEnterOS(defActionTaskStateSwitch); }
  /* Otherwise we are done, and return to the OS operations that generated the error. */ }
    1840:	1f 91       	pop	r17
    1842:	0f 91       	pop	r16
    1844:	ff 90       	pop	r15
    1846:	ef 90       	pop	r14
    1848:	df 90       	pop	r13
    184a:	cf 90       	pop	r12
    184c:	08 95       	ret

0000184e <privTestStackRegion>:


#if (cfgCheckTaskStack == cfgTrue) && (StackSafety > 0)

void privTestStackRegion(void)
{ Tuint08 uiTaskNumber = privTaskNumber(defCurrentTaskNumber);
    184e:	0f 93       	push	r16
    1850:	1f 93       	push	r17
    1852:	cf 93       	push	r28
    1854:	df 93       	push	r29
    1856:	80 e8       	ldi	r24, 0x80	; 128
    1858:	0e 94 0c 0b 	call	0x1618	; 0x1618 <privTaskNumber>
    185c:	08 2f       	mov	r16, r24
    /* Otherwise we must get that from flash too. */
    Tstack uiStackSize = portFlashReadStruc(TtaskDefinitionBlock,pxTDBlist[uiTaskNumber],Tstack,uiStackSize);
  #endif
  /* Now we have the stack size we may first compare it to the stack level. If the latter exceeds the former
   * there is no need to check any further, we must be in error, get the tcb */
  TtaskControlBlock * taskTCB = privTcbList(uiTaskNumber);
    185e:	0e 94 01 0b 	call	0x1602	; 0x1602 <privTcbList>
    1862:	dc 01       	movw	r26, r24
  /* compare the values. Note that for one byte levels it may happen that the values roled over, we cannot
   * detect that situation here. */
  if (taskTCB->pcStackLevel > uiStackSize)
    1864:	8c 91       	ld	r24, X
    1866:	8f 32       	cpi	r24, 0x2F	; 47
    1868:	28 f0       	brcs	.+10     	; 0x1874 <privTestStackRegion+0x26>
  { /* probably the error was already reported as non fatal, but is becomes fatal now, because we are certain
     * the tasks violated the boundaries. */
    privShowError((fatTaskStackOverflowed | errTaskStateCurrent), callIdSystem, errCurrentTask ); }
    186a:	84 ea       	ldi	r24, 0xA4	; 164
    186c:	60 e0       	ldi	r22, 0x00	; 0
    186e:	40 e0       	ldi	r20, 0x00	; 0
    1870:	0e 94 c1 0b 	call	0x1782	; 0x1782 <privShowError>
  /* Get the location where the stack starts. */
  Taddress pcStackOffset = portFlashReadStruc(TtaskDefinitionBlock,pxTDBlist[uiTaskNumber],Taddress,pcStackOffset);
    1874:	e0 2f       	mov	r30, r16
    1876:	f0 e0       	ldi	r31, 0x00	; 0
    1878:	ee 0f       	add	r30, r30
    187a:	ff 1f       	adc	r31, r31
    187c:	ee 57       	subi	r30, 0x7E	; 126
    187e:	f9 4f       	sbci	r31, 0xF9	; 249
    1880:	85 91       	lpm	r24, Z+
    1882:	94 91       	lpm	r25, Z+
    1884:	e8 2f       	mov	r30, r24
    1886:	f9 2f       	mov	r31, r25
    1888:	05 91       	lpm	r16, Z+
    188a:	14 91       	lpm	r17, Z+
    188c:	e8 01       	movw	r28, r16
    188e:	a9 97       	sbiw	r28, 0x29	; 41
#endif


#if (cfgCheckTaskStack == cfgTrue) && (StackSafety > 0)

void privTestStackRegion(void)
    1890:	0d 52       	subi	r16, 0x2D	; 45
    1892:	10 40       	sbci	r17, 0x00	; 0
  { /* read the value of the stack in the 'virginity' area. None of the values may have
     * a different value. */
    #if (cfgSysStackGrowthUp == cfgTrue)
      if (*(pSafetyByte++) != defStackInitByte)
    #else
      if (*(pSafetyByte--) != defStackInitByte)
    1894:	8a 91       	ld	r24, -Y
    1896:	88 23       	and	r24, r24
    1898:	29 f0       	breq	.+10     	; 0x18a4 <privTestStackRegion+0x56>
    #endif
    { /* So the first one to differ is bingo. Note this is a fatal error since other stacks
       * may have been damaged as well. */
      privShowError((fatTaskStackOverflowed | errTaskStateCurrent), callIdSystem, errCurrentTask ); } } }
    189a:	84 ea       	ldi	r24, 0xA4	; 164
    189c:	60 e0       	ldi	r22, 0x00	; 0
    189e:	40 e0       	ldi	r20, 0x00	; 0
    18a0:	0e 94 c1 0b 	call	0x1782	; 0x1782 <privShowError>
    Taddress pSafetyByte = pcStackOffset+StackSafety-uiStackSize;
  #endif
  /* Now see if the safety area is indeed clean. The maximum size of the StackSafety parameter
   * is 0xFF, so the counter must fit one byte. */
  Tuint08  uiCount;
  for (uiCount=0; uiCount<StackSafety; uiCount++)
    18a4:	c0 17       	cp	r28, r16
    18a6:	d1 07       	cpc	r29, r17
    18a8:	a9 f7       	brne	.-22     	; 0x1894 <privTestStackRegion+0x46>
    #else
      if (*(pSafetyByte--) != defStackInitByte)
    #endif
    { /* So the first one to differ is bingo. Note this is a fatal error since other stacks
       * may have been damaged as well. */
      privShowError((fatTaskStackOverflowed | errTaskStateCurrent), callIdSystem, errCurrentTask ); } } }
    18aa:	df 91       	pop	r29
    18ac:	cf 91       	pop	r28
    18ae:	1f 91       	pop	r17
    18b0:	0f 91       	pop	r16
    18b2:	08 95       	ret

000018b4 <privInitOs>:
   * beginning of the compiled routine. */

  /* We can start checking the results from the context save. */
  #if (cfgCheckTaskStack == cfgTrue)  || (cfgCheckRegisters == cfgTrue) || (cfgCheckWatermarks == cfgTrue)
    /* These checks are only sensible if we where previously performing a task */
    if ((uiOsStatus & defContextGetMask) == defContextStateTask)
    18b4:	90 91 0b 01 	lds	r25, 0x010B
    18b8:	90 7c       	andi	r25, 0xC0	; 192
    18ba:	90 34       	cpi	r25, 0x40	; 64
    18bc:	09 f5       	brne	.+66     	; 0x1900 <privInitOs+0x4c>
       * portSaveContext however, we first calculated if the context fits in the remaining
       * stack space, if not, the context is not saved, and uiStackTCheck indicates a stack error. Of course
       * we can never restart that task, but that would not have been possible in a reliable way
       * anyhow. Now, at least we may have reduced the damage to other parts of the memory. */
      #if (cfgCheckTaskStack == cfgTrue)
        if ((xOS.pxSave.uiStackTCheck & defCheckStackGetMask) == defCheckStackStateError)
    18be:	90 91 77 00 	lds	r25, 0x0077
    18c2:	99 23       	and	r25, r25
    18c4:	34 f4       	brge	.+12     	; 0x18d2 <privInitOs+0x1e>
        { /* Now we can have two situations. First the stack may be overflown already, which is
           * is an fatal error since most likely other tasks are damaged as well, or the context
           * may not fit the stack. The former cannot be detected with 100% certainty, but if we can
           * see it has happened, we should issue an fatal error */
          privShowError((errTaskStackWillOverflow | errTaskStateCurrent | uiErrorControl), (callIdSystem | defContextStateOs), errCurrentTask ); }
    18c6:	83 68       	ori	r24, 0x83	; 131
    18c8:	60 e0       	ldi	r22, 0x00	; 0
    18ca:	40 e0       	ldi	r20, 0x00	; 0
    18cc:	0e 94 c1 0b 	call	0x1782	; 0x1782 <privShowError>
    18d0:	15 c0       	rjmp	.+42     	; 0x18fc <privInitOs+0x48>
       * moment however, we decide to stop the task anyway.*/
      #if (cfgCheckRegisters == cfgTrue)
        { /* Determine which register blocks where used without authorization, that are all register blocks
           * used (the ones not check are already set to zero) excluding any of the blocks where use
           * is allowed. */
          Tuint08 uiRegisterViolation = xOS.pxSave.uiRegisterCheck & ~xOS.pxSave.uiRegisterUse;
    18d2:	90 91 75 00 	lds	r25, 0x0075
    18d6:	90 95       	com	r25
    18d8:	20 91 76 00 	lds	r18, 0x0076
    18dc:	92 23       	and	r25, r18
          /* If there is any such block we must report an error */
          if (uiRegisterViolation != 0)
    18de:	71 f0       	breq	.+28     	; 0x18fc <privInitOs+0x48>
          { /* We determine the highest block number in violation, that could be 7  (regs 28,29,30,31)*/
            Tuint08 uiRegBlock = 7;
            /* Check if this is indeed so */
            while ( (uiRegisterViolation & 0x80) == 0 )
    18e0:	99 23       	and	r25, r25
    18e2:	2c f0       	brlt	.+10     	; 0x18ee <privInitOs+0x3a>
    18e4:	47 e0       	ldi	r20, 0x07	; 7
            { /* If not it could be 6, so we decrease the counter one ... */
              uiRegBlock--;
    18e6:	41 50       	subi	r20, 0x01	; 1
             /*  and shift the 6th block to the 7th */
              uiRegisterViolation <<= 1; }
    18e8:	99 0f       	add	r25, r25
          /* If there is any such block we must report an error */
          if (uiRegisterViolation != 0)
          { /* We determine the highest block number in violation, that could be 7  (regs 28,29,30,31)*/
            Tuint08 uiRegBlock = 7;
            /* Check if this is indeed so */
            while ( (uiRegisterViolation & 0x80) == 0 )
    18ea:	ea f7       	brpl	.-6      	; 0x18e6 <privInitOs+0x32>
    18ec:	01 c0       	rjmp	.+2      	; 0x18f0 <privInitOs+0x3c>
    18ee:	47 e0       	ldi	r20, 0x07	; 7
            { /* If not it could be 6, so we decrease the counter one ... */
              uiRegBlock--;
             /*  and shift the 6th block to the 7th */
              uiRegisterViolation <<= 1; }
            /* By now we have found that block, report the error, the faulty block in the slot slot. */
            privShowError((errTaskIllegalRegisterUse | errTaskStateCurrent | uiErrorControl), (callIdSystem | defContextStateOs), (uiRegBlock << errInfoNumberShift) | errCurrentTask);  }  }
    18f0:	42 95       	swap	r20
    18f2:	40 7f       	andi	r20, 0xF0	; 240
    18f4:	84 68       	ori	r24, 0x84	; 132
    18f6:	60 e0       	ldi	r22, 0x00	; 0
    18f8:	0e 94 c1 0b 	call	0x1782	; 0x1782 <privShowError>
       * other tasks may have been damaged. The check only makes sense if we have a safety area.
       * Note that this is done inside a function that is only called once, but is not allowed
       * to be inlined. This is because it will cause to much stack use in privInitOs. The
       * call or returns without error, or causes a fatal error.*/
      #if (cfgCheckTaskStack == cfgTrue) && (StackSafety > 0)
        privTestStackRegion();
    18fc:	0e 94 27 0c 	call	0x184e	; 0x184e <privTestStackRegion>
    1900:	08 95       	ret

00001902 <privTickYield>:

void privTickYield(void)
{ /* Arrive here from a tick interrupt. It is assumed that global interrupts are already switched off.
   * We know we came from a tick, so the global interrupt must have been on before, make sure, the
   * task starts with global interrupts activated when restored. */
  portResqueGlobalInterruptActive();
    1902:	4f 9a       	sbi	0x09, 7	; 9
  /* Since we have no parameters, we may safely save the context now. */
  portSaveContext();
    1904:	0e 94 5e 0d 	call	0x1abc	; 0x1abc <portSaveContext>
    /* These is no need to pass information about the idle state. */
    Tuint08 uiIdleAction = 0;
  #endif
  /* After saving the context (all registers are preserved, and the stack is switched, we initialize
   * the OS. */
  privInitOsReturn();
    1908:	80 e4       	ldi	r24, 0x40	; 64
    190a:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <privInitOs>
  /* Inform that we interrupted the task*/
  privTrace(traceTickInterrupt);
  /* After initializing the OS, we may Enter the OS, indicating that we want a task switch and,
   * since we come from an interrupt, may need to add a tick. We also tell, if needed if we were
   * running an idle task lately. */
  privEnterOS(uiIdleAction | defActionTaskStateSwitch | defActionTickStateTick); }
    190e:	83 e0       	ldi	r24, 0x03	; 3
    1910:	0e 94 12 0b 	call	0x1624	; 0x1624 <privEnterOS>
    1914:	08 95       	ret

00001916 <main>:
   * calls main. */
  /* All tasks must be set up. */
  Tuint08 uiLoopTask;
  /* Usually, there is some hardware related stuff that must be done (setting the pll,
   * choosing the main clock etc etc */
  portInit();
    1916:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <portInit>
     * is made a fatal error. */
    if ((StackSizeOS) < defOsStackMinimum)  { privShowError((fatOsStackUnderMinimum | errTaskStateNon), callIdSystem, errNoInfo); }
  #endif
  /* If present call appBoot code. This is used by the user to perform general initializations. */
  #if (callAppBoot == cfgTrue)
    appBoot();
    191a:	0e 94 e7 03 	call	0x7ce	; 0x7ce <appBoot>
    191e:	c0 e0       	ldi	r28, 0x00	; 0
    1920:	d0 e0       	ldi	r29, 0x00	; 0
      { /* Replace the first start bits by the bits given in the control parameter. */
        uiIntialFilteredStatus = (uiIntialFilteredStatus & defBaseRestartSetMask) | (uiInitControl  & defBaseRestartGetMask); }
    #endif
  #endif
  /* Set the newly prepared  task status. */
  taskTCB->uiTaskStatus = uiIntialFilteredStatus;
    1922:	00 ef       	ldi	r16, 0xF0	; 240
    /* The status register is put at the end of the stack. (See portSaveContext for the reason why) */
    *(pStackTop--) = uiInitCPUStatusRegister;
  #else
    /* Set up the status register with the initial interrupt states: global set and tick set */
    #if (((defInterruptStartFixed) & cfgGlobSet) == cfgGlobSet) && (((defInterruptStartFixed) & cfgTickSet) == cfgTickSet)
      *(pStackTop--) = defInitCPUStatusRegister | (0 << portInitModeInterruptLoc) | (1 << portInitGlobalInterruptLoc) | (1 << portInitTickInterruptLoc);
    1924:	11 e8       	ldi	r17, 0x81	; 129
   * are not cleared when we re-initialize the task. Only about uxDelay there could
   * be debate since the would indicate the last wake time. But what is a last wake
   * time in this case. We could set it to the current time, but have not done so.  */
  /* Report that we are initializing this task. */
  privTrace(traceTaskInit | uiTaskNumber);
  TtaskControlBlock * taskTCB = privTcbList(uiTaskNumber);
    1926:	8c 2f       	mov	r24, r28
    1928:	0e 94 01 0b 	call	0x1602	; 0x1602 <privTcbList>
      { /* Replace the first start bits by the bits given in the control parameter. */
        uiIntialFilteredStatus = (uiIntialFilteredStatus & defBaseRestartSetMask) | (uiInitControl  & defBaseRestartGetMask); }
    #endif
  #endif
  /* Set the newly prepared  task status. */
  taskTCB->uiTaskStatus = uiIntialFilteredStatus;
    192c:	dc 01       	movw	r26, r24
    192e:	11 96       	adiw	r26, 0x01	; 1
    1930:	0c 93       	st	X, r16
    if ((uiInitControl & defInitContextGetMask) == defInitContextRenew)
  #endif
  { /* Report that we are making the context of this task. */
    privTrace(traceCreateContext);
    /* pcStackOffset is a pointer to the beginning of the stack of this task, it is located in flash. */
    Taddress pcStackOffset = portFlashReadStruc(TtaskDefinitionBlock,pxTDBlist[uiTaskNumber],Taddress,pcStackOffset);
    1932:	9e 01       	movw	r18, r28
    1934:	22 0f       	add	r18, r18
    1936:	33 1f       	adc	r19, r19
    1938:	f9 01       	movw	r30, r18
    193a:	ee 57       	subi	r30, 0x7E	; 126
    193c:	f9 4f       	sbci	r31, 0xF9	; 249
    193e:	45 91       	lpm	r20, Z+
    1940:	54 91       	lpm	r21, Z+
    1942:	e4 2f       	mov	r30, r20
    1944:	f5 2f       	mov	r31, r21
    1946:	45 91       	lpm	r20, Z+
    1948:	54 91       	lpm	r21, Z+
    194a:	64 2f       	mov	r22, r20
    194c:	75 2f       	mov	r23, r21
    /* We need the place where the task starts. This is placed on the context as return address. It is located in flash */
    Taddress pTask = portFlashReadWord(Taddress,pxLooplist[uiTaskNumber]);
    194e:	2a 57       	subi	r18, 0x7A	; 122
    1950:	39 4f       	sbci	r19, 0xF9	; 249
    1952:	f9 01       	movw	r30, r18
    1954:	25 91       	lpm	r18, Z+
    1956:	34 91       	lpm	r19, Z+
   * and the status. Here the values are just cleaned. If needed we can add a portInitConext call
   * on the basis of an option. */
  Tuint16 uiStartAddress = (Tuint16) pTaskStart;
  /* At the bottom of the artificial stack the start address of each task is defined. This is a pointer
   * to your Loop code. */
  *(pStackTop--) = (Tuint08) uiStartAddress;
    1958:	fb 01       	movw	r30, r22
    195a:	20 83       	st	Z, r18
  *(pStackTop--) = (Tuint08) (uiStartAddress >> 8);
    195c:	32 93       	st	-Z, r19
   * we will use: */
  #if (defThreeByteAddress == cfgTrue)
    *(pStackTop--) = 0;
  #endif
  /* We rely upon register cleaning done by the Femto OS, or the precleaning done by privTaskInit(). */
  pStackTop -= uiRegisterCount;
    195e:	9f 01       	movw	r18, r30
    1960:	21 52       	subi	r18, 0x21	; 33
    1962:	30 40       	sbci	r19, 0x00	; 0
    /* The status register is put at the end of the stack. (See portSaveContext for the reason why) */
    *(pStackTop--) = uiInitCPUStatusRegister;
  #else
    /* Set up the status register with the initial interrupt states: global set and tick set */
    #if (((defInterruptStartFixed) & cfgGlobSet) == cfgGlobSet) && (((defInterruptStartFixed) & cfgTickSet) == cfgTickSet)
      *(pStackTop--) = defInitCPUStatusRegister | (0 << portInitModeInterruptLoc) | (1 << portInitGlobalInterruptLoc) | (1 << portInitTickInterruptLoc);
    1964:	d9 01       	movw	r26, r18
    1966:	1c 93       	st	X, r17
    1968:	b2 97       	sbiw	r30, 0x22	; 34
      #if (defStackClean == cfgTrue)
        Taddress pStackTop = pcStackOffset;
        while (uiStackSize--) { *(pStackTop--) = defStackInitByte; }
      #endif
      /* Subsequently define the context. */
      taskTCB->pcStackLevel = (Tstack) ((Tuint16) pcStackOffset - (Tuint16) portInitContext(pTask, pcStackOffset, uiRegCount, uiInitialStatus));
    196a:	a4 2f       	mov	r26, r20
    196c:	ae 1b       	sub	r26, r30
    196e:	fc 01       	movw	r30, r24
    1970:	a0 83       	st	Z, r26
    1972:	21 96       	adiw	r28, 0x01	; 1
  #if (callAppBoot == cfgTrue)
    appBoot();
  #endif
  /* Create a task control block for every task and set up a new context, as if the task
   * already existed before. */
  for (uiLoopTask=0; uiLoopTask<defNumberOfTasks; uiLoopTask++)
    1974:	c2 30       	cpi	r28, 0x02	; 2
    1976:	d1 05       	cpc	r29, r1
    1978:	b1 f6       	brne	.-84     	; 0x1926 <main+0x10>
  /* The timer is hardware dependent. The called routine below expects the tick interrupts
   * to be setup, but not activated yet.
   * The (tick) interrupt model used depends on a lot of parameters. At this point it is needed
   * to know that the routines starting a task, idle or sleep state manage the activation of
   * the tick interrupt themselves, so we do not need to take care here. */
  portSetupTimerInterrupt();
    197a:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <portSetupTimerInterrupt>
  /* All preparations are done, we may enter the OS to start the first task. We must really switch
   * since it may be possible that no task can be started, and than we must be able to switch to
   * idle task directly. */
  privEnterOS(defActionTaskStateSwitch);
    197e:	81 e0       	ldi	r24, 0x01	; 1
    1980:	0e 94 12 0b 	call	0x1624	; 0x1624 <privEnterOS>
  /* we never get here */
}
    1984:	08 95       	ret

00001986 <taskDelayFromNow>:

/* Function wrapper for taskDelayFromNow. */
#if (includeTaskDelayFromNow == cfgTrue)

void taskDelayFromNow(Tuint16 uiTicksToWait)
{ portResqueGlobalInterruptState();
    1986:	17 f4       	brid	.+4      	; 0x198c <taskDelayFromNow+0x6>
    1988:	f8 94       	cli
    198a:	4f 9a       	sbi	0x09, 7	; 9
  portSaveContext();
    198c:	0e 94 5e 0d 	call	0x1abc	; 0x1abc <portSaveContext>
  portJump(privDelayFromNowBody); }
    1990:	0c 94 ca 0c 	jmp	0x1994	; 0x1994 <privDelayFromNowBody>

00001994 <privDelayFromNowBody>:


#if (cfgUseDelay == cfgTrue) && (includeTaskDelayFromNow == cfgTrue)

void privDelayFromNowBody(Tuint16 uiTicksToWait)
{ /* Called from user code to pause a task for a certain time, in this case,
    1994:	ec 01       	movw	r28, r24
   * measured from the present value of the tick counter. This is a switching call,
   * let us first initialize the OS.
   * (It is a 'body' function too, see the explanation of this design elsewhere.) */
  privInitOsSwitch();
    1996:	80 e0       	ldi	r24, 0x00	; 0
    1998:	0e 94 5a 0c 	call	0x18b4	; 0x18b4 <privInitOs>
    /* Check the capabilities of the current task */
    privCheckCapabilities(callIdTaskDelayFromNow, ((cfgCapDelay) & 0xFF) );
    /* The usual check to see if the waiting time is not to large. The point is, if we make the waiting
     * so large that the wakeup ends in the same block as the current time (due to roll over), it
     * will be woken almost instantly. This must be prohibited.  */
    if (uiTicksToWait > defDelayTimeMax)
    199c:	8f ef       	ldi	r24, 0xFF	; 255
    199e:	c0 30       	cpi	r28, 0x00	; 0
    19a0:	d8 07       	cpc	r29, r24
    19a2:	28 f0       	brcs	.+10     	; 0x19ae <privDelayFromNowBody+0x1a>
    /* This is not a fatal error, the task is terminated. */
    { privShowError((errTaskDelayTooLong | errTaskStateCurrent | errOsStateAsIs), callIdTaskDelayFromNow, errCurrentTask ); }
    19a4:	8f e8       	ldi	r24, 0x8F	; 143
    19a6:	63 e0       	ldi	r22, 0x03	; 3
    19a8:	40 e0       	ldi	r20, 0x00	; 0
    19aa:	0e 94 c1 0b 	call	0x1782	; 0x1782 <privShowError>
  #endif
  /* If the waiting time equals zero, it is effectively a taskYield. Don't call the
   * delay for otherwise it may end up delaying one full tick round. Otherwise
   * we call the privDelayCalc with the request to measure the delay time from now */
  if (uiTicksToWait != defDelayTimeZero) { privDelayCalcFromNow(uiTicksToWait); }
    19ae:	20 97       	sbiw	r28, 0x00	; 0
    19b0:	d9 f0       	breq	.+54     	; 0x19e8 <privDelayFromNowBody+0x54>
  #if (cfgCheckOsStack == cfgTrue) || (cfgCheckWatermarks == cfgTrue)
    /* This is one of the places in the current design of the Femto OS that is somewhat deeper.
     * Thus it makes sense to check the OS stack here. */
    privCheckOsStackLevel();
  #endif
  TtaskControlBlock * curTCB = privTcbList(privTaskNumber(defCurrentTaskNumber));
    19b2:	80 e8       	ldi	r24, 0x80	; 128
    19b4:	0e 94 0c 0b 	call	0x1618	; 0x1618 <privTaskNumber>
    19b8:	0e 94 01 0b 	call	0x1602	; 0x1602 <privTcbList>
    19bc:	fc 01       	movw	r30, r24
  #endif
  { /* Here the new time is calculated form the current time. */
    /* Now calculate the new Delaytime. This is a 16 bit operation. Note that the uiDelaytime
     * parameter represents the requested delay time whereas the uiDelayTime field in the
     * task control block represents the wakeup time of the particular task due to delay. */
    uiDelayTime += uxTickCount.Full; }
    19be:	80 91 09 01 	lds	r24, 0x0109
    19c2:	90 91 0a 01 	lds	r25, 0x010A
    19c6:	c8 0f       	add	r28, r24
    19c8:	d9 1f       	adc	r29, r25
         * causing the problems, and that we are in pseuso task-space, thus we may switch at error. */
      { privShowError((errTaskDelayTooShort | errTaskStateCurrent | errOsStateAsIs), callIdSystem, errCurrentTask ); }
    #endif
    uiDelayTime += curTCB->uxDelay.Full; }
  /* We have a new wake time, so place it in the appropriate fields. */
  curTCB->uxDelay.Full =  uiDelayTime ;
    19ca:	d3 83       	std	Z+3, r29	; 0x03
    19cc:	c2 83       	std	Z+2, r28	; 0x02
  /* It may be that this task is in the near wake, in which all tasks are that are in the
   * same tick block as the current time. We must check this and set the near wake bit if
   * needed. */
  if (curTCB->uxDelay.HighByte ==  uxTickCount.HighByte )
    19ce:	93 81       	ldd	r25, Z+3	; 0x03
    19d0:	80 91 0a 01 	lds	r24, 0x010A
    19d4:	98 17       	cp	r25, r24
    19d6:	29 f4       	brne	.+10     	; 0x19e2 <privDelayFromNowBody+0x4e>
  { uiOsStatus = ((uiOsStatus & defNearWakeStateSetMask) | defNearWakeStatePresent); }
    19d8:	80 91 0b 01 	lds	r24, 0x010B
    19dc:	80 62       	ori	r24, 0x20	; 32
    19de:	80 93 0b 01 	sts	0x010B, r24
  /* Update the task status of the task, say that the current task is delayed. If we want to
   * allow for delays below the minimum, we must add code here to check and keep the state
   * from being delayed. However we assume that this situation is normally not what you
   * want, because the task can be 'far behind'. We cannot get here for terminated tasks. */
  curTCB->uiTaskStatus = (curTCB->uiTaskStatus & defBaseDelayStateSetMask) | defBaseDelayStateDelayed; }
    19e2:	81 81       	ldd	r24, Z+1	; 0x01
    19e4:	8f 7e       	andi	r24, 0xEF	; 239
    19e6:	81 83       	std	Z+1, r24	; 0x01
  #if (includeGenSuspend == cfgTrue) && (cfgUseSuspendOnDelay == cfgTrue)
    /* Since we come here not voluntarily we only suspend when requested. Therefore supply defSuspendCheck.*/
    privHandleSuspend(defSuspendCheck);
  #endif
  /* We are done and call for a task switch. */
  privEnterOS(defActionTaskStateSwitch);  }
    19e8:	81 e0       	ldi	r24, 0x01	; 1
    19ea:	0e 94 12 0b 	call	0x1624	; 0x1624 <privEnterOS>
    19ee:	08 95       	ret

000019f0 <portShortDelay>:

static void portShortDelay(Tuint08 uiLoops)
{ /* Disable all timer interrupts. Since we use this routine to display some (error) information
   * we do not want to disturbed by other sources. We only make it explicit for timer 0.
   * Note that other timer bits may be destroyed here. */
  devTIMSK = preBitClr2(0x00,devOCIE,devTOIE);
    19f0:	19 be       	out	0x39, r1	; 57
  /* Set the timer in normal 8 bit mode and activate the timer with the chosen prescaler.
   * Now, on some devices these bits are located on the same register, and on other they
   * are not. We must separate. Furthermore, it is assumed it is OK to clear the other
   * bits in the register.  */
  if (preEqualMacros(devTCCRB,devTCCRA))
  { devTCCRA = preBitClr1(0x00,devWGM) | defDelayPrescaleBits; }
    19f2:	95 e0       	ldi	r25, 0x05	; 5
    19f4:	93 bf       	out	0x33, r25	; 51
  { devTCCRA = preBitClr1(0x00,devWGM);
    devTCCRB = defDelayPrescaleBits; }
  /* operate in the standard 8 bit timer mode (some devices do not have a 16 bit mode.
   *  Note we use the same timer as the tick interrupt does. */
  /* reset the timer */
  devTCNT = 0x00;
    19f6:	12 be       	out	0x32, r1	; 50
  /* clear the overflow flag, so that we start with a clean timer. */
  devTIFR = preBitSet1(0x00,devTOV);
    19f8:	91 e0       	ldi	r25, 0x01	; 1
    19fa:	98 bf       	out	0x38, r25	; 56
  /* If you use the simulator of Atmel, it cannot simulate the timer at this point
   * so just skip it. */
  #if (cfgSysDebug == cfgFalse)
    /* wait until the time is done. Note we do not use an interrupt, since that routine
     * is not at our disposal, but there is no need either. */
    while (uiLoops!=0)
    19fc:	88 23       	and	r24, r24
    19fe:	31 f0       	breq	.+12     	; 0x1a0c <portShortDelay+0x1c>
    {  /* Wait until the timer overflows. */
       while (preBitIsClr(devTIFR,devTOV));
    1a00:	08 b6       	in	r0, 0x38	; 56
    1a02:	00 fe       	sbrs	r0, 0
    1a04:	fd cf       	rjmp	.-6      	; 0x1a00 <portShortDelay+0x10>
       /* Reset the overflow flag */
       devTIFR = preBitSet1(0x00,devTOV);
    1a06:	98 bf       	out	0x38, r25	; 56
       /* Every overflow counts as one loop. */
       uiLoops--; }
    1a08:	81 50       	subi	r24, 0x01	; 1
  /* If you use the simulator of Atmel, it cannot simulate the timer at this point
   * so just skip it. */
  #if (cfgSysDebug == cfgFalse)
    /* wait until the time is done. Note we do not use an interrupt, since that routine
     * is not at our disposal, but there is no need either. */
    while (uiLoops!=0)
    1a0a:	d1 f7       	brne	.-12     	; 0x1a00 <portShortDelay+0x10>
    1a0c:	08 95       	ret

00001a0e <portInit>:
    /* Set the ready pin to output, we use it to signal the data is available. */
    devTraceComDRR = preBitSet1(devTraceComDRR,devTraceReadyPin);
    /* Set the acknowledge pin to output, we use it see if the data has been read. */
    devTraceComDRR = preBitClr1(devTraceComDRR,devTraceAckPin);
  #endif
  /* Done */ }
    1a0e:	08 95       	ret

00001a10 <portShowError>:


#if (defCheckReportingError == cfgTrue)

void portShowError(Tuint08 uiMessage, Tuint08 uiCallId, Tuint08 uiInfoTask)
{ /* We display the error code on devErrorComPORT. If you use the stk500 with eight leds, this can be
    1a10:	af 92       	push	r10
    1a12:	bf 92       	push	r11
    1a14:	cf 92       	push	r12
    1a16:	df 92       	push	r13
    1a18:	ef 92       	push	r14
    1a1a:	ff 92       	push	r15
    1a1c:	0f 93       	push	r16
    1a1e:	1f 93       	push	r17
    1a20:	cf 93       	push	r28
    1a22:	df 93       	push	r29
   * seen quite nicely. Specify that we want the message to be repeated 16 times. We arrive here
   * with disabled tick and global interrupts. */
  Tuint08 uiCount = 16;
  /* The error Port must be configured as output on all pins. We do not bother to store its original
   * value, since we must solve the error first. */
  devErrorComDDR = 0xFF;
    1a24:	9f ef       	ldi	r25, 0xFF	; 255
    1a26:	97 bb       	out	0x17, r25	; 23
    1a28:	00 e1       	ldi	r16, 0x10	; 16
    1a2a:	ee 24       	eor	r14, r14
    1a2c:	ff 24       	eor	r15, r15
    1a2e:	68 94       	set
    1a30:	e3 f8       	bld	r14, 3
    1a32:	0f 2e       	mov	r0, r31
    1a34:	f0 e8       	ldi	r31, 0x80	; 128
    1a36:	df 2e       	mov	r13, r31
    1a38:	f0 2d       	mov	r31, r0
    { devErrorComPORT = ~uiRun;
      portShortDelay(0x02);
      uiRun >>= 1; }
    while (uiRun);
    /* Display the message. */
    devErrorComPORT = ~uiMessage;
    1a3a:	c8 2e       	mov	r12, r24
    1a3c:	c0 94       	com	r12
    /* wait a little while */
    portShortDelay(0x20);
    /* Display the caller. */
    devErrorComPORT = ~uiCallId;
    1a3e:	b6 2e       	mov	r11, r22
    1a40:	b0 94       	com	r11
    /* wait a little while */
    portShortDelay(0x20);
    /* Display extra information. */
    devErrorComPORT = ~uiInfoTask;
    1a42:	a4 2e       	mov	r10, r20
    1a44:	a0 94       	com	r10
   * seen quite nicely. Specify that we want the message to be repeated 16 times. We arrive here
   * with disabled tick and global interrupts. */
  Tuint08 uiCount = 16;
  /* The error Port must be configured as output on all pins. We do not bother to store its original
   * value, since we must solve the error first. */
  devErrorComDDR = 0xFF;
    1a46:	e7 01       	movw	r28, r14
    1a48:	1d 2d       	mov	r17, r13
  while (uiCount--)
  { /* Draw the attention of the user by running a led. This also marks the beginning
     * of the sequence of information. */
    Tuint08 uiRun = 0x80;
    do
    { devErrorComPORT = ~uiRun;
    1a4a:	81 2f       	mov	r24, r17
    1a4c:	80 95       	com	r24
    1a4e:	88 bb       	out	0x18, r24	; 24
      portShortDelay(0x02);
    1a50:	82 e0       	ldi	r24, 0x02	; 2
    1a52:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <portShortDelay>
      uiRun >>= 1; }
    1a56:	16 95       	lsr	r17
    1a58:	21 97       	sbiw	r28, 0x01	; 1
    while (uiRun);
    1a5a:	b9 f7       	brne	.-18     	; 0x1a4a <portShowError+0x3a>
    /* Display the message. */
    devErrorComPORT = ~uiMessage;
    1a5c:	c8 ba       	out	0x18, r12	; 24
    /* wait a little while */
    portShortDelay(0x20);
    1a5e:	80 e2       	ldi	r24, 0x20	; 32
    1a60:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <portShortDelay>
    /* Display the caller. */
    devErrorComPORT = ~uiCallId;
    1a64:	b8 ba       	out	0x18, r11	; 24
    /* wait a little while */
    portShortDelay(0x20);
    1a66:	80 e2       	ldi	r24, 0x20	; 32
    1a68:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <portShortDelay>
    /* Display extra information. */
    devErrorComPORT = ~uiInfoTask;
    1a6c:	a8 ba       	out	0x18, r10	; 24
    /* wait a somewhat longer */
    portShortDelay(0x20); }
    1a6e:	80 e2       	ldi	r24, 0x20	; 32
    1a70:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <portShortDelay>
    1a74:	01 50       	subi	r16, 0x01	; 1
  /* The error Port must be configured as output on all pins. We do not bother to store its original
   * value, since we must solve the error first. */
  devErrorComDDR = 0xFF;
  /* Send the error message several times. In order to make them catch the eye we have a special
   * blinking scheme. */
  while (uiCount--)
    1a76:	39 f7       	brne	.-50     	; 0x1a46 <portShowError+0x36>
    portShortDelay(0x20);
    /* Display extra information. */
    devErrorComPORT = ~uiInfoTask;
    /* wait a somewhat longer */
    portShortDelay(0x20); }
  /* Done, we return, if the error was fatal, this method will be called again automatically. */ }
    1a78:	df 91       	pop	r29
    1a7a:	cf 91       	pop	r28
    1a7c:	1f 91       	pop	r17
    1a7e:	0f 91       	pop	r16
    1a80:	ff 90       	pop	r15
    1a82:	ef 90       	pop	r14
    1a84:	df 90       	pop	r13
    1a86:	cf 90       	pop	r12
    1a88:	bf 90       	pop	r11
    1a8a:	af 90       	pop	r10
    1a8c:	08 95       	ret

00001a8e <portIdle>:
  #else
    /* It is the responsibility of the portIdle implementation to activate the timer
     * interrupts, since there are no references with regard to timer activation/
     * deactivation inside the femto OS core. You may assume you arrive here with
     * timer interrupts switched off. */
    devTIMSK = preBitSet1(devTIMSK,devOCIE);
    1a8e:	89 b7       	in	r24, 0x39	; 57
    1a90:	82 60       	ori	r24, 0x02	; 2
    1a92:	89 bf       	out	0x39, r24	; 57
    /* the avr tiny has and idle state that we will utilize, this is the sleep idle mode,
     * enable it */
    devSMCR = preBitClr3(preBitSet1(devSMCR,devSE),devSM2,devSM1,devSM0);
    1a94:	85 b7       	in	r24, 0x35	; 53
    1a96:	8f 70       	andi	r24, 0x0F	; 15
    1a98:	80 68       	ori	r24, 0x80	; 128
    1a9a:	85 bf       	out	0x35, r24	; 53
    /* and start sleeping. An (timer) interrupt will wake the device */
    asm volatile ("sleep" :: );
    1a9c:	88 95       	sleep
    1a9e:	ff cf       	rjmp	.-2      	; 0x1a9e <portIdle+0x10>

00001aa0 <portSetupTimerInterrupt>:
   /* In case of equidistant ticks we make use of the automatic cleaning of the subtick counter
    * If your hardware does not have such a mode, it must be coded by hand in the tick interrupt. */
   #if (cfgUseEquidistantTicks == cfgTrue)
     /* Use the 8 bit CTC mode */
     if (preEqualMacros(devTCCRB,devTCCRA))
     { devTCCRA = preBitSet1(0x00,devWGM) | defTimerPrescaleBits; }
    1aa0:	8c e0       	ldi	r24, 0x0C	; 12
    1aa2:	83 bf       	out	0x33, r24	; 51
     else
     { devTCCRA = preBitSet1(0x00,devWGM);
       devTCCRB = defTimerPrescaleBits; }
     /* Set the time at which the tick interrupt should take place. */
     devOCR = cfgSysSubTicksPerFullTick;
    1aa4:	80 e2       	ldi	r24, 0x20	; 32
    1aa6:	8c bf       	out	0x3c, r24	; 60
    /* We  must make sure a overflow interrupt is not immediately generated, so reset the timer. */
    devTCNT = 0x00;
    /* Set the TOIE0  bit (enables the overflow interrupt). */
    devTIMSK = preBitSet1(devTIMSK,devTOIE);
  #endif
 /* Do not enable the tick interrupt itself. The OS is started with tick interrupts disabled. */ }
    1aa8:	08 95       	ret

00001aaa <__vector_10>:
void devSigTimerCompare(void)
{ /* If your hardware does not support automatic reset of the sub tick counter, you must do so here,
   * but only if (cfgUseEquidistantTicks == cfgTrue). */
  /* Let the OS know the sub tick timer reached its interrupt level and it is
   * time to switch the task. */
  portJump(privTickYield); }
    1aaa:	0c 94 81 0c 	jmp	0x1902	; 0x1902 <privTickYield>

00001aae <portDisableTickInterrupts>:
#if ((cfgIntGlobalOnly == cfgFalse) && (cfgIntTickTrack == cfgTrue)) || (defCheckReportingError == cfgTrue)

void portDisableTickInterrupts(void)
{ /* This simply disables the tick interrupts. Nothing more. The call is not used by the OS itself, (portEnterTickInterrupts /
   * portExitTickInterrupts is used to that end), with the exception of being called from the error handling. */
  asm volatile (
    1aae:	9f b7       	in	r25, 0x3f	; 63
    1ab0:	f8 94       	cli
    1ab2:	89 b7       	in	r24, 0x39	; 57
    1ab4:	8d 7f       	andi	r24, 0xFD	; 253
    1ab6:	89 bf       	out	0x39, r24	; 57
    1ab8:	9f bf       	out	0x3f, r25	; 63
    1aba:	08 95       	ret

00001abc <portSaveContext>:
   */

#if (cfgCheckRegisters == cfgTrue) || (cfgCheckTaskStack == cfgTrue) || (cfgCheckWatermarks == cfgTrue)

  /* This is the code for protected context saving. */
  asm volatile (
    1abc:	f0 93 71 00 	sts	0x0071, r31
    1ac0:	e0 93 72 00 	sts	0x0072, r30
    1ac4:	d0 93 73 00 	sts	0x0073, r29
    1ac8:	c0 93 74 00 	sts	0x0074, r28
    1acc:	ff 91       	pop	r31
    1ace:	f0 93 87 00 	sts	0x0087, r31
    1ad2:	ff 91       	pop	r31
    1ad4:	f0 93 88 00 	sts	0x0088, r31
    1ad8:	f0 91 0b 01 	lds	r31, 0x010B
    1adc:	f7 fd       	sbrc	r31, 7
    1ade:	97 c0       	rjmp	.+302    	; 0x1c0e <portSaveContext+0x152>
    1ae0:	cf b7       	in	r28, 0x3f	; 63
    1ae2:	ed b7       	in	r30, 0x3d	; 61
    1ae4:	d0 91 7c 00 	lds	r29, 0x007C
    1ae8:	ed 1b       	sub	r30, r29
    1aea:	e0 e0       	ldi	r30, 0x00	; 0
    1aec:	fe b7       	in	r31, 0x3e	; 62
    1aee:	d0 91 7d 00 	lds	r29, 0x007D
    1af2:	fd 0b       	sbc	r31, r29
    1af4:	08 f4       	brcc	.+2      	; 0x1af8 <portSaveContext+0x3c>
    1af6:	e0 68       	ori	r30, 0x80	; 128
    1af8:	e0 93 77 00 	sts	0x0077, r30
    1afc:	f0 e0       	ldi	r31, 0x00	; 0
    1afe:	ef 13       	cpse	r30, r31
    1b00:	7d c0       	rjmp	.+250    	; 0x1bfc <portSaveContext+0x140>
    1b02:	f0 91 75 00 	lds	r31, 0x0075
    1b06:	d5 ea       	ldi	r29, 0xA5	; 165
    1b08:	1e 12       	cpse	r1, r30
    1b0a:	e1 60       	ori	r30, 0x01	; 1
    1b0c:	0d 12       	cpse	r0, r29
    1b0e:	e1 60       	ori	r30, 0x01	; 1
    1b10:	2d 12       	cpse	r2, r29
    1b12:	e1 60       	ori	r30, 0x01	; 1
    1b14:	3d 12       	cpse	r3, r29
    1b16:	e1 60       	ori	r30, 0x01	; 1
    1b18:	0f 92       	push	r0
    1b1a:	1f 92       	push	r1
    1b1c:	2f 92       	push	r2
    1b1e:	3f 92       	push	r3
    1b20:	1c 2e       	mov	r1, r28
    1b22:	4d 12       	cpse	r4, r29
    1b24:	e2 60       	ori	r30, 0x02	; 2
    1b26:	5d 12       	cpse	r5, r29
    1b28:	e2 60       	ori	r30, 0x02	; 2
    1b2a:	6d 12       	cpse	r6, r29
    1b2c:	e2 60       	ori	r30, 0x02	; 2
    1b2e:	7d 12       	cpse	r7, r29
    1b30:	e2 60       	ori	r30, 0x02	; 2
    1b32:	4f 92       	push	r4
    1b34:	5f 92       	push	r5
    1b36:	6f 92       	push	r6
    1b38:	7f 92       	push	r7
    1b3a:	8d 12       	cpse	r8, r29
    1b3c:	e4 60       	ori	r30, 0x04	; 4
    1b3e:	9d 12       	cpse	r9, r29
    1b40:	e4 60       	ori	r30, 0x04	; 4
    1b42:	ad 12       	cpse	r10, r29
    1b44:	e4 60       	ori	r30, 0x04	; 4
    1b46:	bd 12       	cpse	r11, r29
    1b48:	e4 60       	ori	r30, 0x04	; 4
    1b4a:	8f 92       	push	r8
    1b4c:	9f 92       	push	r9
    1b4e:	af 92       	push	r10
    1b50:	bf 92       	push	r11
    1b52:	cd 12       	cpse	r12, r29
    1b54:	e8 60       	ori	r30, 0x08	; 8
    1b56:	dd 12       	cpse	r13, r29
    1b58:	e8 60       	ori	r30, 0x08	; 8
    1b5a:	ed 12       	cpse	r14, r29
    1b5c:	e8 60       	ori	r30, 0x08	; 8
    1b5e:	fd 12       	cpse	r15, r29
    1b60:	e8 60       	ori	r30, 0x08	; 8
    1b62:	cf 92       	push	r12
    1b64:	df 92       	push	r13
    1b66:	ef 92       	push	r14
    1b68:	ff 92       	push	r15
    1b6a:	0d 13       	cpse	r16, r29
    1b6c:	e0 61       	ori	r30, 0x10	; 16
    1b6e:	1d 13       	cpse	r17, r29
    1b70:	e0 61       	ori	r30, 0x10	; 16
    1b72:	2d 13       	cpse	r18, r29
    1b74:	e0 61       	ori	r30, 0x10	; 16
    1b76:	3d 13       	cpse	r19, r29
    1b78:	e0 61       	ori	r30, 0x10	; 16
    1b7a:	0f 93       	push	r16
    1b7c:	1f 93       	push	r17
    1b7e:	2f 93       	push	r18
    1b80:	3f 93       	push	r19
    1b82:	4d 13       	cpse	r20, r29
    1b84:	e0 62       	ori	r30, 0x20	; 32
    1b86:	5d 13       	cpse	r21, r29
    1b88:	e0 62       	ori	r30, 0x20	; 32
    1b8a:	6d 13       	cpse	r22, r29
    1b8c:	e0 62       	ori	r30, 0x20	; 32
    1b8e:	7d 13       	cpse	r23, r29
    1b90:	e0 62       	ori	r30, 0x20	; 32
    1b92:	4f 93       	push	r20
    1b94:	5f 93       	push	r21
    1b96:	6f 93       	push	r22
    1b98:	7f 93       	push	r23
    1b9a:	8d 13       	cpse	r24, r29
    1b9c:	e0 64       	ori	r30, 0x40	; 64
    1b9e:	9d 13       	cpse	r25, r29
    1ba0:	e0 64       	ori	r30, 0x40	; 64
    1ba2:	ad 13       	cpse	r26, r29
    1ba4:	e0 64       	ori	r30, 0x40	; 64
    1ba6:	bd 13       	cpse	r27, r29
    1ba8:	e0 64       	ori	r30, 0x40	; 64
    1baa:	8f 93       	push	r24
    1bac:	9f 93       	push	r25
    1bae:	af 93       	push	r26
    1bb0:	bf 93       	push	r27
    1bb2:	c0 91 74 00 	lds	r28, 0x0074
    1bb6:	cd 13       	cpse	r28, r29
    1bb8:	e0 68       	ori	r30, 0x80	; 128
    1bba:	c0 91 73 00 	lds	r28, 0x0073
    1bbe:	cd 13       	cpse	r28, r29
    1bc0:	e0 68       	ori	r30, 0x80	; 128
    1bc2:	c0 91 72 00 	lds	r28, 0x0072
    1bc6:	cd 13       	cpse	r28, r29
    1bc8:	e0 68       	ori	r30, 0x80	; 128
    1bca:	c0 91 71 00 	lds	r28, 0x0071
    1bce:	cd 13       	cpse	r28, r29
    1bd0:	e0 68       	ori	r30, 0x80	; 128
    1bd2:	c0 91 74 00 	lds	r28, 0x0074
    1bd6:	cf 93       	push	r28
    1bd8:	c0 91 73 00 	lds	r28, 0x0073
    1bdc:	cf 93       	push	r28
    1bde:	c0 91 72 00 	lds	r28, 0x0072
    1be2:	cf 93       	push	r28
    1be4:	c0 91 71 00 	lds	r28, 0x0071
    1be8:	cf 93       	push	r28
    1bea:	f1 2d       	mov	r31, r1
    1bec:	4f 99       	sbic	0x09, 7	; 9
    1bee:	f0 68       	ori	r31, 0x80	; 128
    1bf0:	ff 93       	push	r31
    1bf2:	c0 91 76 00 	lds	r28, 0x0076
    1bf6:	ec 23       	and	r30, r28
    1bf8:	e0 93 76 00 	sts	0x0076, r30
    1bfc:	10 90 78 00 	lds	r1, 0x0078
    1c00:	fd b7       	in	r31, 0x3d	; 61
    1c02:	1f 1a       	sub	r1, r31
    1c04:	e0 91 7a 00 	lds	r30, 0x007A
    1c08:	f0 91 7b 00 	lds	r31, 0x007B
    1c0c:	10 82       	st	Z, r1
    1c0e:	e9 b7       	in	r30, 0x39	; 57
    1c10:	ed 7f       	andi	r30, 0xFD	; 253
    1c12:	e9 bf       	out	0x39, r30	; 57
    1c14:	f6 e8       	ldi	r31, 0x86	; 134
    1c16:	fd bf       	out	0x3d, r31	; 61
    1c18:	f0 e0       	ldi	r31, 0x00	; 0
    1c1a:	fe bf       	out	0x3e, r31	; 62
    1c1c:	e0 91 72 00 	lds	r30, 0x0072
    1c20:	f0 91 71 00 	lds	r31, 0x0071
    1c24:	4f 98       	cbi	0x09, 7	; 9
    1c26:	11 24       	eor	r1, r1
    1c28:	08 95       	ret

00001c2a <portRestoreContext>:
{

#if (cfgCheckRegisters == cfgTrue) || (cfgCheckTaskStack == cfgTrue) || (cfgCheckWatermarks == cfgTrue)

  /* This is the code for protected context restoring. */
  asm volatile (
    1c2a:	11 24       	eor	r1, r1
    1c2c:	e9 b7       	in	r30, 0x39	; 57
    1c2e:	ff 91       	pop	r31
    1c30:	4f 98       	cbi	0x09, 7	; 9
    1c32:	f7 fd       	sbrc	r31, 7
    1c34:	4f 9a       	sbi	0x09, 7	; 9
    1c36:	ff 77       	andi	r31, 0x7F	; 127
    1c38:	e2 60       	ori	r30, 0x02	; 2
    1c3a:	ff bf       	out	0x3f, r31	; 63
    1c3c:	e9 bf       	out	0x39, r30	; 57
    1c3e:	00 90 75 00 	lds	r0, 0x0075
    1c42:	f5 ea       	ldi	r31, 0xA5	; 165
    1c44:	2f 2e       	mov	r2, r31
    1c46:	e2 2d       	mov	r30, r2
    1c48:	d2 2d       	mov	r29, r2
    1c4a:	c2 2d       	mov	r28, r2
    1c4c:	ff 91       	pop	r31
    1c4e:	ef 91       	pop	r30
    1c50:	df 91       	pop	r29
    1c52:	cf 91       	pop	r28
    1c54:	b2 2d       	mov	r27, r2
    1c56:	a2 2d       	mov	r26, r2
    1c58:	92 2d       	mov	r25, r2
    1c5a:	82 2d       	mov	r24, r2
    1c5c:	bf 91       	pop	r27
    1c5e:	af 91       	pop	r26
    1c60:	9f 91       	pop	r25
    1c62:	8f 91       	pop	r24
    1c64:	72 2d       	mov	r23, r2
    1c66:	62 2d       	mov	r22, r2
    1c68:	52 2d       	mov	r21, r2
    1c6a:	42 2d       	mov	r20, r2
    1c6c:	7f 91       	pop	r23
    1c6e:	6f 91       	pop	r22
    1c70:	5f 91       	pop	r21
    1c72:	4f 91       	pop	r20
    1c74:	32 2d       	mov	r19, r2
    1c76:	22 2d       	mov	r18, r2
    1c78:	12 2d       	mov	r17, r2
    1c7a:	02 2d       	mov	r16, r2
    1c7c:	3f 91       	pop	r19
    1c7e:	2f 91       	pop	r18
    1c80:	1f 91       	pop	r17
    1c82:	0f 91       	pop	r16
    1c84:	f2 2c       	mov	r15, r2
    1c86:	e2 2c       	mov	r14, r2
    1c88:	d2 2c       	mov	r13, r2
    1c8a:	c2 2c       	mov	r12, r2
    1c8c:	ff 90       	pop	r15
    1c8e:	ef 90       	pop	r14
    1c90:	df 90       	pop	r13
    1c92:	cf 90       	pop	r12
    1c94:	b2 2c       	mov	r11, r2
    1c96:	a2 2c       	mov	r10, r2
    1c98:	92 2c       	mov	r9, r2
    1c9a:	82 2c       	mov	r8, r2
    1c9c:	bf 90       	pop	r11
    1c9e:	af 90       	pop	r10
    1ca0:	9f 90       	pop	r9
    1ca2:	8f 90       	pop	r8
    1ca4:	72 2c       	mov	r7, r2
    1ca6:	62 2c       	mov	r6, r2
    1ca8:	52 2c       	mov	r5, r2
    1caa:	42 2c       	mov	r4, r2
    1cac:	7f 90       	pop	r7
    1cae:	6f 90       	pop	r6
    1cb0:	5f 90       	pop	r5
    1cb2:	4f 90       	pop	r4
    1cb4:	32 2c       	mov	r3, r2
    1cb6:	02 2c       	mov	r0, r2
    1cb8:	3f 90       	pop	r3
    1cba:	2f 90       	pop	r2
    1cbc:	1f 90       	pop	r1
    1cbe:	0f 90       	pop	r0
    1cc0:	4f 9b       	sbis	0x09, 7	; 9
    1cc2:	08 95       	ret
    1cc4:	4f 98       	cbi	0x09, 7	; 9
    1cc6:	18 95       	reti

00001cc8 <TWI_Master_Initialise>:
Call this function to set up the TWI master to its initial standby state.
Remember to enable interrupts from the main application after initializing the TWI.
****************************************************************************/
void TWI_Master_Initialise(void)
{
	TWBR = TWI_TWBR;                                  // Set bit rate register (Baudrate). Defined in header file.
    1cc8:	8c e0       	ldi	r24, 0x0C	; 12
    1cca:	80 b9       	out	0x00, r24	; 0
// TWSR = TWI_TWPS;                                  // Not used. Driver presumes prescaler to be 00.
	TWDR = 0xFF;                                      // Default content = SDA released.
    1ccc:	8f ef       	ldi	r24, 0xFF	; 255
    1cce:	83 b9       	out	0x03, r24	; 3
	TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
    1cd0:	84 e0       	ldi	r24, 0x04	; 4
    1cd2:	86 bf       	out	0x36, r24	; 54
         (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt.
         (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests.
         (0<<TWWC);                                 //
}    
    1cd4:	08 95       	ret

00001cd6 <TWI_Transceiver_Busy>:
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
	return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
    1cd6:	86 b7       	in	r24, 0x36	; 54
}
    1cd8:	81 70       	andi	r24, 0x01	; 1
    1cda:	08 95       	ret

00001cdc <TWI_Get_State_Info>:
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
	  while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
    1cdc:	0e 94 6b 0e 	call	0x1cd6	; 0x1cd6 <TWI_Transceiver_Busy>
    1ce0:	88 23       	and	r24, r24
    1ce2:	e1 f7       	brne	.-8      	; 0x1cdc <TWI_Get_State_Info>
	  return ( TWI_state );                         // Return error state.
}
    1ce4:	80 91 67 00 	lds	r24, 0x0067
    1ce8:	08 95       	ret

00001cea <TWI_Start_Transceiver_With_Data>:
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
    1cea:	1f 93       	push	r17
    1cec:	cf 93       	push	r28
    1cee:	df 93       	push	r29
    1cf0:	ec 01       	movw	r28, r24
    1cf2:	16 2f       	mov	r17, r22
	  unsigned char temp;

	  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    1cf4:	0e 94 6b 0e 	call	0x1cd6	; 0x1cd6 <TWI_Transceiver_Busy>
    1cf8:	88 23       	and	r24, r24
    1cfa:	e1 f7       	brne	.-8      	; 0x1cf4 <TWI_Start_Transceiver_With_Data+0xa>

	  TWI_msgSize = msgSize;                        // Number of data to transmit.
    1cfc:	10 93 e6 00 	sts	0x00E6, r17
	  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
    1d00:	88 81       	ld	r24, Y
    1d02:	80 93 e7 00 	sts	0x00E7, r24
	  
	  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
    1d06:	80 fd       	sbrc	r24, 0
    1d08:	0f c0       	rjmp	.+30     	; 0x1d28 <TWI_Start_Transceiver_With_Data+0x3e>
	  {
		for ( temp = 1; temp < msgSize; temp++ )
    1d0a:	12 30       	cpi	r17, 0x02	; 2
    1d0c:	68 f0       	brcs	.+26     	; 0x1d28 <TWI_Start_Transceiver_With_Data+0x3e>
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    1d0e:	21 96       	adiw	r28, 0x01	; 1
	  TWI_msgSize = msgSize;                        // Number of data to transmit.
	  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
	  
	  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
	  {
		for ( temp = 1; temp < msgSize; temp++ )
    1d10:	e8 ee       	ldi	r30, 0xE8	; 232
    1d12:	f0 e0       	ldi	r31, 0x00	; 0
read/write bit. Consecutive bytes contain the data to be sent, or empty locations for data to be read
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
    1d14:	cf 01       	movw	r24, r30
    1d16:	01 96       	adiw	r24, 0x01	; 1
    1d18:	12 50       	subi	r17, 0x02	; 2
    1d1a:	81 0f       	add	r24, r17
    1d1c:	91 1d       	adc	r25, r1
	  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
	  
	  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
	  {
		for ( temp = 1; temp < msgSize; temp++ )
		  TWI_buf[ temp ] = msg[ temp ];
    1d1e:	29 91       	ld	r18, Y+
    1d20:	21 93       	st	Z+, r18
	  TWI_msgSize = msgSize;                        // Number of data to transmit.
	  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
	  
	  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
	  {
		for ( temp = 1; temp < msgSize; temp++ )
    1d22:	e8 17       	cp	r30, r24
    1d24:	f9 07       	cpc	r31, r25
    1d26:	d9 f7       	brne	.-10     	; 0x1d1e <TWI_Start_Transceiver_With_Data+0x34>
		  TWI_buf[ temp ] = msg[ temp ];
	  }
	  
	  //TWI_statusReg.all = 0;
	  TWI_statusReg.all = 0;      
    1d28:	10 92 e5 00 	sts	0x00E5, r1
	  TWI_state         = TWI_NO_STATE ;
    1d2c:	88 ef       	ldi	r24, 0xF8	; 248
    1d2e:	80 93 67 00 	sts	0x0067, r24
	  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    1d32:	85 ea       	ldi	r24, 0xA5	; 165
    1d34:	86 bf       	out	0x36, r24	; 54
			 (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
			 (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
			 (0<<TWWC);                             //
}
    1d36:	df 91       	pop	r29
    1d38:	cf 91       	pop	r28
    1d3a:	1f 91       	pop	r17
    1d3c:	08 95       	ret

00001d3e <TWI_Start_Transceiver>:
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    1d3e:	0e 94 6b 0e 	call	0x1cd6	; 0x1cd6 <TWI_Transceiver_Busy>
    1d42:	88 23       	and	r24, r24
    1d44:	e1 f7       	brne	.-8      	; 0x1d3e <TWI_Start_Transceiver>
	  
	TWI_statusReg.all = 0;      
    1d46:	10 92 e5 00 	sts	0x00E5, r1
	TWI_state         = TWI_NO_STATE ;
    1d4a:	88 ef       	ldi	r24, 0xF8	; 248
    1d4c:	80 93 67 00 	sts	0x0067, r24
	  
	TWCR = (1<<TWEN)|                             // TWI Interface enabled.
    1d50:	85 ea       	ldi	r24, 0xA5	; 165
    1d52:	86 bf       	out	0x36, r24	; 54
			(1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interupt and clear the flag.
			(0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
			(0<<TWWC);                             //
}
    1d54:	08 95       	ret

00001d56 <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
    1d56:	ff 92       	push	r15
    1d58:	0f 93       	push	r16
    1d5a:	1f 93       	push	r17
    1d5c:	f8 2e       	mov	r15, r24
    1d5e:	09 2f       	mov	r16, r25
    1d60:	16 2f       	mov	r17, r22
	unsigned char i;

	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
    1d62:	0e 94 6b 0e 	call	0x1cd6	; 0x1cd6 <TWI_Transceiver_Busy>
    1d66:	88 23       	and	r24, r24
    1d68:	e1 f7       	brne	.-8      	; 0x1d62 <TWI_Get_Data_From_Transceiver+0xc>

	if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
    1d6a:	80 91 e5 00 	lds	r24, 0x00E5
    1d6e:	80 ff       	sbrs	r24, 0
    1d70:	10 c0       	rjmp	.+32     	; 0x1d92 <TWI_Get_Data_From_Transceiver+0x3c>
	{                                             
		for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    1d72:	11 23       	and	r17, r17
    1d74:	71 f0       	breq	.+28     	; 0x1d92 <TWI_Get_Data_From_Transceiver+0x3c>
    1d76:	e7 ee       	ldi	r30, 0xE7	; 231
    1d78:	f0 e0       	ldi	r31, 0x00	; 0
    1d7a:	af 2d       	mov	r26, r15
    1d7c:	b0 2f       	mov	r27, r16
data when they have arrived. Include a pointer to where to place the data and the number of bytes
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
    1d7e:	cf 01       	movw	r24, r30
    1d80:	01 96       	adiw	r24, 0x01	; 1
    1d82:	11 50       	subi	r17, 0x01	; 1
    1d84:	81 0f       	add	r24, r17
    1d86:	91 1d       	adc	r25, r1

	if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
	{                                             
		for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
		{
			msg[ i ] = TWI_buf[ i ];
    1d88:	21 91       	ld	r18, Z+
    1d8a:	2d 93       	st	X+, r18

	while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.

	if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
	{                                             
		for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
    1d8c:	e8 17       	cp	r30, r24
    1d8e:	f9 07       	cpc	r31, r25
    1d90:	d9 f7       	brne	.-10     	; 0x1d88 <TWI_Get_Data_From_Transceiver+0x32>
		{
			msg[ i ] = TWI_buf[ i ];
		}
	}

	return( TWI_statusReg.lastTransOK );                                   
    1d92:	80 91 e5 00 	lds	r24, 0x00E5
}
    1d96:	81 70       	andi	r24, 0x01	; 1
    1d98:	1f 91       	pop	r17
    1d9a:	0f 91       	pop	r16
    1d9c:	ff 90       	pop	r15
    1d9e:	08 95       	ret

00001da0 <__vector_19>:
****************************************************************************/
//#pragma vector=TWI_vect
//__interrupt void TWI_ISR(void)
//-> adapted to gcc style
ISR(TWI_vect)
{
    1da0:	1f 92       	push	r1
    1da2:	0f 92       	push	r0
    1da4:	0f b6       	in	r0, 0x3f	; 63
    1da6:	0f 92       	push	r0
    1da8:	11 24       	eor	r1, r1
    1daa:	2f 93       	push	r18
    1dac:	3f 93       	push	r19
    1dae:	8f 93       	push	r24
    1db0:	9f 93       	push	r25
    1db2:	ef 93       	push	r30
    1db4:	ff 93       	push	r31
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
    1db6:	81 b1       	in	r24, 0x01	; 1
    1db8:	88 32       	cpi	r24, 0x28	; 40
    1dba:	d1 f0       	breq	.+52     	; 0x1df0 <__vector_19+0x50>
    1dbc:	89 32       	cpi	r24, 0x29	; 41
    1dbe:	40 f4       	brcc	.+16     	; 0x1dd0 <__vector_19+0x30>
    1dc0:	80 31       	cpi	r24, 0x10	; 16
    1dc2:	a1 f0       	breq	.+40     	; 0x1dec <__vector_19+0x4c>
    1dc4:	88 31       	cpi	r24, 0x18	; 24
    1dc6:	a1 f0       	breq	.+40     	; 0x1df0 <__vector_19+0x50>
    1dc8:	88 30       	cpi	r24, 0x08	; 8
    1dca:	09 f0       	breq	.+2      	; 0x1dce <__vector_19+0x2e>
    1dcc:	58 c0       	rjmp	.+176    	; 0x1e7e <__vector_19+0xde>
    1dce:	0e c0       	rjmp	.+28     	; 0x1dec <__vector_19+0x4c>
    1dd0:	80 34       	cpi	r24, 0x40	; 64
    1dd2:	99 f1       	breq	.+102    	; 0x1e3a <__vector_19+0x9a>
    1dd4:	81 34       	cpi	r24, 0x41	; 65
    1dd6:	20 f4       	brcc	.+8      	; 0x1de0 <__vector_19+0x40>
    1dd8:	88 33       	cpi	r24, 0x38	; 56
    1dda:	09 f0       	breq	.+2      	; 0x1dde <__vector_19+0x3e>
    1ddc:	50 c0       	rjmp	.+160    	; 0x1e7e <__vector_19+0xde>
    1dde:	4c c0       	rjmp	.+152    	; 0x1e78 <__vector_19+0xd8>
    1de0:	80 35       	cpi	r24, 0x50	; 80
    1de2:	01 f1       	breq	.+64     	; 0x1e24 <__vector_19+0x84>
    1de4:	88 35       	cpi	r24, 0x58	; 88
    1de6:	09 f0       	breq	.+2      	; 0x1dea <__vector_19+0x4a>
    1de8:	4a c0       	rjmp	.+148    	; 0x1e7e <__vector_19+0xde>
    1dea:	37 c0       	rjmp	.+110    	; 0x1e5a <__vector_19+0xba>
  {
    case TWI_START:             // START has been transmitted  
	case TWI_REP_START:         // Repeated START has been transmitted
		TWI_bufPtr = 0;         // Set buffer pointer to the TWI Address location
    1dec:	10 92 eb 00 	sts	0x00EB, r1
    
	case TWI_MTX_ADR_ACK:       // SLA+W has been tramsmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been tramsmitted and ACK received
		if (TWI_bufPtr < TWI_msgSize)
    1df0:	80 91 eb 00 	lds	r24, 0x00EB
    1df4:	90 91 e6 00 	lds	r25, 0x00E6
    1df8:	89 17       	cp	r24, r25
    1dfa:	60 f4       	brcc	.+24     	; 0x1e14 <__vector_19+0x74>
		{
			TWDR = TWI_buf[TWI_bufPtr++];
    1dfc:	e8 2f       	mov	r30, r24
    1dfe:	f0 e0       	ldi	r31, 0x00	; 0
    1e00:	e9 51       	subi	r30, 0x19	; 25
    1e02:	ff 4f       	sbci	r31, 0xFF	; 255
    1e04:	90 81       	ld	r25, Z
    1e06:	93 b9       	out	0x03, r25	; 3
    1e08:	8f 5f       	subi	r24, 0xFF	; 255
    1e0a:	80 93 eb 00 	sts	0x00EB, r24
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1e0e:	85 e8       	ldi	r24, 0x85	; 133
    1e10:	86 bf       	out	0x36, r24	; 54
    1e12:	3a c0       	rjmp	.+116    	; 0x1e88 <__vector_19+0xe8>
				   (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           //
				   (0<<TWWC);                                 //  
		}
		else                    // Send STOP after last byte
		{
			TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    1e14:	80 91 e5 00 	lds	r24, 0x00E5
    1e18:	81 60       	ori	r24, 0x01	; 1
    1e1a:	80 93 e5 00 	sts	0x00E5, r24
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1e1e:	84 e9       	ldi	r24, 0x94	; 148
    1e20:	86 bf       	out	0x36, r24	; 54
    1e22:	32 c0       	rjmp	.+100    	; 0x1e88 <__vector_19+0xe8>
				   (0<<TWWC);                                 //
		}
		break;
    
	case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK tramsmitted
		TWI_buf[TWI_bufPtr++] = TWDR;
    1e24:	80 91 eb 00 	lds	r24, 0x00EB
    1e28:	93 b1       	in	r25, 0x03	; 3
    1e2a:	e8 2f       	mov	r30, r24
    1e2c:	f0 e0       	ldi	r31, 0x00	; 0
    1e2e:	e9 51       	subi	r30, 0x19	; 25
    1e30:	ff 4f       	sbci	r31, 0xFF	; 255
    1e32:	90 83       	st	Z, r25
    1e34:	8f 5f       	subi	r24, 0xFF	; 255
    1e36:	80 93 eb 00 	sts	0x00EB, r24
    
	case TWI_MRX_ADR_ACK:       // SLA+R has been tramsmitted and ACK received
		if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
    1e3a:	20 91 eb 00 	lds	r18, 0x00EB
    1e3e:	30 e0       	ldi	r19, 0x00	; 0
    1e40:	80 91 e6 00 	lds	r24, 0x00E6
    1e44:	90 e0       	ldi	r25, 0x00	; 0
    1e46:	01 97       	sbiw	r24, 0x01	; 1
    1e48:	28 17       	cp	r18, r24
    1e4a:	39 07       	cpc	r19, r25
    1e4c:	1c f4       	brge	.+6      	; 0x1e54 <__vector_19+0xb4>
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1e4e:	85 ec       	ldi	r24, 0xC5	; 197
    1e50:	86 bf       	out	0x36, r24	; 54
    1e52:	1a c0       	rjmp	.+52     	; 0x1e88 <__vector_19+0xe8>
				   (1<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send ACK after reception
				   (0<<TWWC);                                 //  
		}
		else                    // Send NACK after next reception
		{
			TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1e54:	85 e8       	ldi	r24, 0x85	; 133
    1e56:	86 bf       	out	0x36, r24	; 54
    1e58:	17 c0       	rjmp	.+46     	; 0x1e88 <__vector_19+0xe8>
				   (0<<TWWC);                                 // 
		}    
		break; 
    
	case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK tramsmitted
		TWI_buf[TWI_bufPtr] = TWDR;
    1e5a:	83 b1       	in	r24, 0x03	; 3
    1e5c:	e0 91 eb 00 	lds	r30, 0x00EB
    1e60:	f0 e0       	ldi	r31, 0x00	; 0
    1e62:	e9 51       	subi	r30, 0x19	; 25
    1e64:	ff 4f       	sbci	r31, 0xFF	; 255
    1e66:	80 83       	st	Z, r24
		TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
    1e68:	80 91 e5 00 	lds	r24, 0x00E5
    1e6c:	81 60       	ori	r24, 0x01	; 1
    1e6e:	80 93 e5 00 	sts	0x00E5, r24
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1e72:	84 e9       	ldi	r24, 0x94	; 148
    1e74:	86 bf       	out	0x36, r24	; 54
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
		break;      
    1e76:	08 c0       	rjmp	.+16     	; 0x1e88 <__vector_19+0xe8>
    
	case TWI_ARB_LOST:          // Arbitration lost
		TWCR = (1<<TWEN)|                                 // TWI Interface enabled
    1e78:	85 ea       	ldi	r24, 0xA5	; 165
    1e7a:	86 bf       	out	0x36, r24	; 54
			 (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
		break;
    1e7c:	05 c0       	rjmp	.+10     	; 0x1e88 <__vector_19+0xe8>
//    case TWI_NO_STATE              // No relevant state information available; TWINT = 0
   
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
   
    default:     
		TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
    1e7e:	81 b1       	in	r24, 0x01	; 1
    1e80:	80 93 67 00 	sts	0x0067, r24
                                                        // Reset TWI Interface
		TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
    1e84:	84 e0       	ldi	r24, 0x04	; 4
    1e86:	86 bf       	out	0x36, r24	; 54
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
    1e88:	ff 91       	pop	r31
    1e8a:	ef 91       	pop	r30
    1e8c:	9f 91       	pop	r25
    1e8e:	8f 91       	pop	r24
    1e90:	3f 91       	pop	r19
    1e92:	2f 91       	pop	r18
    1e94:	0f 90       	pop	r0
    1e96:	0f be       	out	0x3f, r0	; 63
    1e98:	0f 90       	pop	r0
    1e9a:	1f 90       	pop	r1
    1e9c:	18 95       	reti

00001e9e <__udivmodhi4>:
    1e9e:	aa 1b       	sub	r26, r26
    1ea0:	bb 1b       	sub	r27, r27
    1ea2:	51 e1       	ldi	r21, 0x11	; 17
    1ea4:	07 c0       	rjmp	.+14     	; 0x1eb4 <__udivmodhi4_ep>

00001ea6 <__udivmodhi4_loop>:
    1ea6:	aa 1f       	adc	r26, r26
    1ea8:	bb 1f       	adc	r27, r27
    1eaa:	a6 17       	cp	r26, r22
    1eac:	b7 07       	cpc	r27, r23
    1eae:	10 f0       	brcs	.+4      	; 0x1eb4 <__udivmodhi4_ep>
    1eb0:	a6 1b       	sub	r26, r22
    1eb2:	b7 0b       	sbc	r27, r23

00001eb4 <__udivmodhi4_ep>:
    1eb4:	88 1f       	adc	r24, r24
    1eb6:	99 1f       	adc	r25, r25
    1eb8:	5a 95       	dec	r21
    1eba:	a9 f7       	brne	.-22     	; 0x1ea6 <__udivmodhi4_loop>
    1ebc:	80 95       	com	r24
    1ebe:	90 95       	com	r25
    1ec0:	bc 01       	movw	r22, r24
    1ec2:	cd 01       	movw	r24, r26
    1ec4:	08 95       	ret

00001ec6 <itoa>:
    1ec6:	fb 01       	movw	r30, r22
    1ec8:	9f 01       	movw	r18, r30
    1eca:	e8 94       	clt
    1ecc:	42 30       	cpi	r20, 0x02	; 2
    1ece:	c4 f0       	brlt	.+48     	; 0x1f00 <itoa+0x3a>
    1ed0:	45 32       	cpi	r20, 0x25	; 37
    1ed2:	b4 f4       	brge	.+44     	; 0x1f00 <itoa+0x3a>
    1ed4:	4a 30       	cpi	r20, 0x0A	; 10
    1ed6:	29 f4       	brne	.+10     	; 0x1ee2 <itoa+0x1c>
    1ed8:	97 fb       	bst	r25, 7
    1eda:	1e f4       	brtc	.+6      	; 0x1ee2 <itoa+0x1c>
    1edc:	90 95       	com	r25
    1ede:	81 95       	neg	r24
    1ee0:	9f 4f       	sbci	r25, 0xFF	; 255
    1ee2:	64 2f       	mov	r22, r20
    1ee4:	77 27       	eor	r23, r23
    1ee6:	0e 94 4f 0f 	call	0x1e9e	; 0x1e9e <__udivmodhi4>
    1eea:	80 5d       	subi	r24, 0xD0	; 208
    1eec:	8a 33       	cpi	r24, 0x3A	; 58
    1eee:	0c f0       	brlt	.+2      	; 0x1ef2 <itoa+0x2c>
    1ef0:	89 5d       	subi	r24, 0xD9	; 217
    1ef2:	81 93       	st	Z+, r24
    1ef4:	cb 01       	movw	r24, r22
    1ef6:	00 97       	sbiw	r24, 0x00	; 0
    1ef8:	a1 f7       	brne	.-24     	; 0x1ee2 <itoa+0x1c>
    1efa:	16 f4       	brtc	.+4      	; 0x1f00 <itoa+0x3a>
    1efc:	5d e2       	ldi	r21, 0x2D	; 45
    1efe:	51 93       	st	Z+, r21
    1f00:	10 82       	st	Z, r1
    1f02:	c9 01       	movw	r24, r18
    1f04:	0c 94 ce 0f 	jmp	0x1f9c	; 0x1f9c <strrev>

00001f08 <ltoa>:
    1f08:	fa 01       	movw	r30, r20
    1f0a:	cf 93       	push	r28
    1f0c:	ff 93       	push	r31
    1f0e:	ef 93       	push	r30
    1f10:	22 30       	cpi	r18, 0x02	; 2
    1f12:	44 f1       	brlt	.+80     	; 0x1f64 <ltoa+0x5c>
    1f14:	25 32       	cpi	r18, 0x25	; 37
    1f16:	34 f5       	brge	.+76     	; 0x1f64 <ltoa+0x5c>
    1f18:	c2 2f       	mov	r28, r18
    1f1a:	e8 94       	clt
    1f1c:	ca 30       	cpi	r28, 0x0A	; 10
    1f1e:	49 f4       	brne	.+18     	; 0x1f32 <ltoa+0x2a>
    1f20:	97 fb       	bst	r25, 7
    1f22:	3e f4       	brtc	.+14     	; 0x1f32 <ltoa+0x2a>
    1f24:	90 95       	com	r25
    1f26:	80 95       	com	r24
    1f28:	70 95       	com	r23
    1f2a:	61 95       	neg	r22
    1f2c:	7f 4f       	sbci	r23, 0xFF	; 255
    1f2e:	8f 4f       	sbci	r24, 0xFF	; 255
    1f30:	9f 4f       	sbci	r25, 0xFF	; 255
    1f32:	2c 2f       	mov	r18, r28
    1f34:	33 27       	eor	r19, r19
    1f36:	44 27       	eor	r20, r20
    1f38:	55 27       	eor	r21, r21
    1f3a:	ff 93       	push	r31
    1f3c:	ef 93       	push	r30
    1f3e:	0e 94 de 0f 	call	0x1fbc	; 0x1fbc <__udivmodsi4>
    1f42:	ef 91       	pop	r30
    1f44:	ff 91       	pop	r31
    1f46:	60 5d       	subi	r22, 0xD0	; 208
    1f48:	6a 33       	cpi	r22, 0x3A	; 58
    1f4a:	0c f0       	brlt	.+2      	; 0x1f4e <ltoa+0x46>
    1f4c:	69 5d       	subi	r22, 0xD9	; 217
    1f4e:	61 93       	st	Z+, r22
    1f50:	b9 01       	movw	r22, r18
    1f52:	ca 01       	movw	r24, r20
    1f54:	60 50       	subi	r22, 0x00	; 0
    1f56:	70 40       	sbci	r23, 0x00	; 0
    1f58:	80 40       	sbci	r24, 0x00	; 0
    1f5a:	90 40       	sbci	r25, 0x00	; 0
    1f5c:	51 f7       	brne	.-44     	; 0x1f32 <ltoa+0x2a>
    1f5e:	16 f4       	brtc	.+4      	; 0x1f64 <ltoa+0x5c>
    1f60:	cd e2       	ldi	r28, 0x2D	; 45
    1f62:	c1 93       	st	Z+, r28
    1f64:	10 82       	st	Z, r1
    1f66:	8f 91       	pop	r24
    1f68:	9f 91       	pop	r25
    1f6a:	cf 91       	pop	r28
    1f6c:	0c 94 ce 0f 	jmp	0x1f9c	; 0x1f9c <strrev>

00001f70 <utoa>:
    1f70:	fb 01       	movw	r30, r22
    1f72:	9f 01       	movw	r18, r30
    1f74:	42 30       	cpi	r20, 0x02	; 2
    1f76:	74 f0       	brlt	.+28     	; 0x1f94 <utoa+0x24>
    1f78:	45 32       	cpi	r20, 0x25	; 37
    1f7a:	64 f4       	brge	.+24     	; 0x1f94 <utoa+0x24>
    1f7c:	64 2f       	mov	r22, r20
    1f7e:	77 27       	eor	r23, r23
    1f80:	0e 94 4f 0f 	call	0x1e9e	; 0x1e9e <__udivmodhi4>
    1f84:	80 5d       	subi	r24, 0xD0	; 208
    1f86:	8a 33       	cpi	r24, 0x3A	; 58
    1f88:	0c f0       	brlt	.+2      	; 0x1f8c <utoa+0x1c>
    1f8a:	89 5d       	subi	r24, 0xD9	; 217
    1f8c:	81 93       	st	Z+, r24
    1f8e:	cb 01       	movw	r24, r22
    1f90:	00 97       	sbiw	r24, 0x00	; 0
    1f92:	a1 f7       	brne	.-24     	; 0x1f7c <utoa+0xc>
    1f94:	10 82       	st	Z, r1
    1f96:	c9 01       	movw	r24, r18
    1f98:	0c 94 ce 0f 	jmp	0x1f9c	; 0x1f9c <strrev>

00001f9c <strrev>:
    1f9c:	dc 01       	movw	r26, r24
    1f9e:	fc 01       	movw	r30, r24
    1fa0:	67 2f       	mov	r22, r23
    1fa2:	71 91       	ld	r23, Z+
    1fa4:	77 23       	and	r23, r23
    1fa6:	e1 f7       	brne	.-8      	; 0x1fa0 <strrev+0x4>
    1fa8:	32 97       	sbiw	r30, 0x02	; 2
    1faa:	04 c0       	rjmp	.+8      	; 0x1fb4 <strrev+0x18>
    1fac:	7c 91       	ld	r23, X
    1fae:	6d 93       	st	X+, r22
    1fb0:	70 83       	st	Z, r23
    1fb2:	62 91       	ld	r22, -Z
    1fb4:	ae 17       	cp	r26, r30
    1fb6:	bf 07       	cpc	r27, r31
    1fb8:	c8 f3       	brcs	.-14     	; 0x1fac <strrev+0x10>
    1fba:	08 95       	ret

00001fbc <__udivmodsi4>:
    1fbc:	a1 e2       	ldi	r26, 0x21	; 33
    1fbe:	1a 2e       	mov	r1, r26
    1fc0:	aa 1b       	sub	r26, r26
    1fc2:	bb 1b       	sub	r27, r27
    1fc4:	fd 01       	movw	r30, r26
    1fc6:	0d c0       	rjmp	.+26     	; 0x1fe2 <__udivmodsi4_ep>

00001fc8 <__udivmodsi4_loop>:
    1fc8:	aa 1f       	adc	r26, r26
    1fca:	bb 1f       	adc	r27, r27
    1fcc:	ee 1f       	adc	r30, r30
    1fce:	ff 1f       	adc	r31, r31
    1fd0:	a2 17       	cp	r26, r18
    1fd2:	b3 07       	cpc	r27, r19
    1fd4:	e4 07       	cpc	r30, r20
    1fd6:	f5 07       	cpc	r31, r21
    1fd8:	20 f0       	brcs	.+8      	; 0x1fe2 <__udivmodsi4_ep>
    1fda:	a2 1b       	sub	r26, r18
    1fdc:	b3 0b       	sbc	r27, r19
    1fde:	e4 0b       	sbc	r30, r20
    1fe0:	f5 0b       	sbc	r31, r21

00001fe2 <__udivmodsi4_ep>:
    1fe2:	66 1f       	adc	r22, r22
    1fe4:	77 1f       	adc	r23, r23
    1fe6:	88 1f       	adc	r24, r24
    1fe8:	99 1f       	adc	r25, r25
    1fea:	1a 94       	dec	r1
    1fec:	69 f7       	brne	.-38     	; 0x1fc8 <__udivmodsi4_loop>
    1fee:	60 95       	com	r22
    1ff0:	70 95       	com	r23
    1ff2:	80 95       	com	r24
    1ff4:	90 95       	com	r25
    1ff6:	9b 01       	movw	r18, r22
    1ff8:	ac 01       	movw	r20, r24
    1ffa:	bd 01       	movw	r22, r26
    1ffc:	cf 01       	movw	r24, r30
    1ffe:	08 95       	ret

00002000 <_exit>:
    2000:	f8 94       	cli

00002002 <__stop_program>:
    2002:	ff cf       	rjmp	.-2      	; 0x2002 <__stop_program>
